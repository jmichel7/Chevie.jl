using Chevie

@GapObj struct CandMonoid{T}<:GarsideMonoid{T}
  δ::T
  orderδ::Int
  stringδ::String
  atoms::Vector{T}
  simples::Dict{T,Int}  # the simples and their length
  W::Group{T}
  one::T
end

function Base.show(io::IO,M::CandMonoid)
  print(io,"garside[",length(M.simples)," simples, delta=",
      joindigits(word(M,M.δ)),"]")
end

Base.length(M::CandMonoid,x)=haskey(M.simples,x) ? M.simples[x] : 1+length(M.simples)

Garside.isleftdescent(M::CandMonoid,simp,i)=length(M,M.atoms[i]\simp)<length(M,simp)
Garside.isrightdescent(M::CandMonoid,simp,i::Integer)=length(M,simp/M.atoms[i])<length(M,simp)
Garside.isrightascent(M::CandMonoid,simp,i)=isleftdescent(rightcomplδ(M,simp),i)

Garside.IntervalStyle(M::CandMonoid)=Garside.Interval()

function CandMonoid(delta,simples,gens)
  atoms=filter(x->haskey(simples,x),gens)
  group=Group(atoms)
  CandMonoid(delta,order(delta),"δ",atoms,simples,group,one(gens[1]),
             Dict{Symbol,Any}())
end

"""
`interval_monoids(gens;atoms=nothing,balanced=nothing)`

Given  generators `gens`  for a  finite permutation  group `G`, returns the
list  of the corresponding [candidate]  Garside interval monoids associated
to  `(G,c)` where `c` is  a balanced element of  `(G,gens)`, destined to be
the  `M.δ` of a returned  monoid M. Balanced means  `c` is divisible by the
same  `gens`, on right and  on left (by all  elements in `atoms`, if given)
and such that the subgroup generated by `div(c)` is the whole of `G`.

The  algorithm  is  much  faster  in  the  case  when  `gens`  is stable by
conjugacy;  it  then  returns  only  a  monoid  for representatives of each
conjugacy  class of balanced elements. `interval_monoids` does not test the
lattice  property  for  the  returned  monoids (but see `check_lattice`). If
`balanced  is given`, it is  checked for being a  balanced element and only
the corresponding monoid is returned.

Note that for a complex reflection group, `Perm.(reflections(G))` returns
all the reflections of `G`.
"""
function interval_monoids(gens;atoms=nothing,balanced=nothing)
# find the length in the generators of each element
  G=Group(gens)
  conj=sort(union(map(x->orbit(G,x),gens)...))==sort(gens)
  if conj println("the given generators are stable by conjugacy") end
  lg=Dict((k,length(v)) for (k,v) in minimal_words(G))
  function isbalanced(g)local l,x,lx,ldiv,rdiv
    l=lg[g]
    ldiv=filter(x->l==lg[x\g]+1,gens)
    rdiv=filter(x->l==lg[g/x]+1,gens)
    if ldiv!=rdiv return false end
    if atoms!==nothing && sort(ldiv)!=sort(atoms) return false end
    if length(Group(ldiv))!=length(G) return false end
    for x in keys(lg)
      lx=lg[x]
      if lx<l && (l-lx==lg[x\g])!=(l-lx==lg[g/x]) return false end
    end
    true
  end
  if balanced!==nothing
    if isbalanced(balanced) balanced=[balanced]
    else error(balanced," is not balanced\n")
    end
  else
    if conj new=classreps(G)
    else new=collect(keys(lg))
    end
    println(length(new)," elements to consider")
    balanced=empty(gens)
    for i in 1:length(new)
      if i%100==0 || conj print(i,".") end
      if isbalanced(new[i])
        println("\nbalanced: $i (length ",lg[new[i]],")")
        push!(balanced,new[i])
      end
    end
  end
  map(balanced)do b
    l=lg[b]
    CandMonoid(b,Dict((x,lx) for (x,lx) in lg if l==lg[x\b]+lx),gens)
  end
end

"""
`lattice(M::GarsideMonoid)` where `M` should be a Garside[-candidate] monoid

describes lattice of simples:
returns a triple [list of simples s, 
list of edges [i,a,j] (a=atom) meaning s[i]*a=s[j], second as a poset]
"""
function lattice(M::GarsideMonoid)
  s=[M.δ]
  to=0
  edges=Tuple{Int,Int,Int}[]
  while true
    from=to
    to=length(s)
    for j in from+1:to
      for a in eachindex(M.atoms)
        if Garside.isrightdescent(M,s[j],a)
          y=/(M,s[j],M.atoms[a])
          p=findfirst(==(y),s[from+1:end])
          if p===nothing push!(s,y);p=length(s) 
          else p+=from
          end
          push!(edges,(j,a,p))
        end
      end
    end
    if s[end]==one(M) break end
  end
  p=1+length(s)
  edges=map(x->p.-reverse(x),edges)
  po=map(x->Int[],s)
  for x in edges push!(po[x[1]],x[3]) end
  (reverse(s),reverse(edges),CPoset(po))
end

"""
check_lattice(M) complement to the previous programs. 

checks the lattice property to make sure `M` is Garside.
"""
function check_lattice(M) 
  p=lattice(M)[3]
  is_join_semilattice(p) && is_meet_semilattice(p)
end

"""
`subsets_representatives(W)` returns representatives of conjugacy classes of
subsets of reflections which generate W
"""
function subsets_representatives(W)
  rr=refls(W)
  r=rr[unique_refls(W)]
  res=[]
  for d in semisimplerank(W):length(r)
    println("d=",d,"=>",ncombinations(r,d))
    l=combinations(r,d)
    l=orbits(W,l,(v,g)->sort(v.^g))
    l=map(o->map(u->indexin(u,rr),o),l)
    l=map(o->sort(sort.(o)),l)
    l=first.(l)
    l=filter(x->length(Group(rr[x]))==length(W),l)
    append!(res,l)
  end
  res
end
