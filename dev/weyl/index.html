<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Finite Coxeter groups, Weyl groups, crystallographic root systems ¬∑ Chevie.jl documentation</title><meta name="title" content="Finite Coxeter groups, Weyl groups, crystallographic root systems ¬∑ Chevie.jl documentation"/><meta property="og:title" content="Finite Coxeter groups, Weyl groups, crystallographic root systems ¬∑ Chevie.jl documentation"/><meta property="twitter:title" content="Finite Coxeter groups, Weyl groups, crystallographic root systems ¬∑ Chevie.jl documentation"/><meta name="description" content="Documentation for Chevie.jl documentation."/><meta property="og:description" content="Documentation for Chevie.jl documentation."/><meta property="twitter:description" content="Documentation for Chevie.jl documentation."/><meta property="og:url" content="https://juliadocs.github.io/Chevie.jl/weyl/"/><meta property="twitter:url" content="https://juliadocs.github.io/Chevie.jl/weyl/"/><link rel="canonical" href="https://juliadocs.github.io/Chevie.jl/weyl/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Chevie.jl documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Chevie</a></li><li><span class="tocitem">Infrastructure</span><ul><li><a class="tocitem" href="../format/">formatting facilities</a></li><li><a class="tocitem" href="../symbols/">Symbols</a></li><li><a class="tocitem" href="../nf/">Number fields</a></li></ul></li><li><span class="tocitem">Reflection groups</span><ul><li><a class="tocitem" href="../permroot/">Finite reflection groups</a></li><li><a class="tocitem" href="../coxgroups/">Coxeter groups</a></li><li class="is-active"><a class="tocitem" href>Finite Coxeter groups, Weyl groups, crystallographic root systems</a></li><li><a class="tocitem" href="../chars/">Classes/characters of reflection groups</a></li></ul></li><li><span class="tocitem">Hecke algebras</span><ul><li><a class="tocitem" href="../hecke/">Hecke algebras</a></li><li><a class="tocitem" href="../kl/">Kazhdan-Lusztig polynomials and bases</a></li><li><a class="tocitem" href="../algebras/">Algebras</a></li></ul></li><li><a class="tocitem" href="../garside/">Garside monoids and groups, braids.</a></li><li><span class="tocitem">Reductive groups</span><ul><li><a class="tocitem" href="../rootdata/">Reductive algebraic groups and root data</a></li><li><a class="tocitem" href="../semisimple/">Semisimple elements</a></li><li><a class="tocitem" href="../cosets/">Reflection cosets and Spets</a></li><li><a class="tocitem" href="../sscoset/">Non-connected reductive groups</a></li><li><a class="tocitem" href="../uch/">Unipotent characters</a></li><li><a class="tocitem" href="../ct/">Classtypes</a></li></ul></li><li><span class="tocitem">Eigenspaces</span><ul><li><a class="tocitem" href="../eigen/">Eigenspaces</a></li><li><a class="tocitem" href="../dseries/">d-Harish-Chandra series</a></li></ul></li><li><span class="tocitem">Unipotent elements</span><ul><li><a class="tocitem" href="../ucl/">Unipotent classes of reductive groups</a></li><li><a class="tocitem" href="../urad/">Unipotent Elements</a></li></ul></li><li><a class="tocitem" href="../gendec/">Decomposition Matrices</a></li><li><a class="tocitem" href="../references/">References</a></li><li><a class="tocitem" href="../dict/">-</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reflection groups</a></li><li class="is-active"><a href>Finite Coxeter groups, Weyl groups, crystallographic root systems</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Finite Coxeter groups, Weyl groups, crystallographic root systems</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jmichel7/Chevie.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jmichel7/Chevie.jl/blob/main/docs/src/weyl.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Finite-Coxeter-groups,-Weyl-groups,-crystallographic-root-systems"><a class="docs-heading-anchor" href="#Finite-Coxeter-groups,-Weyl-groups,-crystallographic-root-systems">Finite Coxeter groups, Weyl groups, crystallographic root systems</a><a id="Finite-Coxeter-groups,-Weyl-groups,-crystallographic-root-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-Coxeter-groups,-Weyl-groups,-crystallographic-root-systems" title="Permalink"></a></h1><ul><li><a href="#Chevie.Weyl"><code>Chevie.Weyl</code></a></li><li><a href="#Chevie.CoxGroups.coxeter_group"><code>Chevie.CoxGroups.coxeter_group</code></a></li><li><a href="#Chevie.CoxGroups.coxeter_group-Tuple{}"><code>Chevie.CoxGroups.coxeter_group</code></a></li><li><a href="#Chevie.CoxGroups.inversions"><code>Chevie.CoxGroups.inversions</code></a></li><li><a href="#Chevie.PermRoot.cartan-Tuple{Symbol, Integer, Integer}"><code>Chevie.PermRoot.cartan</code></a></li><li><a href="#Chevie.PermRoot.reflection_subgroup-Tuple{Chevie.Weyl.FCG, AbstractVector{&lt;:Integer}}"><code>Chevie.PermRoot.reflection_subgroup</code></a></li><li><a href="#Chevie.PermRoot.roots-Tuple{AbstractMatrix}"><code>Chevie.PermRoot.roots</code></a></li><li><a href="#Chevie.Weyl.affine"><code>Chevie.Weyl.affine</code></a></li><li><a href="#Chevie.Weyl.badprimes"><code>Chevie.Weyl.badprimes</code></a></li><li><a href="#Chevie.Weyl.describe_involution"><code>Chevie.Weyl.describe_involution</code></a></li><li><a href="#Chevie.Weyl.highest_short_root"><code>Chevie.Weyl.highest_short_root</code></a></li><li><a href="#Chevie.Weyl.relative_group"><code>Chevie.Weyl.relative_group</code></a></li><li><a href="#Chevie.Weyl.rootdatum-Tuple{AbstractMatrix, AbstractMatrix}"><code>Chevie.Weyl.rootdatum</code></a></li><li><a href="#Chevie.Weyl.rootdatum-Tuple{AbstractMatrix}"><code>Chevie.Weyl.rootdatum</code></a></li><li><a href="#Chevie.Weyl.rootlengths"><code>Chevie.Weyl.rootlengths</code></a></li><li><a href="#Chevie.Weyl.standard_parabolic-Tuple{Union{Chevie.Weyl.FCG, Chevie.Weyl.FCSG}, AbstractVector{&lt;:Integer}}"><code>Chevie.Weyl.standard_parabolic</code></a></li><li><a href="#Chevie.Weyl.two_tree"><code>Chevie.Weyl.two_tree</code></a></li><li><a href="#Chevie.Weyl.with_inversions"><code>Chevie.Weyl.with_inversions</code></a></li></ul><article><details class="docstring" open="true"><summary id="Chevie.Weyl"><a class="docstring-binding" href="#Chevie.Weyl"><code>Chevie.Weyl</code></a> ‚Äî <span class="docstring-category">Module</span></summary><section><div><p>Finite Coxeter groups are the finite complex reflection groups which can be defined on a real vector space <code>V</code>.</p><p><em>Weyl  groups</em> are the  finite Coxeter groups  which can be  defined over a rational vector space <code>V</code> (thus over the integers).</p><p>Like   finite  complex   reflection  groups,   finite  Coxeter  groups  are implemented  as groups  of permutations  of a  set of roots. The particular <em>crystallographic</em>  root systems for Weyl groups  play an important role in mathematics as they classify semi-simple Lie algebras and algebraic groups.</p><p>Let  us give precise definitions.  Let <code>V</code> be a  real vector space and <code>V‚±Ω</code> its  dual. A <em>root system</em> is a finite set of vectors <code>R‚äÇ V</code> (the <em>roots</em>), together with a map <code>r‚Ü¶ r‚±Ω</code> from <code>R</code> to a set <code>R‚±Ω‚äÇ V‚±Ω</code> (the <em>coroots</em>) such that:</p><ul><li>For any <code>r‚àà R</code>,  we have <code>r‚±Ω(r)=2</code>, so  that the formula <code>x‚Ü¶ x-r‚±Ω(x)r</code> defines  a  reflection  <code>s·µ£:V‚Üí  V</code>  with  root  <code>r</code>  and coroot <code>r‚±Ω</code> (see <a href="../permroot/#Chevie.PermRoot.reflectionMatrix"><code>reflectionMatrix</code></a>).</li><li>The reflection <code>s·µ£</code> stabilizes <code>R</code>.</li></ul><p>The  subgroup <code>W=W(R)</code> of <code>GL(V)</code> generated by the reflections <code>s·µ£</code> for <code>r‚àà R</code>  is a finite Coxeter group. We  use only <em>reduced</em> root systems, that is such  that the only elements of <code>R</code> colinear  with <code>r‚àà R</code> are <code>r</code> and <code>-r</code>; for Weyl groups, we also require that the root system be <em>crystallographic</em>, that is <code>r‚±Ω(s)</code> is an integer, for any <code>s‚àà R,r‚±Ω‚àà R‚±Ω</code>.</p><p>If  we identify  <code>V</code> with  <code>V‚±Ω</code> by  choosing a  <code>W</code>-invariant bilinear form <code>(.;.)</code>,  then we have <code>r‚±Ω=2r/(r;r)</code>. A root system <code>R</code> is <em>irreducible</em> if <code>R</code>   is  not  the  union  of  two  orthogonal  subsets;  equivalently  the representation  of <code>W</code> on the subspace  generated by <code>R</code> is irreducible. If <code>R</code> is reducible then the corresponding Coxeter group is the direct product of the Coxeter groups associated with the irreducible components of <code>R</code>.</p><p>Let  us  now  describe  how  a  root  system  <code>R</code> and a presentation of the corresponding  <code>W</code> are encoded in  a Cartan matrix or  a Dynkin diagram. We can  choose a linear  form on <code>V</code>  which does not  vanish on any element of <code>R</code>.  Depending on the sign of the value of this linear form on a root <code>r ‚àà R</code>  we call <code>r</code> <em>positive</em> or <em>negative</em>. Then there exists a unique subset <code>Œ†</code>  of the positive roots, the <em>simple roots</em>, such that any positive root is a linear combination with non-negative coefficients of the roots in <code>Œ†</code>. Any  two sets of simple roots (corresponding to different choices of linear forms) can be transformed into each other by a unique element of <code>W(R)</code>. If <code>S</code>  is  the  set  of  reflections  with  respect to the simple roots, then <code>(W,S)</code>  is  a  Coxeter  system.  These  generating  reflections are called <em>Coxeter generators</em> or <em>simple reflections</em>.</p><p>Since the pairing between <code>V</code> and <code>V‚±Ω</code> is <code>W</code>-invariant, if <code>Œ†</code> is a set of simple  roots and if we  define the <em>Cartan matrix</em>  as being the <code>n</code> times <code>n</code>  matrix <code>C={r‚±Ω(r&#39;)}</code>  for <code>r,r&#39;‚ààŒ†</code>,  this matrix  is independent of the chosen  linear form  up to  simultaneous permutation  of rows  and columns. Since the action of <code>s·µ£</code> on <code>r&#39;</code> for <code>r,r&#39;‚ààŒ†</code> is given by <code>s·µ£(r&#39;)=r&#39;-C(r,r&#39;)r</code>,   the   Cartan   matrix   determines  the  reflection representation of <code>W</code>.</p><p>For  a crystallographic root system the Cartan matrix has integral entries, and  in the basis <code>Œ†</code> (completed by a basis of the orthogonal), <code>s·µ£</code> has an integral    matrix.   In   general,    all   finite-dimensional   (complex) representations  of a finite Coxeter group  can be realized over the (real) subfield generated by the entries of the Cartan matrix.</p><p>An integral Cartan matrix can be encoded in a <em>Dynkin diagram</em>, a tree with weighted  edges and an orientation on edges  of even weight &gt;2, as follows. The  vertices  are  indexed  by  the  simple  reflections; an edge is drawn between  <code>s</code> and <code>t</code> if the order <code>m‚Çõ‚Çú</code>  of <code>st</code> is greater than <code>2</code> and is given  the  weight  <code>m‚Çõ‚Çú</code>.  These  weights  are encoded by drawing the edge single  for weight  3, double  for weight  4 and  triple for  weight 6. The arrows  indicate the  relative root  lengths (going  from the longer to the shorter  root) which  may differ  between different  orbits of  <code>W</code> on <code>R</code>. Alternately  the Dynkin diagram  can be obtained  from the Cartan matrix as follows: if <code>C·µ£‚Çõ</code> and <code>C‚Çõ·µ£</code> are integers such that <code>|C‚Çõ·µ£|‚â•|C·µ£‚Çõ|=1</code> there is an  edge of weight <code>|C‚Çõ·µ£|</code> from <code>r</code> to <code>s</code> with an arrow pointing to <code>s</code> if <code>|C‚Çõ·µ£|&gt;1</code>.  Note  that  the  Cartan  matrices  we  consider  here  are  not necessarily  symmetric,  contrary  to  the  Cartan  matrices  we considered describing  the reflection representation of a general Coxeter group; being symmetric corresponds to all roots being taken of the same length.</p><p>The  irreducible  crystallographic  root  systems  are  classified  by  the following  list of Dynkin diagrams. The labeling  of the nodes is the order of the generators and is shown by the function <code>diagram</code>.</p><pre><code class="language-julia hljs">A‚Çô O‚ÄîO‚ÄîO‚Äî‚Ä¶‚ÄîO   B‚Çô O‚áê O‚ÄîO‚Äî‚Ä¶‚ÄîO  C‚Çô O‚áí O‚ÄîO‚Äî‚Ä¶‚ÄîO  D‚Çô O 2
   1 2 3 ‚Ä¶ n      1  2 3 ‚Ä¶ n     1  2 3 ‚Ä¶ n     Ôø®
                                              O‚ÄîO‚Äî‚Ä¶‚ÄîO
                                              1 3 ‚Ä¶ n

G‚ÇÇ O‚áõ O  F‚ÇÑ O‚ÄîO‚áíO‚ÄîO    E‚ÇÜ  O 2    E‚Çá  O 2      E‚Çà  O 2
   1  2     1 2 3 4        Ôø®          Ôø®            Ôø®
                       O‚ÄîO‚ÄîO‚ÄîO‚ÄîO  O‚ÄîO‚ÄîO‚ÄîO‚ÄîO‚ÄîO  O‚ÄîO‚ÄîO‚ÄîO‚ÄîO‚ÄîO‚ÄîO
                       1 3 4 5 6  1 3 4 5 6 7  1 3 4 5 6 7 8</code></pre><p>If  we ignore the arrows we get  the <em>Coxeter diagram</em>, which describes the underlying  Coxeter system  group: we  see that  the root systems <code>B_n</code> and <code>C_n</code>  correspond to the same Coxeter group (the Coxeter diagram is defined by  the <a href="../coxgroups/#FinitePosets.coxeter_matrix"><code>coxeter_matrix</code></a>). Weyl groups can also be characterized as the finite Coxeter groups such that all off-diagonal entries of the Coxeter matrix are in <code>{2,3,4,6}</code>.</p><p>Here  are the Coxeter diagrams for the  finite Coxeter groups which are not rational (<code>I‚ÇÇ(e)</code> is not rational if <code>e‚àâ {2,3,4,6}</code>).</p><pre><code class="language-julia hljs">       e        5         5
I‚ÇÇ(e) O‚ÄîO   H‚ÇÉ O‚ÄîO‚ÄîO  H‚ÇÑ O‚ÄîO‚ÄîO‚ÄîO
      1 2      1 2 3     1 2 3 4</code></pre><p>The  function <a href="../coxgroups/#Chevie.PermRoot.cartan-Tuple{AbstractMatrix}"><code>cartan</code></a> gives  the cartan matrix  for an irreducible root system</p><pre><code class="language-julia-repl hljs">julia&gt; cartan(:D,4)
4√ó4 Matrix{Int64}:
  2   0  -1   0
  0   2  -1   0
 -1  -1   2  -1
  0   0  -1   2

julia&gt; cartan(:I,2,5) # for type I‚ÇÇ(e) give e as 3rd argument
2√ó2 Matrix{Cyc{Int64}}:
       2  Œ∂‚ÇÖ¬≤+Œ∂‚ÇÖ¬≥
 Œ∂‚ÇÖ¬≤+Œ∂‚ÇÖ¬≥        2</code></pre><p>For  non-irreducible root systems, we can  get their Cartan matrix by using that,   given   Cartan   matrices   <code>c‚ÇÅ,‚Ä¶,c·µ£</code>,   their  matrix  direct  sum (corresponding  to the  orthogonal direct  sum of  the root systems) can be obtained by <code>cat(c‚ÇÅ,‚Ä¶,c·µ£;dims=[1,2])</code>.</p><p>The  whole  root  system  can  be  recovered  from the simple roots and the corresponding  coroots, since each root  is in the orbit  of a simple root. The  restriction of the simple reflections to the span of <code>R</code> is determined by the Cartan matrix, so <code>R</code> is determined by the Cartan matrix and the set of simple roots.</p><p>The function <a href="../cosets/#Chevie.Weyl.rootdatum-Tuple{Symbol, Int64}"><code>rootdatum</code></a> takes as arguments a matrix <code>r</code> whose rows represents the elements of <code>Œ†</code> (given by their coordinates in the canonical basis of <code>V</code>) and another matrix <code>cr</code> whose rows are the coordinates of the corresponding coroots and returns a <code>FiniteCoxeterGroup</code>. Such an object is a  permutation  group  containing  in  addition  the  description of a root system.  <code>cr*transpose(r)</code> should be  a Cartan matrix  for a finite Coxeter group.  Each element of the coxeter group is represented as the permutation it  induces on the roots,  coded as a permutation  of <code>1:2N</code> where we label the  positive roots  by <code>1:N</code>,  and the  negative roots  by <code>N+1:2N</code> (these permutations  do not  depend on  the actual  roots but  just on  the Cartan matrix).  For Weyl groups  the ordering of  the roots is  very specific: we order  the positive roots  by the sum  of their coefficients  on the simple roots, and lexicographically according to the decomposition in simple roots for  a given sum, and  order the negative roots  in the same order as their negatives.</p><p>If a single matrix argument is given to <code>rootdatum</code> it is taken as <code>cr</code> and <code>r</code>  is taken  to be  the identity  matrix; we  get thus  a particular root system  where the  roots are  the canonical  basis of <code>V</code>. For convenience, <code>rootdatum(cartan(t))</code>   can  be  simplified  to  <code>coxgroup(t)</code>,  giving  a convenient way to get a Coxeter group of a given type.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:D,4) # same as rootdatum(cartan(:D,4))
D‚ÇÑ

julia&gt; cartan(W)
4√ó4 Matrix{Int64}:
  2   0  -1   0
  0   2  -1   0
 -1  -1   2  -1
  0   0  -1   2</code></pre><p>Also,  instead  of  using  the  direct  sum  of  the  Cartan  matrices, the <code>FiniteCoxeterGroup</code> associated to a direct sum of irreducible root systems can be obtained as</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,2)*coxgroup(:B,2)
A‚ÇÇ√óB‚ÇÇ

julia&gt; cartan(W) # same as cat(cartan(:A,2), cartan(:B,2),dims=[1,2])
4√ó4 Matrix{Int64}:
  2  -1   0   0
 -1   2   0   0
  0   0   2  -2
  0   0  -1   2</code></pre><p>The elements of a Weyl group are permutations of the roots:</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:D,4)
D‚ÇÑ

julia&gt; p=W(1,3,2,1,3) # permutes the 24 roots
(1,14,13,2)(3,17,8,18)(4,12)(5,20,6,15)(7,10,11,9)(16,24)(19,22,23,21)

julia&gt; word(W,p) # get a word in the Coxeter generators
5-element Vector{Int64}:
 1
 3
 1
 2
 3</code></pre><p>Note that all the function for reflection groups are available for finite Coxeter groups: <a href="../permroot/#Chevie.Symbols.rank"><code>rank</code></a>, <a href="../permroot/#Chevie.PermRoot.semisimplerank"><code>semisimplerank</code></a>, <a href="../permroot/#Chevie.PermRoot.roots-Tuple{PRG}"><code>roots</code></a>, <a href="../permroot/#Chevie.PermRoot.coroots"><code>coroots</code></a>, <a href="../permroot/#Chevie.PermRoot.simpleroots"><code>simpleroots</code></a>, <a href="../permroot/#Chevie.PermRoot.simplecoroots"><code>simplecoroots</code></a>, <a href="../permroot/#Chevie.PermRoot.simple_reps"><code>simple_reps</code></a>, <a href="../permroot/#Chevie.PermRoot.simple_conjugating"><code>simple_conjugating</code></a>, <a href="../permroot/#Chevie.PermRoot.refls"><code>refls</code></a>, <a href="../permroot/#Chevie.PermRoot.refltype"><code>refltype</code></a>, <a href="../permroot/#Chevie.PermRoot.invariant_form"><code>invariant_form</code></a>, <a href="../permroot/#Chevie.PermRoot.YMatrix"><code>YMatrix</code></a>, <a href="../permroot/#Chevie.PermRoot.PermX"><code>PermX</code></a>, <a href="../permroot/#Chevie.PermRoot.PermY"><code>PermY</code></a>, <a href="../permroot/#Chevie.PermRoot.baseX"><code>baseX</code></a>, <a href="../permroot/#Chevie.PermRoot.inclusion"><code>inclusion</code></a>, <a href="../permroot/#Chevie.PermRoot.inclusiongens"><code>inclusiongens</code></a>, <a href="../permroot/#Chevie.PermRoot.restriction"><code>restriction</code></a>, <a href="../permroot/#PermGroups.Perms.reflection_length-Tuple{PermRootGroup, Perm}"><code>reflection_length</code></a>,</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/5346f2be67a0a46c6ee3f400e4fe85cde8a6208b/src/Weyl.jl#L1-L222">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.cartan-Tuple{Symbol, Integer, Integer}"><a class="docstring-binding" href="#Chevie.PermRoot.cartan-Tuple{Symbol, Integer, Integer}"><code>Chevie.PermRoot.cartan</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p><code>cartan(type, rank [,bond])</code></p><p>the  Cartan matrix for a  finite Coxeter group described  by type and rank. The  recognized types are <code>:A, :B, :Bsym, :C, :D, :E, :F, :Fsym, :G, :Gsym, :I,  :H</code>. For type <code>:I</code> a third  argument must be given describing the bond between the two generators. The <code>sym</code> types correspond to (non-crystallographic)  root systems where all  roots have the same length; they  afford automorphisms that  the crystallographic root  system does not afford, which allow to define the &quot;very twisted&quot; Chevalley groups.</p><pre><code class="language-julia-repl hljs">julia&gt; cartan(:F,4)
4√ó4 Matrix{Int64}:
  2  -1   0   0
 -1   2  -1   0
  0  -2   2  -1
  0   0  -1   2

julia&gt; cartan(:I,2,5)
2√ó2 Matrix{Cyc{Int64}}:
       2  Œ∂‚ÇÖ¬≤+Œ∂‚ÇÖ¬≥
 Œ∂‚ÇÖ¬≤+Œ∂‚ÇÖ¬≥        2

julia&gt; cartan(:Bsym,2)
2√ó2 Matrix{Cyc{Int64}}:
   2  -‚àö2
 -‚àö2    2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/5346f2be67a0a46c6ee3f400e4fe85cde8a6208b/src/Weyl.jl#L334-L363">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.roots-Tuple{AbstractMatrix}"><a class="docstring-binding" href="#Chevie.PermRoot.roots-Tuple{AbstractMatrix}"><code>Chevie.PermRoot.roots</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p><code>roots(C::AbstractMatrix)</code></p><p>returns the set of positive roots defined by the Cartan matrix <code>C</code>, which should be the Cartan matrix of a finite Coxeter group.</p><p>For  an integer Cartan matrix, the returned  roots are sorted by height and reverse lexicographically for a given height.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/5346f2be67a0a46c6ee3f400e4fe85cde8a6208b/src/Weyl.jl#L497-L505">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Weyl.two_tree"><a class="docstring-binding" href="#Chevie.Weyl.two_tree"><code>Chevie.Weyl.two_tree</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p><code>two_tree(m)</code></p><p>Given  a  square  matrix  <code>m</code>  with  zeroes  symmetric  with respect to the diagonal,  let  <code>G</code>  be  the  graph  with vertices <code>axes(m)[1]</code> and an edge between <code>i</code> and <code>j</code> iff <code>!iszero(m[i,j])</code>.</p><p>If  <code>G</code>  is  linear  this  function  returns  this  linear ordering it as a <code>Vector{Int}</code>.  If <code>G</code>  is a  tree with  one vertex  <code>c</code> of valence <code>3</code> the function   returns  <code>(c,b1,b2,b3)</code>   where  <code>b1,b2,b3</code>   are  <code>Vector{Int}</code> representing  the branches  from this  vertex sorted  by increasing length. Otherwise the function returns <code>nothing</code>.</p><p>This function is used when recognizing the type of a Cartan matrix.</p><pre><code class="language-julia-repl hljs">julia&gt; two_tree(cartan(:A,4))
4-element Vector{Int64}:
 1
 2
 3
 4

julia&gt; two_tree(cartan(:E,8))
(4, [2], [3, 1], [5, 6, 7, 8])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/5346f2be67a0a46c6ee3f400e4fe85cde8a6208b/src/Weyl.jl#L379-L404">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.reflection_subgroup-Tuple{Chevie.Weyl.FCG, AbstractVector{&lt;:Integer}}"><a class="docstring-binding" href="#Chevie.PermRoot.reflection_subgroup-Tuple{Chevie.Weyl.FCG, AbstractVector{&lt;:Integer}}"><code>Chevie.PermRoot.reflection_subgroup</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p><code>reflection_subgroup(W::FiniteCoxeterGroup,I)</code></p><p>For <code>I‚äÜ1:nref(W)</code>, the subgroup <code>H</code> of <code>W</code> generated by <code>refls(W,I)</code>.</p><p>A  theorem found independently by (<a href="../references/#deo89">Deodhar, 1989</a>) and (<a href="../references/#dye90">Dyer, 1990</a>) is that a  subgroup <code>H</code> of a Coxeter system  <code>(W,S)</code> generated by reflections has a canonical  Coxeter  generating  set,  formed  of  the  <code>t  ‚àà  Ref(H)</code>  such <code>length(W,tt&#39;)&gt;length(W,t)</code>  for any <code>t&#39;‚àà Ref(H)</code>  different from <code>t</code>. This is used by <code>reflection_subgroup</code> to determine the Coxeter system of <code>H</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
G‚ÇÇ

julia&gt; diagram(W)
O‚áõ O G‚ÇÇ
1  2

julia&gt; H=reflection_subgroup(W,[2,6])
G‚ÇÇ‚Çç‚ÇÇ‚ÇÜ‚Çé=AÃÉ‚ÇÅ√óA‚ÇÅ

julia&gt; diagram(H)
O AÃÉ‚ÇÅ
1
O A‚ÇÅ
2</code></pre><p>The  notation <code>G‚ÇÇ‚Çç‚ÇÇ‚ÇÜ‚Çé</code>  means that  <code>roots(W,[2,6])</code> is  a system of simple roots for <code>H</code>.</p><p>If  <code>H</code> is a  standard parabolic subgroup  of a Coxeter  group <code>W</code> then the length  function on  <code>H</code> (with  respect to  its set  of generators)  is the restriction  of the length function on <code>W</code>. This need not no longer be true for  arbitrary reflection subgroups of  <code>W</code>. </p><pre><code class="language-julia-repl hljs">julia&gt; elH=word.(Ref(H),elements(H))
4-element Vector{Vector{Int64}}:
 []
 [1]
 [2]
 [1, 2]

julia&gt; elW=word.(Ref(W),elements(H))
4-element Vector{Vector{Int64}}:
 []
 [2]
 [1, 2, 1, 2, 1]
 [1, 2, 1, 2, 1, 2]

julia&gt; splat(H).(elH)==splat(W).(elW)
true</code></pre><p>We  implement finite  reflection groups  as permutation  groups on a set of roots.  Consequently,  a  reflection  subgroup  <code>H‚äÜ  W</code>  is  a  permutation subgroup, thus its elements are represented as permutations of the roots of the parent group.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/5346f2be67a0a46c6ee3f400e4fe85cde8a6208b/src/Weyl.jl#L1074-L1132">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.CoxGroups.coxeter_group"><a class="docstring-binding" href="#Chevie.CoxGroups.coxeter_group"><code>Chevie.CoxGroups.coxeter_group</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p><code>coxeter_group(type,rank[,bond];sc=false)</code> (or <code>coxgroup</code>)</p><p>Constructs  the finite Coxeter group of given <code>type</code> and <code>rank</code> (and <code>bond</code> for  dihedral  groups).  If  <code>C=cartan(type,rank[,bond])</code>,  the function is equivalent  to <code>rootdatum(C)</code>  (the adjoint  root datum).  If <code>sc=true</code> the function  is equivalent  to <code>rootdatum(permutedims(C),one(C))</code>  (the simply connected root datum).</p><p>The  resulting object <code>W</code>, a  <code>FiniteCoxeterGroup</code>, has an additional entry compared to a <code>PermRootGroup</code>.</p><ul><li><code>W.rootdec</code>:  the roots, given  as linear combinations of simple roots. The  first <code>nref(W)</code> roots  are the positive  roots, the last <code>nref(W)</code> are  the negative of  the first ones.  Moreover, the first <code>rank</code> roots are  the  simple  roots,  so  these  rows form the identity matrix. The positive roots are ordered by increasing height.</li></ul><p>and <code>roots(W)</code> is ordered is the same way as <code>W.rootdec</code>.</p><p>For  how to  get various  information on  the root  system and  the Coxeter group,   see  the  functions   <code>nref,  coroots,  rootlengths,  simple_reps, simple_conjugating,  reflrep,  simpleroots,  simplecoroots,  PermX, cartan, inclusion, restriction, action, rank, semisimplerank</code>.</p><pre><code class="language-julia_repl hljs">julia&gt; W=coxgroup(:G,2)
G‚ÇÇ

julia&gt; cartan(W)
2√ó2 Matrix{Int64}:
  2  -1
 -3   2

julia&gt; W.rootdec
12-element Vector{Vector{Int64}}:
 [1, 0]
 [0, 1]
 [1, 1]
 [1, 2]
 [1, 3]
 [2, 3]
 [-1, 0]
 [0, -1]
 [-1, -1]
 [-1, -2]
 [-1, -3]
 [-2, -3]

julia&gt; reflrep(W)
2-element Vector{Matrix{Int64}}:
 [-1 0; 1 1]
 [1 3; 0 -1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/5346f2be67a0a46c6ee3f400e4fe85cde8a6208b/src/Weyl.jl#L852-L905">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.CoxGroups.coxeter_group-Tuple{}"><a class="docstring-binding" href="#Chevie.CoxGroups.coxeter_group-Tuple{}"><code>Chevie.CoxGroups.coxeter_group</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p><code>coxeter_group()</code> or <code>coxgroup()</code> the trivial Coxeter group</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/5346f2be67a0a46c6ee3f400e4fe85cde8a6208b/src/Weyl.jl#L909">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Weyl.rootlengths"><a class="docstring-binding" href="#Chevie.Weyl.rootlengths"><code>Chevie.Weyl.rootlengths</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p><code>rootlengths(W::FiniteCoxeterGroup)</code>  the vector  of the (squared)  length of the roots of <code>W</code>.  The  shortest roots in an irreducible subsystem are given the length 1. In  a Weyl group the others then have length 2 (or 3 in type <code>G‚ÇÇ</code>). The matrix  of the <code>W</code>-invariant bilinear form is given by  <code>Diagonal(rootlengths(W)[1:ngens(W)])*cartan(W)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/5346f2be67a0a46c6ee3f400e4fe85cde8a6208b/src/Weyl.jl#L975-L982">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Weyl.highest_short_root"><a class="docstring-binding" href="#Chevie.Weyl.highest_short_root"><code>Chevie.Weyl.highest_short_root</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p><code>highest_short_root(W)</code></p><p>It  is  an  error  if  <code>W</code>  is  not an irreducible Coxeter group. Otherwise <code>HighestShortRoot</code>  returns the index  of the unique  short root of maximal height  of <code>W</code>. If all roots have the same length then this is the index of the unique root of maximal height, equal to <code>nref(W)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
G‚ÇÇ

julia&gt; highest_short_root(W)
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/5346f2be67a0a46c6ee3f400e4fe85cde8a6208b/src/Weyl.jl#L1003-L1018">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Weyl.describe_involution"><a class="docstring-binding" href="#Chevie.Weyl.describe_involution"><code>Chevie.Weyl.describe_involution</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p><code>describe_involution(W,w)</code></p><p>Given  an  involution  <code>w</code>  of  a  Coxeter  group  <code>W</code>,  by  a  theorem  of (<a href="../references/#rich82">Richardson, 1982</a>)  there is a unique parabolic  subgroup <code>P</code> of <code>W</code> such that <code>P</code> is finite and <code>w</code> is the longest element of <code>P</code>, and is central in <code>P</code>. The  function  returns  <code>I</code>  such  that  <code>P==reflection_subgroup(W,I)</code>  and <code>w==longest(reflection_subgroup(W,I))</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,2)
A‚ÇÇ

julia&gt; w=longest(W)
(1,5)(2,4)(3,6)

julia&gt; describe_involution(W,w)
1-element Vector{Int64}:
 3

julia&gt; w==longest(reflection_subgroup(W,[3]))
true</code></pre><p>For now only works for finite Coxeter groups.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/5346f2be67a0a46c6ee3f400e4fe85cde8a6208b/src/Weyl.jl#L743-L767">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Weyl.badprimes"><a class="docstring-binding" href="#Chevie.Weyl.badprimes"><code>Chevie.Weyl.badprimes</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p><code>badprimes(W)</code></p><p>Let  <code>W</code>  be  a  Weyl  group.  A  prime  is  <em>bad</em>  for <code>W</code> if it divides a coefficient  of some  root on  the simple  roots. The  function <code>badprimes</code> returns the list of primes which are bad for <code>W</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:E,8)
E‚Çà

julia&gt; badprimes(W)
3-element Vector{Int64}:
 2
 3
 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/5346f2be67a0a46c6ee3f400e4fe85cde8a6208b/src/Weyl.jl#L715-L732">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Weyl.standard_parabolic-Tuple{Union{Chevie.Weyl.FCG, Chevie.Weyl.FCSG}, AbstractVector{&lt;:Integer}}"><a class="docstring-binding" href="#Chevie.Weyl.standard_parabolic-Tuple{Union{Chevie.Weyl.FCG, Chevie.Weyl.FCSG}, AbstractVector{&lt;:Integer}}"><code>Chevie.Weyl.standard_parabolic</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p><code>standard_parabolic(W,H)</code></p><p>Given  a reflection subgroup <code>H</code> or the indices of its simple roots returns <code>nothing</code> if <code>H</code> is not parabolic, otherwise returns <code>w</code> such that <code>H^w</code> is a standard parabolic subgroup of <code>W</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:E,6)
E‚ÇÜ

julia&gt; R=reflection_subgroup(W,[20,30,19,22])
E‚ÇÜ‚Çç‚ÇÅ‚Äö‚Çâ‚Äö‚ÇÅ‚Çâ‚Äö‚ÇÇ‚ÇÄ‚Çé=A‚ÇÑ‚Çç‚ÇÉ‚ÇÅ‚ÇÇ‚ÇÑ‚ÇéŒ¶‚ÇÅ¬≤

julia&gt; p=standard_parabolic(W,R)
(1,4,49,12,10)(2,54,62,3,19)(5,17,43,60,9)(6,21,34,36,20)(7,24,45,41,53)(8,65,50,15,22)(11,32,31,27,28)(13,48,46,37,40)(14,51,58,44,29)(16,23,35,33,30)(18,26,39,55,38)(42,57,70,72,56)(47,68,67,63,64)(52,59,71,69,66)

julia&gt; p==standard_parabolic(W,[19,1,9,20]) # can give inclusiongens
true

julia&gt; reflection_subgroup(W,[20,30,19,22].^p) # same as R^p
E‚ÇÜ‚Çç‚ÇÇ‚ÇÑ‚ÇÖ‚ÇÜ‚Çé=A‚ÇÑŒ¶‚ÇÅ¬≤

julia&gt; R=reflection_subgroup(W,[1,2,3,5,6,35])
E‚ÇÜ‚Çç‚ÇÅ‚Äö‚ÇÇ‚Äö‚ÇÉ‚Äö‚ÇÖ‚Äö‚ÇÜ‚Äö‚ÇÉ‚ÇÖ‚Çé=A‚ÇÇ‚Çç‚ÇÅ‚ÇÉ‚Çé√óA‚ÇÇ‚Çç‚ÇÇ‚ÇÜ‚Çé√óA‚ÇÇ‚Çç‚ÇÑ‚ÇÖ‚Çé

julia&gt; standard_parabolic(W,R)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/5346f2be67a0a46c6ee3f400e4fe85cde8a6208b/src/Weyl.jl#L661-L689">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.CoxGroups.inversions"><a class="docstring-binding" href="#Chevie.CoxGroups.inversions"><code>Chevie.CoxGroups.inversions</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p><code>inversions(W,w)</code></p><p>Returns  the inversions of the element <code>w</code> of the finite Coxeter group <code>W</code>, that  is, the list of the  indices of reflections <code>r</code> of <code>W</code> such that <code>l(rw)&lt;l(w)</code> where <code>l</code> is the Coxeter length.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A‚ÇÉ

julia&gt; inversions(W,W(1,2,1))
3-element Vector{Int64}:
 1
 2
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/5346f2be67a0a46c6ee3f400e4fe85cde8a6208b/src/CoxGroups.jl#L641-L658">source</a></section><section><div><p><code>inversions(W::FiniteCoxeterGroup, w::AbstractVector{&lt;:Integer})</code></p><p>Given  a word <code>w=[s‚ÇÅ,‚Ä¶,s‚Çô]</code> (a vector of integers) representing the element <code>W(w...)</code>,  returns the inversions of  <code>w</code>, that is the  list of indices of the reflections of <code>W</code> given by <code>W(s‚ÇÅ), W(s‚ÇÅ,s‚ÇÇ,s‚ÇÅ), ‚Ä¶, W(s‚ÇÅ,s‚ÇÇ,‚Ä¶,s‚Çô,s‚Çô‚Çã‚ÇÅ,‚Ä¶,s‚ÇÅ)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A‚ÇÉ

julia&gt; inversions(W,[2,1,2])
3-element Vector{Int64}:
 2
 4
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/5346f2be67a0a46c6ee3f400e4fe85cde8a6208b/src/Weyl.jl#L602-L620">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Weyl.with_inversions"><a class="docstring-binding" href="#Chevie.Weyl.with_inversions"><code>Chevie.Weyl.with_inversions</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p><code>with_inversions(W,N)</code></p><p><code>W</code>  should be  a finite  Coxeter group  and <code>N</code>  a subset  of <code>1:nref(W)</code>. Returns  the  element  <code>w</code>  of  <code>W</code> such that <code>N==inversions(W,w)</code>. Returns <code>nothing</code> if no such element exists.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,2)
A‚ÇÇ

julia&gt; with_inversions.(Ref(W),combinations(1:nref(W)))
8-element Vector{Union{Nothing, Perm{Int16}}}:
 ()
 (1,4)(2,3)(5,6)
 (1,3)(2,5)(4,6)
 nothing
 nothing
 (1,6,2)(3,5,4)
 (1,2,6)(3,4,5)
 (1,5)(2,4)(3,6)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/5346f2be67a0a46c6ee3f400e4fe85cde8a6208b/src/Weyl.jl#L624-L646">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Weyl.relative_group"><a class="docstring-binding" href="#Chevie.Weyl.relative_group"><code>Chevie.Weyl.relative_group</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p><code>relative_group(W::FiniteCoxeterGroup,J)</code></p><p><code>J</code>  should be a if <em>distinguished</em> subset of <code>S==eachindex(gens(W))</code>, that is if for <code>s‚àà S-J</code> we set <span>$v(s,J)=w‚ÇÄ^{J‚à™ s}w‚ÇÄ·¥∂$</span> then <code>J</code> is stable by all <code>v(s,J)</code>.  Then <span>$N_W(W_J)=W_J‚ãä N‚ÇÅ$</span>  where <code>N‚ÇÅ</code> is  the group generated by the  <code>v(s,J)</code>,  which  form  a  Coxeter  system for <code>N‚ÇÅ</code>. Equivalently <code>N‚ÇÅ</code> consists   of  the   <code>J</code>-reduced  elements   of  <code>N_W(W_J)</code>.  The  quotient <code>R=N_W(W_J)/W_J</code> has a natural reflection representation on <span>$X(ZL_J/ZG)$</span>, using that by (<a href="../references/#lus76">Lusztig, 1976</a>), the images of the roots of <code>W</code> in <span>$X(ZL_J)$</span> form  a root  system. The  function returns  <code>R</code> as  a reflection  group on <span>$X(ZL_J/ZG)$</span>, with some extra attributes reflecting its origin</p><ul><li><code>R.relative_indices=setdiff(S,J)</code> in a certain order</li><li><code>R.toparent=</code> the list of <code>v(s,J)</code> corresponding to <code>.relative_indices</code>;  defines an isomorphism <code>R‚Üí N‚ÇÅ</code>.</li><li><code>R.fromparent</code>  is  a  function  mapping elements of <code>N‚ÇÅ</code> to <code>R</code>. The  inverse mapping to <code>.toparent</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/5346f2be67a0a46c6ee3f400e4fe85cde8a6208b/src/Weyl.jl#L1188-L1205">source</a></section><section><div><p><code>relative_group(s::Series)</code></p><p>computes  <code>s.WGL</code>  (denoted  <code>W_ùîæ(ùïÉ,Œª)</code>  in  spetses  2014)  as a relgroup, containing  function field <code>.toparent</code>  (lifting reflections to  elts of W) and  field  <code>.reflists</code>  (lifting  a  generator  s  to  reflections  of the parabolic ùïÑ of <code>W</code> such that <code>W_ùïÑ (ùïÉ,Œª)=&lt;s&gt;</code>)</p><p>fills also <code>.WGLdims</code>:  dimensions of <code>Irr(s.WGL)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/5346f2be67a0a46c6ee3f400e4fe85cde8a6208b/src/dSeries.jl#L680-L689">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Weyl.affine"><a class="docstring-binding" href="#Chevie.Weyl.affine"><code>Chevie.Weyl.affine</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>A  <em>generalized Cartan matrix</em> <code>C</code>  is a square integer  matrix of size <code>n</code> such  that <code>c·µ¢·µ¢=2</code>, <code>c·µ¢‚±º‚â§0</code> if <code>i‚â†j</code>, and <code>c·µ¢‚±º==0</code> if and only if <code>c‚±º·µ¢==0</code>. We  say  that  <code>C</code>  is  <em>indecomposable</em>  if  it  does  not admit any block decomposition.</p><p>Let  <code>C</code> be a generalized  Cartan matrix. For <code>I</code>  a subset of <code>{1,‚Ä¶,n}</code> we denote  by <code>C_I</code> the square  submatrix with indices <code>i,j</code>  taken in <code>I</code>. If <code>v</code>  is a real vector of length <code>n</code>, we write <code>v&gt;0</code> if for all <code>i‚àà {1,‚Ä¶,n}</code> we  have <code>v·µ¢&gt;0</code>. It can be shown that <code>C</code> is a Cartan matrix if and only if for  all sets  <code>I</code>, we  have <code>det  C_I&gt;0</code>; or  equivalently, if and only if there  exists  <code>v&gt;0</code>  such  that  <code>C.v&gt;0</code>.  <code>C</code> is called an <em>affine Cartan matrix</em>  if for all proper subsets <code>I</code> we have <code>det C_I&gt;0</code>, but <code>det C==0</code>; or equivalently if there exists <code>v&gt;0</code> such that <code>C.v==0</code>.</p><p>Given  an  irreducible  Weyl  group  <code>W</code>  with  Cartan  matrix  <code>C</code>, we can construct  a generalized  Cartan matrix  <code>CÃÉ</code> as  follows. Let  <code>Œ±‚ÇÄ</code> be the opposed of the highest root. Then the matrix <span>$\left(\begin{array}{cc}C&amp;C.Œ±‚ÇÄ\\  Œ±‚ÇÄ.C&amp;2\end{array}\right)$</span> is  an  affine  Cartan  matrix.  The  affine  Cartan  matrices which can be obtained  in this way  are those we  are interested in,  which give rise to affine Weyl groups.</p><p>Let <code>d=n-rank(C)</code>. A <em>realization</em> of a generalized Cartan matrix is a pair <code>V,V·µõ</code>  of vector spaces of dimension <code>n+d</code> together with vectors <code>Œ±‚ÇÅ,‚Ä¶,Œ±‚Çô‚àà V</code>  (the <em>simple roots</em>), <code>Œ±·µõ‚ÇÅ,‚Ä¶,Œ±·µõ‚Çô‚àà V·µõ</code> (the <em>simple coroots</em>), such that <code>(Œ±·µõ·µ¢,  Œ±‚±º)=c_{i,j}</code>.  Up  to  isomorphism,  a  realization  is obtained as follows: write <span>$C=\left(\begin{array}{c}C_1\\C_2\end{array}\right)$</span> where  <code>C‚ÇÅ</code> is  of same  rank as  <code>C</code>. Then  take <code>Œ±·µ¢</code>  to be the first <code>n</code> vectors  in a basis of <code>V</code>, and take <code>Œ±·µõ‚±º</code> to be given in the dual basis by the rows of the matrix <span>$\left(\begin{array}{cc}C‚ÇÅ&amp;0\\ C_2&amp;\hbox{Id}_d\\ \end{array}\right).$</span> To  <code>C</code> we associate a reflection group  in the space <code>V</code>, generated by the <em>fundamental  reflections</em>  <code>r·µ¢</code>  given  by  <code>r·µ¢(v)=v-(Œ±·µõ·µ¢,v)Œ±·µ¢</code>. This is a Coxeter  group, called the <em>affine Weyl group</em> <code>WÃÉ</code> associated to <code>W</code> when we start with the affine Cartan matrix associated to a Weyl group <code>W</code>.</p><p>The  affine Weyl  group is  infinite; it  has one additional generator <code>s‚ÇÄ</code> (the  affine reflection with respect  to <code>Œ±‚ÇÄ</code>) compared to  <code>W</code>. We can not use  <code>0</code> as a label by default for  a generator of a Coxeter group (because the default labels are used as indices, and indices start at 1 in Julia) so we label it as <code>n+1</code> where <code>n</code> is the numbers of generators of <code>W</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=affine(coxgroup(:A,4))
AÃÉ‚ÇÑ

julia&gt; diagram(W)
       ‚Äî‚Äî‚Äî‚Äî5‚Äî‚Äî‚Äî‚Äî
      /         \
AÃÉ‚ÇÑ   1‚Äî‚Äî‚Äî2‚Äî‚Äî‚Äî3‚Äî‚Äî‚Äî4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/5346f2be67a0a46c6ee3f400e4fe85cde8a6208b/src/Weyl.jl#L1254-L1307">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Weyl.rootdatum-Tuple{AbstractMatrix}"><a class="docstring-binding" href="#Chevie.Weyl.rootdatum-Tuple{AbstractMatrix}"><code>Chevie.Weyl.rootdatum</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p><code>rootdatum(C::AbstractMatrix)</code>  adjoint root datum  from Cartan matrix <code>C</code>. It  is the  same as  <code>rootdatum(one(C),C)</code>. The  adjoint group  is also the default  returned for <code>coxeter_group(type,rank)</code>. The following methods all define <code>pgl‚ÇÉ</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; rootdatum(cartan(:A,3))==coxgroup(:A,3)
true

julia&gt; rootdatum(:pgl,3)
pgl‚ÇÉ</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/5346f2be67a0a46c6ee3f400e4fe85cde8a6208b/src/Weyl.jl#L912-L924">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Weyl.rootdatum-Tuple{AbstractMatrix, AbstractMatrix}"><a class="docstring-binding" href="#Chevie.Weyl.rootdatum-Tuple{AbstractMatrix, AbstractMatrix}"><code>Chevie.Weyl.rootdatum</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p><code>rootdatum(R::AbstractMatrix,CR::AbstractMatrix)</code></p><p>constructs  the root datum given by the  simple roots which are the rows of <code>R</code>  and  the  simple  coroots  which  are  the  rows  of <code>CR</code>. This is the reflection  group  on  the  rowspace  of  <code>R</code>  generated by the reflections <code>reflectionMatrix(R[i,:],CR[i,:])</code>.</p><p>In  another interpretation this constructs the  root datum of the algebraic group  such that the rows of <code>R</code> are  the simple roots on a basis of <code>X(T)</code> and  the rows of <code>CR</code> are the simple  coroots on a basis of <code>Y(T)</code>. In this interpretation the following methods all define <code>gl‚ÇÉ</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; rootdatum(:gl,3)==rootdatum(&quot;gl&quot;,3)
true

julia&gt; rootdatum([1 -1 0;0 1 -1],[1 -1 0;0 1 -1])
A‚ÇÇŒ¶‚ÇÅ</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/5346f2be67a0a46c6ee3f400e4fe85cde8a6208b/src/Weyl.jl#L927-L947">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../coxgroups/">¬´ Coxeter groups</a><a class="docs-footer-nextpage" href="../chars/">Classes/characters of reflection groups ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 8 December 2025 17:29">Monday 8 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
