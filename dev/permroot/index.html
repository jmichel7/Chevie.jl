<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Finite reflection groups · Chevie.jl documentation</title><meta name="title" content="Finite reflection groups · Chevie.jl documentation"/><meta property="og:title" content="Finite reflection groups · Chevie.jl documentation"/><meta property="twitter:title" content="Finite reflection groups · Chevie.jl documentation"/><meta name="description" content="Documentation for Chevie.jl documentation."/><meta property="og:description" content="Documentation for Chevie.jl documentation."/><meta property="twitter:description" content="Documentation for Chevie.jl documentation."/><meta property="og:url" content="https://juliadocs.github.io/Chevie.jl/permroot/"/><meta property="twitter:url" content="https://juliadocs.github.io/Chevie.jl/permroot/"/><link rel="canonical" href="https://juliadocs.github.io/Chevie.jl/permroot/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Chevie.jl documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Chevie</a></li><li><span class="tocitem">Infrastructure</span><ul><li><a class="tocitem" href="../format/">formatting facilities</a></li><li><a class="tocitem" href="../symbols/">Symbols</a></li><li><a class="tocitem" href="../nf/">Number fields</a></li></ul></li><li><span class="tocitem">Reflection groups</span><ul><li class="is-active"><a class="tocitem" href>Finite reflection groups</a></li><li><a class="tocitem" href="../coxgroups/">Coxeter groups</a></li><li><a class="tocitem" href="../weyl/">Finite Coxeter groups, Weyl groups, crystallographic root systems</a></li><li><a class="tocitem" href="../chars/">Classes/characters of reflection groups</a></li></ul></li><li><span class="tocitem">Hecke algebras</span><ul><li><a class="tocitem" href="../hecke/">Hecke algebras</a></li><li><a class="tocitem" href="../kl/">Kazhdan-Lusztig polynomials and bases</a></li><li><a class="tocitem" href="../algebras/">Algebras</a></li></ul></li><li><a class="tocitem" href="../garside/">Garside monoids and groups, braids.</a></li><li><span class="tocitem">Reductive groups</span><ul><li><a class="tocitem" href="../rootdata/">Reductive algebraic groups and root data</a></li><li><a class="tocitem" href="../semisimple/">Semisimple elements</a></li><li><a class="tocitem" href="../cosets/">Reflection cosets and Spets</a></li><li><a class="tocitem" href="../sscoset/">Non-connected reductive groups</a></li><li><a class="tocitem" href="../uch/">Unipotent characters</a></li><li><a class="tocitem" href="../ct/">Classtypes</a></li></ul></li><li><span class="tocitem">Eigenspaces</span><ul><li><a class="tocitem" href="../eigen/">Eigenspaces</a></li><li><a class="tocitem" href="../dseries/">d-Harish-Chandra series</a></li></ul></li><li><span class="tocitem">Unipotent elements</span><ul><li><a class="tocitem" href="../ucl/">Unipotent classes of reductive groups</a></li><li><a class="tocitem" href="../urad/">Unipotent Elements</a></li></ul></li><li><a class="tocitem" href="../gendec/">Decomposition Matrices</a></li><li><a class="tocitem" href="../references/">References</a></li><li><a class="tocitem" href="../dict/">Dictionary from GAP3/Chevie</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reflection groups</a></li><li class="is-active"><a href>Finite reflection groups</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Finite reflection groups</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jmichel7/Chevie.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jmichel7/Chevie.jl/blob/main/docs/src/permroot.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Finite-reflection-groups"><a class="docs-heading-anchor" href="#Finite-reflection-groups">Finite reflection groups</a><a id="Finite-reflection-groups-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-reflection-groups" title="Permalink"></a></h1><ul><li><a href="#Chevie.PermRoot"><code>Chevie.PermRoot</code></a></li><li><a href="#Chevie.PermRoot.PRG"><code>Chevie.PermRoot.PRG</code></a></li><li><a href="#Chevie.PermRoot.PermRootGroup"><code>Chevie.PermRoot.PermRootGroup</code></a></li><li><a href="#Chevie.PermRoot.Reflection"><code>Chevie.PermRoot.Reflection</code></a></li><li><a href="#Chevie.PermRoot.TypeIrred-Tuple{PermRootGroup}"><code>Chevie.PermRoot.TypeIrred</code></a></li><li><a href="#Chevie.PermRoot.TypeIrred"><code>Chevie.PermRoot.TypeIrred</code></a></li><li><a href="#Chevie.Cosets.complex_reflection_group"><code>Chevie.Cosets.complex_reflection_group</code></a></li><li><a href="#Chevie.CoxGroups.braid_relations"><code>Chevie.CoxGroups.braid_relations</code></a></li><li><a href="#Chevie.Diagrams.diagram"><code>Chevie.Diagrams.diagram</code></a></li><li><a href="#Chevie.PermRoot.PermX"><code>Chevie.PermRoot.PermX</code></a></li><li><a href="#Chevie.PermRoot.PermY"><code>Chevie.PermRoot.PermY</code></a></li><li><a href="#Chevie.PermRoot.YMatrix"><code>Chevie.PermRoot.YMatrix</code></a></li><li><a href="#Chevie.PermRoot.action"><code>Chevie.PermRoot.action</code></a></li><li><a href="#Chevie.PermRoot.asreflection"><code>Chevie.PermRoot.asreflection</code></a></li><li><a href="#Chevie.PermRoot.baseX"><code>Chevie.PermRoot.baseX</code></a></li><li><a href="#Chevie.PermRoot.bipartite_decomposition"><code>Chevie.PermRoot.bipartite_decomposition</code></a></li><li><a href="#Chevie.PermRoot.cartan-Tuple{PermRootGroup}"><code>Chevie.PermRoot.cartan</code></a></li><li><a href="#Chevie.PermRoot.cartan-Tuple{PermRootGroup, Any, Any}"><code>Chevie.PermRoot.cartan</code></a></li><li><a href="#Chevie.PermRoot.codegrees-Tuple{PermRootGroup}"><code>Chevie.PermRoot.codegrees</code></a></li><li><a href="#Chevie.PermRoot.coroot"><code>Chevie.PermRoot.coroot</code></a></li><li><a href="#Chevie.PermRoot.coroots"><code>Chevie.PermRoot.coroots</code></a></li><li><a href="#Chevie.PermRoot.coxeter_number"><code>Chevie.PermRoot.coxeter_number</code></a></li><li><a href="#Chevie.PermRoot.degrees-Tuple{PermRootGroup}"><code>Chevie.PermRoot.degrees</code></a></li><li><a href="#Chevie.PermRoot.generic_order"><code>Chevie.PermRoot.generic_order</code></a></li><li><a href="#Chevie.PermRoot.hyperplane_orbits"><code>Chevie.PermRoot.hyperplane_orbits</code></a></li><li><a href="#Chevie.PermRoot.inclusion"><code>Chevie.PermRoot.inclusion</code></a></li><li><a href="#Chevie.PermRoot.inclusiongens"><code>Chevie.PermRoot.inclusiongens</code></a></li><li><a href="#Chevie.PermRoot.independent_roots"><code>Chevie.PermRoot.independent_roots</code></a></li><li><a href="#Chevie.PermRoot.invariant_form"><code>Chevie.PermRoot.invariant_form</code></a></li><li><a href="#Chevie.PermRoot.invariants"><code>Chevie.PermRoot.invariants</code></a></li><li><a href="#Chevie.PermRoot.isparabolic"><code>Chevie.PermRoot.isparabolic</code></a></li><li><a href="#Chevie.PermRoot.number_of_hyperplanes"><code>Chevie.PermRoot.number_of_hyperplanes</code></a></li><li><a href="#Chevie.PermRoot.number_of_reflections"><code>Chevie.PermRoot.number_of_reflections</code></a></li><li><a href="#Chevie.PermRoot.parabolic_closure"><code>Chevie.PermRoot.parabolic_closure</code></a></li><li><a href="#Chevie.PermRoot.parabolic_reps"><code>Chevie.PermRoot.parabolic_reps</code></a></li><li><a href="#Chevie.PermRoot.reflectionMatrix"><code>Chevie.PermRoot.reflectionMatrix</code></a></li><li><a href="#Chevie.PermRoot.reflection_character"><code>Chevie.PermRoot.reflection_character</code></a></li><li><a href="#Chevie.PermRoot.reflection_eigenvalues"><code>Chevie.PermRoot.reflection_eigenvalues</code></a></li><li><a href="#Chevie.PermRoot.reflection_representation-Tuple{PRG}"><code>Chevie.PermRoot.reflection_representation</code></a></li><li><a href="#Chevie.PermRoot.reflection_representation-Tuple{PermRootGroup, Any}"><code>Chevie.PermRoot.reflection_representation</code></a></li><li><a href="#Chevie.PermRoot.reflection_representation-Tuple{PRG, Integer}"><code>Chevie.PermRoot.reflection_representation</code></a></li><li><a href="#Chevie.PermRoot.reflection_subgroup-Tuple{PRG, AbstractVector}"><code>Chevie.PermRoot.reflection_subgroup</code></a></li><li><a href="#Chevie.PermRoot.reflections"><code>Chevie.PermRoot.reflections</code></a></li><li><a href="#Chevie.PermRoot.refls"><code>Chevie.PermRoot.refls</code></a></li><li><a href="#Chevie.PermRoot.refltype"><code>Chevie.PermRoot.refltype</code></a></li><li><a href="#Chevie.PermRoot.restriction"><code>Chevie.PermRoot.restriction</code></a></li><li><a href="#Chevie.PermRoot.roots-Tuple{PRG, Any}"><code>Chevie.PermRoot.roots</code></a></li><li><a href="#Chevie.PermRoot.roots-Tuple{PRG}"><code>Chevie.PermRoot.roots</code></a></li><li><a href="#Chevie.PermRoot.semisimplerank"><code>Chevie.PermRoot.semisimplerank</code></a></li><li><a href="#Chevie.PermRoot.simple_conjugating"><code>Chevie.PermRoot.simple_conjugating</code></a></li><li><a href="#Chevie.PermRoot.simple_reps"><code>Chevie.PermRoot.simple_reps</code></a></li><li><a href="#Chevie.PermRoot.simplecoroots"><code>Chevie.PermRoot.simplecoroots</code></a></li><li><a href="#Chevie.PermRoot.simpleroots"><code>Chevie.PermRoot.simpleroots</code></a></li><li><a href="#Chevie.PermRoot.torus_order"><code>Chevie.PermRoot.torus_order</code></a></li><li><a href="#Chevie.PermRoot.unique_refls"><code>Chevie.PermRoot.unique_refls</code></a></li><li><a href="#Chevie.Symbols.rank"><code>Chevie.Symbols.rank</code></a></li><li><a href="#Chevie.Weyl.standard_parabolic-Tuple{PermRootGroup, Any}"><code>Chevie.Weyl.standard_parabolic</code></a></li><li><a href="#Combinat.catalan-Tuple{Group, Any}"><code>Combinat.catalan</code></a></li><li><a href="#LaurentPolynomials.discriminant"><code>LaurentPolynomials.discriminant</code></a></li><li><a href="#PermGroups.Perms.reflection_length-Tuple{PermRootGroup, Perm}"><code>PermGroups.Perms.reflection_length</code></a></li></ul><article><details class="docstring" open="true"><summary id="Chevie.PermRoot"><a class="docstring-binding" href="#Chevie.PermRoot"><code>Chevie.PermRoot</code></a> — <span class="docstring-category">Module</span></summary><section><div><p>Let  <code>V</code> be a vector  space over a subfield  <code>K</code> of the complex numbers (in Julia  the elements  of <code>K</code>  will be  usually represented by <code>Rational</code>s or <code>Cyc</code>s).</p><p>A <em>complex reflection</em> is an element <code>s∈ GL(V)</code> of finite order whose fixed point  set is  a hyperplane,  the <em>reflecting  hyperplane</em> <code>Hₛ</code> of <code>s</code>.</p><p>Most  of the  time we  abbreviate &quot;complex  reflection&quot; to <em>reflection</em>; in some  literature &quot;reflection&quot; is reserved for  <code>s</code> of order 2 and otherwise <em>pseudo-reflection</em> is used.</p><p>A  reflection <code>s</code> has a unique eigenvalue <code>ζₛ</code> not equal to <code>1</code>, which is a root  of  unity;  if  <code>K</code>  is  a  subfield  of  the  real  numbers, <code>ζₛ</code> is necessarily  equal to <code>-1</code> and <code>s</code> is of  order 2. An eigenvector <code>r∈ V</code> of <code>s</code>  for the eigenvalue  <code>ζₛ</code> is called  a <em>root</em> of  <code>s</code> and a linear form <code>rᵛ</code>  on <code>V</code> of  kernel <code>Hₛ</code> is  called a <em>coroot</em>  of <code>s</code>. Usually <code>r</code> and <code>rᵛ</code>  are scaled so that <code>rᵛ(r)=1-ζ</code>; then <code>s</code> is the map on <code>V</code> defined by <code>s(x)=x-rᵛ(x)r</code>.  Such roots and  coroots for <code>s</code>  are unique up to scaling the root and inversely scaling the <a href="#Chevie.PermRoot.coroot"><code>coroot</code></a>.</p><p>A  finite  complex  reflection  group  <code>W</code>  is  a finite group generated by complex  reflections.  Since  whenever  <code>W</code>  contains  a  reflection <code>s</code> it contains  its powers, <code>W</code> is always  generated by reflections <code>s</code> such that <code>ζₛ==E(d)</code>  where <code>d</code> is the  order of <code>s</code>; we  can also assume that <code>s</code> is not  a  power  of  another  reflection  of  <code>W</code>  with  larger order. Such a reflection is called a <em>distinguished</em> reflection of <code>W</code>; it is a canonical generator  of the cyclic subgroup of  <code>W</code> centralizing <code>Hₛ</code>. The generators of  the  complex  reflection  groups  we construct are always distinguished reflections; the set of distinguished reflections are in bijection with the reflecting  hyperplanes.  In  a  real  reflection group all reflections are distinguished.</p><p>It  is much  more efficient  to compute  with permutation  groups than with matrix  groups; hence we use for computing with a finite complex reflection group  <code>W</code> a permutation representation on  a <code>W</code>-invariant set of root and coroot vectors for reflections of <code>W</code>; that is, a set <code>R</code> of pairs <code>(r,rᵛ)∈ V×Vᵛ</code>  invariant by <code>W</code> and such that every distinguished reflection in <code>W</code> is determined by some pair in <code>R</code> (see <a href="#Chevie.PermRoot.reflectionMatrix"><code>reflectionMatrix</code></a>). Using a <code>W</code>-invariant set implies that there are several pairs determining the same reflection,  which differ  by roots  of unity.  This generalizes  the usual construction  for Coxeter groups (the case <code>K=ℝ</code>) where to each reflection of <code>W</code> is associated two roots, one positive and one negative.</p><p>A  complex reflection group  is <em>irreducible</em> if  the representation <code>V</code> is irreducible.  For irreducible complex reflection groups, there are at least as  many roots for a given distinguished reflection as the lcm of the order of the reflection and of the order of the center of <code>W</code>.</p><p>The following methods are defined for finite complex reflection groups:</p><ul><li><p><code>gens(W)</code>: the (distinguished) reflections which generate <code>W</code>, given as permutations of the roots. <code>reflrep(W)</code> gives them as matrices.</p></li><li><p><a href="#Chevie.PermRoot.roots-Tuple{PRG}"><code>roots</code></a><code>(W)</code>: the list of roots of <code>W</code>.</p></li><li><p><a href="#Chevie.PermRoot.coroots"><code>coroots</code></a><code>(W)</code>: the list of coroots, in the same order as the roots.</p></li><li><p><a href="#Chevie.PermRoot.refls"><code>refls</code></a><code>(W)</code>: a list of distinguished reflections of <code>W</code>, as permutations.  This list is of same length as the roots, and its <code>i</code>-th element is the distinguished reflection for the <code>i</code>-th root, so it will have repetitions. <a href="#Chevie.PermRoot.unique_refls"><code>unique_refls</code></a><code>(W)</code> returns a sublist of <code>1:length(roots(W))</code> such that the distinguished reflections around the corresponding  roots reach one time  only each distinguished reflection of <code>W</code>.</p></li></ul><p>The  lists <code>roots</code>, <code>coroots</code> and <code>refls</code> starts with those attached to the reflections  <code>gens(W)</code>;  these  are  called  <em>simple</em>  roots,  coroots  and reflections.</p><ul><li><p><a href="#Chevie.PermRoot.simpleroots"><code>simpleroots</code></a><code>(W)</code>:  the simple roots as a matrix.</p></li><li><p><a href="#Chevie.PermRoot.simplecoroots"><code>simplecoroots</code></a>(W)`:  the simple coroots as a matrix.</p></li><li><p><a href="#Chevie.PermRoot.reflections"><code>reflections</code></a><code>(W)</code> gives a list without repetitions of all  reflections  of <code>W</code>  (not only  the distinguished  ones), as objects of type  <a href="#Chevie.PermRoot.Reflection"><code>Reflection</code></a>, starting with the distinguished reflections in  the  same  order  as  <code>unique_refls</code>.  These  objects  contain more information on each reflection.</p></li></ul><p>The  finite irreducible complex  reflection groups have  been classified in (<a href="../references/#st54">Shephard and Todd, 1954</a>). They consist of one infinite family <code>G(de,e,r)</code> depending on 3  parameters (which includes the infinite families of Weyl groups), and 34 exceptional  groups which have been given  by Shephard and Todd names which range  from <code>G₄</code> to <code>G₃₇</code>. These exceptional groups include the exceptional Weyl groups, e.g., <code>coxgroup(:E,8)</code> is the same as <code>G₃₇</code>.</p><p>We provide functions to build any finite reflection group, either by giving a  list of simple roots and simple coroots (see <a href="#Chevie.PermRoot.PRG"><code>PRG</code></a>), or in terms of   the   classification   (see  <a href="#Chevie.Cosets.complex_reflection_group"><code>complex_reflection_group</code></a>).  The non-irreducible  one  can  be  obtained  by  the  <code>*</code>  operation (they also naturally  appear as  reflection subgroups).  In the  context e.g.  of Weyl groups,  one wants to describe the particular root system chosen in term of the  traditional classification  of crystallographic  root systems. This is done  via  calls  to  the  function <a href="../coxgroups/#Chevie.CoxGroups.coxeter_group-Tuple{AbstractMatrix}"><code>coxeter_group</code></a> (see the module <a href="../weyl/#Chevie.Weyl"><code>Weyl</code></a>).  There is not yet  a general theory on  how to construct a nice  set of roots for  a non-real reflection group;  the roots chosen here where  obtained  case-by-case;  however,  they  satisfy  several  important properties:</p><ul><li><p>The simple reflections  satisfy braid relations  which present the braid group associated to <code>W</code> (see <a href="#Chevie.Diagrams.diagram"><code>diagram</code></a>).</p></li><li><p>The <em>field  of definition</em>  of <code>W</code>  is the  field <code>K</code> generated by the traces  of the elements of <code>W</code> acting on  <code>V</code>. It is a theorem that <code>W</code> may be realized as a reflection group over <code>K</code>.</p></li><li><p>The Cartan matrix <code>rᵛ(r&#39;)</code> where <code>r</code> and <code>r&#39;</code> runs over the simple roots and  coroots has entries in  the ring <code>ℤₖ</code> of  integers of <code>K</code>, and the other  roots (resp. coroots) are  linear combinations with coefficients in <code>ℤₖ</code> of a linearly independent subset of them.</p></li></ul><p>It  turns out that all representations of <code>W</code> are defined over the field of definition  <code>K</code>, see  (<a href="../references/#ben76">Benard, 1976</a>) and  D.~Bessis&#39; thesis.  This has been known  for a long time in  the case <code>K=ℚ</code>, the  case of Weyl groups, whose representations are all integral.</p><pre><code class="language-julia-repl hljs">julia&gt; W=complex_reflection_group(4)
G₄

julia&gt; gens(W) # as permutations of the 24 roots
2-element Vector{Perm{Int16}}:
 (1,3,9)(2,4,7)(5,10,18)(6,11,16)(8,12,19)(13,15,20)(14,17,21)(22,23,24)
 (1,5,13)(2,6,10)(3,7,14)(4,8,15)(9,16,22)(11,12,17)(18,19,23)(20,21,24)

julia&gt; length(unique(refls(W)))
4

julia&gt; length(refls(W)) # 24=4*(number of roots of unity in ℚ (ζ₃))
24

julia&gt; reflrep(W) # the generators as matrices
2-element Vector{Matrix{Cyc{Rational{Int64}}}}:
 [1 0; 0 ζ₃]
 [√-3/3 -ζ₃²√-3/3; (-3+√-3)/3 -ζ₃√-3/3]</code></pre><p>For  almost  all  irreducible  complex  reflection  groups,  the generating matrices  for <code>W</code> we give have coefficients in the field of definition <code>K</code>. Further,  the set of matrices for all elements of <code>W</code> is globally invariant under  the  Galois  group  of  <code>K/ℚ</code>,  thus  the  Galois  action  induces automorphisms  of <code>W</code>. The exceptions are <code>G₂₂, G₂₇</code> where the matrices are in  a  degree  two  extension  of  <code>K</code>  (this  is needed to have a globally invariant  model, see (<a href="../references/#marinmichel10">Marin and Michel, 2010</a>)) and  some dihedral groups, as well  as  <code>H₃</code>  and  <code>H₄</code>,  where  the  matrices  given  (the usual Coxeter reflection representation over <code>K</code>) are not globally invariant (but one can get invariant ones by <code>chevieget(:H4,:InvariantModel)</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; braid_relations(W) # as tuples of equal words in the generators
1-element Vector{Tuple{Vector{Int64}, Vector{Int64}}}:
 ([1, 2, 1], [2, 1, 2])

julia&gt; diagram(W) # the same in pictures
③ ——③ G₄
1   2

julia&gt; cartan(W)
2×2 Matrix{Cyc{Rational{Int64}}}:
 ζ₃²√-3     ζ₃²
   -ζ₃²  ζ₃²√-3

julia&gt; simpleroots(W)
2×2 Matrix{Cyc{Rational{Int64}}}:
    0  ζ₃²√-3
 2ζ₃²     ζ₃²

julia&gt; simplecoroots(W)
2×2 Matrix{Cyc{Rational{Int64}}}:
     0      1
 √-3/3  √-3/3</code></pre><p>Let <code>SV</code> be the symmetric algebra of <code>V</code>. The invariants of <code>W</code> in <code>SV</code> are called the <em>polynomial invariants</em> of <code>W</code>. If <code>n=dim V</code>, they are generated as   a  polynomial  ring  by   <code>n</code>  homogeneous  algebraically  independent polynomials <code>f₁,…,fₙ</code>. The polynomials <code>fᵢ</code> are not uniquely determined but their  degrees are. The <code>fᵢ</code> are called  the <em>basic invariants</em> of <code>W</code>, and their degrees the <em>reflection degrees</em> of <code>W</code>; the function <a href="../cosets/#Chevie.PermRoot.degrees-Tuple{Spets}"><code>degrees</code></a> returns these invariants.</p><p>Let  <code>I</code> be the  ideal generated by  the homogeneous invariants of positive degree  in <code>SV</code>. Then <code>SV/I</code> is isomorphic to the regular representation of <code>W</code>  as a  <code>W</code>-module. It  is thus  a graded  (by the degree of elements of <code>SV</code>)  version of the  regular representation of  <code>W</code>. The polynomial which gives  the graded  multiplicity of  a character  <code>φ</code> of  <code>W</code> in  the graded module   <code>SV/I</code>  is  called   the  <em>fake  degree</em>   of  <code>φ</code>.  The  function <a href="../chars/#Chevie.Chars.fakedegrees"><code>fakedegrees</code></a> returns these polynomials.</p><pre><code class="language-julia-repl hljs">julia&gt; degrees(W)
2-element Vector{Int64}:
 4
 6

julia&gt; fakedegrees(W,Pol(:x))
7-element Vector{Pol{Int64}}:
 1
 x⁴
 x⁸
 x⁷+x⁵
 x⁵+x³
 x³+x
 x⁶+x⁴+x²</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L1-L205">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.asreflection"><a class="docstring-binding" href="#Chevie.PermRoot.asreflection"><code>Chevie.PermRoot.asreflection</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>asreflection(s::Matrix [,r::AbstractVector])</code></p><p><code>s</code>  should be is a square  matrix, and if given <code>r</code>  should be a vector of length  <code>size(s,1)</code>.  The  function  determines  if  <code>s</code> is the matrix of a complex  reflection  (resp.  if  <code>r</code>  is  given  if  it  is the matrix of a reflection  of root <code>r</code>; the point of  giving <code>r</code> is to specify exactly the desired root and coroot, which otherwise are determined only up to a scalar and  its  inverse).  The  function  returns  <code>nothing</code>  if  <code>s</code> if is not a reflection  (resp. not a reflection with root <code>r</code>), and otherwise returns a named tuple with four fields:</p><p><code>.root</code>:   the root of the reflection <code>s</code> (equal to <code>r</code> if given)</p><p><code>.coroot</code>:  the coroot of <code>s</code></p><p><code>.eigenvalue</code>:  the non-trivial eigenvalue of <code>s</code></p><p><code>.isunitary</code>: a boolean which is <code>true</code> if and only if <code>s</code> is unitary   with  respect to the usual scalar product  (then <code>s</code> is determined by the   root and the eigenvalue as <code>reflectionMatrix(.root,.eigenvalue)</code>)</p><pre><code class="language-julia-repl hljs">julia&gt; asreflection([-1 0 0;1 1 0;0 0 1])
(root = [2, 0, 0], coroot = Rational{Int64}[1, -1//2, 0], eig = -1, isunitary = false)

julia&gt; asreflection([-1 0 0;1 1 0;0 0 1],[1,0,0])
(root = [1, 0, 0], coroot = Rational{Int64}[2, -1, 0], eig = -1, isunitary = false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L300-L329">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.reflectionMatrix"><a class="docstring-binding" href="#Chevie.PermRoot.reflectionMatrix"><code>Chevie.PermRoot.reflectionMatrix</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>reflectionMatrix(root,  coroot)</code> the matrix of the reflection with a given root and coroot.</p><p>A (complex) reflection is a finite order element <code>s</code> of <code>GL(V)</code>, the linear group of a vector space over a subfield of the complex numbers, whose fixed points  form  a  hyperplane  <code>H</code>  (the  <em>reflecting hyperplane</em> of <code>s</code>); an eigenvector  <code>r</code> for  the non-trivial  eigenvalue <code>ζ</code>  (a root of unity) is called  a <em>root</em> of <code>s</code>. If we choose  a linear form <code>rᵛ</code> defining <code>H</code> such that <code>rᵛ(r)=1-ζ</code> (a <em>coroot</em> of <code>s</code>) then <code>s</code> is given by <code>x↦ x-rᵛ(x)r</code>.</p><p>A  way  of  specifying  <code>s</code>  is  by  giving  a root and a coroot, which are uniquely determined by <code>s</code> up to multiplication of the root by a scalar and of  the coroot by the inverse scalar. The function <code>reflectionMatrix</code> gives the  matrix of the  corresponding reflection in  the standard basis of <code>V</code>, where  the <code>root</code> and the <code>coroot</code> are  vectors given in the standard bases of <code>V</code> and <code>Vᵛ</code>, so the pairing <code>rᵛ(r)</code> is obtained as <code>transpose(root)*coroot</code>.</p><pre><code class="language-julia hljs">julia&gt; r=reflectionMatrix([1,0,0],[2,-1,0])
3×3 Matrix{Int64}:
 -1  0  0
  1  1  0
  0  0  1

julia&gt; r==reflrep(coxgroup(:A,3),1)
true

julia&gt; r*[2,-1,0]
3-element Vector{Int64}:
 -2
  1
  0

julia&gt; [1 0 0]*r
1×3 Matrix{Int64}:
 -1  0  0</code></pre><p>As  we see in the last lines, in  Julia a matrix operates from the right on the  vector space <code>V</code>  of row vectors  and from the  left on the dual space <code>Vᵛ</code> of column vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L235-L277">source</a></section><section><div><p><code>reflectionMatrix(r, ζ=-1)</code></p><p>returns the matrix of the unitary complex reflection determined by the root <code>r</code> and the eigenvalue <code>ζ</code>, that is, when the vector space and its dual are identified  via the scalar product <code>&lt;x,y&gt;=transpose(x)*conj(y)</code>; the coroot <code>rᵛ</code> is then equal to the linear form <code>x-&gt;(1-ζ)&lt;x,r&gt;/&lt;r,r&gt;</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; reflectionMatrix([1,0,-E(3,2)])
3×3 Matrix{Cyc{Rational{Int64}}}:
  0  0  ζ₃²
  0  1    0
 ζ₃  0    0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L280-L294">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.PermRootGroup"><a class="docstring-binding" href="#Chevie.PermRoot.PermRootGroup"><code>Chevie.PermRoot.PermRootGroup</code></a> — <span class="docstring-category">Type</span></summary><section><div><p><code>PermRootGroup</code>   is  the  type  of  reflection  groups  represented  as  a permutation group on a set of roots.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L574-L577">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Cosets.complex_reflection_group"><a class="docstring-binding" href="#Chevie.Cosets.complex_reflection_group"><code>Chevie.Cosets.complex_reflection_group</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>complex_reflection_group(STnumber)</code> or <code>crg(STnumber)</code></p><p><code>complex_reflection_group(p,q,r)</code> or <code>crg(p,q,r)</code></p><p>The first form of <code>complex_reflection_group</code> returns the complex reflection group  which has  Shephard-Todd number  <code>STnumber</code>, see  (<a href="../references/#st54">Shephard and Todd, 1954</a>). The second form returns the imprimitive complex reflection group <code>G(p,q,r)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; G=complex_reflection_group(4)
G₄

julia&gt; degrees(G)
2-element Vector{Int64}:
 4
 6

julia&gt; length(G)
24

julia&gt; G*coxgroup(:A,2) # how to make a non-irreducible group
G₄×A₂

julia&gt; complex_reflection_group(1,1,3) # another way to enter A₂
gl₃

julia&gt; crg(4) # there is also a short alias
G₄</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/complexr.jl#L3-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.PRG"><a class="docstring-binding" href="#Chevie.PermRoot.PRG"><code>Chevie.PermRoot.PRG</code></a> — <span class="docstring-category">Type</span></summary><section><div><p><code>PRG(roots,coroots)</code> complex reflection group with given roots and coroots</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L1810-L1812">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.TypeIrred"><a class="docstring-binding" href="#Chevie.PermRoot.TypeIrred"><code>Chevie.PermRoot.TypeIrred</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>a  <code>TypeIrred</code> object  classifies an  irreducible finite complex reflection group,  or an  irreducible coset  (the latter  means that  the group  has a single orbit of irreducible components under <code>.phi</code>).</p><p>For an irreducible group a <code>TypeIrred</code> has the properties:</p><ul><li><code>.rank</code>  the semisimplerank of the group</li><li><code>.series</code> which takes one of the values <code>:A,:B,:D,:E,:F,:G,:H,:I</code> for an    irreducible Coxeter group, and is <code>:ST</code> for non-real groups.</li><li><code>.ST</code> for a primitive non-real group holding the Shepard-Todd number</li><li><code>.p</code> and <code>.q</code> for an imprimitive non-real group, holding <code>.p=de</code> and <code>.q=e</code> for <code>G(de,e,r)</code>.</li></ul><p>a  <code>TypeIrred</code> may  also contain  information specifying  a specific Cartan matrix  for  the  given  type.  When  there  are  two  conjugacy classes of generators,  <code>.cartanType</code>  (assumed  to  be  <code>1</code>  if  this  key is absent) contains  the ratio  of the  root lengths  compared to  the standard cartan matrix  for  that  type;  that  is,  the  Cartan matrix is conjugate to the standard  Cartan matrix by <code>Diagonal([1,…,1,c,…,c])</code> where <code>c=.cartanType</code>. This  this  how  type  <code>B</code>  (with  <code>.cartanType==2</code>)  and  type  <code>C</code>  (with <code>.cartanType==1</code>), which have both <code>.series==:B</code>,  are distinguished.</p><p>For an irreducible coset a <code>TypeIrred</code> has the properties</p><ul><li><code>.orbit</code> a <code>Vector{TypeIrred}</code> holding the types of the groups in the orbit under <code>.phi</code>, such that <code>.phi</code> send each item to the next.</li><li><code>.phi</code> if <code>k</code> is the length of <code>.orbit</code>, contains the permutation effected by <code>.phi^k</code> on the simple roots of the first item of the orbit.</li></ul><p>In addition, a <code>TypeIrred</code> <code>t</code> for a group <code>W</code> or a <code>t</code> appearing in a <code>.orbit</code> for a coset of a group <code>W</code> contains a property</p><ul><li><code>.indices</code> giving the indices in <code>gens(W)</code> represented by the generators of the irreducible component described by <code>t</code>.</li></ul><p>The <code>.indices</code> of a <code>TypeIrred</code> are always in a canonical order for a given component, such that the associated Cartan matrix is the &quot;canonical&quot; one. For instance, in type <code>C</code>, the longest root is always the first one, etc…</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L347-L382">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.TypeIrred-Tuple{PermRootGroup}"><a class="docstring-binding" href="#Chevie.PermRoot.TypeIrred-Tuple{PermRootGroup}"><code>Chevie.PermRoot.TypeIrred</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><code>TypeIrred(W::PermRootGroup)</code></p><p><code>W</code> must be an <em>irreducible</em> finite complex reflection group, computed as a permutation   group  of  a  set  of  roots,  generated  by  a  set  <code>S</code>  of distinguished   reflections.   <code>TypeIrred</code>   classifies   <code>W</code>   (returns  a <code>TypeIrred</code> object) by using the following algorithm. It computes in order:</p><ul><li><code>r=semisimplerank(W)</code>, the dimension of the space spanned by the roots</li><li><code>i=length(W)/factorial(r)</code></li><li><code>o</code>=the maximum order of a reflection=<span>$max_{s∈ S}o(s)$</span></li><li><code>D</code>=all distinguished reflections of <code>W</code>, the <code>W</code>-orbit of <code>S</code></li><li><code>h</code>=the Coxeter number=<span>$(∑_{s∈ D}o(s))/r$</span></li></ul><p><code>(r,i,o)</code>  are sufficient  to determine  a <span>$G_{de,e,r}$</span>  excepted for the ambiguity  between <span>$G_{2e,e,2}$</span> and <span>$I₂(4e)$</span>,  which is resolved by <code>h</code> (excepted   for   <code>e=1</code>,   where   the   two   solutions  are  isomorphic). <span>$G_{de,e,r}$</span> has <span>$i=(de)ʳ/e$</span>, <span>$o=max(2,d)$</span>, <span>$h=ed(r-1)+d-δ_{d,1}$</span></p><p><code>(r,i,o)</code>  are also sufficient  to distinguish primitive  groups except for the tuples (which are resolved by <code>h</code>):</p><pre><code class="language-julia hljs">(G₉, G₂₄‚₆‚₂)
(G₁₂, G₁₂‚₆‚₂, I₂(24))
(G₁₃, G₂₄‚₁₂‚₂, I₂(48))
(G₂₂, G₆₀‚₃₀‚₂, I₂(120))
(G₇, G₁₄, G₂₄‚₈‚₂)
(G₈, G₁₂‚₃‚₂)
(G₁₅, G₄₈‚₁₆‚₂)
(G₁₇, G₁₂₀‚₂₄‚₂)
(G₂₁, G₁₂₀‚₄₀‚₂)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L803-L833">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.refltype"><a class="docstring-binding" href="#Chevie.PermRoot.refltype"><code>Chevie.PermRoot.refltype</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>refltype(W::ComplexReflectionGroup</code> or coset<code>)</code> or <code>reflection_type(W)</code></p><p>returns the <code>Vector{TypeIrred}</code> which classifies <code>W</code> (see <a href="#Chevie.PermRoot.TypeIrred"><code>TypeIrred</code></a>).  The  <code>refltype</code>  is  used  for displaying <code>W</code> at the repl. The function <code>indices</code> on the result of <code>refltype</code>or on a <code>TypeIrred</code> tells  the index in <code>gens(W)</code> of each standard generator of the irreducible component  s. In the  REPL display of  <code>W</code>, these indices  are omitted when they  are the  expected ones  (the component  is in  order at  the expected indices).</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:D,3) # a D₃ is an A₃ in disorder
A₃₍₁₃₂₎

julia&gt; t=refltype(W)
A₃₍₁₃₂₎

julia&gt; indices(t)
3-element Vector{Int64}:
 1
 3
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L1075-L1098">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Symbols.rank"><a class="docstring-binding" href="#Chevie.Symbols.rank"><code>Chevie.Symbols.rank</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>rank(W::ComplexReflectionGroup)</code></p><p>returns  the <em>rank</em> of  <code>W</code>, which is  the dimension of  the space where it acts.</p><pre><code class="language-julia-repl hljs">julia&gt; rank(complex_reflection_group(31))
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L790-L800">source</a></section><section><div><p><code>rank(S)</code> rank of symbol <code>S</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; rank(CharSymbol([[1,5,6],[1,2]]))
11</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/Symbols.jl#L316-L323">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.semisimplerank"><a class="docstring-binding" href="#Chevie.PermRoot.semisimplerank"><code>Chevie.PermRoot.semisimplerank</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>semisimpleRank(W::ComplexReflectionGroup)</code></p><p>returns  the <em>semisimple rank</em> of <code>W</code>, which  is the dimension of the space where  it effectively acts. If <code>W</code> is  a reflection group on the space <code>V</code>, and  <code>V₁</code> is the subspace generated by <code>roots(W)</code>, then <code>semisimplerank(W)</code> is the dimension of <code>V₁</code>. The reflection group <code>W</code> is called <em>essential</em> if <code>V₁=V</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=reflection_subgroup(coxgroup(:A,3),[1,3])
A₃₍₁₃₎=A₁×A₁Φ₁

julia&gt; semisimplerank(W)
2

julia&gt; rank(W)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L1369-L1388">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.number_of_reflections"><a class="docstring-binding" href="#Chevie.PermRoot.number_of_reflections"><code>Chevie.PermRoot.number_of_reflections</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>number_of_reflections(W::ComplexReflectionGroup)</code> or <code>nref(W)</code></p><p>the number of reflections of <code>W</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L599-L603">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.number_of_hyperplanes"><a class="docstring-binding" href="#Chevie.PermRoot.number_of_hyperplanes"><code>Chevie.PermRoot.number_of_hyperplanes</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>number_of_hyperplanes(W::ComplexReflectionGroup)</code> or <code>nhyp(W)</code></p><p>The number of reflecting hyperplanes of <code>W</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L608-L612">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.coxeter_number"><a class="docstring-binding" href="#Chevie.PermRoot.coxeter_number"><code>Chevie.PermRoot.coxeter_number</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>coxeter_number(W::PermRootGroup,i)</code> or <code>coxnum</code></p><p>(<a href="../references/#gg12">Gordon and Griffeth, 2012</a>) have defined the <em>Coxeter number</em> of an irreducible character <code>φ</code>  of  a  complex  reflection  group  as  the scalar by which the central element  <code>∑_{s  in  reflections(W)}(1-s)</code>  acts  on  the  representation of character  <code>φ</code>. The  function <code>coxnum</code>  returns the  Coxeter number  of the <code>i</code>-th irreducible character of <code>W</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L617-L625">source</a></section><section><div><p><code>coxeter_number(W::PermRootGroup)</code> or <code>coxnum</code></p><p>(<a href="../references/#gg12">Gordon and Griffeth, 2012</a>)  have defined the <em>Coxeter  number</em> of an irreducible complex reflection  group as the Coxeter number  of its reflection character. It is also given by the formula <code>(nref(W)+nhyp(W))/rank(W)</code>; for a well-generated group  it is equal to the  highest reflection degree. For a non-irreducible group,  the  Coxeter  number  is  the  sum  of  those  of  its  irreducible components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L629-L638">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.roots-Tuple{PRG}"><a class="docstring-binding" href="#Chevie.PermRoot.roots-Tuple{PRG}"><code>Chevie.PermRoot.roots</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><code>roots(W::PermRootGroup)</code> the roots of <code>W</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L1882">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.roots-Tuple{PRG, Any}"><a class="docstring-binding" href="#Chevie.PermRoot.roots-Tuple{PRG, Any}"><code>Chevie.PermRoot.roots</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><code>roots(W::PermRootGroup,i)</code> same as <code>roots(W)[i]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L1884">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.coroots"><a class="docstring-binding" href="#Chevie.PermRoot.coroots"><code>Chevie.PermRoot.coroots</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>coroots(W)</code> the list of coroots of <code>W</code> (listed in the same order as the roots)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L1896">source</a></section><section><div><p><code>coroots(W,i)</code> same as but better than <code>coroots(W)[i]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L1911">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.coroot"><a class="docstring-binding" href="#Chevie.PermRoot.coroot"><code>Chevie.PermRoot.coroot</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>coroot(r,λ=-1)</code></p><p>the coroot for a unitary reflection of root <code>r</code> and eigenvalue <code>λ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L225-L229">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.simpleroots"><a class="docstring-binding" href="#Chevie.PermRoot.simpleroots"><code>Chevie.PermRoot.simpleroots</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>simpleroots(W::ComplexReflectionGroup)</code>  the  simple  roots  of <code>W</code> (those corresponding to <code>gens(W)</code>) as the rows of a matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L1886-L1889">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.simplecoroots"><a class="docstring-binding" href="#Chevie.PermRoot.simplecoroots"><code>Chevie.PermRoot.simplecoroots</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>simplecoroots(W::ComplexReflectionGroup)</code> the simple coroots of <code>W</code> (those <code>corresponding to gens(W)</code>) as the rows of a matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L1899-L1902">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.baseX"><a class="docstring-binding" href="#Chevie.PermRoot.baseX"><code>Chevie.PermRoot.baseX</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>baseX(W::ComplexReflectionGroup)</code></p><p>returns  as the rows of a matrix a  particular basis of the space <code>V</code> where <code>W</code> acts: the first <code>semisimplerank(W)</code> rows contain the coordinates on the basis of <code>V</code> of a basis of the root lattice (given by <code>simpleroots(W)[independent_roots(W)]</code>) and the last <code>rank(W)-semisimplerank(W)</code> ones contain the same for the orthogonal of the coroots.</p><p>When <code>W</code> represents a rootdatum for a reductive group, the first lines are the same as <code>simpleroots(W)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L1395-L1407">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.independent_roots"><a class="docstring-binding" href="#Chevie.PermRoot.independent_roots"><code>Chevie.PermRoot.independent_roots</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>independent_roots(W::ComplexReflectionGroup)</code></p><p>A vector of indices of length <code>semisimplerank(W)</code> such that <code>simpleroots(W)[independent_roots(W)]</code>  is  a  basis  of  the  vector space spanned by the roots of <code>W</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L1354-L1360">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.cartan-Tuple{PermRootGroup}"><a class="docstring-binding" href="#Chevie.PermRoot.cartan-Tuple{PermRootGroup}"><code>Chevie.PermRoot.cartan</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><code>cartan(W::PermRootGroup)</code>    Cartan matrix of <code>W</code>.</p><p>Let  <code>s₁,…,sₙ</code> be reflections with associated  roots <code>rᵢ</code> and coroots <code>cᵢ</code>. The  matrix <code>C</code> with  entries <code>Cᵢ,ⱼ=cᵢ(rⱼ)</code> is  called a <em>Cartan matrix</em> of <code>s₁,…,sₙ</code>.  Since a reflection determines up to scalar a root and a coroot, <code>C</code>  is uniquely  determined by  <code>s₁,…,sₙ</code> up  to conjugation by a diagonal matrix.</p><p>If <code>s₁,…,sₙ</code> generate a reflection group <code>W</code>, then <code>C</code> up to conjugation by a  diagonal matrix is an invariant of the reflection representation of <code>W</code>. If invertible, the matrix <code>C</code> determines this representation since then the <code>rᵢ</code>  form a basis in  which the matrix for  <code>sᵢ</code> differs from the identity only  on  the  <code>i</code>-th  row,  where  the  corresponding  row of <code>C</code> has been subtracted.</p><p>In general <code>cartan(W)==simplecoroots(W)*permutedims(simpleroots(W))</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; cartan(W)
3×3 Matrix{Int64}:
  2  -1   0
 -1   2  -1
  0  -1   2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L741-L768">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.cartan-Tuple{PermRootGroup, Any, Any}"><a class="docstring-binding" href="#Chevie.PermRoot.cartan-Tuple{PermRootGroup, Any, Any}"><code>Chevie.PermRoot.cartan</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><code>cartan(W::PermRootGroup,i,j)</code> the  cartan coefficient <code>cᵢ(rⱼ)</code>, the value of the linear form given by the <code>i</code>-th coroot <code>cᵢ</code> on the <code>j</code>-th root <code>rᵢ</code> of <code>W</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L734-L738">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.refls"><a class="docstring-binding" href="#Chevie.PermRoot.refls"><code>Chevie.PermRoot.refls</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>refls(W::ComplexReflectionGroup)</code></p><p>a  list of same length as <code>W.roots</code> giving the corresponding element of <code>W</code> representing  a distinguished reflection.  In particular this  list is much longer  than <code>unique(refls(W))</code>  since in  general there  are several roots corresponding to a reflection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L691-L698">source</a></section><section><div><p><code>refls(W::ComplexReflectionGroup,i)</code></p><p>the  element of <code>W</code> representing  the distinguished reflection around the <code>i</code>-th root of <code>W</code> (<code>i</code> can be an index or a vector of indices)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L701-L706">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.unique_refls"><a class="docstring-binding" href="#Chevie.PermRoot.unique_refls"><code>Chevie.PermRoot.unique_refls</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>unique_refls(W::ComplexReflectionGroup)</code> A  sublist of <code>1:length(roots(W))</code> such  that the distinguished reflections around  the  corresponding  roots  reach  one  time only each distinguished reflection of <code>W</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L718-L723">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.Reflection"><a class="docstring-binding" href="#Chevie.PermRoot.Reflection"><code>Chevie.PermRoot.Reflection</code></a> — <span class="docstring-category">Type</span></summary><section><div><p><code>Reflection</code> is a <code>struct</code> representing a reflection in a reflection group.</p><pre><code class="language-julia-repl hljs">julia&gt; W=crg(8);

julia&gt; r=reflections(W)[7] # shows (r.W,r.rootno,r.eigen)
Reflection(G₈,1,-1)

julia&gt; r.rootno # r is a reflection for the first root
1

julia&gt; r.eigen # the non-trival eigenvalue, as a Root1
Root1: -1

julia&gt; r.W # the group of which r is a reflection
G₈

julia&gt; r==Reflection(W,1,-1) # specify r with .rootno and .eigen
true

julia&gt; Reflection(W,1) # specify with .rootno gets the distinguished reflection
Reflection(G₈,1,ζ₄)

julia&gt; root(r)
2-element Vector{Cyc{Rational{Int64}}}:
  0
 ζ₄

julia&gt; coroot(r)
2-element Vector{Cyc{Int64}}:
    0
 -2ζ₄

julia&gt; Matrix(r)
2×2 Matrix{Cyc{Rational{Int64}}}:
 1   0
 0  -1

julia&gt; hyperplane(r) # the fixed hyperplane, as a rowspace
1×2 Matrix{Cyc{Rational{Int64}}}:
 1  0

julia&gt; hyperplane(r)*Matrix(r)==hyperplane(r)
true

julia&gt; isdistinguished(r) # r is not distinguished
false

julia&gt; exponent(r) # which power of a distinguished reflection it is
2

julia&gt; Perm(r)
(1,8)(2,9)(3,16)(4,15)(5,17)(6,18)(7,19)(10,22)(11,21)(12,23)

julia&gt; hyperplane_orbit(r) # r is in the first hyperplane orbit
1

julia&gt; position_class(r) # the index of the conjugacy class of r in W 
15

julia&gt; simple_rep(r) # smallest root index affording a conjugate reflection
1

julia&gt; word(r) # a word in the generators of r.W for r
2-element Vector{Int64}:
 1
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/reflection.jl#L12-L80">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.reflections"><a class="docstring-binding" href="#Chevie.PermRoot.reflections"><code>Chevie.PermRoot.reflections</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>reflections(W)</code>   a  <code>Vector{Reflection}</code>   of  all   reflections  of  the reflection   group   <code>W</code>   (including   the   non-distinguished  ones;  see <a href="#Chevie.PermRoot.Reflection"><code>Reflection</code></a>).  <code>reflections(W)[1:nhyp(W)]</code>  are  the distinguished reflections.</p><pre><code class="language-julia-repl hljs">julia&gt; W=crg(4)
G₄

julia&gt; reflections(W)
8-element Vector{Reflection{PRG{Cyc{Rational{Int64}}, Int16}}}:
 Reflection(G₄,1,ζ₃)
 Reflection(G₄,2,ζ₃)
 Reflection(G₄,4,ζ₃)
 Reflection(G₄,5,ζ₃)
 Reflection(G₄,1,ζ₃²)
 Reflection(G₄,2,ζ₃²)
 Reflection(G₄,4,ζ₃²)
 Reflection(G₄,5,ζ₃²)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/reflection.jl#L156-L177">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PermGroups.Perms.reflection_length-Tuple{PermRootGroup, Perm}"><a class="docstring-binding" href="#PermGroups.Perms.reflection_length-Tuple{PermRootGroup, Perm}"><code>PermGroups.Perms.reflection_length</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><code>reflection_length(W::PermRootGroup,w::Perm)</code> or <code>reflength</code></p><p>This  function returns the  number of eigenvalues  of <code>w</code> in the reflection representation  which are not equal to 1.  For a finite Coxeter group, this is  equal to the  reflection length of  <code>w</code>, that is  the minimum number of reflections  of which <code>w</code>  is a product.  This also holds  in general for a well-generated  complex reflection group if  <code>w</code> divides for the reflection length a Coxeter element.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,4)
A₄

julia&gt; reflength(W,longest(W))
2

julia&gt; reflength(W,W(1,2,3,4))
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L1273-L1293">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.simple_reps"><a class="docstring-binding" href="#Chevie.PermRoot.simple_reps"><code>Chevie.PermRoot.simple_reps</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>simple_reps(W)</code></p><p>for  each root, the index  of the first simple  root conjugate to it (it is the index of a generator of <code>W</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L657-L662">source</a></section><section><div><p><code>simple_reps(W,i)</code></p><p>the  smallest index of a root in the  same <code>W</code>-orbit as the <code>i</code>-th root (it is the index of a generator of <code>W</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L683-L688">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.simple_conjugating"><a class="docstring-binding" href="#Chevie.PermRoot.simple_conjugating"><code>Chevie.PermRoot.simple_conjugating</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>simple_conjugating(W::ComplexReflectionGroup)</code></p><p>For each index <code>i</code> of a root, an element <code>w∈ W</code> such that <code>action(W,simple_reps(W,i),w)==i</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L710-L715">source</a></section><section><div><p><code>simple_conjugating(W,i)</code></p><p>an element <code>w∈ W</code> such that <code>action(W,simple_reps(W,i),w)==i</code>. In particular <code>W(simple_reps(W,i))^simple_conjugating(W,i)==refls(W,i)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L726-L731">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Diagrams.diagram"><a class="docstring-binding" href="#Chevie.Diagrams.diagram"><code>Chevie.Diagrams.diagram</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>diagram(W)</code>  prints  a  diagram  describing  a  presentation of the finite reflection group or spets <code>W</code></p><pre><code class="language-julia-repl hljs">julia&gt; diagram(coxgroup(:E,8))
    O 2
    ￨
O—O—O—O—O—O—O E₈
1 3 4 5 6 7 8

julia&gt; diagram(crg(33))
    3 ②       G₃₃
     /^\
② ——② ——② ——② 
1   2   4   5     423423=342342</code></pre><p>The  nodes of the diagram represent  the generating reflections of <code>W</code>. For complex  reflection groups, the nodes circle an integer noting the order of the corresponding reflection.</p><p>The  edges of the diagram represent braid  relations in the same way as for Dynkin  diagrams  (see  <a href="../weyl/#Chevie.Weyl"><code>Weyl</code></a>). Nodes  not  adjacent  by  an  edge represent  commuting  generators.  Braid  relations  using  more  than  two generators are listed separately.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/Diagrams.jl#L44-L68">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.hyperplane_orbits"><a class="docstring-binding" href="#Chevie.PermRoot.hyperplane_orbits"><code>Chevie.PermRoot.hyperplane_orbits</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>hyperplane_orbits(W::ComplexReflectionGroup)</code></p><p>returns  a  list  of  named  tuples,  one  for each hyperplane orbit of the reflection  group <code>W</code>. If <code>o</code> is the named tuple for such an orbit, and <code>s</code> is  the first  element of  <code>gens(W)</code> whose  hyperplane is  in the orbit, it contains the following fields</p><p><code>.s</code>:     index of <code>s</code> in <code>gens(W)</code></p><p><code>.order</code>: order of s</p><p><code>.cl_s</code>:  for i in <code>1:order-1</code>, <code>position_class(W,W(s)^i)</code></p><p><code>.N_s</code>:    size of hyperplane orbit</p><p><code>.det_s</code>:  for i in <code>1:order-1</code>, position in <code>CharTable(W)</code> of <code>detₛⁱ</code>, where    <code>detₛ</code> is the linear character taking the value <code>det(reflrep(W,s))</code> on <code>s</code>    and <code>1</code> on non-conjugate reflections.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:B,2)
B₂

julia&gt; hyperplane_orbits(W)
2-element Vector{@NamedTuple{s::Int64, cl_s::Vector{Int64}, order::Int64, N_s::Int64, det_s::Vector{Int64}}}:
 (s = 1, cl_s = [2], order = 2, N_s = 2, det_s = [5])
 (s = 2, cl_s = [4], order = 2, N_s = 2, det_s = [1])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L2354-L2383">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.CoxGroups.braid_relations"><a class="docstring-binding" href="#Chevie.CoxGroups.braid_relations"><code>Chevie.CoxGroups.braid_relations</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>braid_relations(W)</code></p><p>this  function returns the  relations which present  the braid group of the reflection group <code>W</code>. These are homogeneous (both sides of the same length) relations  between generators in bijection  with the generating reflections of  <code>W</code>. A presentation  of <code>W</code> is  obtained by adding relations specifying the order of the generators.</p><pre><code class="language-julia-repl hljs">julia&gt; W=complex_reflection_group(29)
G₂₉

julia&gt; braid_relations(W)
7-element Vector{Tuple{Vector{Int64}, Vector{Int64}}}:
 ([1, 2, 1], [2, 1, 2])
 ([2, 4, 2], [4, 2, 4])
 ([3, 4, 3], [4, 3, 4])
 ([2, 3, 2, 3], [3, 2, 3, 2])
 ([1, 3], [3, 1])
 ([1, 4], [4, 1])
 ([4, 3, 2, 4, 3, 2], [3, 2, 4, 3, 2, 4])</code></pre><p>each  relation  is  represented  as  a  pair  of lists, specifying that the product  of the  generators according  to the  indices on  the left side is equal  to the product according to the  indices on the right side. See also <code>diagram</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/CoxGroups.jl#L760-L788">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.reflection_representation-Tuple{PermRootGroup, Any}"><a class="docstring-binding" href="#Chevie.PermRoot.reflection_representation-Tuple{PermRootGroup, Any}"><code>Chevie.PermRoot.reflection_representation</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><code>reflection_representation(W::ComplexReflectionGroup,w)</code> or <code>reflrep(W,w)</code></p><p>Let  <code>V</code> be the space on  which <code>W</code> acts as a  reflection group and let <code>w∈ W</code>,  represented  as  a  permutation  of  the roots. The function <code>reflrep</code> returns  the matrix of <code>w</code> acting on  <code>V</code> (<em>from the right</em> on the elements of  <code>V</code> seen as  row vectors by  our conventions in  <code>Chevie</code>). This is the linear  transformation of <code>V</code> which acts trivially on the orthogonal of the coroots  and has same effect as <code>w</code> on the simple roots. The function makes sense  more generally for a permutation of  the roots induced by an element of  <code>GL(V)</code> which stabilizes the roots (thus in particular normalizes <code>W</code>); thus  it works for reflection cosets.  For a <code>rootdatum</code> corresponding to a coset <code>Wσ</code> we get the action of <code>Wσ</code> on <code>X(𝐓)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=reflection_subgroup(rootdatum(&quot;E7sc&quot;),1:6)
E₇₍₁₂₃₄₅₆₎=E₆Φ₁

julia&gt; reflrep(W,longest(W))
7×7 Matrix{Int64}:
  0   0   0   0   0  -1  2
  0  -1   0   0   0   0  2
  0   0   0   0  -1   0  3
  0   0   0  -1   0   0  4
  0   0  -1   0   0   0  3
 -1   0   0   0   0   0  2
  0   0   0   0   0   0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L1642-L1670">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.reflection_representation-Tuple{PRG}"><a class="docstring-binding" href="#Chevie.PermRoot.reflection_representation-Tuple{PRG}"><code>Chevie.PermRoot.reflection_representation</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><code>reflection_representation(W::ComplexReflectionGroup)</code> or <code>reflrep(W)</code></p><p>returns  <code>reflrep.(Ref(W),gens(W))</code>,  that  is  the  generators  of  <code>W</code> as matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L1932-L1937">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.reflection_representation-Tuple{PRG, Integer}"><a class="docstring-binding" href="#Chevie.PermRoot.reflection_representation-Tuple{PRG, Integer}"><code>Chevie.PermRoot.reflection_representation</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><code>reflection_representation(W,i::Integer)</code>  or <code>reflrep(W,i)</code></p><p>the matrix for the distinguished reflection around the <code>i</code>-th root of <code>W</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L1940-L1944">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.reflection_character"><a class="docstring-binding" href="#Chevie.PermRoot.reflection_character"><code>Chevie.PermRoot.reflection_character</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>reflection_character(W::ComplexReflectionGroup,w)</code> or <code>reflchar</code></p><p>Returns  the trace  of the  element <code>w</code>  of <code>W</code>  as an  endomorphism of the vector space <code>V</code> on which <code>W</code> acts.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:B,3)
B₃

julia&gt; reflchar(W,longest(W))
-3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L1187-L1200">source</a></section><section><div><p><code>reflection_character(W::ComplexReflectionGroup)</code> or <code>reflchar</code></p><p>Returns  the reflection  character of  <code>W</code>. When  <code>W</code> is irreducible, it is <code>CharTable(W).irr[charinfo(W).extRefl[2]]</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; reflchar(coxgroup(:A,3))
5-element Vector{Int64}:
  3
  1
 -1
  0
 -1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L1205-L1220">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.YMatrix"><a class="docstring-binding" href="#Chevie.PermRoot.YMatrix"><code>Chevie.PermRoot.YMatrix</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>YMatrix(W,w)</code></p><p>Let  <code>W</code> be a finite reflection group on  the space <code>V</code> and let <code>w∈ W</code>. The function  <code>YMatrix</code> returns the  matrix of <code>w</code>  acting on the  dual <code>V*</code> of <code>V</code>.  This is the linear transformation of <code>V*</code> which acts trivially on the orthogonal  of the roots and has same  effect as <code>w</code> on the simple coroots. The function makes sense more generally for an element of the normalizer of <code>W</code>  in the whole permutation group of the coroots. The resulting matrix is the  transposed  of  the  matrix  <code>reflrep(W,w)</code>,  which,  according to our conventions  acts on the right (on the row vectors representing elements of the  dual of <code>V</code>). For  a <code>rootdatum</code> corresponding to  a coset <code>Wσ</code> we get the action of <code>Wσ</code> on <code>Y(𝐓)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=reflection_subgroup(rootdatum(&quot;E7sc&quot;),1:6)
E₇₍₁₂₃₄₅₆₎=E₆Φ₁

julia&gt; YMatrix(W,longest(W))
7×7 transpose(::Matrix{Int64}) with eltype Int64:
  0   0   0   0   0  -1  0
  0  -1   0   0   0   0  0
  0   0   0   0  -1   0  0
  0   0   0  -1   0   0  0
  0   0  -1   0   0   0  0
 -1   0   0   0   0   0  0
  2   2   3   4   3   2  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L1683-L1711">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.PermX"><a class="docstring-binding" href="#Chevie.PermRoot.PermX"><code>Chevie.PermRoot.PermX</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>PermX(W::ComplexReflectionGroup,M::AbstractMatrix)</code></p><p>Let <code>M</code> be an invertible linear map of the reflection representation of <code>W</code> which  preserves the set  of roots of  <code>parent(W)</code>, and normalizes <code>W</code> (for the  action of  matrices on  the right).  <code>PermX</code> returns the corresponding permutation  of the roots of <code>parent(W)</code>;  it returns <code>nothing</code> if <code>M</code> does not normalize the set of roots of <code>parent(W)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=reflection_subgroup(rootdatum(&quot;E7sc&quot;),1:6)
E₇₍₁₂₃₄₅₆₎=E₆Φ₁

julia&gt; PermX(W,reflrep(W,longest(W)))==longest(W)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L1440-L1456">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.PermY"><a class="docstring-binding" href="#Chevie.PermRoot.PermY"><code>Chevie.PermRoot.PermY</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>PermY(W::ComplexReflectionGroup,M::AbstractMatrix)</code></p><p>Let  <code>M</code>  be  an  invertible  linear  map  on  the  dual  of the reflection representation  of <code>W</code> which  preserves the set  of coroots of <code>parent(W)</code>, and  normalizes  <code>W</code>  (for  the  action  of matrices on the right). <code>PermY</code> returns  the corresponding  permutation of  the coroots  of <code>parent(W)</code>; it returns  <code>nothing</code>  if  <code>M</code>  does  not  normalize  the  set  of  coroots of <code>parent(W)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=reflection_subgroup(rootdatum(&quot;E7sc&quot;),1:6)
E₇₍₁₂₃₄₅₆₎=E₆Φ₁

julia&gt; PermY(W,YMatrix(W,longest(W)))==longest(W)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L1713-L1730">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.reflection_eigenvalues"><a class="docstring-binding" href="#Chevie.PermRoot.reflection_eigenvalues"><code>Chevie.PermRoot.reflection_eigenvalues</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>reflection_eigenvalues(W)</code> or <code>refleigen(W)</code></p><p>Let <code>W</code> be a reflection group on the vector space <code>V</code>. <code>reflection_eigenvalues(W)</code> returns for each conjugacy class representative <code>x</code>  of <code>W</code> (see <code>classreps</code>)  the eigenvalues of <code>x</code>  on <code>V</code>, as a list of <code>Root1</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; refleigen(coxgroup(:B,2))
5-element Vector{Vector{Root1}}:
 [1, 1]
 [-1, 1]
 [-1, -1]
 [-1, 1]
 [ζ₄³, ζ₄]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L1223-L1240">source</a></section><section><div><p><code>refleigen(W,i)</code> faster than <code>refleigen(W)[i]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L1270">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.degrees-Tuple{PermRootGroup}"><a class="docstring-binding" href="#Chevie.PermRoot.degrees-Tuple{PermRootGroup}"><code>Chevie.PermRoot.degrees</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><code>degrees(W::ComplexReflectionGroup)</code></p><p>returns  a list  holding the  degrees of  <code>W</code> as  a reflection group on the vector  space <code>V</code> on which  it acts. These are  the degrees <code>d₁,…,dₙ</code> where <code>n</code>  is the dimension of  <code>V</code> of the basic  invariants of <code>W</code> in <code>SV</code>. They reflect  various properties  of <code>W</code>;  in particular,  their product  is the cardinality of <code>W</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=complex_reflection_group(30)
H₄

julia&gt; degrees(W)
4-element Vector{Int64}:
  2
 12
 20
 30

julia&gt; length(W)
14400</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L2293-L2316">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.codegrees-Tuple{PermRootGroup}"><a class="docstring-binding" href="#Chevie.PermRoot.codegrees-Tuple{PermRootGroup}"><code>Chevie.PermRoot.codegrees</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><code>codegrees(W::ComplexReflectionGroup)</code></p><p>returns  the vector of codegrees of <code>W</code>  as a reflection group on the space <code>V</code>  of <code>reflrep(W)</code>.  These are  one less  than the  degrees of  the basic derivations of <code>W</code> on <code>SV⊗ V^vee</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=complex_reflection_group(4)
G₄

julia&gt; codegrees(W)
2-element Vector{Int64}:
 0
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L2323-L2339">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.invariants"><a class="docstring-binding" href="#Chevie.PermRoot.invariants"><code>Chevie.PermRoot.invariants</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>invariants(W::ComplexReflectionGroup)</code></p><p>returns  the fundamental invariants of <code>W</code> in its reflection representation <code>V</code>.  That is, returns  a set of  algebraically independent elements of the symmetric  algebra  of  the  dual  of  <code>V</code> which generate the <code>W</code>-invariant polynomial  functions on <code>V</code>. Each such invariant function is returned as a function:  if <code>e₁,…,eₙ</code> is a basis of <code>V</code> and <code>f</code> is the function, then the value  of the polynomial  function on <code>a₁e₁+…+aₙeₙ</code>  is obtained by calling <code>f(a₁,…,aₙ)</code>. This function depends on the classification, and is dependent on the exact reflection representation of <code>W</code>. So for the moment it is only implemented   when  the  reflection   representation  for  the  irreducible components has the same Cartan matrix as the one provided by Chevie for the corresponding  irreducible  group.  The  polynomials  are invariant for the natural   action  of   the  group   elements  as   matrices;  that  is,  if <code>m==reflrep(W,w)</code>  for some  <code>w</code> in  <code>W</code>, then  an invariant  <code>f</code> satisfies <code>f(a₁,…,aₙ)=f(v₁,…,vₙ)</code>   where  <code>[v₁,…,vₙ]=[a₁,…,aₙ]×m</code>.  This  action  is implemented on <code>Mvp</code>s by the function <code>^</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,2)
A₂

julia&gt; @Mvp x,y,z

julia&gt; i=invariants(W);

julia&gt; map(f-&gt;f(x,y),i)
2-element Vector{Mvp{Int64, Int64}}:
 -2x²+2xy-2y²
 6x²y-6xy²

julia&gt; W=complex_reflection_group(24)
G₂₄

julia&gt; p=invariants(W)[1](x,y,z)
Mvp{Rational{Int64}}: (14//1)x⁴+(-12//1)x²y²+(-42//1)x²yz+(21//2)x²z²+(18//7)y⁴+(-6//1)y³z+(-9//2)y²z²+(-21//8)z⁴

julia&gt; map(v-&gt;^(v,reflrep(W,1);vars=[:x,:y,:z]),(x,y,z))
((1//2)x+(3√-7/14)y, (-√-7/2)x+(-1//2)y, z)

julia&gt; p^reflrep(W,1)-p
Mvp{Cyc{Rational{Int64}}}: 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L2225-L2269">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LaurentPolynomials.discriminant"><a class="docstring-binding" href="#LaurentPolynomials.discriminant"><code>LaurentPolynomials.discriminant</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>discriminant(W)</code></p><p>returns  the  discriminant  of  the  complex  reflection  group  <code>W</code>,  as a polynomial in the fundamental invariants. The discriminant is the invariant obtained  by  taking  the  product  of  the  linear  forms  describing  the reflecting   hyperplanes  of  <code>W</code>,   each  raised  to   the  order  of  the corresponding  reflection. The discriminant  is returned as  a function <code>f</code> such  that  the  discriminant  in  the  variables  <code>a₁,…,aₙ</code> is obtained by calling <code>f(a₁,…,aₙ)</code>. For the moment, this function is implemented only for the exceptional complex reflection groups <code>G₄</code> to <code>G₃₃</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=complex_reflection_group(4);@Mvp x,y

julia&gt; discriminant(W)(x,y)
Mvp{Int64}: x³-y²</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/Chars.jl#L1899-L1917">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.invariant_form"><a class="docstring-binding" href="#Chevie.PermRoot.invariant_form"><code>Chevie.PermRoot.invariant_form</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>invariant_form(W::ComplexReflectionGroup)</code></p><p>This  function  returns  the  matrix  <code>F</code>  (defined  up  to a scalar) of an Hermitian form invariant under the action of the reflection group <code>W</code>. That is, if <code>M</code> is the matrix of an element of <code>W</code>, then <code>M*F*M&#39;=F</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=complex_reflection_group(4)
G₄

julia&gt; invariant_form(W)
2×2 Matrix{Int64}:
 1  0
 0  2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L2156-L2172">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.bipartite_decomposition"><a class="docstring-binding" href="#Chevie.PermRoot.bipartite_decomposition"><code>Chevie.PermRoot.bipartite_decomposition</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>bipartite_decomposition(W)</code></p><p>Returns  a bipartite decomposition <code>[L,R]</code> of the indices of the generators of  the  reflection  group  <code>W</code>,  such  that <code>reflection_subgroup(W,L)</code> and <code>reflection_subgroup(W,R)</code> are abelian subgroups, and <code>W=reflection_subgroup(W,   vcat(L,R))</code>.   Gives   an   error  if  no  such decomposition is possible.</p><pre><code class="language-julia-repl hljs">julia&gt; bipartite_decomposition(coxgroup(:E,8))
([1, 4, 6, 8], [3, 2, 5, 7])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L1150-L1164">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Combinat.catalan-Tuple{Group, Any}"><a class="docstring-binding" href="#Combinat.catalan-Tuple{Group, Any}"><code>Combinat.catalan</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><code>catalan(W::ComplexReflectionGroup)</code></p><p>returns the Catalan Number of the irreducible complex reflection group <code>W</code>. For well-generated groups, this number is equal to the number of simples in the  dual Braid monoid.  For other groups  it was defined by (<a href="../references/#gg12">Gordon and Griffeth, 2012</a>). For Weyl groups, it also counts the number of antichains of roots.</p><pre><code class="language-julia-repl hljs">julia&gt; catalan(coxgroup(:A,7))
1430</code></pre><p><code>catalan(W,i)</code></p><p>returns   the  <code>i</code>-th  Fuss-Catalan  Number   of  the  irreducible  complex reflection  group <code>W</code>. For  well-generated groups, this  number is equal to the  number of chains  <code>s₁,…,sᵢ</code> of simples  in the dual  monoid where <code>sⱼ</code> divides  <code>sⱼ₊₁</code>. For these groups, it is also equal to <code>∏ⱼ(ih+dⱼ)/dⱼ</code> where the  product runs over the reflection degrees  of <code>W</code>, and where <code>h</code> is the Coxeter  number of <code>W</code>. For non-well generated groups, the definition is in (<a href="../references/#gg12">Gordon and Griffeth, 2012</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; catalan(complex_reflection_group(7),2)
16</code></pre><p><code>catalan(W;q=1)</code>, resp. <code>catalan(W,i;q=1)</code></p><p>for  <code>q</code>  a  variable  (like  <code>Pol()</code>  or an <code>Mvp</code>) returns the <code>q</code>-Catalan number  (resp.  the  <code>i</code>-th  <code>q</code>-Fuss  Catalan  number)  of  <code>W</code>. Again the definitions in general are in (<a href="../references/#gg12">Gordon and Griffeth, 2012</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; catalan(complex_reflection_group(7),2;q=Pol())
Pol{Int64}: q⁷²+2q⁶⁰+3q⁴⁸+4q³⁶+3q²⁴+2q¹²+1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L2099-L2137">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.generic_order"><a class="docstring-binding" href="#Chevie.PermRoot.generic_order"><code>Chevie.PermRoot.generic_order</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>generic_order(W,q=Pol())</code></p><p>returns  the generic  order of  <code>W</code> as  a polynomial  in <code>q</code> (the &quot;compact&quot; order  of the  Spets). This  is <span>$q^{Nₕ}Πᵢ(q^{dᵢ}-1)$</span>  where <code>dᵢ</code>  are the reflection  degrees and  <code>Nₕ</code> the  number of  reflecting hyperplanes. For a Weyl  group, it is the order  of the associated semisimple finite reductive group over the field with <code>q</code> elements.</p><pre><code class="language-julia-repl hljs">julia&gt; PermRoot.generic_order(complex_reflection_group(4),Pol(:q))
Pol{Int64}: q¹⁴-q¹⁰-q⁸+q⁴</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L2204-L2217">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.torus_order"><a class="docstring-binding" href="#Chevie.PermRoot.torus_order"><code>Chevie.PermRoot.torus_order</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>torus_order(W::ComplexReflectionGroup,i,q=Pol())</code></p><p>returns  as a  polynomial in  <code>q</code> the  toric order  of the <code>i</code>-th conjugacy class  of <code>W</code>. This is the characteristic  polynomial of an element of that class  on  the  reflection  representation  of  <code>W</code>.  It is the same as the generic  order of the reflection subcoset <code>torus(W,i)</code> of <code>W</code> determined by the trivial subgroup and a representative of the <code>i</code>-th conjugacy class.</p><pre><code class="language-julia-repr hljs">julia&gt; W=complex_reflection_group(4)

julia&gt; torus_order.(Ref(W),1:nconjugacy_classes(W),Pol(:q))
7-element Vector{Pol{Cyc{Int64}}}:
 q²-2q+1
 q²+2q+1
 q²+1
 q²-ζ₃q+ζ₃²
 q²+ζ₃q+ζ₃²
 q²+ζ₃²q+ζ₃
 q²-ζ₃²q+ζ₃</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L1298-L1320">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.reflection_subgroup-Tuple{PRG, AbstractVector}"><a class="docstring-binding" href="#Chevie.PermRoot.reflection_subgroup-Tuple{PRG, AbstractVector}"><code>Chevie.PermRoot.reflection_subgroup</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><code>reflection_subgroup(W,r)</code></p><p>returns  the  reflection  subgroup  of  the  complex  reflection  group <code>W</code> generated by <code>refls(W,r)</code>.</p><p>A  reflection subgroup <code>H</code> of  <code>W</code> is a permutation  subgroup with the same additional  information as  <code>W</code>, and  some new  one added which express the relationship with the parent <code>W</code>:</p><p><code>inclusion(H)</code>:   the indices of the roots of <code>H</code> in the roots of <code>W</code></p><p><code>parent(H)</code>:  is set to <code>W</code>.</p><p><code>restriction(H)</code>:  a list of length <code>length(roots(W))</code> with non-zero entries    in positions <code>inclusion(H)</code> bound to <code>eachindex(roots(H))</code>.</p><p>A  reflection  group  which  is  not  a  subgroup  actually  also  has this information, set to the trivial values: <code>inclusion(W)==restriction(W)==eachindex(roots(W))</code>,   and   <code>parent()==W</code>. This  allows a lot of code to be  written in the same way for parent groups or reflection subgroups.</p><p><code>reflection_subgroup(R)</code> where <code>R</code> is itself a reflection subgroup returns a  reflection subgroup of the parent of <code>R</code>.</p><pre><code class="language-julia_repl hljs">julia&gt; W=coxgroup(:F,4)
F₄

julia&gt; H=reflection_subgroup(W,[1,2,11,20])
F₄₍₉‚₂‚₁‚₁₆₎=D₄₍₃₂₁₄₎

julia&gt; [restriction(H)]
1-element Vector{Vector{Int64}}:
 [1, 2, 0, 0, 5, 0, 0, 0, 3, 0  …  0, 16, 0, 19, 0, 21, 0, 22, 23, 24]

julia&gt; reflection_subgroup(H,[1,2,3])
F₄₍₉₁₂₎=A₃₍₃₁₂₎Φ₁</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L2001-L2041">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.inclusion"><a class="docstring-binding" href="#Chevie.PermRoot.inclusion"><code>Chevie.PermRoot.inclusion</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>inclusion(W::ComplexReflectionGroup)</code></p><p>the indices of the roots of <code>W</code> in the roots of <code>parent(W)</code>.</p><p><code>inclusion(W::PermRootGroup,i::Integer)</code> <code>inclusion(W::PermRootGroup,v::AbstractVector{&lt;:Integer})</code></p><p>same as <code>inclusion(W)[i]</code> or <code>inclusion(W)[v]</code> (but more efficient).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L586-L595">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.inclusiongens"><a class="docstring-binding" href="#Chevie.PermRoot.inclusiongens"><code>Chevie.PermRoot.inclusiongens</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>inclusion(W::ComplexReflectionGroup)</code></p><p>the indices of <code>simpleroots(W)</code> in the roots of <code>parent(W)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L580-L584">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.restriction"><a class="docstring-binding" href="#Chevie.PermRoot.restriction"><code>Chevie.PermRoot.restriction</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>restriction(W::PermRootGroup)</code></p><p>A  list for each root of <code>parent(W)</code>, which  holds <code>0</code> if the root is not a root of <code>W</code> and <code>i</code> if the root is the <code>i</code>-th root of <code>W</code>.</p><p><code>restriction(W::PermRootGroup,i::Integer)</code> <code>restriction(W::PermRootGroup,v::AbstractVector{&lt;:Integer})</code></p><p>same as <code>restriction(W)[i]</code> or <code>restriction(W)[v]</code> (but more efficient).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L1959-L1969">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.action"><a class="docstring-binding" href="#Chevie.PermRoot.action"><code>Chevie.PermRoot.action</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>action(W::ComplexReflectionGroup,i::Integer,p::Perm)</code></p><p>The elements of a <code>PermRootGroup</code> permute the roots of <code>parent(W)</code>, that is are  permutations on  <code>eachindex(roots(parent(W)))</code>. The  function <code>action</code> translates  this action of <code>p∈W</code> to <code>eachindex(roots(W))</code>. For a reflection subgroup we have <code>action(W,i,p)==restriction(W,inclusion(W,i)^p)</code> and for a parent  group <code>action(W,i,p)==i^p</code>. The first formula is always valid since for a parent group <code>restriction(W)==inclusion(W)==eachindex(roots(W))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L1983-L1992">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Weyl.standard_parabolic-Tuple{PermRootGroup, Any}"><a class="docstring-binding" href="#Chevie.Weyl.standard_parabolic-Tuple{PermRootGroup, Any}"><code>Chevie.Weyl.standard_parabolic</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><code>standard_parabolic(W::PermRootGroup, H)</code></p><p>Let  <code>H</code> be a  reflection subgroup of  <code>W</code>. Returns an  element <code>w∈ W</code> such that  <code>H^w</code> is a standard  parabolic subgroup of <code>W</code>  (or nothing if <code>H</code> is not parabolic or not conjugate to a standard parabolic).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/Eigenspaces.jl#L343-L349">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.parabolic_reps"><a class="docstring-binding" href="#Chevie.PermRoot.parabolic_reps"><code>Chevie.PermRoot.parabolic_reps</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>parabolic_reps(W)</code></p><p>For  a Coxeter group or finite complex reflection group <code>W</code>, returns a list of  indices  of  roots  of  <code>W</code>  describing  representatives  of  orbits of parabolic  subgroups  under  conjugation  by  <code>W</code>. For Coxeter groups, each orbit  has a representative which is a standard parabolic subgroup, that is whose indices is a subset of <code>eachindex(gens(W))</code>. This may not be the case in general.</p><pre><code class="language-julia-repl hljs">julia&gt; parabolic_reps(coxgroup(:A,4))
7-element Vector{Vector{Int64}}:
 []
 [1]
 [1, 2]
 [1, 3]
 [1, 2, 3]
 [1, 2, 4]
 [1, 2, 3, 4]

julia&gt; parabolic_reps(complex_reflection_group(3,3,3))
7-element Vector{Vector{Int64}}:
 []
 [1]
 [1, 2]
 [1, 3]
 [1, 9]
 [2, 3]
 [1, 2, 3]</code></pre><p><code>parabolic_reps(W,r)</code></p><p>If  a second  argument <code>r</code>  is given,  returns only  representatives of the parabolic subgroups of semisimple rank <code>r</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; parabolic_reps(coxgroup(:A,4),2)
2-element Vector{Vector{Int64}}:
 [1, 2]
 [1, 3]

julia&gt; parabolic_reps(complex_reflection_group(3,3,3),2)
4-element Vector{Vector{Int64}}:
 [1, 2]
 [1, 3]
 [1, 9]
 [2, 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L1522-L1571">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.parabolic_closure"><a class="docstring-binding" href="#Chevie.PermRoot.parabolic_closure"><code>Chevie.PermRoot.parabolic_closure</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>parabolic_closure(W,I)</code></p><p><code>I</code>  should be a  list of indices  of reflections of  <code>W</code>. Returns <code>J</code> such that  <code>reflection_subgroup(W,J)</code> is the smallest  parabolic subgroup of <code>W</code> containing <code>reflection_subgroup(W,I)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=complex_reflection_group(7)
G₇

julia&gt; parabolic_closure(W,[1])
1-element Vector{Int64}:
 1

julia&gt; parabolic_closure(W,[1,2])
3-element Vector{Int64}:
 1
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L1758-L1779">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.isparabolic"><a class="docstring-binding" href="#Chevie.PermRoot.isparabolic"><code>Chevie.PermRoot.isparabolic</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><code>isparabolic(W)</code></p><p>whether the reflection subgroup <code>W</code> is a parabolic subgroup of <code>parent(W)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=complex_reflection_group(7)
G₇

julia&gt; isparabolic(reflection_subgroup(W,[1,2]))
false

julia&gt; isparabolic(reflection_subgroup(W,[1]))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/c1a1344b4b391335fcfd98da5c038f152dcc4939/src/PermRoot.jl#L1733-L1747">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../nf/">« Number fields</a><a class="docs-footer-nextpage" href="../coxgroups/">Coxeter groups »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 4 December 2025 17:57">Thursday 4 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
