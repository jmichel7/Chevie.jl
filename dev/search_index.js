var documenterSearchIndex = {"docs":
[{"location":"#Chevie","page":"Chevie","title":"Chevie","text":"Chevie uses its rich total infrastructure to provide extensions to several of its infrastructure packages.","category":"section"},{"location":"#Extensions-to-Laurent-and-Puiseux-polynomials","page":"Chevie","title":"Extensions to Laurent and Puiseux polynomials","text":"","category":"section"},{"location":"#Arithmetic-and-finite-fields","page":"Chevie","title":"Arithmetic and finite fields","text":"","category":"section"},{"location":"#Extensions-to-groups","page":"Chevie","title":"Extensions to groups","text":"","category":"section"},{"location":"#Extensions-to-linear-algebra","page":"Chevie","title":"Extensions to linear algebra","text":"","category":"section"},{"location":"#Useful-macros","page":"Chevie","title":"Useful macros","text":"","category":"section"},{"location":"#Chevie","page":"Chevie","title":"Chevie","text":"This  is the current version of the Chevie package. It began life in 2018 as  a port  to Julia  of the  GAP3 package  with the  same name.  All new developments  are  now  carried  out  in  this  version.  If  you are using Chevie.jl   in  a  paper  and  wish  to  acknowledge  it,  you  can  cite (Michel, 2015).\n\nThe  package has  no yet  reached version  1, thus  some function  names or interfaces may yet change. Pull requests and issues are welcomed.\n\nThe  infrastructure needed to make Chevie work has also been implemented, most  of it  as independent  registered packages.  They may have advantages compared  to  other  Julia  packages  providing  similar functionality. You should  take a look at them. They are loaded and re-exported by Chevie so that  their functionality is automatically available when you use Chevie. In other words, Chevie is a meta-package for the following packages:\n\n(univariate) LaurentPolynomials (and rational fractions)\n(multivariate) PuiseuxPolynomials (and rational fractions when there are no fractional exponents)\nCyclotomicNumbers(elements of cyclotomic fields)\nModuleElts (elements of a free module over some ring)\nCombinat (combinatorics and some basic number theory)\nPermGroups (permutations, groups, permutations groups. It contains the modules Perms and Groups which could be separate packages)\nSignedPerms (signed permutations)\nMatInt (Integer matrices and lattices)\nCycPols (cyclotomic polynomials)\nGenLinearAlgebra (linear algebra on any field/ring)\nFinitePosets (finite posets)\nFiniteFields (finite fields)\nGroupPresentations (presentations of groups, and groups defined by generators and relations)\nUsingMerge (Automatically compose a package with the current environment)\n\nTake  a  look  at  the  documentation  for  the  above packages to see what features they provide and how to use them.\n\nSome  other implemented infrastructure which  currently resides in Chevie but may eventually become separate packages:\n\nfactorizing polynomials over finite fields (module FFfac)\nfactorizing polynomials over the rationals (module Fact)\nNumber fields which are subfields of the Cyclotomics (module Nf)\nTruncated Laurent series (module Truncs)\n\nFor permutation groups I have often replaced GAP's sophisticated algorithms with  naive  but  easy-to-write  methods  that  are only suitable for small groups.  These are sufficient for  the rest of the  package but perhaps not for your needs. Otherwise the infrastructure code is often competitive with GAP3's, despite using much less code â€“- often 100 lines of Julia replace 1000  lines of C; and I am sure  it could be optimised better than I did. Comments  on  code  and  design  are  welcome.  For  functions that are too inefficient  or  difficult  to  implement  (such  as  character  tables  of arbitrary  groups), Chevie uses  the GAP package  as an extension. This means  that  if  you  have  the  GAP  package  installed,  Chevie  will automatically call GAP to implement these functions.\n\nThe functions in the Chevie.jl package are often 10 times faster than the equivalent   functions  in  GAP3/Chevie,  after  the  frustratingly  long compilation time on the first run (Julia's TTFP).\n\nThe  Chevie package currently implements  almost all of the GAP3/Chevie functionality,  as well as some functionality from the GAP3 Algebra and VKcurve  packages.  It  also  has  some  new functionality not present in GAP3/Chevie.  If you are a user  of GAP3/Chevie, the gap function can help  you to find the equivalent  functionality in Chevie.jl for a GAP3 function:  it takes  a string  and provides  Julia translations of matching GAP3 functions (the match is case-insensitive).\n\njulia> gap(\"words\")\nCharRepresentationWords  =>  traces_words_mats\nCoxeterWords(W[,l])      =>  word.(Ref(W),elements(W[,l]))\nGarsideWords             =>  elements\n\nYou can then access online help for the functions you have found.\n\nInstalling\n\nChevie  is a  registered package  that can  be installed/upgraded  in the standard  way. For  Julia newbies,  here's a  reminder of  what this is. To install, enter the following at the REPL command line:\n\nenter package mode with ]\ndo the command\n\n(@v1.10) pkg> add Chevie\n\nexit package mode with backspace and then do\n\njulia> using Chevie\n\nand you are set up. For first help, type \"?Chevie\". Have a look at the documentation.\n\nTo update later to the latest version, do\n\n(@v1.10) pkg> update\n\nChevie.jl requires julia 1.10 or later. \n\n\n\n\n\n","category":"module"},{"location":"#Primes.factor-Union{Tuple{p}, Tuple{Pol{FFE{p}}, Any}} where p","page":"Chevie","title":"Primes.factor","text":"factor(f::Pol{FFE{p}}[, F])\n\nGiven  f a polynomial  over a finite  field of characteristic p, factor f,  by default over the  field of its coefficients,  or if specified over the field F. The result is a Primes.Factorization{Pol{FFE{p}}}.\n\njulia> @Pol q\nPol{Int64}: q\n\njulia> f=q^3*(q^4-1)^2*Z(3)^0\nPol{FFE{3}}: qÂ¹Â¹+qâ·+qÂ³\n\njulia> factor(f)\n(qÂ²+1)Â² * (q+1)Â² * (q-1)Â² * qÂ³\n\njulia> factor(f,GF(9))\n(q+1)Â² * (q-1)Â² * (q+Zâ‚‰Â²)Â² * (q+Zâ‚‰â¶)Â² * qÂ³\n\n\n\n\n\n","category":"method"},{"location":"#Primes.factor-Union{Tuple{Pol{T}}, Tuple{T}} where T<:Union{Integer, Rational}","page":"Chevie","title":"Primes.factor","text":"factor(f::Pol{<:Union{Integer,Rational{<:Integer}}})\n\nFactor f over the rationals. The result is a Primes.Factorization{typeof(f)}.\n\njulia> factor(Pol(:q)^24-1)\n(q-1) * (qÂ²-q+1) * (qâ´-qÂ²+1) * (qâ¸-qâ´+1) * (qâ´+1) * (qÂ²+1) * (q+1) * (qÂ²+q+1)\n\n\n\n\n\n","category":"method"},{"location":"#Primes.factor-Union{Tuple{Mvp{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"Chevie","title":"Primes.factor","text":"factor(p::Mvp)\n\np  should be of degree <=2 thus  represent a quadratic form. The function returns  a list  of two  linear forms  of which  p is the product if such forms exist, otherwise it returns [p].\n\njulia> @Mvp x,y\n\njulia> factor(x^2-y^2+x+3y-2)\n2-element Vector{Mvp{Int64, Int64}}:\n x-y+2\n x+y-1\n\njulia> factor(x^2+x+1)\n2-element Vector{Mvp{Cyc{Int64}, Int64}}:\n x-Î¶â‚ƒ\n x-Î¶â‚ƒÂ²\n\njulia> factor(x*y-1)\n1-element Vector{Mvp{Int64, Int64}}:\n xy-1\n\n\n\n\n\n","category":"method"},{"location":"#LaurentPolynomials.valuation-Tuple{Integer, Integer}","page":"Chevie","title":"LaurentPolynomials.valuation","text":"valuation(c::Union{Integer,Rational{<:Integer},p::Integer)  p-adic  valuation of c (largest  power of p which  divides c; for a Rational, valuation of the numerator minus that of the denominator).\n\njulia> valuation.(24,(2,3,5))\n(3, 1, 0)\n\n\n\n\n\n","category":"method"},{"location":"#FiniteFields.FFE-Union{Tuple{Any}, Tuple{p}} where p","page":"Chevie","title":"FiniteFields.FFE","text":"FFE{p}(z::Cyc)  where z is  a p-integral cyclotomic  number (that is, z  times some number prime  to p is a  cyclotomic integer), returns the reduction  of z mod.  p, an element  of some extension  ğ”½_{pÊ³} of the prime field ğ”½â‚š.\n\njulia> FFE{3}(E(7))\nZâ‚‡â‚‚â‚‰Â¹â°â´\n\n\n\n\n\n","category":"method"},{"location":"#Chevie.Tools.abelian_gens","page":"Chevie","title":"Chevie.Tools.abelian_gens","text":"abelian_gens(A)\n\nA  should be an abelian group or the list of its generators. Such a group has  a unique decomposition up to isomorphism as a product of cyclic groups C(nâ‚)Ã—â€¦Ã—C(nâ‚–)  where C(náµ¢)  is a  cyclic group  of order  náµ¢ and náµ¢ divides  náµ¢â‚Šâ‚. The function returns a list  of generators for each of the C(náµ¢).\n\njulia> abelian_gens([Perm(1,2),Perm(3,4,5),Perm(6,7)])\n2-element Vector{Perm{Int16}}:\n (6,7)\n (1,2)(3,5,4)(6,7)\n\n\n\n\n\n","category":"function"},{"location":"#Chevie.Tools.abelian_invariants","page":"Chevie","title":"Chevie.Tools.abelian_invariants","text":"abelian_invariants(G::Group )\n\nG  should be an abelian group. Such a group has a unique decomposition up to  isomorphism as a product of cyclic groups C(nâ‚)Ã—â€¦Ã—C(nâ‚–) where C(náµ¢) is  a cyclic  group of  order náµ¢  and náµ¢  divides náµ¢â‚Šâ‚.  The function returns the list nâ‚,â€¦,nâ‚–.\n\njulia> abelian_invariants(Group(Perm(1,2),Perm(3,4,5),Perm(6,7)))\n2-element Vector{Int64}:\n 2\n 6\n\n\n\n\n\n","category":"function"},{"location":"#Combinat.blocks-Tuple{Group, Integer}","page":"Chevie","title":"Combinat.blocks","text":"blocks(G::Group,p::Integer)\n\nLet  p be a prime. This function returns the partition of the irreducible characters  of G  in p-blocks,  represented by  the list  of indices of irreducibles characters in each block.\n\njulia> W=coxsym(5)\nğ”– â‚…\n\njulia> blocks(W,2)\n2-element Vector{Vector{Int64}}:\n [1, 3, 4, 5, 7]\n [2, 6]\n\njulia> blocks(W,3)\n3-element Vector{Vector{Int64}}:\n [1, 5, 6]\n [2, 3, 7]\n [4]\n\njulia> blocks(W,7)\n7-element Vector{Vector{Int64}}:\n [1]\n [2]\n [3]\n [4]\n [5]\n [6]\n [7]\n\n\n\n\n\n","category":"method"},{"location":"#Base.parent-Tuple{Group}","page":"Chevie","title":"Base.parent","text":"parent(W::Group)\n\nIf W is a subgroup of a group H, return H. Otherwise return W.\n\n\n\n\n\n","category":"method"},{"location":"#Chevie.Tools2.eigmat","page":"Chevie","title":"Chevie.Tools2.eigmat","text":"eigmat(m::Matrix) eigenvalues of finite order of m, as a Vector{Root1}\n\n\n\n\n\n","category":"function"},{"location":"#Chevie.Util.@forward","page":"Chevie","title":"Chevie.Util.@forward","text":"@forward T.f f1,f2,...\n\nis a macro which delegates definitions. The above generates \n\nf1(a::T,args...)=f1(a.f,args...)\nf2(a::T,args...)=f2(a.f,args...)\n...\n\n\n\n\n\n","category":"macro"},{"location":"references/#References","page":"References","title":"References","text":"Alvis,Â D. (1987). The left cells of the Coxeter group of type H_4. J.Â Algebra 107, 160â€“168.\n\n\n\nAlvis,Â D. and Lusztig,Â G. (1982). The representations and generic degrees of the Hecke                   algebra of type H_4. J.Â reineÂ angew.Â Math. 336, 201â€“212. Erratum: ibid. vol. 449, 217â€“218 (1994).\n\n\n\nBala,Â P. and Carter,Â R.Â W. (1976). Classes of unipotent elements in simple algebraic groups. II. Math.Â Proc.Â CambridgeÂ Philos.Â Soc. 80, 1â€“17.\n\n\n\nBenard,Â M. (1976). Schur indices and splitting fields of the unitary                   reflection groups. J.Â Algebra 38, 318â€“342.\n\n\n\nBessis,Â D.; Digne,Â F. and Michel,Â J. (2002). Springer theory in braid groups and the Birman-Ko-Lee monoid. PacificÂ J.Â Math. 205, 287â€“309.\n\n\n\nBessis,Â D. and Michel,Â J. (2004). Explicit presentations for exceptional braid groups. ExperimentalÂ mathematics 13, 257â€“266.\n\n\n\nBonnafÃ©,Â C. (2005). Quasi-Isolated Elements in Reductive Groups 1. CommunicationsÂ inÂ Algebra 33, 2315â€“2337.\n\n\n\nBoura,Â C.; Chavli,Â E. and Chlouveraki,Â M. (2020). The BMM symmetrising trace conjecture for the exceptional               2-reflection groups of rank 2. J.Â Algebra 558, 176â€“198.\n\n\n\nBoura,Â C.; Chavli,Â E.; Chlouveraki,Â M. and Karvounis,Â K. (2020). The BMM symmetrising trace conjecture for groups G_4,               G_5, G_6, G_7, G_8. J.Â SymbolicÂ Comput. 96, 62â€“84.\n\n\n\nBourbaki,Â N. (1968). Ã‰lÃ©ments de mathÃ©matique. Fasc. XXXIV. Groupes et               algÃ¨bres de Lie. Chapitre IV: Groupes de Coxeter et               systÃ¨mes de Tits. Chapitre V: Groupes engendrÃ©s par               des rÃ©flexions. Chapitre VI: systÃ¨mes de racines. ActualitÃ©s Scientifiques et Industrielles [Current Scientific               and Industrial Topics], No. 1337 (Hermann, Paris); p.Â 288 pp. (loose errata).\n\n\n\nBrieskorn,Â E. and Saito,Â K. (1972). Artin-Gruppen und Coxeter-Gruppen. Invent.Â Math. 17, 245â€“271.\n\n\n\nBrouÃ©,Â M. and Malle,Â G. (1993). Zyklotomische Heckealgebren. AstÃ©risque 212, 119â€“189.\n\n\n\nBrouÃ©,Â M.; Malle,Â G. and Michel,Â J. (1993). Generic blocks of finite reductive groups. AstÃ©risque, 7â€“92. ReprÃ©sentations unipotentes gÃ©nÃ©riques et blocs des groupes rÃ©ductifs finis.\n\n\n\nBrouÃ©,Â M.; Malle,Â G. and Michel,Â J. (1999). Towards Spetses I. TransformationÂ Groups 4, 157â€“218.\n\n\n\nBrouÃ©,Â M.; Malle,Â G. and Michel,Â J. (2014). Split spetses for primitive reflection groups. AstÃ©risque, vi+146. With an erratum to [bmm99].\n\n\n\nBrouÃ©,Â M.; Malle,Â G. and Rouquier,Â R. (1998). Complex reflection groups, braid groups, Hecke algebras. J.Â reineÂ angew.Â Math. 500, 127â€“190.\n\n\n\nBrouÃ©,Â M. and Michel,Â J. (1997). Sur certains Ã©lÃ©ments rÃ©guliers des groupes de Weyl et               les variÃ©tÃ©s de Deligne-Lusztig associÃ©es. In: Finite reductive groups (Luminy, 1994), Vol.Â 141 of Progr. Math. (BirkhÃ¤user Boston, Boston, MA); pp.Â 73â€“139.\n\n\n\nCarter,Â R.Â W. (1972). Conjugacy classes in the Weyl group. CompositioÂ Math. 25, 1â€“59.\n\n\n\nCarter,Â R.Â W. (1972). Simple groups of Lie type (Wiley, New York).\n\n\n\nCarter,Â R.Â W. (1985). Finite groups of Lie type: Conjugacy classes and complex characters (Wiley, New York).\n\n\n\nChavli,Â E. (2018). The BMR freeness conjecture for the tetrahedral and octahedral families. Comm.Â Algebra 46, 386â€“464.\n\n\n\nChlouveraki,Â M. (2009). Blocks and families for cyclotomic Hecke algebras. Vol.Â 1981 of Lecture Notes in Mathematics (Springer-Verlag, Berlin); p.Â xiv+160.\n\n\n\nCurtis,Â C.Â W. and Reiner,Â I. (1987). Methods of representation theory. Vol. II. Pure and Applied Mathematics (New York) (John Wiley & Sons, Inc., New York); p.Â xviii+951. With applications to finite groups and orders.\n\n\n\nDehornoy,Â P. and Paris,Â L. (1999). Gaussian groups and Garside groups, two generalizations of Artin groups. Proc.Â LMS 79, 569â€“604.\n\n\n\nDeligne,Â P. (1972). Les immeubles des groupes de tresses gÃ©nÃ©ralisÃ©s. Invent.Â Math. 17, 273â€“302.\n\n\n\nDeodhar,Â V. (1989). A note on subgroups generated by reflections in Coxeter                   groups. Arch.Â derÂ math. 53, 543â€“546.\n\n\n\nDigne,Â F. and Michel,Â J. (2018). Quasi-semisimple elements. Proc.Â LMS 116, 1301â€“1328.\n\n\n\nDigne,Â F. and Michel,Â J. (1985). Fonctions mathcal L des variÃ©tÃ©s de Deligne-Lusztig et descente de Shintani. BulletinÂ deÂ laÂ S.M.F.Â mÃ©moires 20.\n\n\n\nDyer,Â M. (1990). Reflection subgroups of Coxeter systems. J.Â Algebra 135, 57â€“73.\n\n\n\nFrame,Â J.Â S. (1951). The classes and representations of the groups of 27 lines               and 28 bitangents. Ann.Â Mat.Â PuraÂ Appl.Â (4) 32, 83â€“119.\n\n\n\nFrame,Â J.Â S. (1970). The characters of the Weyl group E_8. In: Computational Problems in Abstract Algebra (Proc.               Conf., Oxford, 1967) (Pergamon, Oxford-New York-Toronto, Ont.); pp.Â 111â€“130.\n\n\n\nFranco,Â N. and GonzÃ¡lez-Meneses,Â J. (2003). Computation of centralizers in braid groups and Garside groups. In: Proceedings of the International Conference on Algebraic               Geometry and Singularities (Spanish) (Sevilla, 2001), Vol.Â 19 no.Â 2; pp.Â 367â€“384.\n\n\n\nGarside,Â F.Â A. (1969). The braid groups and other groups. Quart.Â J.Â Math.Â Oxford,Â 2^ndÂ Ser 20, 235â€“254.\n\n\n\nGebhardt,Â V. and GonzÃ¡lez-Meneses,Â J. (2010). Solving the conjugacy problem in Garside groups by cyclic sliding. J.Â SymbolicÂ Comput. 45, 629â€“656.\n\n\n\nGeck,Â M. and Michel,Â J. (1997). On ``good'' elements in the conjugacy classes of finite                   Coxeter groups and their eigenvalues on the irreducible                   representations of Iwahori-Hecke algebras. Proc.Â LondonÂ Math.Â Soc. 74, 275â€“305.\n\n\n\nGeck,Â M. and Pfeiffer,Â G. (1993). On the irreducible characters of Hecke algebras. AdvancesÂ inÂ Math. 102, 79â€“94.\n\n\n\nGeck,Â M. and Halls,Â A. (2015). On the Kazhdan-Lusztig cells in type E_8. Math.Â Comp. 84, 3029â€“3049.\n\n\n\nGeck,Â M. and Pfeiffer,Â G. (2000). Characters of finite Coxeter groups and Iwahori-Hecke algebras. Vol.Â 21 of London Mathematical Society Monographs. New Series (The Clarendon Press, Oxford University Press, New York); p.Â xvi+446.\n\n\n\nGordon,Â I.Â G. and Griffeth,Â S. (2012). Catalan numbers for complex reflection groups. AmericanÂ JournalÂ ofÂ Mathematics 134, 1491â€“1502.\n\n\n\nHe,Â X. and Nie,Â S. (2012). Minimal length elements of finite Coxeter groups. DukeÂ Math.Â J. 161, 2945â€“2967.\n\n\n\nHugues (1985). On decompositions in complex imprimitive reflection                   groups. Indagationes 88, 207â€“219.\n\n\n\nHumphreys,Â J.Â E. (1990). Reflections groups and Coxeter groups. Vol.Â 29 of Cambridge studies in advanced Math (Camb. Univ. Press).\n\n\n\nKazhdan,Â D.Â A. and Lusztig,Â G. (1979). Representations of Coxeter groups and Hecke algebras. Invent.Â Math. 53, 165â€“184.\n\n\n\nKondo,Â T. (1965). The characters of the Weyl group of type F_4. J.Â Fac.Â Sci.Â Univ.Â Tokyo 11, 145â€“153.\n\n\n\nLehrer,Â G.Â I. and Springer,Â T. (1999). Reflection multiplicities and reflection subquotients of                   unitary reflection groups, I. In: geometric group theory down under; pp.Â 181â€“193.\n\n\n\nLusztig,Â G. (1976). Coxeter orbits and eigenspaces of Frobenius. Invent.Â Math. 34, 101â€“159.\n\n\n\nLusztig,Â G. (1977). Irreducible representations of finite classical groups. Invent.Â Math. 43, 125â€“175.\n\n\n\nLusztig,Â G. (1983). Left cells in Weyl groups. In: Lie groups representations, Vol.Â 1024 (Springer); pp.Â 99â€“111.\n\n\n\nLusztig,Â G. (1985). Characters of reductive groups over a finite field. Vol.Â 107 of Annals of Math. Studies (Princeton University Press).\n\n\n\nLusztig,Â G. (2004). Character sheaves on disconnected groups, II. RepresentationÂ theory 8, 72â€“124.\n\n\n\nLusztig,Â G. and Spaltenstein,Â N. (1985). On the generalized Springer correspondence for classical groups. In: Adv. Stud. Pure Math., Vol.Â 6; pp.Â 289â€“316.\n\n\n\nLusztig,Â G. (1978). Representations of finite Chevalley groups. Vol.Â 39 of CBMS Regional Conference Series in Mathematics (American Mathematical Society, Providence, RI); p.Â v+48. Expository lectures from the CBMS Regional Conference held at               Madison, Wis., August 8â€“12, 1977.\n\n\n\nMalle,Â G. (1994). DegrÃ©s relatifs des algÃ¨bres                   cyclotomiques associÃ©es aux groupes de                   rÃ©flexions complexes de dimension deux. In: Luminy94.\n\n\n\nMalle,Â G. (1995). Unipotente Grade imprimitiver komplexer Spiegelungsgruppen. J.Â Algebra 177, 768â€“826.\n\n\n\nMalle,Â G. (2000). On the generic degrees of cyclotomic algebras. RepresentationÂ theory 4, 342â€“369.\n\n\n\nMalle,Â G. and Mathas,Â A. (1998). Symmetric cyclotomic Hecke algebras. J.Â Algebra 205, 275â€“293.\n\n\n\nMalle,Â G. and Michel,Â J. (2010). Constructing representations of Hecke algebras for complex                   reflection groups. LMSÂ J.Â Comput.Â Math. 13, 426â€“450.\n\n\n\nMalle,Â G. and Rouquier,Â R. (2003). Familles de caractÃ¨res de groupes de rÃ©flexions complexes. RepresentationÂ theory 7, 610â€“640.\n\n\n\nMalle,Â G. and Testerman,Â D. (2011). Linear algebraic groups and finite groups of Lie type. Vol.Â 133 of Cambridge Studies in Advanced Mathematics (Cambridge University Press, Cambridge); p.Â xiv+309.\n\n\n\nMarin,Â I. and Michel,Â J. (2010). Automorphisms of complex reflection groups. RepresentationÂ theory 14, 747â€“788.\n\n\n\nMarin,Â I. and Pfeiffer,Â G. (2017). The BMR freeness conjecture for the 2-reflection groups. Math.Â Comp. 86, 2005â€“2023.\n\n\n\nMichel,Â J. (2015). The development version of the CHEVIE package of GAP3. J.Â ofÂ Algebra 435, 308â€“336.\n\n\n\nMizuno,Â K. (1977). The conjugate classes of Chevalley groups of type E_6. J.Â Fac.Â Sci.Â Univ.Â TokyoÂ Sect.Â IAÂ Math. 24, 525â€“563.\n\n\n\nMizuno,Â K. (1980). The conjugate classes of unipotent elements of the Chevalley               groups E_7 and E_8. TokyoÂ J.Â Math. 3, 391â€“461.\n\n\n\nMurphy (1995). The representations of Hecke algebras of type A. J.Â Algebra 173, 97â€“121.\n\n\n\nParis,Â L. (2002). Artin monoids inject in their groups. Comment.Â Math.Â Helv. 77, 609â€“637.\n\n\n\nRichardson,Â R.Â W. (1982). Conjugacy classes of involutions in Coxeter groups. Bull.Â Aust.Â Math.Â Soc. 26, 1â€“15.\n\n\n\nShephard,Â G.Â C. and Todd,Â J.Â A. (1954). Finite unitary reflection groups. Canad.Â J.Â Math. 6, 274â€“304.\n\n\n\nShoji,Â T. (1982). On the Green polynomials of a Chevalley group of type F_4. Comm.Â Algebra 10, 505â€“543.\n\n\n\nSokal,Â A.Â D. (2023). A simple algorithm for expanding a power series as a continued       fraction. ExpositionesÂ Math. 41, 245â€“287.\n\n\n\nSpaltenstein,Â N. (1982). Classes unipotentes et sous-groupes de Borel. Vol.Â 946 of Lecture notes in Mathematics (Springer).\n\n\n\nSpaltenstein,Â N. (1985). On the generalized Springer correspondence for exceptional groups. In: Algebraic groups and related topics (Kyoto, Nagoya, 1983), Vol.Â 6 of Adv. Stud. Pure Math. (North-Holland, Amsterdam); pp.Â 317â€“338.\n\n\n\nStembridge,Â J.Â R. (1989). On the eigenvalues of representations of reflection groups                   and wreath products. PacificÂ J.Â Math. 140, 353â€“396.\n\n\n\nTsuchioka,Â S. (2020). BMR freeness for icosahedral family. Exp.Â Math. 29, 234â€“245.\n\n\n\nZheng,Â H. (2006). A new approach to extracting roots in Garside groups. Comm.Â Algebra 34, 1793â€“1802.\n\n\n\n","category":"section"},{"location":"semisimple/#Semisimple-elements","page":"Semisimple elements","title":"Semisimple elements","text":"Pages=[\"semisimple.md\"]","category":"section"},{"location":"semisimple/#Chevie.Semisimple","page":"Semisimple elements","title":"Chevie.Semisimple","text":"Semisimple elements\n\nLet ğ† a reductive group and ğ“ a maximal torus. We construct semi-simple elements  in two ways. The  first way is for  finite order elements of ğ“, which over an algebraically closed field K are in bijection with elements of  Y(ğ“)âŠ— â„š /â„¤ whose  denominator is prime to  the characteristic of K. These  are represented  as a  vector of  Rationals r  such that 0â‰¤r<1 expressing   such  an  element  in  the   basis  of  Y(ğ“).  The  function ss  constructs  such  a  semisimple  element  from  a  vector  of Rationals.\n\nMore generally a torus ğ“ over a field K is isomorphic to (KË£)^n where n  is the dimension  of ğ“, so  a vector of  elements of KË£  is a more general representation which is produced by the function SemisimpleElement;   in  this  setting  the  result  of  ss  is naturally  interpreted as a Vector{Root1}, so  it can also be obtained by calling SemisimpleElement which such a vector.\n\njulia> G=rootdatum(:sl,4)\nslâ‚„\n\njulia> ss(G,[1//3,1//4,3//4,2//3])\nSemisimpleElement{Root1}: <Î¶â‚ƒ,Î¶â‚„,Î¶â‚„Â³,Î¶â‚ƒÂ²>\n\njulia> SemisimpleElement(G,[E(3),E(4),E(4,3),E(3,2)])\nSemisimpleElement{Root1}: <Î¶â‚ƒ,Î¶â‚„,Î¶â‚„Â³,Î¶â‚ƒÂ²>\n\njulia> L=reflection_subgroup(G,[1,3])\nAâ‚ƒâ‚â‚â‚ƒâ‚=Aâ‚Ã—Aâ‚Î¦â‚\n\njulia> C=algebraic_center(L)\n(Z0 = SubTorus(Aâ‚ƒâ‚â‚â‚ƒâ‚=Aâ‚Ã—Aâ‚Î¦â‚,[1 2 1]), AZ = Group(SemisimpleElement{Root1}[<1,1,-1>]), descAZ = [[1, 2]], ZD = Group(SemisimpleElement{Root1}[<-1,1,1>, <1,1,-1>]))\n\njulia> T=torsion_subgroup(C.Z0,3)\nGroup(SemisimpleElement{Root1}[<Î¶â‚ƒ,Î¶â‚ƒÂ²,Î¶â‚ƒ>])\n\njulia> e=sort(elements(T))\n3-element Vector{SemisimpleElement{Root1}}:\n <1,1,1>\n <Î¶â‚ƒ,Î¶â‚ƒÂ²,Î¶â‚ƒ>\n <Î¶â‚ƒÂ²,Î¶â‚ƒ,Î¶â‚ƒÂ²>\n\nIn  the above, the Levi subgroup  L of SLâ‚„ consisting of block-diagonal matrices  of shape  2Ã—2 is  constructed. The  function algebraic_center returns  a named tuple with : the  neutral component Zâ° of the center Z of L, represented by a basis of Y(Zâ°), a complement subtorus S of ğ“ to  Zâ°  represented  similarly  by  a  basis  of  Y(S), and semi-simple elements  representing the classes of Z modulo  Zâ° , chosen in S. The classes  Z/Zâ° also biject to the fundamental  group as given by the field .descAZ,  see algebraic_center for  an explanation. Finally the semi-simple elements of order 3 in Zâ° are computed.\n\njulia> e[3]^G(2)\nSemisimpleElement{Root1}: <Î¶â‚ƒÂ²,1,Î¶â‚ƒÂ²>\n\njulia> orbit(G,e[3])\n6-element Vector{SemisimpleElement{Root1}}:\n <Î¶â‚ƒÂ²,Î¶â‚ƒ,Î¶â‚ƒÂ²>\n <Î¶â‚ƒÂ²,1,Î¶â‚ƒÂ²>\n <Î¶â‚ƒ,1,Î¶â‚ƒÂ²>\n <Î¶â‚ƒÂ²,1,Î¶â‚ƒ>\n <Î¶â‚ƒ,1,Î¶â‚ƒ>\n <Î¶â‚ƒ,Î¶â‚ƒÂ²,Î¶â‚ƒ>\n\nHere  is the same  computation as above  performed with semisimple elements whose  coefficients are in the  finite field FF(4), representing elements of slâ‚„(ğ”½â‚„).\n\njulia> G=rootdatum(:sl,4)\nslâ‚„\n\njulia> s=SemisimpleElement(G,Z(4).^[1,2,1])\nSemisimpleElement{FFE{2}}: <Zâ‚„,Zâ‚„Â²,Zâ‚„>\n\njulia> s^G(2)\nSemisimpleElement{FFE{2}}: <Zâ‚„,1,Zâ‚„>\n\njulia> orbit(G,s)\n6-element Vector{SemisimpleElement{FFE{2}}}:\n <Zâ‚„,Zâ‚„Â²,Zâ‚„>\n <Zâ‚„,1,Zâ‚„>\n <Zâ‚„Â²,1,Zâ‚„>\n <Zâ‚„,1,Zâ‚„Â²>\n <Zâ‚„Â²,1,Zâ‚„Â²>\n <Zâ‚„Â²,Zâ‚„,Zâ‚„Â²>\n\nWe can compute the centralizer C_ğ† (s) of a semisimple element in ğ†:\n\njulia> G=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> s=ss(G,[0,1//2,0])\nSemisimpleElement{Root1}: <1,-1,1>\n\njulia> centralizer(G,s)\nAâ‚ƒâ‚â‚â‚ƒâ‚=(Aâ‚Aâ‚)Î¦â‚‚\n\nThe  result is  an ExtendedReflectionGroup;  the reflection group part   is  the  Weyl  group  of  C_ğ†â°(s)  and  the  extended  part  are representatives   of  C_ğ†(s)   modulo  C_ğ†â°(s)   taken  as  diagram automorphisms  of the reflection part. Here it  is printed as a coset C_ğ† â°(s)Ï• which generates C_ğ†(s).\n\n\n\n\n\n","category":"module"},{"location":"semisimple/#Chevie.Semisimple.SemisimpleElement","page":"Semisimple elements","title":"Chevie.Semisimple.SemisimpleElement","text":"SemisimpleElement(W,v)\n\nconstructs  a semisimple element  of the reductive  group associated to the Weyl group W whose coefficients on Y(ğ“) are specified by v.\n\n\n\n\n\n","category":"type"},{"location":"semisimple/#Chevie.Semisimple.ss","page":"Semisimple elements","title":"Chevie.Semisimple.ss","text":"ss(W,v)\n\nconstructs  a semisimple  element of  finite order  of the  reductive group associated  to  the  Weyl  group  W.  This  is specified by an element of Y(ğ“)âŠ—â„š/â„¤ specified by a vector of rational v (which are taken modZ). The elements of v are displayed as Root1.\n\njulia> ss(rootdatum(:sl,4),[1//3,1//4,3//4,2//3])\nSemisimpleElement{Root1}: <Î¶â‚ƒ,Î¶â‚„,Î¶â‚„Â³,Î¶â‚ƒÂ²>\n\n\n\n\n\n","category":"function"},{"location":"semisimple/#Chevie.Semisimple.quasi_isolated_reps-Tuple{FiniteCoxeterGroup}","page":"Semisimple elements","title":"Chevie.Semisimple.quasi_isolated_reps","text":"quasi_isolated_reps(W,p=0)\n\nW  should be a Weyl  group corresponding to an  algebraic group ğ† over an algebraically  closed field  of characteristic  0. This  function returns a list  of  semisimple  elements  for  ğ†,  which  are  representatives of the ğ†-orbits  of quasi-isolated  semisimple elements.  It follows the algorithm given in (BonnafÃ©, 2005; Theorem 4.6). If a second argument p is given, it gives  representatives  of  those  quasi-isolated  elements  which exist in characteristic p.\n\njulia> W=coxgroup(:E,6);l=quasi_isolated_reps(W)\n5-element Vector{SemisimpleElement{Root1}}:\n <1,1,1,1,1,1>\n <1,-1,1,1,1,1>\n <1,1,1,Î¶â‚ƒ,1,1>\n <Î¶â‚ƒ,1,1,1,1,Î¶â‚ƒ>\n <1,Î¶â‚†,Î¶â‚†,1,Î¶â‚†,1>\n\njulia> map(s->isisolated(W,s),l)\n5-element Vector{Bool}:\n 1\n 1\n 1\n 0\n 0\n\njulia> W=rootdatum(:E6sc);l=quasi_isolated_reps(W)\n7-element Vector{SemisimpleElement{Root1}}:\n <1,1,1,1,1,1>\n <-1,1,1,-1,1,-1>\n <Î¶â‚ƒ,1,Î¶â‚ƒÂ²,1,Î¶â‚ƒ,Î¶â‚ƒÂ²>\n <Î¶â‚ƒÂ²,1,Î¶â‚ƒ,1,Î¶â‚ƒ,Î¶â‚ƒÂ²>\n <Î¶â‚ƒÂ²,1,Î¶â‚ƒ,1,Î¶â‚ƒÂ²,Î¶â‚ƒ>\n <Î¶â‚†âµ,1,Î¶â‚ƒÂ²,1,Î¶â‚ƒ,Î¶â‚ƒÂ²>\n <Î¶â‚ƒÂ²,1,Î¶â‚ƒ,1,Î¶â‚ƒÂ²,Î¶â‚†âµ>\n\njulia> map(s->isisolated(W,s),l)\n7-element Vector{Bool}:\n 1\n 1\n 1\n 1\n 1\n 1\n 1\n\njulia> Semisimple.quasi_isolated_reps(W,3)\n2-element Vector{SemisimpleElement{Root1}}:\n <1,1,1,1,1,1>\n <-1,1,1,-1,1,-1>\n\n\n\n\n\n","category":"method"},{"location":"semisimple/#Chevie.Semisimple.isisolated","page":"Semisimple elements","title":"Chevie.Semisimple.isisolated","text":"isisolated(WF::Spets,t::SemisimpleElement{Root1})\n\nWF  should be  a Coxeter  coset representing  an algebraic  coset ğ† â‹…Ïƒ, where  ğ† is a connected  reductive group (represented by W=Group(WF)), and  Ïƒ  is  a  quasi-central  automorphism  of  ğ† defined by WF. The element  t should be a semisimple element of ğ†. The function returns a boolean describing whether tÏƒ is isolated, that is whether the Weyl group of C_ğ† (tÏƒ)â° is not in any proper parabolic subgroup of W^Ïƒ.\n\njulia> WF=rootdatum(:u,6)\nuâ‚†\n\njulia> l=quasi_isolated_reps(WF)\n4-element Vector{SemisimpleElement{Root1}}:\n <1,1,1,1,1,1>\n <Î¶â‚„,Î¶â‚„,Î¶â‚„,Î¶â‚„Â³,Î¶â‚„Â³,Î¶â‚„Â³>\n <Î¶â‚„,Î¶â‚„,1,1,Î¶â‚„Â³,Î¶â‚„Â³>\n <Î¶â‚„,1,1,1,1,Î¶â‚„Â³>\n\njulia> isisolated.(Ref(WF),l)\n4-element BitVector:\n 1\n 1\n 1\n 0\n\n\n\n\n\n","category":"function"},{"location":"semisimple/#Chevie.Semisimple.torsion_subgroup","page":"Semisimple elements","title":"Chevie.Semisimple.torsion_subgroup","text":"torsion_subgroup(S::SubTorus,n)\n\nThis  function  returns  the  subgroup  of  semi-simple  elements  of order dividing n in the subtorus S.\n\njulia> G=rootdatum(:sl,4)\nslâ‚„\n\njulia> L=reflection_subgroup(G,[1,3])\nAâ‚ƒâ‚â‚â‚ƒâ‚=Aâ‚Ã—Aâ‚Î¦â‚\n\njulia> C=algebraic_center(L)\n(Z0 = SubTorus(Aâ‚ƒâ‚â‚â‚ƒâ‚=Aâ‚Ã—Aâ‚Î¦â‚,[1 2 1]), AZ = Group(SemisimpleElement{Root1}[<1,1,-1>]), descAZ = [[1, 2]], ZD = Group(SemisimpleElement{Root1}[<-1,1,1>, <1,1,-1>]))\n\njulia> T=torsion_subgroup(C.Z0,3)\nGroup(SemisimpleElement{Root1}[<Î¶â‚ƒ,Î¶â‚ƒÂ²,Î¶â‚ƒ>])\n\njulia> sort(elements(T))\n3-element Vector{SemisimpleElement{Root1}}:\n <1,1,1>\n <Î¶â‚ƒ,Î¶â‚ƒÂ²,Î¶â‚ƒ>\n <Î¶â‚ƒÂ²,Î¶â‚ƒ,Î¶â‚ƒÂ²>\n\n\n\n\n\n","category":"function"},{"location":"semisimple/#Chevie.Semisimple.algebraic_center","page":"Semisimple elements","title":"Chevie.Semisimple.algebraic_center","text":"algebraic_center(W)\n\nW  should  be  a  Weyl  group,  or  an extended Weyl group. This function returns  a description  of the  center Z of  the algebraic  group ğ† defined by W as a named tuple with the following fields:\n\nZ0: the neutral component Zâ° of Z as a subtorus of ğ“.\n\nAZ: representatives in Z of A(Z):=Z/Zâ° given as a group of semisimple elements.\n\nZD:  center of the derived subgroup of ğ† given as a group of semisimple elements.\n\ndescAZ:  if W  is not  an extended  Weyl group,  describes A(Z)  as a quotient  of the center  pi of the  simply connected covering  of ğ† (an incarnation of the fundamental group). It contains a list of elements given as  words  in  the  generators  of  pi  which  generate the kernel of the quotient map.\n\njulia> G=rootdatum(:sl,4)\nslâ‚„\n\njulia> L=reflection_subgroup(G,[1,3])\nAâ‚ƒâ‚â‚â‚ƒâ‚=Aâ‚Ã—Aâ‚\n\nulia> C=algebraic_center(L)\n(Z0 = SubTorus(Aâ‚ƒâ‚â‚â‚ƒâ‚=Aâ‚Ã—Aâ‚Î¦â‚,[1 2 1]), AZ = Group(SemisimpleElement{Root1}[<1,1,-1>]), descAZ = [[1, 2]], ZD = Group(SemisimpleElement{Root1}[<-1,1,1>, <1,1,-1>]))\n\njulia> G=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> s=ss(G,[0,1//2,0])\nSemisimpleElement{Root1}: <1,-1,1>\n\njulia> C=centralizer(G,s)\nAâ‚ƒâ‚â‚â‚ƒâ‚=(Aâ‚Aâ‚)Î¦â‚‚\n\njulia> algebraic_center(C)\n(Z0 = SubTorus(Aâ‚ƒâ‚â‚â‚ƒâ‚=Aâ‚Ã—Aâ‚Î¦â‚,Matrix{Int64}(undef, 0, 3)), AZ = Group(SemisimpleElement{Root1}[<1,-1,1>]))\n\n\n\n\n\n","category":"function"},{"location":"semisimple/#PermGroups.Groups.centralizer-Tuple{FiniteCoxeterGroup, SemisimpleElement}","page":"Semisimple elements","title":"PermGroups.Groups.centralizer","text":"centralizer(W,s::SemisimpleElement)\n\nW  should  be  a  Weyl  group  or  an extended reflection group and s a semisimple  element of the  algebraic group G  corresponding to W. This function  returns the Weyl group of C_G(s), which describes it. This is an  extended reflection group, with the  reflection group part equal to the Weyl  group of C_G(s)â°,  and the diagram  automorphism part being those induced   by   C_G(s).   The   algorithm  follows  (BonnafÃ©, 2005; proposition 3.14).\n\njulia> G=coxgroup(:A,3)\nAâ‚ƒ\njulia> s=ss(G,[0,1//2,0])\nSemisimpleElement{Root1}: <1,-1,1>\njulia> centralizer(G,s) # the brackets around the Aâ‚ means they are permuted\nAâ‚ƒâ‚â‚â‚ƒâ‚=(Aâ‚Aâ‚)Î¦â‚‚\n\n\n\n\n\n","category":"method"},{"location":"semisimple/#Chevie.Semisimple.semisimple_centralizer_representatives","page":"Semisimple elements","title":"Chevie.Semisimple.semisimple_centralizer_representatives","text":"semisimple_centralizer_representatives(W [,p]) or sscentralizer_reps\n\nW  should be a Weyl group corresponding  to an algebraic group ğ†. This function  returns a list describing representatives  ğ‡ of ğ†-orbits of reductive  subgroups  of  ğ†  which  are  the  identity component of the centralizer of a semisimple element. Each group ğ‡ is specified by a list h   of  reflection  indices  in  W   such  that  ğ‡  corresponds  to reflection_subgroup(W,h).  If a  second argument  p is  given, only the list of the centralizers which occur in characteristic p is returned.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> sscentralizer_reps(W)\n6-element Vector{Vector{Int64}}:\n []\n [1]\n [2]\n [1, 2]\n [1, 5]\n [2, 6]\n\njulia> reflection_subgroup.(Ref(W),sscentralizer_reps(W))\n6-element Vector{FiniteCoxeterSubGroup{Perm{Int16},Int64}}:\n Gâ‚‚â‚â‚=Î¦â‚Â²\n Gâ‚‚â‚â‚â‚=Aâ‚Î¦â‚\n Gâ‚‚â‚â‚‚â‚=AÌƒâ‚Î¦â‚\n Gâ‚‚\n Gâ‚‚â‚â‚â‚…â‚=Aâ‚‚\n Gâ‚‚â‚â‚‚â‚†â‚=AÌƒâ‚Ã—Aâ‚\n\njulia> sscentralizer_reps(W,2)\n5-element Vector{Vector{Int64}}:\n []\n [1]\n [2]\n [1, 2]\n [1, 5]\n\n\n\n\n\n","category":"function"},{"location":"semisimple/#Chevie.Semisimple.structure_rational_points_connected_centre","page":"Semisimple elements","title":"Chevie.Semisimple.structure_rational_points_connected_centre","text":"structure_rational_points_connected_centre(W,q)\n\nW  should be  a Coxeter  group or  a Coxeter  coset representing a finite reductive  group ğ† ^F, and q should  be the prime power associated to the  isogeny F. The function returns the abelian invariants of the finite abelian group Zâ°ğ† ^F where Zâ°ğ† is the connected center of ğ†.\n\nIn  the following example one determines the structure of ğ“(ğ”½â‚ƒ) where ğ“ runs over all the maximal tori of SLâ‚„.\n\njulia> l=twistings(rootdatum(:sl,4),Int[])\n5-element Vector{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}}:\n Aâ‚ƒâ‚â‚=Î¦â‚Â³\n Aâ‚ƒâ‚â‚=Î¦â‚Â²Î¦â‚‚\n Aâ‚ƒâ‚â‚=Î¦â‚Î¦â‚‚Â²\n Aâ‚ƒâ‚â‚=Î¦â‚Î¦â‚ƒ\n Aâ‚ƒâ‚â‚=Î¦â‚‚Î¦â‚„\n\njulia> structure_rational_points_connected_centre.(l,3)\n5-element Vector{Vector{Int64}}:\n [2, 2, 2]\n [2, 8]\n [4, 8]\n [26]\n [40]\n\n\n\n\n\n","category":"function"},{"location":"semisimple/#Chevie.Semisimple.fixed_points","page":"Semisimple elements","title":"Chevie.Semisimple.fixed_points","text":"fixed_points(T::SubTorus,m)\n\nLet Ïƒ be an automorphism of T represented as a matrix mâˆˆ GL(X(T)). The function returns (T^Ïƒ0Ïƒ-stable representatives of TT^Ïƒ0)\n\nIt uses the formula in  (Digne and Michel, 2018; 1.2(1))  for TT^Ïƒ0 which is Ker(1+Ïƒ+Ïƒ^2+...)/Im(Ïƒ-Id).\n\n\n\n\n\n","category":"function"},{"location":"semisimple/#Chevie.Semisimple.ExtendedReflectionGroup","page":"Semisimple elements","title":"Chevie.Semisimple.ExtendedReflectionGroup","text":"ExtendedReflectionGroup(W,mats)\n\nExtendedReflectionGroup(W,perms)\n\nAn  extended reflection  group is  the semi-direct  product of a reflection group W on the space V by a group of diagram automorphisms (elements of GL(V)  which  normalize  W).  It  is  represented  as  a  collection of reflection cosets which generate it.\n\nIn  the  first  form,  mats  are  the  automorphisms given as elements of GL(V).  In  the  second  form,  the  automorphisms  are  specified by the permutations they induce on the roots of W.\n\n\n\n\n\n","category":"function"},{"location":"ucl/#Unipotent-classes-of-reductive-groups","page":"Unipotent classes of reductive groups","title":"Unipotent classes of reductive groups","text":"Pages=[\"ucl.md\"]","category":"section"},{"location":"ucl/#Chevie.Ucl","page":"Unipotent classes of reductive groups","title":"Chevie.Ucl","text":"This  module gives information  about the unipotent  conjugacy classes of a connected  reductive group  ğ† over  an algebraically  closed field k of characteristic   p,  and  various  associated  invariants,  such  as  the generalised  Springer correspondence. The unipotent  classes depend on p; their  classification differs  when p  is not  good (that  is, when p divides  one  of  the  coefficients  of  the  highest  root  of  one of the irreducible  components). In good characteristic, the unipotent classes are in bijection with nilpotent orbits on the Lie algebra ğ”¤ of ğ†.\n\nFor each unipotent conjugacy class, we give the following information for a representative u of that class:\n\nthe centralizer C_ğ† (u), that we describe by the reductive part of C_ğ†  (u)^0, by the  group of components  A(u)=C_ğ† (u)C_ğ† (u)^0, and by the dimension of its unipotent radical.\nin good characteristic, the  Dynkin-Richardson  diagram.\nthe generalised  Springer correspondence,  attaching a  character of the Weyl group or a relative Weyl group to each character of A(u).\n\nThe  Dynkin-Richarson diagram is  attached to a  nilpotent element e of the  Lie algebra  ğ”¤. By  the Jacobson-Morozov  theorem there  exists an ğ”°ğ”©â‚‚ subalgebra of ğ”¤ containing e as the element beginpmatrix0100  endpmatrix.  Let  ğ’  be  the  torus beginpmatrixh00h^-1 endpmatrix of SLâ‚‚ and let ğ“ be  a  maximal  torus  containing  ğ’,  so  that ğ’ is the image of a one-parameter   subgroup  Ïƒ  Y(ğ“).  Consider  the  root  decomposition ğ”¤=_Î±Î¦ğ”¤_Î±  given by ğ“ and the  root system Î¦; then Î±ÏƒÎ± defines  a linear form  on Î¦, determined  by its value  on simple roots Î .  It is possible to choose a  system of simple roots such that ÏƒÎ± 0  for Î±Î ,  and then  ÏƒÎ±012 for  any Î±Î . The Dynkin diagram  of  Î   decorated  by  these  values  012  is  called the Dynkin-Richardson  diagram  of  e,  and  in  good  characteristic  is a complete  invariant  of  the  ğ”¤-orbit  of  e. The Dynkin-Richardson diagrams thus classify unipotent classes of ğ† in good characteristic.\n\nAnother classification of unipotent classes was given by (Bala and Carter, 1976). A standard  parabolic subgroup ğ of ğ† associated with the subset IâŠ‚Î  of the simple roots is distinguished if the linear form Ïƒ taking the value 2 on Î±âˆˆ I and 0 on other simple roots satisfies 2nâ‚€+semisimplerank(ğ†)=nâ‚‚,  where náµ¢ is the number of roots in Î¦ where Ïƒ  takes the value i.  Given a distinguished parabolic  ğ, there is a unique  unipotent class which is dense in the unipotent radical of ğ. For this  class, the linear form described  by the Dynkin-Richardson diagram is equal  to  Ïƒ.  Such  unipotent  classes  are  called distinguished. The Bala-Carter theorem says that every unipotent class is distinguished in the smallest  Levi subgroup ğ‹ which  contains it, and that  such pairs of ğ‹ and the distinguished parabolic ğ of ğ‹ taken up to ğ†-conjugacy are in bijection with unipotent classes of ğ†. The function induced_linear_form allows to find the Dynkin-Richardson diagram in ğ† of a unipotent class of ğ‹ and thus recover these diagrams from the Bala-Carter classification.\n\nLet  â„¬ be  the variety  of all  Borel subgroups  and let  â„¬áµ¤ be the subvariety  of Borel subgroups  containing the unipotent  element u. Then dim C_ğ†(u)=rank ğ† + 2 dim â„¬_u and in good characteristic this dimension can  be computed from the linear  form Ïƒ defined by the Dynkin-Richardson diagram:  the dimension of the class of u is the number of roots Î± such that ÏƒÎ±01.\n\nWe   now  describe  the  Springer  correspondence.  Indecomposable  locally constant  ğ†-equivariant  sheaves  on  a  unipotent  class C, called local  systems, are  parameterised by  irreducible characters of A(u) for  uâˆˆ C. The ordinary Springer  correspondence is a bijection between irreducible  characters of the Weyl  group and a large  subset of the local systems,  containing all trivial local  systems (those parameterised by the trivial  character  of  A(u)  for  each  u).  More  generally,  the generalised  Springer correspondence  associates to  each local  system a (unique  up to ğ†-conjugacy) cuspidal datum,  a Levi subgroup ğ‹ of ğ†  and a cuspidal local system on  an unipotent class of ğ‹, and a character  of the relative Weyl group W_ğ† (ğ‹)=N_ğ† (ğ‹)ğ‹. There are few cuspidal  local  systems  (at  most  one  in  each  dimension for classical groups).  The ordinary  Springer correspondence  is the  special case where ğ‹  is a maximal torus, the cuspidal  local system is the trivial system on the identity element, and W_ğ† (ğ‹)=W, the Weyl group.\n\nThe  Springer correspondence gives information on the character values of a finite  reductive  group  as  follows:  assume  that k is the algebraic closure  of a finite field ğ”½_q and that F is the Frobenius attached to  an ğ”½_q-structure of  ğ†. Let C  be an F-stable unipotent class  and let u C^F; we call C the geometric class of u and the ğ†^F-classes within C^F are parameterised by the F-conjugacy classes  of A(u),  denoted by  HÂ¹(FA(u)) (most  of the time we can find u C such that F acts trivially on A(u) and HÂ¹(FA(u)) parametrises  the conjugacy classes). To an F-stable character Ï† of A(u)  we associate  the characteristic  function of the corresponding local  system (actually  associated with  an extension  Ï†Ìƒ of  Ï† to A(u)F);  it is  a class  function Y_uÏ†  on ğ†^F which can be normalised  so  that:  Y_uÏ†(uâ‚)=Ï†Ìƒ(cF)  if  uâ‚  is geometrically conjugate   to  u  and  its   ğ†^F-class  is  parameterised  by  the F-conjugacy  class cF of  A(u), otherwise Y_uÏ†(uâ‚)=0. If the  pair  uÏ†  corresponds  via  the  Springer  correspondence  to the character  Ï‡ of  W_ğ†(ğ‹), then  Y_uÏ† is  also denoted Yáµª. There  is another important class of functions indexed by local systems: to a  local  system  on  class  C  is  attached an intersection cohomology complex,  which is  a complex  of sheaves  supported on the closure CÌ„. Such a complex of sheaves is associated with its characteristic function, a class function of ğ†^F obtained by taking the alternating trace of the Frobenius acting on the stalks of the cohomology sheaves. If Y_Ïˆ is the characteristic  function of a local  system, the characteristic function of the  corresponding intersection  cohomology complex  is denoted by X_Ïˆ. This  function is supported on CÌ„, and Lusztig has shown that X_Ïˆ=_Ï‡ P_ÏˆÏ‡  Yáµª where P_ÏˆÏ‡ are integer polynomials in q and Yáµª are attached to local systems on classes lying in CÌ„.\n\nLusztig   and  Shoji  have  given  an   algorithm  to  compute  the  matrix P_ÏˆÏ‡, which is implemented in Chevie. The relation to the characters of   ğ†(ğ”½_q),   considering   for   simplicity   the  ordinary  Springer correspondence,  is that the  restriction to the  unipotent elements of the almost  character R_Ï‡ is equal to  q^báµª Xáµª, where báµª is dim â„¬áµ¤  for an element u of  the class C such that  the support of Ï‡ is CÌ„.  The restrictions of the Deligne-Lusztig characters R_w for wâˆˆ W  on the  unipotents are  called the  Green functions  and can  also be computed  by Chevie.  The values  of all  unipotent characters on unipotent elements  can also be  computed in principle  by applying Lusztig's Fourier transform  matrix (see the  section on the  Fourier matrix) but  there is a difficulty  in that the  Xáµª must first  be multiplied by  some roots of unity  which are not known  in all cases (and  when known may depend on the congruence class of q modulo some small prime).\n\nFinally,  we describe  how unipotent  classes of  ğ† are  parameterised in various   quasisimple  groups.   In  classical   types,  the   classes  are parametrised by partitions corresponding to the Jordan form in the standard representation. Thus,\n\nfor Aâ‚™ we have partitions of n+1.\nfor  B_n we have partitions of 2n+1  where even parts occur an even number  of times. In characteristic  2, types B and  C are isogenous so have the same classification; thus see the next paragraph.\nfor  C_n we  have partitions  of 2n  where odd  parts occur an even number  of times. In characteristic 2,  there are 2áµ classes attached to  a partition where  k is the  number of even  parts which occur an even number of times.\nfor  D_n we have partitions of 2n  where even parts occur an even number  of times,  excepted there  are two  classes when  all parts are even.  In characteristic 2, we have  partitions of 2n where odd parts occur  an  even  number  of  times,  excepted  there are 2áµ+Î´ classes attached  to a partition  where k is  the number of  even parts which occur an even number of times, and Î´ is 2 when all parts are even and 0 otherwise.\n\nIn  exceptional  groups,  the  names  of  the  classes are derived from the Bala-Carter  classification. The name of a class parametrised by (ğ‹,ğ) is of  the form l(p)  where l is  the name of  ğ‹ and (p) is present if there  is more than one distinguished  parabolic in ğ‹ and describes which one  it is. Before the  Bala-Carter classification was universally adopted, Shoji  and  Mizuno  used  a  different  scheme  where a class was sometimes parametrised  by a reductive subgroup of maximal rank which was not a Levi. These  older labels  can be  obtained instead  by giving  the IO property :shoji=>true  or :mizuno=>true. In a  bad characteristic p, there are extra  classes.  Each  of  them  is  associated  with  a  class c in good characteristic and is called (c)â‚š.\n\nWe illustrate the above descriptions on some examples:\n\njulia> UnipotentClasses(rootdatum(:sl,4))\nUnipotentClasses(slâ‚„)\n1111<211<22<31<4\nâ”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚u   â”‚D-R dâ„¬ áµ¤ B-C   C_ğ†(u) Aâ‚ƒ(Î¦â‚Â³) Aâ‚(Aâ‚Ã—Aâ‚Î¦â‚)/-1 .(Aâ‚ƒ)/Î¶â‚„ .(Aâ‚ƒ)/Î¶â‚„Â³â”‚\nâ”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚4   â”‚222    0 222    qÂ³.Zâ‚„     1:4           -1:2    Î¶â‚„:Id    Î¶â‚„Â³:Idâ”‚\nâ”‚31  â”‚202    1 22.    qâ´.Î¦â‚   Id:31                                  â”‚\nâ”‚22  â”‚020    2 2.2 qâ´.Aâ‚.Zâ‚‚    2:22          11:11                   â”‚\nâ”‚211 â”‚101    3 2..  qâµ.Aâ‚Î¦â‚  Id:211                                  â”‚\nâ”‚1111â”‚000    6 ...       Aâ‚ƒ Id:1111                                  â”‚\nâ””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nThe first column of the table gives the name of the unipotent class, here a partition  describing  the  Jordan  form.  The  partial  order on unipotent classes  given by the Zariski closure is given before the table. The column D-R,   which   is   only   shown   in   good  characteristic,  gives  the Dynkin-Richardson  diagram  for  each  class;  the  column  dBu gives the dimension  of the variety  â„¬ áµ¤. The  column B-C gives the Bala-Carter classification of u, that is in the case of slâ‚„ it shows u as a regular  unipotent  in  a  Levi  subgroup  by  giving the Dynkin-Richardson diagram  of a regular unipotent (all  2's) for the entries corresponding to the  Levi and . for the entries  which not corresponding to the Levi. The column C(u) describes the group C_ğ†(u): a power qáµˆ describes that the  unipotent  radical  of  C_ğ†(u)  has  dimension  d (thus qáµˆ rational  points); then follows a description  of the reductive part of the neutral  component of C_ğ†(u), given by the name of its root datum. Then if  C_ğ†(u) is not connected, the description of A(u) is given using a  different vocabulary: a cyclic group of order  4 is given as Z4, and a symmetric group on 3 points would be given as S3.\n\nFor  example, the first  class 4 has  C_ğ†(u)^0 unipotent of dimension 3 and A(u) equal to Z4, the cyclic group of order 4. The class 22 has  C_G(u) with unipotent radical of  dimension 4, reductive part of type  A1 and  A(u) is  Z2, the  cyclic group  of order 2. The other classes have C_ğ†(u) connected. For the class 31 the reductive part of C_G(u) is a torus of rank 1.\n\nThen  there is a column  for each Springer series,  giving for each class the  pairs  'a:b'  where  'a'  is  the  name  of  the character of A(u) describing  the local system involved and 'b'  is the name of the character of  the (relative) Weyl group corresponding by the Springer correspondence. At  the top of  the column is  the name of  the relative Weyl group, and in brackets  the name  of the  Levi affording  a cuspidal  local system; then, separated  by a /,  is a description  of the central character associated with  the Springer series  (omitted if this  central character is trivial): all  local systems in a given Springer  series have the same restriction to the  centre of ğ†. To see what the picture becomes for another algebraic group  in the same isogeny class, for example the adjoint group, one simply discards the Springer series whose central character becomes trivial on the centre  of ğ†; and each group A(u)  must be quotiented by the common kernel  of  the  remaining  characters.  Here  is the table for the adjoint group:\n\njulia> UnipotentClasses(coxgroup(:A,3))\nUnipotentClasses(Aâ‚ƒ)\n1111<211<22<31<4\nâ”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚u   â”‚D-R dâ„¬ áµ¤ B-C  C_ğ†(u) Aâ‚ƒ(Î¦â‚Â³)â”‚\nâ”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚4   â”‚222    0 222      qÂ³    Id:4â”‚\nâ”‚31  â”‚202    1 22.   qâ´.Î¦â‚   Id:31â”‚\nâ”‚22  â”‚020    2 2.2   qâ´.Aâ‚   Id:22â”‚\nâ”‚211 â”‚101    3 2.. qâµ.Aâ‚Î¦â‚  Id:211â”‚\nâ”‚1111â”‚000    6 ...      Aâ‚ƒ Id:1111â”‚\nâ””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nHere is another example:\n\njulia> UnipotentClasses(coxgroup(:G,2))\nUnipotentClasses(Gâ‚‚)\n1<Aâ‚<AÌƒâ‚<Gâ‚‚(aâ‚)<Gâ‚‚\nâ”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚u     â”‚D-R dâ„¬ áµ¤ B-C C_ğ†(u)         Gâ‚‚(Î¦â‚Â²)  .(Gâ‚‚)â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚Gâ‚‚    â”‚ 22    0  22     qÂ²         Id:Ï†â‚â€šâ‚€       â”‚\nâ”‚Gâ‚‚(aâ‚)â”‚ 20    1  20  qâ´.Sâ‚ƒ 21:Ï†â€²â‚â€šâ‚ƒ 3:Ï†â‚‚â€šâ‚ 111:Idâ”‚\nâ”‚AÌƒâ‚    â”‚ 01    2  .2  qÂ³.Aâ‚         Id:Ï†â‚‚â€šâ‚‚       â”‚\nâ”‚Aâ‚    â”‚ 10    3  2.  qâµ.Aâ‚        Id:Ï†â€³â‚â€šâ‚ƒ       â”‚\nâ”‚1     â”‚ 00    6  ..     Gâ‚‚         Id:Ï†â‚â€šâ‚†       â”‚\nâ””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nwhich illustrates that on class Gâ‚‚(aâ‚) there are two local systems in the principal series of the Springer correspondence, and another cuspidal local system. It also illustrates how we represent the Bala-Carter classification in  general. If a class is attached to (ğ‹,ğ) then the simple roots in the complement  of ğ‹ have a ..  Those in ğ‹ have a  0 or a 2, the 2s characterising ğ. So, from the B-C column, we see that that Gâ‚‚(aâ‚) is not  in a proper Levi, in which case the Bala-Carter diagram coincides with the Dynkin-Richardson diagram.\n\nCharacteristics 2 and 3 are not good for G2. To get the unipotent classes and  the Springer  correspondence in  a bad  characteristic, give  a second argument to the function UnipotentClasses:\n\njulia> UnipotentClasses(coxgroup(:G,2),3)\nUnipotentClasses(Gâ‚‚,3)\n1<Aâ‚,(AÌƒâ‚)â‚ƒ<AÌƒâ‚<Gâ‚‚(aâ‚)<Gâ‚‚\nâ”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚u     â”‚dâ„¬ áµ¤ B-C C_ğ†(u)  Gâ‚‚(Î¦â‚Â²) .(Gâ‚‚) .(Gâ‚‚)  .(Gâ‚‚)â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚Gâ‚‚    â”‚   0  22  qÂ².Zâ‚ƒ   1:Ï†â‚â€šâ‚€       Î¶â‚ƒ:Id Î¶â‚ƒÂ²:Idâ”‚\nâ”‚Gâ‚‚(aâ‚)â”‚   1  20  qâ´.Zâ‚‚   2:Ï†â‚‚â€šâ‚ 11:Id             â”‚\nâ”‚AÌƒâ‚    â”‚   2  .2     qâ¶  Id:Ï†â‚‚â€šâ‚‚                   â”‚\nâ”‚Aâ‚    â”‚   3  2.  qâµ.Aâ‚ Id:Ï†â€³â‚â€šâ‚ƒ                   â”‚\nâ”‚(AÌƒâ‚)â‚ƒ â”‚   3  ??  qâµ.Aâ‚ Id:Ï†â€²â‚â€šâ‚ƒ                   â”‚\nâ”‚1     â”‚   6  ..     Gâ‚‚  Id:Ï†â‚â€šâ‚†                   â”‚\nâ””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nThe  function ICCTable gives the  transition matrix between the functions Xáµª  and Y_Ïˆ.\n\njulia> uc=UnipotentClasses(coxgroup(:G,2));\njulia> t=ICCTable(uc;q=Pol(:q))\nCoefficients of Xáµª on Yáµ© for series L=Gâ‚‚â‚â‚=Î¦â‚Â² W_G(L)=Gâ‚‚\nâ”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚X\\Y   â”‚Gâ‚‚ Gâ‚‚(aâ‚)â½Â²Â¹â¾ Gâ‚‚(aâ‚) AÌƒâ‚ Aâ‚  1â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚XÏ†â‚â€šâ‚€ â”‚ 1          .      1  1  1  1â”‚\nâ”‚XÏ†â€²â‚â€šâ‚ƒâ”‚ .          1      .  1  . qÂ²â”‚\nâ”‚XÏ†â‚‚â€šâ‚ â”‚ .          .      1  1  1 Î¦â‚ˆâ”‚\nâ”‚XÏ†â‚‚â€šâ‚‚ â”‚ .          .      .  1  1 Î¦â‚„â”‚\nâ”‚XÏ†â€³â‚â€šâ‚ƒâ”‚ .          .      .  .  1  1â”‚\nâ”‚XÏ†â‚â€šâ‚† â”‚ .          .      .  .  .  1â”‚\nâ””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nAn example which illustrates how to get the shoji names of classes\n\njulia> uc=UnipotentClasses(coxgroup(:F,4));\n\njulia> uc.classes[10:end]\n7-element Vector{UnipotentClass}:\n UnipotentClass(Câ‚ƒ(aâ‚))\n UnipotentClass(Fâ‚„(aâ‚ƒ))\n UnipotentClass(Câ‚ƒ)\n UnipotentClass(Bâ‚ƒ)\n UnipotentClass(Fâ‚„(aâ‚‚))\n UnipotentClass(Fâ‚„(aâ‚))\n UnipotentClass(Fâ‚„)\n\njulia> xdisplay(uc.classes[10:end],shoji=true)\n7-element Vector{UnipotentClass}:\n UnipotentClass(Aâ‚+Bâ‚‚)\n UnipotentClass(Aâ‚ƒ+AÌƒâ‚)\n UnipotentClass(Câ‚ƒ)\n UnipotentClass(Bâ‚ƒ)\n UnipotentClass(Câ‚ƒ+Aâ‚)\n UnipotentClass(Bâ‚„)\n UnipotentClass(Fâ‚„)\n\nIn  the ICCTable the  row labels and  column labels show  the two ways of indexing  local systems: the row labels  give the character of the relative Weyl  group and the column labels give the  class and the name of the local system as a character of A(u): for example, G2(a1) is the trivial local system  of the  class G2(a1),  while G2(a1)(21)  is the local system on this class corresponding to the 2-dimensional character of A(u)=Aâ‚‚.\n\nThe  data on unipotent classes for  arbitrary reductive groups are obtained as follows. We may reduce to the case where the radical is trivial, that is ğ†  is semisimple. Then ğ† is the quotient of a simply connected group by a  finite central group. The data  for quasi-simple simply connected groups have  been entered  by hand  for each  type and  a general simply connected group  is  a  direct  product  of  quasi-simple  ones.  In  such a group, a character  of A(Z), the group of components of the centre, is attached to each  Springer series.  For an  isogenous reductive  group ğ†' with centre Z'  the group  A(Z') is  a quotient  of the  group A(Z). The Springer series  for ğ†' are those such  that the corresponding character of A(Z) factors through A(Z') (to compute A(Z') see algebraic_center).  The  geometric  unipotent  classes of ğ† and ğ†'  are in bijection. For  u a unipotent element  of ğ†' (which we can also consider as a unipotent element of ğ†) the group Aâ‚=A(u) in ğ†' is a quotient of A=A(u) in ğ† which we can compute as follows: the Springer correspondence  for ğ†' tells us which  characters of A survive in ğ†'. Then A' is the quotient of A by the common kernel of these characters.\n\n\n\n\n\n","category":"module"},{"location":"ucl/#Chevie.Ucl.UnipotentClasses","page":"Unipotent classes of reductive groups","title":"Chevie.Ucl.UnipotentClasses","text":"UnipotentClasses(W[,p])\n\nW should be a FiniteCoxeterGroup record for a Weyl group or rootdatum describing  a reductive algebraic group ğ†.  The function returns a record containing information about the unipotent classes of ğ† in characteristic p  (if omitted, p  is assumed to  be any good  characteristic for ğ†). This contains the following fields:\n\ngroup: a pointer to W\n\np: the characteristic of the field for which the unipotent classes were computed. It is 0 for any good characteristic.\n\norderclasses:  a list describing the Hasse diagram of the partial order induced   on   unipotent   classes   by   the  closure  relation.  That  is .orderclasses[i]  is the list of j such that CÌ„â±¼ CÌ„áµ¢  and  there  is no  class  Câ‚–  such  that CÌ„â±¼ CÌ„â‚– CÌ„áµ¢.\n\nclasses:  a list of records holding information for each unipotent class. See  the  help  for  UnipotentClass  for  a  description of these records.\n\nspringerseries:  a list of records, each  of which describes a Springer series  of ğ†.\n\nThe  records  describing  individual  Springer  series  have  the following fields:\n\nlevi:the  indices of the  reflections corresponding to  the Levi subgroup ğ‹  where  lives  the  cuspidal  local  system Î¹ from which the Springer series is induced.\n\nrelgroup: The relative Weyl group N_ğ†(ğ‹Î¹)ğ‹. The first series is the principal series for which .levi=[] and .relgroup=W.\n\nlocsys:  a  list  of  length  nconjugacy_classes(.relgroup), holding in i-th  position a  pair describing  which local  system corresponds to the i-th  character of  N_ğ†(ğ‹Î¹). The  first element  of the  pair is the index  of the concerned unipotent class u, and the second is the index of the corresponding character of A(u).\n\nZ:  the central character associated  to the Springer series, specified by its value on the generators of the center.\n\njulia> W=rootdatum(:sl,4)\nslâ‚„\n\njulia> uc=UnipotentClasses(W);\n\njulia> uc.classes\n5-element Vector{UnipotentClass}:\n UnipotentClass(1111)\n UnipotentClass(211)\n UnipotentClass(22)\n UnipotentClass(31)\n UnipotentClass(4)\n\nThe  show  function  for  unipotent  classes  accepts  all the options of showtable  and of charnames. Giving the option mizuno (resp. shoji) uses  the names given by  (Mizuno, 1977; Mizuno, 1980) (resp. (Shoji, 1982)) for unipotent  classes. Moreover, there is also an option fourier which gives the  Springer  correspondence  tensored  with  the  sign  character of each relative   Weyl  group,  which   is  the  correspondence   obtained  via  a Fourier-Deligne  transform (here we  assume that p  is very good, so that there  is a nondegenerate  invariant bilinear form  on the Lie algebra, and also one can identify nilpotent orbits with unipotent classes).\n\nHere is how to display the non-cuspidal part of the Springer correspondence of  the unipotent classes of Eâ‚† using the notations of (Mizuno, 1977) for the  classes and those  of (Frame, 1951) for  the characters of the Weyl group  and  of  (Spaltenstein, 1985)  for  the  characters  of  Gâ‚‚  (this  is convenient for checking our data with (Spaltenstein, 1985) which used that same conventions):\n\njulia> uc=UnipotentClasses(rootdatum(:E6sc));\n\njulia> xdisplay(uc;cols=[5,6,7],spaltenstein=true,frame=true,mizuno=true,\n      order=false)\nâ”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚u     â”‚             Eâ‚†(Î¦â‚â¶) Gâ‚‚(Aâ‚‚Ã—Aâ‚‚Î¦â‚Â²)/Î¶â‚ƒ Gâ‚‚(Aâ‚‚Ã—Aâ‚‚Î¦â‚Â²)/Î¶â‚ƒÂ²â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚Eâ‚†    â”‚                1:1â‚š            Î¶â‚ƒ:1            Î¶â‚ƒÂ²:1â”‚\nâ”‚Eâ‚†(aâ‚)â”‚                1:6â‚š           Î¶â‚ƒ:Îµâ‚—           Î¶â‚ƒÂ²:Îµâ‚—â”‚\nâ”‚Dâ‚…    â”‚              Id:20â‚š                                 â”‚\nâ”‚Aâ‚…+Aâ‚ â”‚        -1:15â‚š 1:30â‚š           Î¶â‚ƒ:Î¸â€²           Î¶â‚ƒÂ²:Î¸â€²â”‚\nâ”‚Aâ‚…    â”‚              1:15_q           Î¶â‚ƒ:Î¸â€³           Î¶â‚ƒÂ²:Î¸â€³â”‚\nâ”‚Dâ‚…(aâ‚)â”‚              Id:64â‚š                                 â”‚\nâ”‚Aâ‚„+Aâ‚ â”‚              Id:60â‚š                                 â”‚\nâ”‚Dâ‚„    â”‚              Id:24â‚š                                 â”‚\nâ”‚Aâ‚„    â”‚              Id:81â‚š                                 â”‚\nâ”‚Dâ‚„(aâ‚)â”‚111:20â‚› 3:80â‚› 21:90â‚›                                 â”‚\nâ”‚Aâ‚ƒ+Aâ‚ â”‚              Id:60â‚›                                 â”‚\nâ”‚2Aâ‚‚+Aâ‚â”‚               1:10â‚›          Î¶â‚ƒ:Îµ_c          Î¶â‚ƒÂ²:Îµ_câ”‚\nâ”‚Aâ‚ƒ    â”‚             Id:81â‚šâ€²                                 â”‚\nâ”‚Aâ‚‚+2Aâ‚â”‚             Id:60â‚šâ€²                                 â”‚\nâ”‚2Aâ‚‚   â”‚              1:24â‚šâ€²            Î¶â‚ƒ:Îµ            Î¶â‚ƒÂ²:Îµâ”‚\nâ”‚Aâ‚‚+Aâ‚ â”‚             Id:64â‚šâ€²                                 â”‚\nâ”‚Aâ‚‚    â”‚      11:15â‚šâ€² 2:30â‚šâ€²                                 â”‚\nâ”‚3Aâ‚   â”‚            Id:15_qâ€²                                 â”‚\nâ”‚2Aâ‚   â”‚             Id:20â‚šâ€²                                 â”‚\nâ”‚Aâ‚    â”‚              Id:6â‚šâ€²                                 â”‚\nâ”‚1     â”‚              Id:1â‚šâ€²                                 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n\n\n\n\n","category":"type"},{"location":"ucl/#Chevie.Ucl.UnipotentClass","page":"Unipotent classes of reductive groups","title":"Chevie.Ucl.UnipotentClass","text":"A struct UnipotentClass representing the class C of a unipotent element u  of the reductive  group ğ† with  Weyl group W,  contains always the following information\n\n.name  The name of C\n.parameter A parameter describing C. Sometimes the same as .name; a partition describing the Jordan form, for classical groups.\n.dimBu The dimension of the variety of Borel subgroups containing u.\n\nFor  some  classes  in  types  Eâ‚†,  Eâ‚‡,  Eâ‚ˆ  there  is  a field .mizuno containing the names given by Mizuno for some classes, and for some classes in type Fâ‚„ a field .shoji containing the names given by Shoji.\n\nA  UnipotentClass contains also some of  the following information (all of it for some types and some characteristics but sometimes much less)\n\n.dynkin the Dynkin-Richardson diagram of C (a vector giving a weight 0, 1 or 2 to the simple roots).\n.dimred the dimension of the reductive part of C_G(u).\n.red a CoxeterCoset recording the type of the reductive part of C_G(u), with the twisting induced by the Frobenius if any.\n.Au the group A_G(u)=C_G(u)/C^0_G(u).\n.balacarter encodes the Bala-Carter classification of C, which says that u is distinguished in a Levi L (the Richardson class in a parabolic P_L) as a vector listing the indices of the simple roots in L, with those not in P_L negated.\n.rep a list of indices for roots such that if U=UnipotentGroup(W) then prod(U,u.rep) is a representative of C (which can be obtained also by representative(W,u)).\n.dimunip the dimension of the unipotent part of C_G(u).\n.AuAction an ExtendedCoxeterGroup recording the action of A_G(u) on red.\n\n\n\n\n\n","category":"type"},{"location":"ucl/#Chevie.Ucl.ICCTable","page":"Unipotent classes of reductive groups","title":"Chevie.Ucl.ICCTable","text":"ICCTable(uc,seriesNo=1;q=Pol())\n\nThis function gives the table of decompositions of the functions X_Î¹ in terms  of the functions Y_Î¹. Here Î¹ is a ğ†-equivariant local system on  the  class  C  of  a  unipotent  element  u. Such a local system is parametrised  by the pair  (u,Ï•) of u  and a character  of the group of components   A(u)   of   C_ğ†   (u).   The  function  Y_Î¹  is  the characteristic   function  of  this   local  system  and   X_Î¹  is  the characteristic   function  of  the  corresponding  intersection  cohomology complex  on CÌ„. The  Springer correspondence says  that the local systems can  also be  indexed by  characters of  a relative  Weyl group.  Since the coefficient of Xáµª on Yáµ© is 0 if Ï‡ and Ï† are not characters of the same  relative Weyl group (are not in  the same Springer series), the table is  for one  Springer series,  specified by  the argument  'seriesNo' (this defaults  to 'seriesNo=1' which is the principal series). The decomposition multiplicities  are graded,  and are  given as  polynomials in one variable (specified by the argument q; if not given Pol() is assumed).\n\njulia> uc=UnipotentClasses(coxgroup(:A,3));t=ICCTable(uc)\nCoefficients of Xáµª on Yáµ© for series L=Aâ‚ƒâ‚â‚=Î¦â‚Â³ W_G(L)=Aâ‚ƒ\nâ”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚X\\Y  â”‚4 31 22 211 1111â”‚\nâ”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚X4   â”‚1  1  1   1    1â”‚\nâ”‚X31  â”‚.  1  1  Î¦â‚‚   Î¦â‚ƒâ”‚\nâ”‚X22  â”‚.  .  1   1   Î¦â‚„â”‚\nâ”‚X211 â”‚.  .  .   1   Î¦â‚ƒâ”‚\nâ”‚X1111â”‚.  .  .   .    1â”‚\nâ””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nIn  the  above  the  multiplicities  are  given  as  products of cyclotomic polynomials  to display them  more compactly. However  the format of such a table can be controlled more precisely.\n\nFor  instance,  one  can  ask  to  not  display  the entries as products of cyclotomic polynomials and not display the zeroes as '.'\n\njulia> xdisplay(t;cycpol=false,dotzero=false)\nCoefficients of Xáµª on Yáµ© for A3\nâ”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚X\\Y  â”‚4 31 22 211   1111â”‚\nâ”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚X4   â”‚1  1  1   1      1â”‚\nâ”‚X31  â”‚0  1  1 q+1 qÂ²+q+1â”‚\nâ”‚X22  â”‚0  0  1   1   qÂ²+1â”‚\nâ”‚X211 â”‚0  0  0   1 qÂ²+q+1â”‚\nâ”‚X1111â”‚0  0  0   0      1â”‚\nâ””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nSince  show  uses  the  function  showtable,  all  the  options of this function  are  also  available.  We  can  use  this to restrict the entries displayed  to a  given sublist  of the  rows and  columns (here the indices correspond  to the number  in Chevie of  the corresponding character of the relative Weyl group of the given Springer series):\n\njulia> uc=UnipotentClasses(coxgroup(:F,4));\njulia> t=ICCTable(uc);\njulia> sh=[13,24,22,18,14,9,11,19];\njulia> xdisplay(t,rows=sh,cols=sh)\nCoefficients of Xáµª on Yáµ© for series L=Fâ‚„â‚â‚=Î¦â‚â´ W_G(L)=Fâ‚„\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚X\\Y    â”‚Aâ‚+AÌƒâ‚ Aâ‚‚ AÌƒâ‚‚ Aâ‚‚+AÌƒâ‚ AÌƒâ‚‚+Aâ‚ Bâ‚‚â½Â¹Â¹â¾ Bâ‚‚ Câ‚ƒ(aâ‚)â½Â¹Â¹â¾â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚XÏ†â‚‰â€šâ‚â‚€ â”‚    1  .  .     .     .      .  .          .â”‚\nâ”‚XÏ†â€³â‚ˆâ€šâ‚‰ â”‚    1  1  .     .     .      .  .          .â”‚\nâ”‚XÏ†â€²â‚ˆâ€šâ‚‰ â”‚    1  .  1     .     .      .  .          .â”‚\nâ”‚XÏ†â€³â‚„â€šâ‚‡ â”‚    1  1  .     1     .      .  .          .â”‚\nâ”‚XÏ†â€²â‚†â€šâ‚† â”‚   Î¦â‚„  1  1     1     1      .  .          .â”‚\nâ”‚XÏ†â‚„â€šâ‚ˆ  â”‚   qÂ²  .  .     .     .      1  .          .â”‚\nâ”‚XÏ†â€³â‚‰â€šâ‚† â”‚   Î¦â‚„ Î¦â‚„  .     1     .      .  1          .â”‚\nâ”‚XÏ†â€²â‚„â€šâ‚‡ â”‚   qÂ²  . Î¦â‚„     .     1      .  .          1â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nThe  Ã¬o option rowlocsys=true  will display local  systems also for the row labels.\n\nThe   function  'ICCTable'  returns  an   object  with  various  pieces  of information which can help further computations.\n\n.scalar:  this contains the table of  multiplicities Páµªáµ© of the Xáµª on the  Yáµ©.  One  should  pay  attention  that  by default, the table is not displayed  in the same order as the  stored |.scalar|, which is in order in Chevie  of  the  characters  in  the  relative  Weyl  group;  the  table is transposed,  then lines  and rows  are sorted  by dimBu,class  no,index of character in A(u) while displayed.\n\n.group: The group W.\n\n.relgroup: The relative Weyl group for the Springer series.\n\n.series: The index of the Springer series given for W.\n\n.dimBu: The list of dimâ„¬áµ¤ for each local system (u,Ï†) in the series.\n\n:L:  The matrix of (unnormalised) scalar products of the functions Yáµ© with  themselves,  that  is  the  (Ï†Ï‡)  entry  is _gğ†(ğ”½_q) Yáµ©(g) Yáµª(g). This is thus a symmetric, block-diagonal matrix where the diagonal blocks  correspond to geometric unipotent conjugacy classes. This matrix is obtained as a by-product of Lusztig's algorithm to compute Páµ©áµª.\n\n\n\n\n\n","category":"type"},{"location":"ucl/#Chevie.Ucl.XTable","page":"Unipotent classes of reductive groups","title":"Chevie.Ucl.XTable","text":"XTable(uc;classes=false)\n\nThis  function presents  in a  different way  the information obtained from ICCTable. Let XÌƒ_uÏ•=q^12(codim C-dim Z(ğ‹ ))X_uÏ• where C is the  class of u and Z(ğ‹) is the  center of Levi subgroup on which lives the cuspidal local system attached to the local system (u,Ï•).\n\nThen  XTable(uc) gives the decomposition of the functions XÌƒ_uÏ• on local   systems.  t=XTable(uc,classes==true)  gives  the  values  of  the functions   XÌƒ_uÏ•   on   unipotent   classes.   A   side  effect  of classes=true  is  to  compute  the  cardinal  of  the unipotent conjugacy classes,  available in t.cardClass; in this case displaying t will show the  cardinal  of  the  centralizers  of  unipotent  elements, available in t.centClass.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> XTable(UnipotentClasses(W))\nValues of character sheaves XÌƒáµª of Gâ‚‚ on local systems Ï†\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚XÌƒáµª|Ï†      â”‚   1 Aâ‚ AÌƒâ‚ Gâ‚‚(aâ‚)â½Â¹Â¹Â¹â¾ Gâ‚‚(aâ‚)â½Â²Â¹â¾ Gâ‚‚(aâ‚) Gâ‚‚â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚X_Ï†â‚â€šâ‚€^Gâ‚‚ â”‚   1  1  1           .          .      1  1â”‚\nâ”‚X_Ï†â‚â€šâ‚†^Gâ‚‚ â”‚  qâ¶  .  .           .          .      .  .â”‚\nâ”‚X_Ï†â€²â‚â€šâ‚ƒ^Gâ‚‚â”‚  qÂ³  .  q           .          q      .  .â”‚\nâ”‚X_Ï†â€³â‚â€šâ‚ƒ^Gâ‚‚â”‚  qÂ³ qÂ³  .           .          .      .  .â”‚\nâ”‚X_Ï†â‚‚â€šâ‚^Gâ‚‚ â”‚ qÎ¦â‚ˆ  q  q           .          .      q  .â”‚\nâ”‚X_Ï†â‚‚â€šâ‚‚^Gâ‚‚ â”‚qÂ²Î¦â‚„ qÂ² qÂ²           .          .      .  .â”‚\nâ”‚X_Id^.    â”‚   .  .  .          qÂ²          .      .  .â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nThe functions XÌƒ in the first column are decorated by putting as an exponent the relative groups W_ğ† (ğ‹).\n\njulia> t=XTable(UnipotentClasses(W);classes=true)\nValues of character sheaves XÌƒáµª of Gâ‚‚ on unipotent classes\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚XÌƒáµª|class  â”‚           1     Aâ‚     AÌƒâ‚ Gâ‚‚(aâ‚) Gâ‚‚(aâ‚)â‚â‚‚â‚â‚ Gâ‚‚(aâ‚)â‚â‚ƒâ‚ Gâ‚‚â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚X_Ï†â‚â€šâ‚€^Gâ‚‚ â”‚           1      1      1      1          1         1  1â”‚\nâ”‚X_Ï†â‚â€šâ‚†^Gâ‚‚ â”‚          qâ¶      .      .      .          .         .  .â”‚\nâ”‚X_Ï†â€²â‚â€šâ‚ƒ^Gâ‚‚â”‚          qÂ³      .      q     2q          .        -q  .â”‚\nâ”‚X_Ï†â€³â‚â€šâ‚ƒ^Gâ‚‚â”‚          qÂ³     qÂ³      .      .          .         .  .â”‚\nâ”‚X_Ï†â‚‚â€šâ‚^Gâ‚‚ â”‚         qÎ¦â‚ˆ      q      q      q          q         q  .â”‚\nâ”‚X_Ï†â‚‚â€šâ‚‚^Gâ‚‚ â”‚        qÂ²Î¦â‚„     qÂ²     qÂ²      .          .         .  .â”‚\nâ”‚X_Id^.    â”‚           .      .      .     qÂ²        -qÂ²        qÂ²  .â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚|C_ğ†(u)|  â”‚qâ¶Î¦â‚Â²Î¦â‚‚Â²Î¦â‚ƒÎ¦â‚† qâ¶Î¦â‚Î¦â‚‚ qâ´Î¦â‚Î¦â‚‚    6qâ´        2qâ´       3qâ´ qÂ²â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\njulia> XTable(UnipotentClasses(W,2))\nValues of character sheaves XÌƒáµª of Gâ‚‚ on local systems Ï†\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚XÌƒáµª|Ï†      â”‚   1 Aâ‚ AÌƒâ‚ Gâ‚‚(aâ‚)â½Â¹Â¹Â¹â¾ Gâ‚‚(aâ‚)â½Â²Â¹â¾ Gâ‚‚(aâ‚) Gâ‚‚â½Â¹Â¹â¾ Gâ‚‚â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚X_Ï†â‚â€šâ‚€^Gâ‚‚ â”‚   1  1  1           .          .      1      .  1â”‚\nâ”‚X_Ï†â‚â€šâ‚†^Gâ‚‚ â”‚  qâ¶  .  .           .          .      .      .  .â”‚\nâ”‚X_Ï†â€²â‚â€šâ‚ƒ^Gâ‚‚â”‚  qÂ³  .  q           .          q      .      .  .â”‚\nâ”‚X_Ï†â€³â‚â€šâ‚ƒ^Gâ‚‚â”‚  qÂ³ qÂ³  .           .          .      .      .  .â”‚\nâ”‚X_Ï†â‚‚â€šâ‚^Gâ‚‚ â”‚ qÎ¦â‚ˆ  q  q           .          .      q      .  .â”‚\nâ”‚X_Ï†â‚‚â€šâ‚‚^Gâ‚‚ â”‚qÂ²Î¦â‚„ qÂ² qÂ²           .          .      .      .  .â”‚\nâ”‚X_Id^.    â”‚   .  .  .          qÂ²          .      .      .  .â”‚\nâ”‚X_Id^.    â”‚   .  .  .           .          .      .      q  .â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\njulia> XTable(UnipotentClasses(rootdatum(:sl,4)))\nValues of character sheaves XÌƒáµª of slâ‚„ on local systems Ï†\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚XÌƒáµª|Ï†    â”‚1111 211 22â½Â¹Â¹â¾ 22 31 4 4^(Î¶â‚„) 4â½â»Â¹â¾ 4^(Î¶â‚„Â³)â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚Xâ‚â‚â‚â‚^Aâ‚ƒâ”‚  qâ¶   .      .  .  . .      .     .       .â”‚\nâ”‚Xâ‚‚â‚â‚^Aâ‚ƒ â”‚qÂ³Î¦â‚ƒ  qÂ³      .  .  . .      .     .       .â”‚\nâ”‚Xâ‚‚â‚‚^Aâ‚ƒ  â”‚qÂ²Î¦â‚„  qÂ²      . qÂ²  . .      .     .       .â”‚\nâ”‚Xâ‚ƒâ‚^Aâ‚ƒ  â”‚ qÎ¦â‚ƒ qÎ¦â‚‚      .  q  q .      .     .       .â”‚\nâ”‚Xâ‚„^Aâ‚ƒ   â”‚   1   1      .  1  1 1      .     .       .â”‚\nâ”‚Xâ‚â‚^Aâ‚  â”‚   .   .     qÂ³  .  . .      .     .       .â”‚\nâ”‚Xâ‚‚^Aâ‚   â”‚   .   .     qÂ²  .  . .      .     q       .â”‚\nâ”‚X_Id^.  â”‚   .   .      .  .  . .   qÂ³â„â‚‚     .       .â”‚\nâ”‚X_Id^.  â”‚   .   .      .  .  . .      .     .    qÂ³â„â‚‚â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n\n\n\n\n","category":"type"},{"location":"ucl/#Chevie.Ucl.GreenTable","page":"Unipotent classes of reductive groups","title":"Chevie.Ucl.GreenTable","text":"GreenTable(uc;classes=false)\n\nKeeping the same notations as in the description of XTable, this function returns a table of the functions Q_wF, attached to elements wF W_ğ† (ğ‹)F where W_ğ† (ğ‹) are the relative weyl groups attached to cuspidal local  systems.  These  functions  are  defined  by Q_wF=_uÏ• Ï•Ìƒ(wF) XÌƒ_uÏ•.  Note that for  the principal Springer  series, when ğ‹=ğ“ is a maximal  torus, the function Q_wF coincides with the unipotent values of  the  Deligne-Lusztig  character  R^ğ†_ğ“_W(1).  As for XTable, by default  values are given  in terms of  local systems. If classes=true is given, then the values of the Q_wF on conjugacy classes are given.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> GreenTable(UnipotentClasses(W))\nValues of Green functions Q_wF of Gâ‚‚ on local systems Ï†\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚Qá´µ_wF|Ï†   â”‚        1     Aâ‚       AÌƒâ‚ Gâ‚‚(aâ‚)â½Â¹Â¹Â¹â¾ Gâ‚‚(aâ‚)â½Â²Â¹â¾ Gâ‚‚(aâ‚) Gâ‚‚â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚Q_Aâ‚€^Gâ‚‚   â”‚  Î¦â‚‚Â²Î¦â‚ƒÎ¦â‚†   Î¦â‚‚Î¦â‚ƒ (2q+1)Î¦â‚‚           .          q   2q+1  1â”‚\nâ”‚Q_AÌƒâ‚^Gâ‚‚   â”‚-Î¦â‚Î¦â‚‚Î¦â‚ƒÎ¦â‚†  -Î¦â‚Î¦â‚ƒ       Î¦â‚‚           .          q      1  1â”‚\nâ”‚Q_Aâ‚^Gâ‚‚   â”‚-Î¦â‚Î¦â‚‚Î¦â‚ƒÎ¦â‚†   Î¦â‚‚Î¦â‚†      -Î¦â‚           .         -q      1  1â”‚\nâ”‚Q_Gâ‚‚^Gâ‚‚   â”‚ Î¦â‚Â²Î¦â‚‚Â²Î¦â‚ƒ -Î¦â‚Î¦â‚‚Â²    -Î¦â‚Î¦â‚‚           .         -q     Î¦â‚‚  1â”‚\nâ”‚Q_Aâ‚‚^Gâ‚‚   â”‚ Î¦â‚Â²Î¦â‚‚Â²Î¦â‚†  Î¦â‚Â²Î¦â‚‚    -Î¦â‚Î¦â‚‚           .          q    -Î¦â‚  1â”‚\nâ”‚Q_Aâ‚+AÌƒâ‚^Gâ‚‚â”‚  Î¦â‚Â²Î¦â‚ƒÎ¦â‚†  -Î¦â‚Î¦â‚† (2q-1)Î¦â‚           .         -q  -2q+1  1â”‚\nâ”‚Q^.       â”‚        .      .        .          qÂ²          .      .  .â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nThe  functions Q_wF depend only on the conjugacy class of wF, so in the  first column the indices of 'Q' are the names of the conjugacy classes of W_ğ†(ğ‹). The exponents are the names of the groups W_ğ†(ğ‹).\n\njulia> GreenTable(UnipotentClasses(W);classes=true)\nValues of Green functions Q_wF of Gâ‚‚ on unipotent classes\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚Qá´µ_wF|classâ”‚        1     Aâ‚       AÌƒâ‚ Gâ‚‚(aâ‚) Gâ‚‚(aâ‚)â‚â‚‚â‚â‚ Gâ‚‚(aâ‚)â‚â‚ƒâ‚ Gâ‚‚â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚Q_Aâ‚€^Gâ‚‚    â”‚  Î¦â‚‚Â²Î¦â‚ƒÎ¦â‚†   Î¦â‚‚Î¦â‚ƒ (2q+1)Î¦â‚‚   4q+1       2q+1        Î¦â‚‚  1â”‚\nâ”‚Q_AÌƒâ‚^Gâ‚‚    â”‚-Î¦â‚Î¦â‚‚Î¦â‚ƒÎ¦â‚†  -Î¦â‚Î¦â‚ƒ       Î¦â‚‚   2q+1          1       -Î¦â‚  1â”‚\nâ”‚Q_Aâ‚^Gâ‚‚    â”‚-Î¦â‚Î¦â‚‚Î¦â‚ƒÎ¦â‚†   Î¦â‚‚Î¦â‚†      -Î¦â‚  -2q+1          1        Î¦â‚‚  1â”‚\nâ”‚Q_Gâ‚‚^Gâ‚‚    â”‚ Î¦â‚Â²Î¦â‚‚Â²Î¦â‚ƒ -Î¦â‚Î¦â‚‚Â²    -Î¦â‚Î¦â‚‚    -Î¦â‚         Î¦â‚‚      2q+1  1â”‚\nâ”‚Q_Aâ‚‚^Gâ‚‚    â”‚ Î¦â‚Â²Î¦â‚‚Â²Î¦â‚†  Î¦â‚Â²Î¦â‚‚    -Î¦â‚Î¦â‚‚     Î¦â‚‚        -Î¦â‚     -2q+1  1â”‚\nâ”‚Q_Aâ‚+AÌƒâ‚^Gâ‚‚ â”‚  Î¦â‚Â²Î¦â‚ƒÎ¦â‚†  -Î¦â‚Î¦â‚† (2q-1)Î¦â‚  -4q+1      -2q+1       -Î¦â‚  1â”‚\nâ”‚Q^.        â”‚        .      .        .     qÂ²        -qÂ²        qÂ²  .â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\njulia> GreenTable(UnipotentClasses(rootdatum(:sl,4)))\nValues of Green functions Q_wF of slâ‚„ on local systems Ï†\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚Qá´µ_wF|Ï† â”‚     1111          211 22â½Â¹Â¹â¾       22   31 4 4^(Î¶â‚„) 4â½â»Â¹â¾ 4^(Î¶â‚„Â³)â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚Qâ‚â‚â‚â‚^Aâ‚ƒâ”‚  Î¦â‚‚Â²Î¦â‚ƒÎ¦â‚„ (3qÂ²+2q+1)Î¦â‚‚      . (2q+1)Î¦â‚‚ 3q+1 1      .     .       .â”‚\nâ”‚Qâ‚‚â‚â‚^Aâ‚ƒ â”‚-Î¦â‚Î¦â‚‚Î¦â‚ƒÎ¦â‚„   -qÂ³+qÂ²+q+1      .       Î¦â‚‚   Î¦â‚‚ 1      .     .       .â”‚\nâ”‚Qâ‚‚â‚‚^Aâ‚ƒ  â”‚  Î¦â‚Â²Î¦â‚ƒÎ¦â‚„        -Î¦â‚Î¦â‚„      .  2qÂ²-q+1  -Î¦â‚ 1      .     .       .â”‚\nâ”‚Qâ‚ƒâ‚^Aâ‚ƒ  â”‚ Î¦â‚Â²Î¦â‚‚Â²Î¦â‚„        -Î¦â‚Î¦â‚‚      .    -Î¦â‚Î¦â‚‚    1 1      .     .       .â”‚\nâ”‚Qâ‚„^Aâ‚ƒ   â”‚ -Î¦â‚Â³Î¦â‚‚Î¦â‚ƒ        Î¦â‚Â²Î¦â‚‚      .      -Î¦â‚  -Î¦â‚ 1      .     .       .â”‚\nâ”‚Qâ‚â‚^Aâ‚  â”‚        .            .   qÂ²Î¦â‚‚        .    . .      .     q       .â”‚\nâ”‚Qâ‚‚^Aâ‚   â”‚        .            .  -qÂ²Î¦â‚        .    . .      .     q       .â”‚\nâ”‚Q^.     â”‚        .            .      .        .    . .   qÂ³â„â‚‚     .       .â”‚\nâ”‚Q^.     â”‚        .            .      .        .    . .      .     .    qÂ³â„â‚‚â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n\n\n\n\n","category":"type"},{"location":"ucl/#Chevie.Ucl.UnipotentValues","page":"Unipotent classes of reductive groups","title":"Chevie.Ucl.UnipotentValues","text":"UnipotentValues(uc,classes=false)\n\nThis  function returns  a table  of the  values of  unipotent characters on local systems (by default) or on unipotent classes (if classes=true).\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> UnipotentValues(UnipotentClasses(W);classes=true)\nValues of unipotent characters for Gâ‚‚ on unipotent classes\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚       â”‚        1          Aâ‚     AÌƒâ‚   Gâ‚‚(aâ‚) Gâ‚‚(aâ‚)â‚â‚‚â‚â‚ Gâ‚‚(aâ‚)â‚â‚ƒâ‚ Gâ‚‚â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚Ï†â‚â€šâ‚€   â”‚        1           1      1        1          1         1  1â”‚\nâ”‚Ï†â‚â€šâ‚†   â”‚       qâ¶           .      .        .          .         .  .â”‚\nâ”‚Ï†â€²â‚â€šâ‚ƒ  â”‚  qÎ¦â‚ƒÎ¦â‚†/3    -qÎ¦â‚Î¦â‚‚/3      q (q+5)q/3     -qÎ¦â‚/3     qÎ¦â‚/3  .â”‚\nâ”‚Ï†â€³â‚â€šâ‚ƒ  â”‚  qÎ¦â‚ƒÎ¦â‚†/3  (2qÂ²+1)q/3      .    qÎ¦â‚/3     -qÎ¦â‚/3  (q+2)q/3  .â”‚\nâ”‚Ï†â‚‚â€šâ‚   â”‚ qÎ¦â‚‚Â²Î¦â‚ƒ/6 (2q+1)qÎ¦â‚‚/6  qÎ¦â‚‚/2 (q+5)q/6     -qÎ¦â‚/6     qÎ¦â‚/6  .â”‚\nâ”‚Ï†â‚‚â€šâ‚‚   â”‚ qÎ¦â‚‚Â²Î¦â‚†/2       qÎ¦â‚‚/2  qÎ¦â‚‚/2   -qÎ¦â‚/2      qÎ¦â‚‚/2    -qÎ¦â‚/2  .â”‚\nâ”‚Gâ‚‚[-1] â”‚ qÎ¦â‚Â²Î¦â‚ƒ/2      -qÎ¦â‚/2 -qÎ¦â‚/2   -qÎ¦â‚/2      qÎ¦â‚‚/2    -qÎ¦â‚/2  .â”‚\nâ”‚Gâ‚‚[1]  â”‚ qÎ¦â‚Â²Î¦â‚†/6 (2q-1)qÎ¦â‚/6 -qÎ¦â‚/2 (q+5)q/6     -qÎ¦â‚/6     qÎ¦â‚/6  .â”‚\nâ”‚Gâ‚‚[Î¶â‚ƒ] â”‚qÎ¦â‚Â²Î¦â‚‚Â²/3    -qÎ¦â‚Î¦â‚‚/3      .    qÎ¦â‚/3     -qÎ¦â‚/3  (q+2)q/3  .â”‚\nâ”‚Gâ‚‚[Î¶â‚ƒÂ²]â”‚qÎ¦â‚Â²Î¦â‚‚Â²/3    -qÎ¦â‚Î¦â‚‚/3      .    qÎ¦â‚/3     -qÎ¦â‚/3  (q+2)q/3  .â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\njulia> UnipotentValues(UnipotentClasses(W,3);classes=true)\nValues of unipotent characters for Gâ‚‚ on unipotent classes\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚       â”‚        1          Aâ‚         AÌƒâ‚ Gâ‚‚(aâ‚) Gâ‚‚(aâ‚)â‚â‚‚â‚    Gâ‚‚       Gâ‚‚_(Î¶â‚ƒ)â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚Ï†â‚â€šâ‚€   â”‚        1           1          1      1         1     1             1â”‚\nâ”‚Ï†â‚â€šâ‚†   â”‚       qâ¶           .          .      .         .     .             .â”‚\nâ”‚Ï†â€²â‚â€šâ‚ƒ  â”‚  qÎ¦â‚ƒÎ¦â‚†/3    -qÎ¦â‚Î¦â‚‚/3        q/3  qÎ¦â‚‚/3    -qÎ¦â‚/3 -2q/3           q/3â”‚\nâ”‚Ï†â€³â‚â€šâ‚ƒ  â”‚  qÎ¦â‚ƒÎ¦â‚†/3  (2qÂ²+1)q/3        q/3  qÎ¦â‚‚/3    -qÎ¦â‚/3 -2q/3           q/3â”‚\nâ”‚Ï†â‚‚â€šâ‚   â”‚ qÎ¦â‚‚Â²Î¦â‚ƒ/6 (2q+1)qÎ¦â‚‚/6  (3q+1)q/6  qÎ¦â‚‚/6    -qÎ¦â‚/6  2q/3          -q/3â”‚\nâ”‚Ï†â‚‚â€šâ‚‚   â”‚ qÎ¦â‚‚Â²Î¦â‚†/2       qÎ¦â‚‚/2      qÎ¦â‚‚/2 -qÎ¦â‚/2     qÎ¦â‚‚/2     .             .â”‚\nâ”‚Gâ‚‚[-1] â”‚ qÎ¦â‚Â²Î¦â‚ƒ/2      -qÎ¦â‚/2     -qÎ¦â‚/2 -qÎ¦â‚/2     qÎ¦â‚‚/2     .             .â”‚\nâ”‚Gâ‚‚[1]  â”‚ qÎ¦â‚Â²Î¦â‚†/6 (2q-1)qÎ¦â‚/6 (-3q+1)q/6  qÎ¦â‚‚/6    -qÎ¦â‚/6  2q/3          -q/3â”‚\nâ”‚Gâ‚‚[Î¶â‚ƒ] â”‚qÎ¦â‚Â²Î¦â‚‚Â²/3    -qÎ¦â‚Î¦â‚‚/3        q/3  qÎ¦â‚‚/3    -qÎ¦â‚/3   q/3 (-Î¶â‚ƒ+2Î¶â‚ƒÂ²)q/3â”‚\nâ”‚Gâ‚‚[Î¶â‚ƒÂ²]â”‚qÎ¦â‚Â²Î¦â‚‚Â²/3    -qÎ¦â‚Î¦â‚‚/3        q/3  qÎ¦â‚‚/3    -qÎ¦â‚/3   q/3  (2Î¶â‚ƒ-Î¶â‚ƒÂ²)q/3â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚       â”‚     Gâ‚‚_(Î¶â‚ƒÂ²)       (AÌƒâ‚)â‚ƒâ”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚Ï†â‚â€šâ‚€   â”‚            1           1â”‚\nâ”‚Ï†â‚â€šâ‚†   â”‚            .           .â”‚\nâ”‚Ï†â€²â‚â€šâ‚ƒ  â”‚          q/3  (2qÂ²+1)q/3â”‚\nâ”‚Ï†â€³â‚â€šâ‚ƒ  â”‚          q/3    -qÎ¦â‚Î¦â‚‚/3â”‚\nâ”‚Ï†â‚‚â€šâ‚   â”‚         -q/3 (2q+1)qÎ¦â‚‚/6â”‚\nâ”‚Ï†â‚‚â€šâ‚‚   â”‚            .       qÎ¦â‚‚/2â”‚\nâ”‚Gâ‚‚[-1] â”‚            .      -qÎ¦â‚/2â”‚\nâ”‚Gâ‚‚[1]  â”‚         -q/3 (2q-1)qÎ¦â‚/6â”‚\nâ”‚Gâ‚‚[Î¶â‚ƒ] â”‚ (2Î¶â‚ƒ-Î¶â‚ƒÂ²)q/3    -qÎ¦â‚Î¦â‚‚/3â”‚\nâ”‚Gâ‚‚[Î¶â‚ƒÂ²]â”‚(-Î¶â‚ƒ+2Î¶â‚ƒÂ²)q/3    -qÎ¦â‚Î¦â‚‚/3â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n\n\n\n\n","category":"function"},{"location":"ucl/#Chevie.Ucl.induced_linear_form","page":"Unipotent classes of reductive groups","title":"Chevie.Ucl.induced_linear_form","text":"induced_linear_form(W, H, h)\n\nThis routine can be used to find the unipotent class in the reductive group with  Weyl group W which contains a  given unipotent class of a reductive subgroup of maximum rank represented by the reflection subgroup H of W.\n\nThe  argument h is a linear form on  the roots of H, given by its value on  the simple roots; this  linear form is extended  to the roots of W by 0  on the orthogonal of the roots  of H; and finally the resulting form is  conjugated by an element of W so that it takes positive values on the simple roots. If the initial form describes a Dynkin-Richardson diagram for H, the result will describe a Dynkin-Richardson diagram for W.\n\njulia> W=coxgroup(:F,4)\nFâ‚„\n\njulia> H=reflection_subgroup(W,[1,3])\nFâ‚„â‚â‚â‚ƒâ‚=Aâ‚Ã—AÌƒâ‚Î¦â‚Â²\n\njulia> induced_linear_form(W,H,[2,2])\n4-element Vector{Int64}:\n 0\n 1\n 0\n 0\n\njulia> uc=UnipotentClasses(W);\n\njulia> uc.classes[4].dynkin\n4-element Vector{Int64}:\n 0\n 1\n 0\n 0\n\njulia> uc.classes[4]\nUnipotentClass(Aâ‚+AÌƒâ‚)\n\nThe  example above shows that the class containing the regular class of the Levi subgroup of type Aâ‚Ã—AÌƒâ‚ is the class Aâ‚+AÌƒâ‚.\n\n\n\n\n\n","category":"function"},{"location":"ucl/#Chevie.Ucl.special_pieces","page":"Unipotent classes of reductive groups","title":"Chevie.Ucl.special_pieces","text":"'special_pieces(<uc>)'\n\nThe special pieces form a partition of the unipotent variety of a reductive group  ğ† which  was first  defined in  (Spaltenstein, 1982; chap. III) as the fibres of d^2, where d is a \"duality map\". Another definition is as the set  of classes in  the Zariski closure  of a special  class and not in the Zariski  closure of any smaller  special class, where a  special class is a class  such that the  trivial local system  on it corresponds  to a special character by the Springer correspondence.\n\nSince   each  Lusztig  family  of  characters  contains  a  unique  speical character, special pieces are in bijection with lusztig families.\n\nEach  piece is a union of unipotent  conjugacy classes so is represented in Chevie  as a  list of  class numbers.  Thus the  list of  special pieces is returned  as  a  list  of  lists  of  class  numbers. The list is sorted by increasing  piece dimension, while each piece is sorted by decreasing class dimension, so that the special class is listed first.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> special_pieces(UnipotentClasses(W))\n3-element Vector{Vector{Int64}}:\n [1]\n [4, 3, 2]\n [5]\n\njulia> special_pieces(UnipotentClasses(W,3))\n3-element Vector{Vector{Int64}}:\n [1]\n [4, 3, 2, 6]\n [5]\n\nThe  example above shows  that the special  pieces may be  different in bad characteristic.\n\n\n\n\n\n","category":"function"},{"location":"ucl/#Chevie.Ucl.distinguished_parabolics","page":"Unipotent classes of reductive groups","title":"Chevie.Ucl.distinguished_parabolics","text":"distinguished_parabolics(W)\n\nthe  list of distinguished (in the  sense of Richardson) standard parabolic subgroups W_I of W, each given by the list I of indices in the simple reflections. The distinguished unipotent conjugacy classes of the reductive group  ğ† with Weyl group W consist of  the dense unipotent orbit in the unipotent  radical of a  parabolic subgroup ğ_I  of ğ† associated with a distinguished  W_I.  Their  Dynkin-Richardson  diagram  contains  a  0 at indices  I and a 2 in other entries. If ğ_I=ğ‹ğ” is a Levi decomposition, ğ_I is distinguished iff dim ğ‹âˆ©ğ†'=dim ğ”/ğ”'.\n\njulia> W=coxgroup(:F,4)\nFâ‚„\n\njulia> distinguished_parabolics(W)\n4-element Vector{Vector{Int64}}:\n []\n [3]\n [1, 3]\n [1, 3, 4]\n\n\n\n\n\n","category":"function"},{"location":"chars/#Classes/characters-of-reflection-groups","page":"Classes/characters of reflection groups","title":"Classes/characters of reflection groups","text":"Pages=[\"chars.md\"]","category":"section"},{"location":"chars/#Chevie.Chars","page":"Classes/characters of reflection groups","title":"Chevie.Chars","text":"Characters and conjugacy classes of complex reflection groups.\n\nThe  CharTable  of  a  finite  complex  reflection  group  W is computed  using  the  decomposition  of  W  in  irreducible  groups,  see refltype.  For an irreducible group the character table is either computed  using recursive formulas for the  infinite series, or read from a library  file  for  the  exceptional  types.  Thus, character tables can be obtained  quickly  even  for  very  large  groups  like W(Eâ‚ˆ) or ğ”–â‚â‚…. Similar remarks apply for conjugacy classes.\n\nThe  conjugacy  classes  and  irreducible  characters of irreducible finite complex  reflection groups  are labelled  by certain combinatorial objects; these  labels are shown in  the tables we give.  For the classes, these are partitions or partition tuples for the infinite series, or, for exceptional Coxeter  groups,  Carter's  admissible  diagrams  (Carter, 1972); for other primitive  complex reflection groups we just use words in the generators to specify  representatives of the  classes. For the  characters, these labels are  again partitions or partition tuples  for the infinite series, and for the  exceptional groups they are pairs of two integers (d,b) where d is the  degree of the character and b is the smallest symmetric power of the reflection  representation containing  the character  as a constituent (the valuation of the fakedegree); further a ' or '' may be added to disambiguate  pairs with  the same  (d,b). These  labels are shown by the functions   classinfo  and   charinfo.  Displaying  the character table also shows the labelings for classes and characters.\n\nA  typical example is coxgroup(:A,n),  the symmetric group ğ”–â‚™â‚ where classes  and characters are parameterized by  partitions of n+1 (the same table is shown for coxsym(n+1)).\n\njulia> CharTable(coxgroup(:A,3))\nCharTable(Aâ‚ƒ)\nâ”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚    â”‚1111 211 22 31  4â”‚\nâ”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚1111â”‚   1  -1  1  1 -1â”‚\nâ”‚211 â”‚   3  -1 -1  .  1â”‚\nâ”‚22  â”‚   2   .  2 -1  .â”‚\nâ”‚31  â”‚   3   1 -1  . -1â”‚\nâ”‚4   â”‚   1   1  1  1  1â”‚\nâ””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\njulia> ct=CharTable(coxgroup(:G,2))\nCharTable(Gâ‚‚)\nâ”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚     â”‚Aâ‚€ AÌƒâ‚ Aâ‚ Gâ‚‚ Aâ‚‚ Aâ‚+AÌƒâ‚â”‚\nâ”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚Ï†â‚â€šâ‚€ â”‚ 1  1  1  1  1     1â”‚\nâ”‚Ï†â‚â€šâ‚† â”‚ 1 -1 -1  1  1     1â”‚\nâ”‚Ï†â€²â‚â€šâ‚ƒâ”‚ 1  1 -1 -1  1    -1â”‚\nâ”‚Ï†â€³â‚â€šâ‚ƒâ”‚ 1 -1  1 -1  1    -1â”‚\nâ”‚Ï†â‚‚â€šâ‚ â”‚ 2  .  .  1 -1    -2â”‚\nâ”‚Ï†â‚‚â€šâ‚‚ â”‚ 2  .  . -1 -1     2â”‚\nâ””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\njulia> charnames(ct,TeX=true)\n6-element Vector{String}:\n \"\\phi_{1,0}\"\n \"\\phi_{1,6}\"\n \"\\phi_{1,3}'\"\n \"\\phi_{1,3}''\"\n \"\\phi_{2,1}\"\n \"\\phi_{2,2}\"\n\njulia> classnames(ct,TeX=true)\n6-element Vector{String}:\n \"A_0\"\n \"\\tilde A_1\"\n \"A_1\"\n \"G_2\"\n \"A_2\"\n \"A_1+\\tilde A_1\"\n\nReflection  groups  have  fakedegrees](@ref),  whose valuation and degree give  two  invariants  b,B  for  each  irreducible  character of W. For spetsial  groups (which include  finite Coxeter groups),  the valuation and degree  of the generic degrees of the  spetsial Hecke algebra give two more invariants  a,A; for Coxeter groups  see (Carter, 1985; chap.11) for more details.  These integers are used in the operations of truncated induction, see j_induction_table and J_induction_table.\n\nIwahori-Hecke  algebras and  cyclotomic Hecke  algebras also have character tables, see HeckeAlgebras.\n\nWe  now describe for each type our conventions for labeling the classes and characters.\n\nType Aâ‚™ (nâ‰¥0). \n\nWe  have  W(Aâ‚™)ğ”–â‚™â‚;  its  classes  and  characters  are  labelled  by partitions  of n+1. The partition labelling a  class is the cycle type of the  elements in that  class; the representative  word in the generators in .classtext  is the concatenation of the words corresponding to each part, where  the  word  for  a  part  i  is  the  product  of i-1 consecutive generators  (starting  one  higher  than  the  last  generator used for the previous  parts). The partition labelling a character describes the type of the  Young  subgroup  such  that  the  trivial  character induced from this subgroup  contains that character with multiplicity 1 and such that every other character occurring in this induced character has a higher a-value. Thus,  the sign  character is  labelled by  the partition  (1â¿âºÂ¹) and the trivial character by the partition (n+1). The character of the reflection representation of W is labelled by (n,1).\n\nType  Bâ‚™  (nâ‰¥2).  \n\nThe group W=W(Bâ‚™) is isomorphic to the wreath product of the cyclic group of  order  2  with  the  symmetric  group ğ”–â‚™. Hence  the  classes and characters are parameterized by pairs of partitions such that the total sum of  their parts equals n. The pair corresponding to a class describes the signed  cycle type for the elements in that class, as in (Carter, 1972). We use  the convention that if (Î»,Î¼) is  such a pair then Î» corresponds to the  positive  and  Î¼  to  the  negative  cycles.  Thus,  ((1â¿),-)  and (-,(1â¿))  label  respectively  the  trivial  class  and  the class of the longest element.\n\nThe  pair  corresponding  to  an  irreducible  character  is determined via Clifford  theory using the  semidirect product decomposition W(Bâ‚™)=Nğ”–â‚™ where N is the standard n-dimensional ğ”½â‚‚â¿-vector space. For a,b â‰¥ 0 such that n=a+b let Î·_ab be the irreducible character of N which takes  value 1 on the first a  standard basis vectors and value -1 on the  last b standard basis  vectors of N. Then  the inertia subgroup of Î·_ab   has  the  form  T_ab=N(ğ”–_ağ”–_b)  and  we  can  extend Î·_ab   trivially  to   an  irreducible   character  Î·Ìƒ_ab  of T_ab. Let Î± and Î² be partitions of a and b, respectively. We take  the  tensor  product  of  the corresponding irreducible characters of ğ”–_a  and  ğ”–_b  and  regard  this  as  an  irreducible  character of T_ab.  Multiplying this character with  Î·Ìƒ_ab and inducing to W(Bâ‚™)  yields an irreducible character  Ï‡= Ï‡_(Î±Î²) of W(Bâ‚™). This defines  the  correspondence  between  irreducible  characters and pairs of partitions as above.\n\nFor example, the pair ((n),-) labels the trivial character and (-,(1â¿)) labels  the  sign  character.  The  character  of  the  natural  reflection representation is labeled by ((n-1),(1)).\n\nType  Dâ‚™ (nâ‰¥4). \n\nThe  group W(Dâ‚™)  can be  embedded as  a subgroup  of index  2 into the Coxeter  group W(Bâ‚™). The intersection of a class of W(Bâ‚™) with W(Dâ‚™) is  either empty or a single class in W(Dâ‚™) or splits up into two classes in W(Dâ‚™). This also leads to a parameterization of the classes of W(Dâ‚™) by  pairs of partitions (Î»,Î¼) as before  but where the number of parts of Î¼  is even and where there  are two classes of this  type if Î¼ is empty and all parts of Î» are even. In the latter case we denote the two classes in  W(Dâ‚™) by (Î»,+)  and (Î»,-), where  we use the  convention that the class  labeled by (Î»,+) contains a representative which can be written as a word in {sâ‚,sâ‚ƒ,â€¦,sâ‚™} and (Î»,-) contains a representative which can be written as a word in {sâ‚‚,sâ‚ƒ, â€¦,sâ‚™}.\n\nBy  Clifford theory the restriction of  an irreducible character of W(Bâ‚™) to  W(Dâ‚™)  is  either  irreducible  or  splits  up  into  two irreducible components.  Let (Î±,Î²) be  a pair of  partitions with total  sum of parts equal to n. If Î±!=Î² then the restrictions of the irreducible characters of  W(Bâ‚™) labeled  by (Î±,Î²)  and (Î²,Î±)  are irreducible and equal. If Î±=Î²  then the restriction of the character labeled by (Î±,Î±) splits into two  irreducible components  which we  denote by  (Î±,+) and (Î±,-). Note that  this can only happen if n is  even. In order to fix the notation we use  a result of (Stembridge, 1989) which describes the value of the difference of  these two  characters on  a class  of the  form (Î»,+) in terms of the character  values of  the symmetric  group ğ”–_n2.  Recall that  it is implicit  in the notation (Î»,+) that all  parts of Î» are even. Let Î»' be  the partition of n/2 obtained by  dividing each part by 2. Then the value  of Ï‡_(Î±-)-Ï‡_(Î±+)  on an  element in  the class  (Î»,+) is given  by  2^{k(Î»)}  times  the  value  of  the  irreducible character of ğ”–_n2  labeled by Î± on the class  of cycle type Î»'. (Here, k(Î») denotes the number of non-zero parts of Î».)\n\nThe  labels for the trivial, the  sign and the natural reflection character are the same as for W(Bâ‚™), since these characters are restrictions of the corresponding characters of W(Bâ‚™).\n\nThe groups G(d,1,n).\n\nThey are isomorphic to the wreath product Î¼_dğ”–â‚™ of the cyclic group of order  d with the  symmetric group. Hence  the classes and characters are parameterized  by d-tuples of partitions such that the total sum of their parts  equals n. The words chosen  as representatives of the classes are, when d>2, computed in a slightly different way than for Bâ‚™, in order to agree  with the words on which Ram  and Halverson compute the characters of the  Hecke algebra. First the parts of the d partitions are merged in one big  partition and sorted in  increasing order. Then, to  a part i coming from  the j-th partition is  associated the word (l+1â€¦1â€¦ l+1)Ê²â»Â¹l+2â€¦l+i where l is the highest generator used to express the previous part.\n\nThe  d-tuple corresponding to an  irreducible character is determined via Clifford  theory in  a similar  way than  for the  Bâ‚™ case.  The identity character  has the first  partition with one  part equal n  and the other ones  empty. The character of the  reflection representations has the first two  partitions with one part  equal respectively to n-1  and to 1, and the other partitions empty.\n\nThe groups G(de,e,n).\n\nThey  are normal  subgroups of  index e  in G(de,1,n).  The quotient is cyclic,  generated by the image g  of the first generator of G(de,1,n). The  classes are parameterized as the  classes of G(de,e,n) with an extra information for a component of a class which splits.\n\nAccording  to (Hugues, 1985), a class C  of G(de,1,n) parameterized by a de-partition  (Sâ‚€S_de-1) is in G(de,e,n) if e divides áµ¢ i _p Sáµ¢p. It splits in d classes for the largest d dividing e and all  parts of all Sáµ¢ and  such that Sáµ¢ is empty  if d does not divide i.  If wâˆˆC then [gâ± w gâ»â± for i in 0:d-1] are representatives of the classes  of G(de,e,n) which meet C.  They are labelled by appending the integer i to the label for C.\n\nThe  characters are described by Clifford theory. We make g act on labels for  characters of G(de,1,n)  . The action  of g permutes circularly by d  the partitions in the de-tuple.  A character has same restriction to G(de,e,n)  as its transform by g.  The number of irreducible components of its restriction is equal to the order k of its stabilizer under powers of  g.  We  encode  a  character  of  G(de,e,n)  by first, choosing the smallest  for lexicographical order label  of a character whose restriction contains  it; then this label is periodic with a motive repeated k times; we  represent the  character by  one of  these motives,  to which we append E(k)â± for i in 0:k-1 to describe which component of the restriction we choose.\n\nTypes Gâ‚‚ and Fâ‚„. \n\nA character is labeled by a pair (d,b) where d denotes the degree and b the  corresponding b-invariant. If there  are several characters with the same pair (d,b) we attach a prime to them, as in (Carter, 1985).\n\nThe  matrices of  character values  and the  orderings and labelings of the irreducible characters are exactly the same as in (Carter, 1985; p.412â€“413):  in type Gâ‚‚ the character  Ï†â‚,â‚ƒ' takes the value -1 on  the reflection associated  to the long  simple root; in  type Fâ‚„, the characters  Ï†â‚,â‚â‚‚', Ï†â‚‚,â‚„',  Ï†â‚„,â‚‡', Ï†â‚ˆ,â‚‰'  and Ï†â‚‰,â‚†'  occur in the induced  of the  identity from  the Aâ‚‚  corresponding to the short simple roots;  the pairs (Ï†â‚‚,â‚â‚†', Ï†â‚‚,â‚„â€³) and (Ï†â‚ˆ,â‚ƒ', Ï†â‚ˆ,â‚‰â€³) are related by tensoring  by  sign;  and  finally  Ï†â‚†,â‚†â€³  is  the exterior square of the reflection  representation. Note, however, that we put the long root at the left  of the Dynkin  diagrams to be  in accordance with  the conventions in (Lusztig, 1985; (4.8) and (4.10)).\n\nThe  classes are labeled by  Carter's admissible diagrams (Carter, 1972).\n\nTypes  Eâ‚†,Eâ‚‡,Eâ‚ˆ. \n\nThe  character tables are obtained by  specialization of those of the Hecke algebra.   The  classes   are  labeled   by  Carter's  admissible  diagrams (Carter, 1972).  A  character  is  labeled  by  the  pair (d,b) where d denotes  the degree and  b is the  corresponding b-invariant. For these types, this gives a unique labeling of the characters.\n\nNon-crystallographic  types Iâ‚‚(m), Hâ‚ƒ, Hâ‚„. \n\nIn these cases we do not have canonical labelings for the classes. We label them by reduced expressions.\n\nEach  character for  type Hâ‚ƒ  is uniquely  determined by the pair (d,b) where  d is the degree and  b the corresponding b-invariant. For type Hâ‚„  there are just  two characters (those  of degree 30)  for which the corresponding  pairs are  the same.  These two  characters are nevertheless distinguished  by  their  fake  degrees:  the  character Ï†â‚ƒâ‚€,â‚â‚€' has fake degree  qÂ¹â°+qÂ¹Â²+ higher terms, while Ï†â‚ƒâ‚€,â‚â‚€â€³ has fake degree qÂ¹â°+qÂ¹â´+ higher  terms. The characters in the table for type Hâ‚„ are ordered in the same way as in (Alvis and Lusztig, 1982).\n\nFinally,  the characters  of degree 2  for type  Iâ‚‚(m) are  ordered as follows.  The matrix representations affording the characters of degree 2 are given by: Ï_j  sâ‚sâ‚‚  beginpmatrixzeta_m^j00zeta_m^-jendpmatrix  sâ‚beginpmatrix0110endpmatrix where  1  j   (m-1)2. The reflection representation is  Ïâ‚. The  characters in  the table  are ordered by listing first the characters of degree 1 and then Ïâ‚,Ïâ‚‚,â€¦.\n\nPrimitive complex reflection groups Gâ‚„ to Gâ‚ƒâ‚„.\n\nThe  groups Gâ‚‚â‚ƒ=Hâ‚ƒ, Gâ‚‚â‚ˆ=Fâ‚„, Gâ‚ƒâ‚€=Hâ‚„ are exceptional Coxeter groups and have  been  explained  above.  Similarly  for  the  other groups labels for characters  consist primarily  of the  pair (d,b)  where d  denotes the degree  and b is the corresponding  b-invariant. This is sufficient for Gâ‚„,  Gâ‚â‚‚, Gâ‚‚â‚‚ and Gâ‚‚â‚„. For other  groups there are pairs or triples of  characters which  have the  same (d,b)  value. We  disambiguate these according to the conventions of (Malle, 2000) for Gâ‚‚â‚‡, Gâ‚‚â‚‰, Gâ‚ƒâ‚, Gâ‚ƒâ‚ƒ and Gâ‚ƒâ‚„:\n\nFor Gâ‚‚â‚‡:\n\nThe  fake degree  of Ï†â‚ƒ,â‚…'  (resp. Ï†â‚ƒ,â‚‚â‚€',  Ï†â‚ˆ,â‚‰â€³) has smaller degree that  of  Ï†â‚ƒ,â‚…â€³  (resp.  Ï†â‚ƒ,â‚‚â‚€â€³,  Ï†â‚ˆ,â‚‰'). The characters Ï†â‚…,â‚â‚…' and Ï†â‚…,â‚†' occur with multiplicity 1 in the induced from the trivial character of  the parabolic subgroup  of type Aâ‚‚  generated by the  first and third generator  (it is asserted  mistakenly in (Malle, 2000)  that Ï†â‚…,â‚†â€³ does not occur in this induced; it occurs with multiplicity 2).\n\nFor Gâ‚‚â‚‰:\n\nThe  character  Ï†â‚†,â‚â‚€â€´  is  the  exterior  square  of Ï†â‚„,â‚; its complex conjugate  is Ï†â‚†,â‚â‚€â—. The  character Ï†â‚â‚…,â‚„â€³ occurs  in Ï†â‚„,â‚âŠ—Ï†â‚„,â‚ƒ; the character  Ï†â‚â‚…,â‚â‚‚â€³  is  tensored  by  the  sign  character from Ï†â‚â‚…,â‚„â€³. Finally  Ï†â‚†,â‚â‚€' occurs in  the induced from  the trivial character of the standard parabolic subgroup of type Aâ‚ƒ generated by the first, second and fourth generators.\n\nFor Gâ‚ƒâ‚:\n\nThe  characters Ï†â‚â‚…,â‚ˆ', Ï†â‚â‚…,â‚‚â‚€' and Ï†â‚„â‚…,â‚ˆâ€³ occur in Ï†â‚„,â‚âŠ—Ï†â‚‚â‚€,â‚‡; the character   Ï†â‚‚â‚€,â‚â‚ƒ'  is  complex  conjugate  of  Ï†â‚‚â‚€,â‚‡;  the  character Ï†â‚„â‚…,â‚â‚‚'  is tensored by sign of Ï†â‚„â‚…,â‚ˆ'. The two terms of maximal degree of  the fakedegree of Ï†â‚ƒâ‚€,â‚â‚€' are  qâµâ°+qâ´â¶ while for Ï†â‚ƒâ‚€,â‚â‚€â€³ they are qâµâ°+2qâ´â¶.\n\nFor Gâ‚ƒâ‚ƒ:\n\nThe two terms of maximal degree of the fakedegree of Ï†â‚â‚€,â‚ˆ' are qÂ²â¸+qÂ²â¶ while  for Ï†â‚â‚€,â‚ˆâ€³ they are qÂ²â¸+qÂ²â´. The  terms of maximal degree of the fakedegree   of  Ï†â‚„â‚€,â‚…'  are  qÂ³Â¹+qÂ²â¹   while  for  Ï†â‚„â‚€,â‚…â€³  they  are qÂ³Â¹+2qÂ²â¹.  The character  Ï†â‚â‚€,â‚â‚‡' is  tensored by  sign of Ï†â‚â‚€,â‚ˆ' and Ï†â‚„â‚€,â‚â‚„' is tensored by sign of Ï†â‚„â‚€,â‚…'.\n\nFor Gâ‚ƒâ‚„:\n\nThe  character Ï†â‚‚â‚€,â‚ƒâ‚ƒ' occurs in Ï†â‚†,â‚âŠ—Ï†â‚â‚…,â‚â‚„. The character Ï†â‚‡â‚€,â‚‰' is rational.  The character  Ï†â‚‡â‚€,â‚‰â€³ occurs  in Ï†â‚†,â‚âŠ—Ï†â‚â‚…,â‚â‚„.  The character Ï†â‚‡â‚€,â‚„â‚…'   is  rational.The   character  Ï†â‚‡â‚€,â‚„â‚…â€³   is  tensored  by  the determinant  character of  Ï†â‚‡â‚€,â‚‰â€³. The  character Ï†â‚…â‚†â‚€,â‚â‚ˆ' is rational. The character Ï†â‚…â‚†â‚€,â‚â‚ˆâ€´ occurs in Ï†â‚†,â‚âŠ—Ï†â‚ƒâ‚ƒâ‚†,â‚â‚‡. The character Ï†â‚‚â‚ˆâ‚€,â‚â‚‚' occurs    in   Ï†â‚†,â‚âŠ—Ï†â‚ƒâ‚ƒâ‚†,â‚â‚‡.   The   character   Ï†â‚‚â‚ˆâ‚€,â‚ƒâ‚€â€³   occurs   in Ï†â‚†,â‚âŠ—Ï†â‚ƒâ‚ƒâ‚†,â‚â‚‡.  The  character  Ï†â‚…â‚„â‚€,â‚‚â‚'  occurs  in Ï†â‚†,â‚âŠ—Ï†â‚â‚€â‚…,â‚‚â‚€. The character  Ï†â‚â‚€â‚…,â‚ˆ' is  complex conjugate  of Ï†â‚â‚€â‚…,â‚„,  and Ï†â‚ˆâ‚„â‚€,â‚â‚ƒ' is complex  conjugate  of  Ï†â‚ˆâ‚„â‚€,â‚â‚.  The  character  Ï†â‚ˆâ‚„â‚€,â‚‚â‚ƒ'  is  complex conjugate  of  Ï†â‚ˆâ‚„â‚€,â‚â‚‰.  Finally  Ï†â‚â‚‚â‚€,â‚‚â‚'  occurs  in induced from the trivial character of the standard parabolic subgroup of type Aâ‚… generated by the generators of Gâ‚ƒâ‚„ with the third one omitted.\n\nFor  the groups Gâ‚… and Gâ‚‡ we  adopt the following conventions. For Gâ‚… they are compatible with those of (Malle and Rouquier, 2003) and (BrouÃ© et al., 2014).\n\nFor Gâ‚…:\n\nWe  let W=complex_reflection_group(5),  so the  generators are  W(1) and W(2).\n\nThe  character Ï†â‚,â‚„' (resp. Ï†â‚,â‚â‚‚', Ï†â‚‚,â‚ƒ') takes the value 1 (resp. Î¶â‚ƒ,  -Î¶â‚ƒ)  on  W(1).  The  character  Ï†â‚,â‚ˆâ€³ is complex conjugate to Ï†â‚,â‚â‚†,  and the character  Ï†â‚,â‚ˆ' is complex  conjugate to Ï†â‚,â‚„' . The character  Ï†â‚‚,â‚…â€³ is complex conjugate to  Ï†â‚‚,â‚; Ï†â‚‚,â‚…' takes the value -1 on W(1). The character Ï†â‚‚,â‚‡' is complex conjugate to Ï†â‚‚,â‚…'.\n\nFor Gâ‚‡:\n\nWe  let W=complex_reflection_group(7),  so the  generators are W(1), W(2) and W(3).\n\nThe  characters  Ï†â‚,â‚„'  and  Ï†â‚,â‚â‚€'  take  the value 1 on W(2). The character  Ï†â‚,â‚ˆâ€³ is complex  conjugate to Ï†â‚,â‚â‚†  and Ï†â‚,â‚ˆ' is complex conjugate  to Ï†â‚,â‚„'. The characters Ï†â‚,â‚â‚‚'  and Ï†â‚,â‚â‚ˆ' take the value Î¶â‚ƒ  on W(2). The character Ï†â‚,â‚â‚„â€³ is complex conjugate to Ï†â‚,â‚‚â‚‚ and Ï†â‚,â‚â‚„'  is complex conjugate to Ï†â‚,â‚â‚€'. The character Ï†â‚‚,â‚ƒ' takes the value  -Î¶â‚ƒ on  W(2) and  Ï†â‚‚,â‚â‚ƒ' takes  the value  -1 on W(2). The characters  Ï†â‚‚,â‚â‚â€³, Ï†â‚‚,â‚…â€³, Ï†â‚‚,â‚‡â€´ and  Ï†â‚‚,â‚ are Galois conjugate, as well  as  the  characters  Ï†â‚‚,â‚‡',  Ï†â‚‚,â‚â‚ƒ',  Ï†â‚‚,â‚â‚'  and  Ï†â‚‚,â‚…'. The character  Ï†â‚‚,â‚‰' is complex  conjugate to Ï†â‚‚,â‚â‚…  and Ï†â‚‚,â‚‰â€´ is complex conjugate to Ï†â‚‚,â‚ƒ'.\n\nFinally,  for the remaining groups Gâ‚†, Gâ‚ˆ  to Gâ‚â‚, Gâ‚â‚ƒ to Gâ‚‚â‚, Gâ‚‚â‚…, Gâ‚‚â‚†,  Gâ‚ƒâ‚‚ and Gâ‚ƒâ‚ƒ there are only  pairs of characters with same value (d,b).  We give labels uniformly to these characters by applying in order the following rules :\n\nIf the two characters have  different fake degrees, label Ï†_{d,b}' the  one  whose  fake  degree  is  minimal  for  the  lexicographic  order of  polynomials (starting with the highest term).\nFor the not yet labeled pairs, if only one of the two characters has the  property   that  in  its   Galois  orbit  at   least  one  character  is  distinguished by its (d,b)-invariant, label it Ï†_{d,b}'.\nFor the not yet labeled pairs,  if the minimum of the (d,b)-value (for  the  lexicographic  order  (d,b))  in  the  Galois  orbits  of the two  character  is different, label Ï†_{d,b}' the character with the minimal  minimum.\nWe define now a new invariant t for a character Ï†: consider all the  pairs of irreducible characters Ï‡ and Ïˆ uniquely determined by their  (d,b)-invariant such that Ï† occurs with non-zero multiplicity m in  Ï‡âŠ—Ïˆ.  We define  t(Ï†) to  be the  minimal (for  lexicographic order)  possible list (d(Ï‡),b(Ï‡),d(Ïˆ),b(Ïˆ),m).\n\nFor  the not  yet labeled  pairs, if  the t-invariants are different, label Ï†_{d,b}' the character with the minimal t-invariant.\n\nAfter  applying  the  last  rule  all  the  pairs  will be labelled for the considered  groups. The labelling obtained  is compatible for Gâ‚‚â‚…, Gâ‚‚â‚†, Gâ‚ƒâ‚‚  and  Gâ‚ƒâ‚ƒ  with  that  of  (Malle, 2000)  and  for  Gâ‚ˆ with that described in (Malle and Rouquier, 2003).\n\nWe  should  emphasize  that  for  all  groups  with  a  few exceptions, the parameters  for characters do  not depend on  any non-canonical choice. The exceptions  are G(de,e,n) with e>1, and Gâ‚…, Gâ‚‡, Gâ‚‚â‚‡, Gâ‚‚â‚ˆ, Gâ‚‚â‚‰ and  Gâ‚ƒâ‚„, groups  which admit  outer automorphisms  preserving the set of reflections,  so choices  of a  particular value  on a particular generator must be made for characters which are not invariant by these automorphisms.\n\nLabels  for the classes. \n\nFor  the exceptional complex reflection groups,  the labels for the classes represent  the decomposition of a representative  of the class as a product of  generators,  with  the  additional  conventions that z represents the generator  of the  center and  for well-generated  groups c  represents a Coxeter element (a product of the generators which is a regular element for the highest reflection degree).\n\n\n\n\n\n","category":"module"},{"location":"chars/#Chevie.Chars.CharTable","page":"Classes/characters of reflection groups","title":"Chevie.Chars.CharTable","text":"CharTable is a structure to hold character tables of groups and Hecke  algebras\n\n\n\n\n\n","category":"type"},{"location":"chars/#Chevie.Chars.decompose-Tuple{CharTable, AbstractVector}","page":"Classes/characters of reflection groups","title":"Chevie.Chars.decompose","text":"decompose(ct::CharTable,c::Vector;exact=true)\n\ndecompose  class function c (given by its values on conjugacy classes) on irreducible  characters as  given by  CharTable ct.  By default  c is expected to be a virtual character so the result will be an integer vector. If  c is not a virtual character  give the keyword exact=false to get a correct result.\n\njulia> ct=CharTable(coxsym(4));\n\njulia> decompose(ct,ct.irr[2,:].*ct.irr[2,:])\n5-element Vector{Int64}:\n 0\n 1\n 1\n 1\n 1\n\n\n\n\n\n","category":"method"},{"location":"chars/#Chevie.Chars.scalar_product-Tuple{CharTable, AbstractVector, AbstractVector}","page":"Classes/characters of reflection groups","title":"Chevie.Chars.scalar_product","text":"scalar_product(ct::CharTable,Ï†â‚,Ï†â‚‚;exact=true)\n\nscalar  product  of  the  class  functions  Ï†â‚  and Ï†â‚‚ according to the character  table ct. By default Ï†â‚ and  Ï†â‚‚ are expected to be virtual characters  so the  result will  be an  integer. If  one of  them is  not a virtual character give the keyword exact=false to get a correct result.\n\njulia> ct=CharTable(coxsym(4));\n\njulia> scalar_product(ct,3*ct.irr[2,:],ct.irr[2,:])\n3\n\n\n\n\n\n","category":"method"},{"location":"chars/#Chevie.Chars.on_chars","page":"Classes/characters of reflection groups","title":"Chevie.Chars.on_chars","text":"on_chars(G,aut)\n\naut  is an automorphism of  the group G (for  a permutation group, this could  be  given  as  a  permutation  normalizing  G).  The result is the permutation of the indices of the irreducible characters induced by aut.\n\njulia> WF=rootdatum(\"3D4\")\nÂ³Dâ‚„\n\njulia> on_chars(Group(WF),WF.phi)\n(1,2,7)(8,9,12)\n\n\n\n\n\n","category":"function"},{"location":"chars/#Chevie.Chars.charinfo","page":"Classes/characters of reflection groups","title":"Chevie.Chars.charinfo","text":"charinfo(W)\n\nreturns   information  about  the  irreducible  characters  of  the  finite reflection group or Spets W. The result is an object with various entries describing  properties of  the irreducible  characters of  W. This object prints  at the  Repl or  in Pluto  or Jupyter  as a table synthesizing most information.\n\nA  field  not  printed  is  .charparams:  it  contains parameters for the irreducible  characters.  A  parameter  is  a  list  with one item for each irreducible  component of W (as given  by refltype). For an irreducible W see the explanation in Chars for what are the parameters.\n\njulia> charinfo(coxgroup(:G,2)).charparams\n6-element Vector{Vector{Vector{Int64}}}:\n [[1, 0]]\n [[1, 6]]\n [[1, 3, 1]]\n [[1, 3, 2]]\n [[2, 1]]\n [[2, 2]]\n\njulia> charinfo(coxgroup(:G,2))\nâ”Œâ”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚n0â”‚ name ext b B a A spaltenstein lusztig              symbolâ”‚\nâ”œâ”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚1 â”‚ Ï†â‚â€šâ‚€  Id 0 0 0 0            1       1       (0,0,0,0,0,2)â”‚\nâ”‚2 â”‚ Ï†â‚â€šâ‚† det 6 6 6 6            Îµ       Îµ (01,01,01,01,01,12)â”‚\nâ”‚3 â”‚Ï†â€²â‚â€šâ‚ƒ     3 3 1 5           Îµâ‚—      Îµâ€²            (0,0,1+)â”‚\nâ”‚4 â”‚Ï†â€³â‚â€šâ‚ƒ     3 3 1 5          Îµ_c      Îµâ€³            (0,0,1-)â”‚\nâ”‚5 â”‚ Ï†â‚‚â€šâ‚  Î›Â¹ 1 5 1 5           Î¸â€²      Î¸â€²       (0,0,0,0,1,1)â”‚\nâ”‚6 â”‚ Ï†â‚‚â€šâ‚‚     2 4 1 5           Î¸â€³      Î¸â€³       (0,0,0,1,0,1)â”‚\nâ””â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nIn  the table printed  at the Repl,  the columns reflect  various fields of charinfo.  The  column  name  reflects  the  field .charnames, a name computed  from .charparams. This  is the same  as charnames(io,W) where here io being the Repl has the property :limit true.\n\nThe   column   ext   shows   the   exterior   powers  of  the  reflection representation.  It corresponds  to the  field .extrefl  which is present only  if W  is irreducible.  Otherwise, only  two items  are shown in the column:  Id corresponds to the field  .positionId and shows the trivial character.  det  corresponds  to  the  field .positionDet and shows the determinant  character (for Coxeter groups the sign character). When W is irreducible,  the characters marked  Î›â± are the  i-th exterior power of the  reflection  representation.  They  are  irreducible  by  a  theorem of Steinberg.\n\nThe  column  b  shows  the  field  .b  listing  for  each character the valuation  of the fake degree, and the column B shows the field .B, the degree of the fake degree.\n\nThe  columns a and  A only appear  for Spetsial groups. They correspond then  to the fields  .a and .A,  and contain respectively the valuation and the degree of the generic degree of the character (in the one-parameter Hecke algebra hecke(W,Pol()) for W).\n\nFor  irreducible  groups,  the  table  shows  sometimes additional columns, corresponding to a field of the same name.\n\nfor  Fâ‚„,  the  column  kondo  gives  the  labeling of the characters in (Kondo, 1965). The columns spaltenstein and lusztig show variants used in (Spaltenstein, 1985) and (Lusztig, 1985; (4.10)).\n\nfor Eâ‚†, Eâ‚‡, Eâ‚ˆ the column frame gives the labeling of the characters in (Frame, 1951; Frame, 1970), also used in (Lusztig, 1985; (4.11) to (4.13)).\n\nfor  Gâ‚‚ the  column spaltenstein  gives the  labeling of the characters used  by (Spaltenstein, 1985) and the column  lusztig shows a variant used in (Lusztig, 1985).\n\nfor  Hâ‚ƒ and Hâ‚„ the  column gp  gives the  labeling of the characters used  in (Geck and Pfeiffer, 2000).\n\nfor G(de,e,2) even e and d>1, the column malle gives the parameters for the characters used in (Malle, 1994).\n\nIf  W  is  irreducible  spetsial  and  imprimitive,  the  column symbol (corresponding  to the field  .charSymbols) shows the  symbol attached to the corresponding unipotent caracter.\n\nIf  W  isa  Spets,  the  column  restr.  (corresponding  to  the  field .charRestrictions)  gives  the  index  of  the corresponding character of Group(W).\n\nFinally,  the  field  .hgal  contains  the  permutation of the characters resulting  from a Galois  action on the  characters of H=hecke(W,Pol()^e) where  e is the order of  the center of W. H  splits by taking v an e-th root of Pol(), and .hgal records the permutation effected by the Galois action v->E(e)*v (charinfo does not have the key :hgal if this permutation   is  trivial).  .hgal*conj,  where  conj  is  the  complex conjugaison, is the Opdam involution.\n\njulia> charinfo(complex_reflection_group(24))\nâ”Œâ”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚n0â”‚ name ext  b  B  a  Aâ”‚\nâ”œâ”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚1 â”‚ Ï†â‚â€šâ‚€  Id  0  0  0  0â”‚\nâ”‚2 â”‚Ï†â‚â€šâ‚‚â‚ det 21 21 21 21â”‚\nâ”‚3 â”‚ Ï†â‚ƒâ€šâ‚ˆ      8 18  8 20â”‚\nâ”‚4 â”‚ Ï†â‚ƒâ€šâ‚  Î›Â¹  1 11  1 13â”‚\nâ”‚5 â”‚Ï†â‚ƒâ€šâ‚â‚€  Î›Â² 10 20  8 20â”‚\nâ”‚6 â”‚ Ï†â‚ƒâ€šâ‚ƒ      3 13  1 13â”‚\nâ”‚7 â”‚ Ï†â‚†â€šâ‚‚      2 12  1 13â”‚\nâ”‚8 â”‚ Ï†â‚†â€šâ‚‰      9 19  8 20â”‚\nâ”‚9 â”‚ Ï†â‚‡â€šâ‚†      6 18  6 18â”‚\nâ”‚10â”‚ Ï†â‚‡â€šâ‚ƒ      3 15  3 15â”‚\nâ”‚11â”‚ Ï†â‚ˆâ€šâ‚„      4 16  4 17â”‚\nâ”‚12â”‚ Ï†â‚ˆâ€šâ‚…      5 17  4 17â”‚\nâ””â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\nhgal=(11,12)\n\n\n\n\n\n","category":"function"},{"location":"chars/#Chevie.Chars.charnames-Tuple{IO, Union{Coset, Group}}","page":"Classes/characters of reflection groups","title":"Chevie.Chars.charnames","text":"charnames(W;options...) or charnames(io::IO,W)\n\nreturns  the list of character names for  the reflection group or Spets W (W  could also  be a  CharTable or  CharInfo). The  options may imply alternative  names in certain cases, or  a different formatting of names in general.  They are specified by IO attributes  if giving an IO as first argument.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> charnames(W;limit=true)\n6-element Vector{String}:\n \"Ï†â‚â€šâ‚€\"\n \"Ï†â‚â€šâ‚†\"\n \"Ï†â€²â‚â€šâ‚ƒ\"\n \"Ï†â€³â‚â€šâ‚ƒ\"\n \"Ï†â‚‚â€šâ‚\"\n \"Ï†â‚‚â€šâ‚‚\"\n\njulia> charnames(W;TeX=true)\n6-element Vector{String}:\n \"\\phi_{1,0}\"\n \"\\phi_{1,6}\"\n \"\\phi_{1,3}'\"\n \"\\phi_{1,3}''\"\n \"\\phi_{2,1}\"\n \"\\phi_{2,2}\"\n\njulia> charnames(W;spaltenstein=true,limit=true)\n6-element Vector{String}:\n \"1\"\n \"Îµ\"\n \"Îµâ‚—\"\n \"Îµ_c\"\n \"Î¸â€²\"\n \"Î¸â€³\"\n\njulia> charnames(W;spaltenstein=true,TeX=true)\n6-element Vector{String}:\n \"1\"\n \"\\varepsilon\"\n \"\\varepsilon_l\"\n \"\\varepsilon_c\"\n \"\\theta'\"\n \"\\theta''\"\n\nThe  last two commands  show the character  names used in (Spaltenstein, 1985). Other  keywords  available  are  frame,  kondo,  malle,  gp, lusztig, see charinfo for a description.\n\n\n\n\n\n","category":"method"},{"location":"chars/#Chevie.Chars.classnames","page":"Classes/characters of reflection groups","title":"Chevie.Chars.classnames","text":"classnames(W;options...) or classnames(io::IO,W)\n\nreturns  the list of class names for the reflection group W (W may also be  a CharTable or  the result of  classinfo). The optional options are IOContext  attributes which can give alternative names in certain cases, or a different formatting of names in general. They can be specified by giving an IO as argument.\n\njulia> classnames(coxgroup(:G,2),TeX=true)\n6-element Vector{String}:\n \"A_0\"\n \"\\tilde A_1\"\n \"A_1\"\n \"G_2\"\n \"A_2\"\n \"A_1+\\tilde A_1\"\n\n\n\n\n\n","category":"function"},{"location":"chars/#Chevie.Chars.classinfo","page":"Classes/characters of reflection groups","title":"Chevie.Chars.classinfo","text":"classinfo(W)\n\nreturns  information about the  conjugacy classes of  the finite reflection group or Spets W. The result is an object with various entries describing properties  of the conjugacy classes of W. This object prints at the Repl or in Pluto or Jupyter as a table synthesizing most information.\n\nA field not shown in the table is .classparams, containing parameters for the  conjugacy classes. Each parameter  is a vector which  has one item for each  irreducible  component  of  W.  For  what are the parameters for an irreducible W, see the description for each type in Chars.\n\njulia> classinfo(coxgroup(:A,2))\nâ”Œâ”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚n0â”‚name length order wordâ”‚\nâ”œâ”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚1 â”‚ 111      1     1    .â”‚\nâ”‚2 â”‚  21      3     2    1â”‚\nâ”‚3 â”‚   3      2     3   12â”‚\nâ””â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nThe table contains the columns:\n\nname, corresponding to the field .classnames:  strings describing the conjugacy classes, made out of the information in :classparams.\nlength, corresponding to the field .classes, is the number of elements in the conjugacy class.\norder, corresponding to the field .orders, is the order of elements in the conjugacy class.\nword, corresponding to the field .classtext, describes a word in the  generators for the  representatives of each  conjugacy class. Each word is a list of integers where the generator W(i) is represented by the  integer  i.  For  finite  Coxeter  groups,  it  is  the  same as word.(Ref(W),classreps(W)),   and  each  such  representative  is  of minimal  length in its conjugacy class and  is a \"very good\" element in the sense of (Geck and Michel, 1997).\n\n\n\n\n\n","category":"function"},{"location":"chars/#Chevie.Symbols.fakedegree-Tuple{Any, Any, Any}","page":"Classes/characters of reflection groups","title":"Chevie.Symbols.fakedegree","text":"fakedegree(W, Ï†, q=Pol())\n\nreturns the fake degree (see fakedegrees for a definition) of the character  of parameter  Ï† (see  charinfo(W).charparams) of the reflection group W, evaluated at q .\n\njulia> fakedegree(coxgroup(:A,2),[[2,1]],Pol(:q))\nPol{Int64}: qÂ²+q\n\n\n\n\n\n","category":"method"},{"location":"chars/#Chevie.Chars.fakedegrees","page":"Classes/characters of reflection groups","title":"Chevie.Chars.fakedegrees","text":"fakedegrees(W, q=Pol())\n\nreturns  a list holding the fake degrees of the reflection group W on the vector  space V, evaluated at q. These are the graded multiplicities of the  irreducible characters of W in the quotient SV/I where SV is the symmetric  algebra of V and I is the ideal generated by the homogeneous invariants  of  positive  degree  in  SV.  The  ordering  of  the  result corresponds to the ordering of the characters in charinfo(W).\n\njulia> fakedegrees(coxgroup(:A,2),Pol(:q))\n3-element Vector{Pol{Int64}}:\n qÂ³\n qÂ²+q\n 1\n\n\n\n\n\n","category":"function"},{"location":"chars/#Chevie.Chars.representation-Tuple{Union{Spets, FiniteCoxeterGroup, PermRootGroup}, Integer}","page":"Classes/characters of reflection groups","title":"Chevie.Chars.representation","text":"representation(W,i)\n\nreturns,   for  the  i-th  irreducible   representation  of  the  complex reflection  group or Spets W, a list of matrices images of the generating reflections  of W in a model of the representation (for Spets, the result is  a NamedTuple with fields gens,  a representation of Group(W), and F,  the matrix for W.phi in the representation). This function is based on  the  classification,  and  is  not  yet fully implemented for Gâ‚ƒâ‚„; 60 representations   are  missing  out   of  169,  that   is,  about  half  of representations  of  dimension  â‰¥140.  nothing  is returned for a missing representation.\n\njulia> representation(complex_reflection_group(24),3)\n3-element Vector{Matrix{Cyc{Int64}}}:\n [1 0 0; -1 -1 0; -1 0 -1]\n [-1 0 -1; 0 -1 (1-âˆš-7)/2; 0 0 1]\n [-1 -1 0; 0 1 0; 0 (1+âˆš-7)/2 -1]\n\n\n\n\n\n","category":"method"},{"location":"chars/#Chevie.Chars.representations-Tuple{Union{Spets, FiniteCoxeterGroup, PermRootGroup}}","page":"Classes/characters of reflection groups","title":"Chevie.Chars.representations","text":"representations(W)\n\nreturns  the list  of representations  of the  complex reflection  group or Spets W (see representation).\n\njulia> representations(coxgroup(:B,2))\n5-element Vector{Vector{Matrix{Int64}}}:\n [[1;;], [-1;;]]\n [[1 0; -1 -1], [1 2; 0 -1]]\n [[-1;;], [-1;;]]\n [[1;;], [1;;]]\n [[-1;;], [1;;]]\n\n\n\n\n\n","category":"method"},{"location":"chars/#Chevie.Chars.induction_table","page":"Classes/characters of reflection groups","title":"Chevie.Chars.induction_table","text":"induction_table(u,g)\n\nreturns   an  object  describing  the   decomposition  of  the  irreducible characters  of the subgroup  u induced to  the group g.  At the repl or IJulia  or Pluto,  a table  is displayed  where the  rows correspond to the characters  of the parent group, and the  columns to those of the subgroup. The  returned  object  has  a  field  scalar  which  is  a  Matrix{Int} containing  the  induction  table,  and  the  other fields contain labeling information taken from the character tables of u and g when it exists.\n\njulia> g=Group([Perm(1,2),Perm(2,3),Perm(3,4)])\nGroup([(1,2),(2,3),(3,4)])\n\njulia> u=Group( [ Perm(1,2), Perm(3,4) ])\nGroup([(1,2),(3,4)])\n\njulia> induction_table(u,g)  #     needs \"using GAP\"\nInduction table from Group((1,2),(3,4)) to Group((1,2),(2,3),(3,4))\nâ”Œâ”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚   â”‚X.1 X.2 X.3 X.4â”‚\nâ”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚X.1â”‚  .   1   .   .â”‚\nâ”‚X.2â”‚  .   1   1   1â”‚\nâ”‚X.3â”‚  1   1   .   .â”‚\nâ”‚X.4â”‚  1   .   1   1â”‚\nâ”‚X.5â”‚  1   .   .   .â”‚\nâ””â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\njulia> g=coxgroup(:G,2)\nGâ‚‚\n\njulia> u=reflection_subgroup(g,[1,6])\nGâ‚‚â‚â‚â‚…â‚=Aâ‚‚\n\njulia> t=induction_table(u,g)\nInduction table from Gâ‚‚â‚â‚â‚…â‚=Aâ‚‚ to Gâ‚‚\nâ”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚     â”‚111 21 3â”‚\nâ”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚Ï†â‚â€šâ‚€ â”‚  .  . 1â”‚\nâ”‚Ï†â‚â€šâ‚† â”‚  1  . .â”‚\nâ”‚Ï†â€²â‚â€šâ‚ƒâ”‚  1  . .â”‚\nâ”‚Ï†â€³â‚â€šâ‚ƒâ”‚  .  . 1â”‚\nâ”‚Ï†â‚‚â€šâ‚ â”‚  .  1 .â”‚\nâ”‚Ï†â‚‚â€šâ‚‚ â”‚  .  1 .â”‚\nâ””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nIO attributes can be transmitted to the table format method\n\njulia> xdisplay(t;rows=[5],cols=[3,2])\nInduction table from Gâ‚‚â‚â‚â‚…â‚=Aâ‚‚ to Gâ‚‚\nâ”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”\nâ”‚     â”‚3 21â”‚\nâ”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤\nâ”‚Ï†â‚‚â€šâ‚ â”‚.  1â”‚\nâ””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜\n\nIt is also possible to TeX induction tables with xdisplay(t;TeX=true).\n\ninduction_table also works for spets (reflection cosets).\n\n\n\n\n\n","category":"function"},{"location":"chars/#Chevie.Chars.j_induction_table","page":"Classes/characters of reflection groups","title":"Chevie.Chars.j_induction_table","text":"j_induction_table(H, W)\n\ncomputes  the decomposition  into irreducible  characters of the reflection group  W  of  the  j-induced  of  the  irreducible  characters  of  the reflection  subgroup  H.  The  j-induced  of  Ï†  is  the  sum  of the irreducible  components of the induced of  Ï† which have same b-function (see charinfo) as Ï†. What is returned is an InductionTable struct.\n\njulia> W=coxgroup(:D,4)\nDâ‚„\n\njulia> H=reflection_subgroup(W,[1,3])\nDâ‚„â‚â‚â‚ƒâ‚=Aâ‚‚Î¦â‚Â²\n\njulia> j_induction_table(H,W)\nj-induction table from Dâ‚„â‚â‚â‚ƒâ‚=Aâ‚‚Î¦â‚Â² to Dâ‚„\nâ”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚     â”‚111 21 3â”‚\nâ”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚11+  â”‚  .  . .â”‚\nâ”‚11-  â”‚  .  . .â”‚\nâ”‚1.111â”‚  .  . .â”‚\nâ”‚.1111â”‚  .  . .â”‚\nâ”‚11.2 â”‚  .  . .â”‚\nâ”‚1.21 â”‚  1  . .â”‚\nâ”‚.211 â”‚  .  . .â”‚\nâ”‚2+   â”‚  .  . .â”‚\nâ”‚2-   â”‚  .  . .â”‚\nâ”‚.22  â”‚  .  . .â”‚\nâ”‚1.3  â”‚  .  1 .â”‚\nâ”‚.31  â”‚  .  . .â”‚\nâ”‚.4   â”‚  .  . 1â”‚\nâ””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n\n\n\n\n","category":"function"},{"location":"chars/#Chevie.Chars.J_induction_table","page":"Classes/characters of reflection groups","title":"Chevie.Chars.J_induction_table","text":"J_induction_table(H, W)\n\ncomputes  the decomposition  into irreducible  characters of the reflection group  W  of  the  J-induced  of  the  irreducible  characters  of  the reflection  subgroup  H.  The  J-induced  of  Ï†  is  the  sum  of the irreducible  components of the induced of  Ï† which have same a-function (see charinfo) as Ï†. What is returned is an InductionTable struct.\n\njulia> W=coxgroup(:D,4)\nDâ‚„\n\njulia> H=reflection_subgroup(W,[1,3])\nDâ‚„â‚â‚â‚ƒâ‚=Aâ‚‚Î¦â‚Â²\n\njulia> J_induction_table(H,W)\nJ-induction table from Dâ‚„â‚â‚â‚ƒâ‚=Aâ‚‚Î¦â‚Â² to Dâ‚„\nâ”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚     â”‚111 21 3â”‚\nâ”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚11+  â”‚  .  . .â”‚\nâ”‚11-  â”‚  .  . .â”‚\nâ”‚1.111â”‚  .  . .â”‚\nâ”‚.1111â”‚  .  . .â”‚\nâ”‚11.2 â”‚  1  . .â”‚\nâ”‚1.21 â”‚  1  . .â”‚\nâ”‚.211 â”‚  .  . .â”‚\nâ”‚2+   â”‚  .  . .â”‚\nâ”‚2-   â”‚  .  . .â”‚\nâ”‚.22  â”‚  .  . .â”‚\nâ”‚1.3  â”‚  .  1 .â”‚\nâ”‚.31  â”‚  .  . .â”‚\nâ”‚.4   â”‚  .  . 1â”‚\nâ””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n\n\n\n\n","category":"function"},{"location":"chars/#Chevie.Chars.schur_functor","page":"Classes/characters of reflection groups","title":"Chevie.Chars.schur_functor","text":"schur_functor(mat,Î»)\n\nmat  should be  a square  matrix and  Î» a  partition. The result is the Schur  functor  of  the  matrix  mat  corresponding to partition Î»; for example,   if  Î»==[n]  it  returns  the   n-th  symmetric  power  and  if Î»==[1,1,1] it returns the 3rd exterior power. The current algorithm (from Littlewood)  is rather inefficient so it is  quite slow for partitions of n where n>6.\n\njulia> m=cartan(:A,3)\n3Ã—3 Matrix{Int64}:\n  2  -1   0\n -1   2  -1\n  0  -1   2\n\njulia> schur_functor(m,[2,2])\n6Ã—6 Matrix{Rational{Int64}}:\n   9   -6    4  3//2   -2    1\n -12   16  -16  -4      8   -4\n   4   -8   16   2     -8    4\n  12  -16   16  10    -16   12\n  -4    8  -16  -4     16  -12\n   1   -2    4  3//2   -6    9\n\n\n\n\n\nschur_functor(ct::CharTable,Ï†::AbstractVector,Î»)\n\nschur_functor(ct::CharTable,i::Integer,Î»)\n\nct  should be a character table for some group G. In the first form Ï† should  be a vector representing a character of G, and in the second form i  denotes the i-th  character Ï† of  G. Î» is  a partition of some integer  n, representing an irreducible character  of ğ”– â‚™. The function returns  the Schur functor Ï†[Î»] of Ï† defined by Î» . This is the character defined by the formula\n\nÏ†Î»(g)=_Î¼ Î»(Î¼)_k1nÏ†(gáµ)^nâ‚–(Î¼)\n\nwhere  Î¼ runs over the partitions of  n, representing the classes of ğ”– â‚™,  where Î»(Î¼) is the  value of the character  Î» at the class Î¼, and nâ‚–(Î¼) is the number of parts of Î¼ equal to k.\n\nParticular  examples are the exterior  powers, corresponding to Î»=1â¿, and the symmetric powers, corresponding Î»=n.\n\nct  should  have  .powermaps  containing  powermaps  for  at  least the prime divisors of the order of G.\n\n\n\n\n\n","category":"function"},{"location":"chars/#Chevie.Chars.detPerm","page":"Classes/characters of reflection groups","title":"Chevie.Chars.detPerm","text":"detPerm(W)\n\nreturn  the permutation of the characters of the reflection group W which is effected when tensoring by the determinant character (for Coxeter groups this is the sign character).\n\njulia> W=coxgroup(:D,4)\nDâ‚„\n\njulia> detPerm(W)\n(1,8)(2,9)(3,11)(4,13)(7,12)\n\n\n\n\n\n","category":"function"},{"location":"chars/#Chevie.Chars.conjPerm","page":"Classes/characters of reflection groups","title":"Chevie.Chars.conjPerm","text":"conjPerm(W)\n\nreturn  the permutation of the characters of the group W which is effected when taking the complex conjugate of the character table.\n\njulia> W=complex_reflection_group(4)\nGâ‚„\n\njulia> conjPerm(W)\n(2,3)(5,6)\n\n\n\n\n\n","category":"function"},{"location":"symbols/#Symbols","page":"Symbols","title":"Symbols","text":"Pages=[\"symbols.md\"]","category":"section"},{"location":"symbols/#Chevie.Symbols","page":"Symbols","title":"Chevie.Symbols","text":"The  combinatorial objects  in this  module are  partitions, Î²-sets and symbols.\n\nA  partition is a non-increasing  list of nonnegative integers pâ‚â‰¥pâ‚‚â‰¥â€¦pâ‚™, represented as a Vector{Int}, which is normalized if it has no trailing zeroes. The functions for partitions in this module are\n\nPartition(pâ‚,â€¦,pâ‚™) or Partition([pâ‚,â€¦,pâ‚™]) makes a Partition object from the list pâ‚,â€¦,pâ‚™.\ncore(Î¼::Partition,e) which returns the e-core of Î¼.\nquotient(Î¼::Partition,e) which returns the e-quotient of Î¼.\npartition_core_quotient(Î¼::Partition,q) which recovers a partition given its e-core Î¼ and its e-quotient q.\n\nA  Î²-set is a strictly increasing Vector of nonnegative integers, up to shift,  the  equivalence  relation  generated  by the elementary shifts [bâ‚,â€¦,bâ‚™]âˆ¼[0,1+bâ‚,â€¦,1+bâ‚™].  An equivalence  class has  exactly one member which does not contain 0: it is called a normalized Î²-set.\n\nTo  a  normalized  partition  pâ‚â‰¥pâ‚‚â‰¥â€¦pâ‚™>0  is  associated  a Î²-set, whose normalized  representative is pâ‚™,pâ‚™â‚‹â‚+1,â€¦,pâ‚+n-1. A mnemonic is that this is  the areas of  the hooks in  the Young diagram  going up along the first column.  Conversely, to each Î²-set bâ‚<bâ‚‚<â€¦<bâ‚™ is associated the partition bâ‚™-n+1â‰¥â€¦â‰¥bâ‚‚-1â‰¥bâ‚,  which may have some trailing  zeros if starting from a non-normalized representative.\n\nThe functions for Î²sets in this module are\n\nÎ²set which constructs a normalized Î²set from a partition.\nshiftÎ² which shifts a Î²set\npartÎ² which constructs a partition from a Î²set\n\nAs  a generalisation of Î²-sets, (Lusztig, 1977) has introduced 2-symbols and   more  general  e-symbols  were  introduced  in  (Malle, 1995).  An e-symbol   is  a  vector  S=[Sâ‚,â€¦,Sâ‚‘]   of  Î²-sets,  taken  modulo  the equivalence  relation generated by the simultaneous elementary shift of all Î²-sets,  and by  cyclic permutations  of S;  in the particular case where e=2,  S  is  thus  an  unordered  pair  of Î²-sets. S is a normalized symbol  if  0  is  not  in  the  intersection  of  the  Sáµ¢; equivalent normalized  symbols are equivalent by  cyclic permutation. The content of S  is mod(c,e)  where c=sum(length.(S));  it is  an invariant  of the symbol, as well as the rank, defined for an e-symbol as sum(sum,S)-div((c-1)*(c-e+1),2*e).  Invariant  by  shift  but  not cyclic permutation is the shape s.-minimum(s) where s=length.(S).\n\nWhen e=2 we choose a normalized representative of a symbol [Sâ‚,Sâ‚‚] such that length(Sâ‚)â‰¥length(Sâ‚‚), so the shape is [d,0] for some dâ‰¥0 called the defect of the symbol; the content is equal to mod(d,2). When d==0 we  choose a normalized representative  such that Pâ‚â‰¤Pâ‚‚ lexicographically where Pâ‚,Pâ‚‚ are the partitions associated to Sâ‚,Sâ‚‚. For e>2 we choose the  reduced representative, which  means a symbol  â‰¥ to all its cyclic permutations,  where a symbol  is < another  if the shape length.(S) is lexicographically smaller and, if the shapes are the same, if the vector of Î²sets is lexicographically greater.\n\nPartitions  and  pairs  of  partitions  parametrize  characters of the Weyl groups  of classical types, and tuples of partitions parametrize characters of  imprimitive complex reflection  groups. 2-Symbols parametrize unipotent characters  of  classical  Chevalley  groups,  and more general e-symbols parametrize   unipotent  characters  of   spetses  associated  to  spetsial imprimitive complex reflection groups. The rank of a symbol is equal to the semi-simple rank of the corresponding Chevalley group or Spets.\n\nSymbols of rank n and defect 0 parametrize characters of the Weyl group W(Dâ‚™),  and  symbols  of  rank  n  and  defectâ‰¡0 (mod 4) parameterize unipotent  characters of SOâ‚‚â‚™; symbols of rank n and defectâ‰¡2 (mod 4) parameterize  unipotent  characters  of  SOâ»â‚‚â‚™.  Symbols  of rank n and defect 1 parametrize characters of the Weyl group W(Bâ‚™), and symbols of rank  n  and  odd  defect  parametrize  unipotent characters of Spâ‚‚â‚™ or SOâ‚‚â‚™â‚Šâ‚.\n\nTo parametrize unipotent characters of spetses we need another statistic on symbols, the Malle-defect defined in (Malle, 1995) as mod(binomial(e,2)*div(sum(length.(S)),e)-dot(O:e-1,length.(S)),e).  It is invariant  under  shift;  it  is  invariant  under circular permutation for symbols  of content O but not for  symbols of content 1; for these only one circular permutation has Malle-defect 0.\n\ne-symbols  of rank n and  content 1 parameterize unipotent characters of the spets G(e,1,n). The principal series (in bijection with characters of   the  reflection  group)  is  parametrized  by  symbols  whose  reduced representative has shape [1,0,â€¦,0].\n\nUnipotent   characters  of   the  spets   G(e,e,n)  are  parametrized  by e-symbols  of  content  0  and  Malle-defect  0.  The symbols for the principal series characters have shape [0,â€¦,0].\n\nUnipotent  characters of the twisted  spets áµ—G(e,e,n) are parametrized by e-symbols of rank n, content 0 and Malle-defect t.\n\nIn  the above parametrizations, periodic symbols,  that is symbols S such that  the  sequence  Sâ‚,â€¦,Sâ‚™  is  a  repetition  k  times  of a shorter sequence,  must be  repeated k  times. To  distinguish the k copies, an additional parameter, a k-th root of unity, is attached to the symbol. As an example, here are the symbols for Gâ‚ƒ,â‚ƒ,â‚ƒ:\n\njulia> symbols(3,3,0)\n12-element Vector{CharSymbol}:\n (1+)\n (1Î¶â‚ƒ)\n (1Î¶â‚ƒÂ²)\n (01,12,02)\n (01,02,12)\n (012,012,123)\n (0,1,2)\n (0,2,1)\n (01,01,13)\n (0,0,3)\n (012,,)\n (012,012,)\n\nwhen  the symbol has  a period, only  the period is  shown, followed by the root  of unity (where  1 is shown  as + and  -1 is shown  as -.\n\nThe functions for symbols in this module are\n\nCharSymbol, which constructs a symbol\nSymbol_partition_tuple which constructs a symbol of a given shape from a partition tuple\nrank which computes the rank of a symbol\ndefect which returns the defect  of a 2-symbol\nMalledefect which returns the Malle-defect of a symbol\ncore(l,Î¶â‚‘Ê²) which returns the (l,Î¶â‚‘Ê²)-core of a symbol\nfakedegree, degree_feg, valuation_feg return the fake degree (resp. its degree and valuation) of the unipotent character parametrized by a symbol\ngendeg, degree_gendeg, valuation_gendeg return the generic degree (resp. its degree and valuation) of the unipotent character parametrized by a symbol\nsymbols returns the list of symbols of a given length, rank and content.\n\nFinally,  in this  module we  also provides  a function XSP which returns  the \"symbols\"  (pairs of  vectors of  increasing positive integers satisfying  some  conditions)  XÌƒ^Ï-ss_nd  defined by Lusztig and Spaltenstein  which  parametrize  local  systems  on  unipotent classes for classical reductive groups.\n\n\n\n\n\n","category":"module"},{"location":"symbols/#Chevie.Symbols.Partition","page":"Symbols","title":"Chevie.Symbols.Partition","text":"A  Partition object  is formed  from a  non-increasing of integers ending with  a  number>0.  The  following  two  forms  are equivalent for making a Partition object:\n\njulia> Partition([2,1,1])\nPartition: 211\n\njulia> p=Partition(2,1,1)\nPartition: 211\n\njulia> length(p) # how many parts\n3\n\njulia> size(p) # the sum of the parts\n4\n\nsome basic operations on partitions is the union and the conjugate partition\n\njulia> union(p,p)\nPartition: 221111\n\njulia> p'\nPartition: 31\n\nwe  get the i-th part by indexing with the convention that we get 0 for large i.\n\njulia> p[1]\n2\n\njulia> p[4]\n0\n\nThe partitions are ordered by size, and then lexicographically.\n\n\n\n\n\n","category":"type"},{"location":"symbols/#Chevie.Symbols.shiftÎ²","page":"Symbols","title":"Chevie.Symbols.shiftÎ²","text":"shiftÎ²( Î², n) shift the Î²-set Î² by n\n\njulia> shiftÎ²([2,3],2)\n4-element Vector{Int64}:\n 0\n 1\n 4\n 5\n\njulia> shiftÎ²([0,1,4,5],-2)\n2-element Vector{Int64}:\n 2\n 3\n\n\n\n\n\nshiftÎ²(Î²) returns the unique normalized representative of Î².\n\njulia> shiftÎ²([0,1,4,5])\n2-element Vector{Int64}:\n 2\n 3\n\n\n\n\n\n","category":"function"},{"location":"symbols/#Chevie.Symbols.Î²set","page":"Symbols","title":"Chevie.Symbols.Î²set","text":"Î²set(p) normalized Î²-set of partition p\n\njulia> Î²set([3,3,1])\n3-element Vector{Int64}:\n 1\n 4\n 5\n\n\n\n\n\n","category":"function"},{"location":"symbols/#Chevie.Symbols.partÎ²","page":"Symbols","title":"Chevie.Symbols.partÎ²","text":"partÎ²(Î²) partition defined by Î²-set Î²\n\njulia> partÎ²([0,4,5])\n2-element Vector{Int64}:\n 3\n 3\n\n\n\n\n\n","category":"function"},{"location":"symbols/#Chevie.Symbols.string_partition_tuple","page":"Symbols","title":"Chevie.Symbols.string_partition_tuple","text":"string_partition_tuple(tuple)\n\nconverts  the partition tuple tuple to  a string where the partitions are separated by a dot.\n\njulia> d=partition_tuples(3,2)\n10-element Vector{Vector{Vector{Int64}}}:\n [[1, 1, 1], []]\n [[1, 1], [1]]\n [[1], [1, 1]]\n [[], [1, 1, 1]]\n [[2, 1], []]\n [[1], [2]]\n [[2], [1]]\n [[], [2, 1]]\n [[3], []]\n [[], [3]]\n\njulia> string_partition_tuple.(d)\n10-element Vector{String}:\n \"111.\"\n \"11.1\"\n \"1.11\"\n \".111\"\n \"21.\"\n \"1.2\"\n \"2.1\"\n \".21\"\n \"3.\"\n \".3\"\n\n\n\n\n\n","category":"function"},{"location":"symbols/#Chevie.Symbols.quotient","page":"Symbols","title":"Chevie.Symbols.quotient","text":"quotient(Î¼::Partition,e) the e-quotient of the partition Î¼.\n\nThe  e-quotient is best described  in terms of Î²sets.  Divide the Î²set of Î¼  in e sets  Sâ‚€,â€¦,Sâ‚‘â‚‹â‚ according to  the congruence mod e. Replace Sáµ¢ by S'áµ¢={(x-i)/eâˆ£xâˆˆSáµ¢}. Then each S'áµ¢ can be interpreted in turn as the  Î²set  of  a  partition.  The  resulting e-tuple of partitions is the e-quotient of mu.\n\njulia> quotient(Partition(3,3,1),3)\n3-element Vector{Vector{Int64}}:\n []\n []\n [1]\n\n\n\n\n\n","category":"function"},{"location":"symbols/#Chevie.Symbols.CharSymbol","page":"Symbols","title":"Chevie.Symbols.CharSymbol","text":"CharSymbol(v::Vector{Vector{Int}},repeat::Int=1,no::Int=0)\n\nCharSymbol makes a vector of Î²sets into a symbol. If the vector of Î²sets has a period this is specified by giving a number repeats of repetitions and a number 0â‰¤no<repat.\n\njulia> CharSymbol([[1],Int[],[2]])\n(1,,2)\n\njulia> CharSymbol([[1],[1],[1]],3,2)\n(1Î¶â‚ƒÂ²)\n\n\n\n\n\n","category":"type"},{"location":"symbols/#Chevie.Symbols.rank-Tuple{CharSymbol}","page":"Symbols","title":"Chevie.Symbols.rank","text":"rank(S) rank of symbol S.\n\njulia> rank(CharSymbol([[1,5,6],[1,2]]))\n11\n\n\n\n\n\n","category":"method"},{"location":"symbols/#Chevie.Symbols.defect-Tuple{CharSymbol}","page":"Symbols","title":"Chevie.Symbols.defect","text":"defect(s::CharSymbol)\n\nFor an e-symbol [Sâ‚,Sâ‚‚,â€¦,Sâ‚‘] returns length(Sâ‚)-length(Sâ‚‚).\n\njulia> defect(CharSymbol([[1,5,6],[1,2]]))\n1\n\n\n\n\n\n","category":"method"},{"location":"symbols/#Chevie.Symbols.Malledefect","page":"Symbols","title":"Chevie.Symbols.Malledefect","text":"Malledefect(S::CharSymbol)\n\nMalle-defect of S. This is an invariant by shift but not in general under cyclic permutations.\n\n\n\n\n\n","category":"function"},{"location":"symbols/#Chevie.Symbols.core","page":"Symbols","title":"Chevie.Symbols.core","text":"core(Î¼::Partition,e) the  e-core of the partition Î¼.\n\nIt  is the partition left after removing recursively all possible e-hooks from the young diagram of Î¼.\n\njulia> core(Partition(3,3,1),3)\nPartition: 211\n\n\n\n\n\ncore(s::CharSymbol,l,j=0) the (l,Î¶â‚‘Ê²) core of the e-symbol s\n\nThis core is obtained by removing recursively all possible (l,Î¶â‚‘Ê²)-hooks. An  (l,Î¶â‚‘Ê²)-hook consists of,  assuming x occurs  in the i-th Î²set of s  and x-l does not occur in the mod1(i+j,e)-th Î²set of s, removing x from the i-th Î²-set and adding x-l to the mod1(i+j,e)-th Î²set.\n\n\n\n\n\n","category":"function"},{"location":"symbols/#Chevie.Symbols.partition_core_quotient","page":"Symbols","title":"Chevie.Symbols.partition_core_quotient","text":"partition_core_quotient(c::Partition,q) \n\ngiven a partition c and an e-tuple q of partitions, return a partition  p of e-core c and e-quotient q.\n\njulia> partition_core_quotient(Partition(2,1,1),[Int[],Int[],[1]])\nPartition: 331\n\n\n\n\n\n","category":"function"},{"location":"symbols/#Chevie.Symbols.Symbol_partition_tuple","page":"Symbols","title":"Chevie.Symbols.Symbol_partition_tuple","text":"Symbol_partition_tuple(p, s) symbol of shape s for partition tuple p.\n\nIn  the general case, s is a Vector{Int}  of same length as p and the i-th  element of the result is the Î²-set for páµ¢ shifted to be of length sáµ¢ (the minimal integer which makes this possible is added to s).\n\nWhen  s is  a positive  integer it  is interpreted  as [s,0,0,â€¦]  and a negative  integer is interpreted  as [0,-s,-s,â€¦] so  when p is a double partition  one gets the  symbol of defect  s associated to  p; as other uses  the  unipotent  symbol  for  a  character  of the principal series of G(e,1,r)   parameterized   by   an   e-tuple   p   of  partitions  is Symbol_partition_tuple(p,1) and for G(e,e,r) the similar computation is Symbol_partition_tuple(p,0)  (the function handles coded periodic p for G(e,e,r)).\n\njulia> Symbol_partition_tuple([[2,1],[1]],1)\n(13,1)\n\njulia> Symbol_partition_tuple([[2,1],[1]],0)\n(13,02)\n\njulia> Symbol_partition_tuple([[2,1],[1]],-1)\n(13,013)\n\n\n\n\n\n","category":"function"},{"location":"symbols/#Chevie.Symbols.fakedegree-Tuple{CharSymbol}","page":"Symbols","title":"Chevie.Symbols.fakedegree","text":"fakedegree(S::CharSymbol,p=0)\n\nreturns as  a CycPol the  fake degree of  the character of symbol S.\n\njulia> fakedegree(CharSymbol([[1,5,6],[1,2]]))\nqÂ¹â¶Î¦â‚…Î¦â‚‡Î¦â‚ˆÎ¦â‚‰Î¦â‚â‚€Î¦â‚â‚Î¦â‚â‚„Î¦â‚â‚†Î¦â‚â‚ˆÎ¦â‚‚â‚€Î¦â‚‚â‚‚\n\nIf S is an e-symbol, when given a second argument p dividing e, and a  first  argument  of  shape  (0,â€¦,0)  representing  the  restriction of the character to G(e,e,r), works for the coset G(e,e,r).sâ‚áµ–.\n\n\n\n\n\n","category":"method"},{"location":"symbols/#Chevie.Symbols.degree_feg","page":"Symbols","title":"Chevie.Symbols.degree_feg","text":"degree_feg(s::CharSymbol)\n\nthe  degree  of  the  fake  degree  of  the  character parameterized by the symbol s.\n\njulia> degree_feg(CharSymbol([[1,5,6],[1,2]]))\n88\n\n\n\n\n\n","category":"function"},{"location":"symbols/#Chevie.Symbols.valuation_feg","page":"Symbols","title":"Chevie.Symbols.valuation_feg","text":"valuation_feg(s::CharSymbol)\n\nthe  valuation of  the fake  degree of  the character  parameterized by the symbol s.\n\njulia> valuation_feg(CharSymbol([[1,5,6],[1,2]]))\n16\n\n\n\n\n\n","category":"function"},{"location":"symbols/#Chevie.Symbols.gendeg","page":"Symbols","title":"Chevie.Symbols.gendeg","text":"gendeg(S::CharSymbol)\n\nreturns  as  a  CycPol  the  generic  degree  of  the unipotent character parameterized by S.\n\njulia> gendeg(CharSymbol([[1,2],[1,5,6]]))\nqÂ¹Â³Î¦â‚…Î¦â‚†Î¦â‚‡Î¦â‚ˆÂ²Î¦â‚‰Î¦â‚â‚€Î¦â‚â‚Î¦â‚â‚„Î¦â‚â‚†Î¦â‚â‚ˆÎ¦â‚‚â‚€Î¦â‚‚â‚‚/2\n\nworks for spetses G(e,1,r),  G(e,e,r), áµ—G(e,e,r)\n\nsee (Malle, 1995; 3.9 and 6.4).\n\n\n\n\n\n","category":"function"},{"location":"symbols/#Chevie.Symbols.degree_gendeg","page":"Symbols","title":"Chevie.Symbols.degree_gendeg","text":"degree_gendeg(S::CharSymbol)\n\nthe  degree of the generic degree  of the unipotent character parameterized by the symbol S.\n\njulia> degree_gendeg(CharSymbol([[1,5,6],[1,2]]))\n91\n\n\n\n\n\n","category":"function"},{"location":"symbols/#Chevie.Symbols.valuation_gendeg","page":"Symbols","title":"Chevie.Symbols.valuation_gendeg","text":"valuation_gendeg(S::CharSymbol)\n\nthe   valuation  of   the  generic   degree  of   the  unipotent  character parameterized by the symbol S.\n\njulia> valuation_gendeg(CharSymbol([[1,5,6],[1,2]]))\n13\n\n\n\n\n\n","category":"function"},{"location":"symbols/#Chevie.Symbols.symbols","page":"Symbols","title":"Chevie.Symbols.symbols","text":"symbols(e,r,content=1,Malledefect=0)\n\nThe list of e-symbols of rank r and given content and Malle-defect.\n\nThe symbols parametrize unipotent characters of:\n\nG(d,1,r) : symbols(d,r)\nG(e,e,r) : symbols(e,r,0).\nG(e,e,r).sâ‚áµ— where sâ‚ is the first generator of G(e,1,r) and t|e: symbols(e,r,0,t)\n\nIn particular we have\n\nAâ‚™ : symbols(1,n)\nBâ‚™ : symbols(2,n)\nDâ‚™ : symbols(2,n,0)\nÂ²Dâ‚™ : symbols(2,n,0,1)\nÂ²Bâ‚‚ : symbols(4,2,0,1)\nÂ²Gâ‚‚ : symbols(6,2,0,1)\n\njulia> symbols(2,4,0,1) # unipotent characters of Â²Dâ‚„\n10-element Vector{CharSymbol}:\n (123,0)\n (023,1)\n (0124,12)\n (01234,123)\n (13,)\n (013,2)\n (014,1)\n (0123,13)\n (04,)\n (012,3)\n\n\n\n\n\n","category":"function"},{"location":"symbols/#Chevie.Symbols.ennola-Tuple{CharSymbol}","page":"Symbols","title":"Chevie.Symbols.ennola","text":"ennola(S::CharSymbol)\n\nEnnola of e-symbol S (of content 1 or 0) The order of Ennola (order of  center of  reflection group)  is computed  automatically: it is e for content 1 and gcd(e,rank(S)) for content 0.\n\n\n\n\n\n","category":"method"},{"location":"symbols/#Chevie.Symbols.XSP","page":"Symbols","title":"Chevie.Symbols.XSP","text":"XSP(Ï,s,n,even=false) Lusztig-Spaltenstein symbols.\n\nreturns  the union of the  (Lusztig and Spaltenstein, 1985) symbols XÌƒ^Ï-ss_nd for all  d  even  when  even=true,  all  d  odd  otherwise; these symbols parametrize  local  systems  on  unipotent  conjugacy classes for classical groups.  In (Lusztig, 2004; 13.2) the  notation is  ^Ï X^s_nd. The result  is a vector of vectors, each inner vector regrouping the symbols in a  similarity class (the local systems  whose support is the same conjugacy class). If s==0, only positive defects d are considered.\n\nXSP(2,1,n) gives Lusztig-Spaltenstein symbols for Spâ‚‚â‚™\nXSP(4,2,n) gives Lusztig-Spaltenstein symbols for Spâ‚‚â‚™ in char.2\nXSP(2,0,n) gives Lusztig-Spaltenstein symbols for SOâ‚‚â‚™â‚Šâ‚ of odd defect\nXSP(2,0,n,true) gives Lusztig-Spaltenstein symbols for SOâ‚‚â‚™ of even defect\nXSP(4,0,n,true) gives Lusztig-Spaltenstein symbols for SOâ‚‚â‚™ in char 2\n\nEach  Lusztig-Spaltenstein symbol  is represented  by a  NamedTuple whose fields describe the local system. The fields are\n\nsymbol the Lusztig-Spaltenstein symbol\ndimBu for the support u of the local system\nAu describes the character  of A(u) corresponding to the  local system   as a boolean list where true->sgn, false->Id\nsp  is the parameter (double partition) of the generalized Springer  correspondent (a character of the relative Weyl group)\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Finite-reflection-groups","page":"Finite reflection groups","title":"Finite reflection groups","text":"Pages=[\"permroot.md\"]","category":"section"},{"location":"permroot/#Chevie.PermRoot","page":"Finite reflection groups","title":"Chevie.PermRoot","text":"Let  V be a vector  space over a subfield  K of the complex numbers (in Julia  the elements  of K  will be  usually represented by Rationals or Cycs).\n\nA complex reflection is an element sâˆˆ GL(V) of finite order whose fixed point  set is  a hyperplane,  the reflecting  hyperplane Hâ‚› of s.\n\nMost  of the  time we  abbreviate \"complex  reflection\" to reflection; in some  literature \"reflection\" is reserved for  s of order 2 and otherwise pseudo-reflection is used.\n\nA  reflection s has a unique eigenvalue Î¶â‚› not equal to 1, which is a root  of  unity;  if  K  is  a  subfield  of  the  real  numbers, Î¶â‚› is necessarily  equal to -1 and s is of  order 2. An eigenvector râˆˆ V of s  for the eigenvalue  Î¶â‚› is called  a root of  s and a linear form ráµ›  on V of  kernel Hâ‚› is  called a coroot  of s. Usually r and ráµ›  are scaled so that ráµ›(r)=1-Î¶; then s is the map on V defined by s(x)=x-ráµ›(x)r.  Such roots and  coroots for s  are unique up to scaling the root and inversely scaling the coroot.\n\nA  finite  complex  reflection  group  W  is  a finite group generated by complex  reflections.  Since  whenever  W  contains  a  reflection s it contains  its powers, W is always  generated by reflections s such that Î¶â‚›==E(d)  where d is the  order of s; we  can also assume that s is not  a  power  of  another  reflection  of  W  with  larger order. Such a reflection is called a distinguished reflection of W; it is a canonical generator  of the cyclic subgroup of  W centralizing Hâ‚›. The generators of  the  complex  reflection  groups  we construct are always distinguished reflections; the set of distinguished reflections are in bijection with the reflecting  hyperplanes.  In  a  real  reflection group all reflections are distinguished.\n\nIt  is much  more efficient  to compute  with permutation  groups than with matrix  groups; hence we use for computing with a finite complex reflection group  W a permutation representation on  a W-invariant set of root and coroot vectors for reflections of W; that is, a set R of pairs (r,ráµ›)âˆˆ VÃ—Váµ›  invariant by W and such that every distinguished reflection in W is determined by some pair in R (see reflectionMatrix). Using a W-invariant set implies that there are several pairs determining the same reflection,  which differ  by roots  of unity.  This generalizes  the usual construction  for Coxeter groups (the case K=â„) where to each reflection of W is associated two roots, one positive and one negative.\n\nA  complex reflection group  is irreducible if  the representation V is irreducible.  For irreducible complex reflection groups, there are at least as  many roots for a given distinguished reflection as the lcm of the order of the reflection and of the order of the center of W.\n\nThe following methods are defined for finite complex reflection groups:\n\ngenerators(W),  abbreviated gens: the (distinguished) reflections which generate W, given as permutations of the roots. reflection_representation(W)  (abbreviated reflrep) gives them as matrices.\nroots(W): the list of roots of W.\ncoroots(W): the list of coroots, in the same order as the roots.\nrefls(W): a list of distinguished reflections of W, as permutations.  This list is of same length as the roots, and its i-th element is the distinguished reflection for the i-th root, so it will have  repetitions.  unique_refls(W)  returns  a  sublist of 1:length(roots(W)) such that the distinguished reflections around the corresponding roots are in bijection with the distinguished reflections of W.\n\nThe  lists roots, coroots and refls starts with those attached to the reflections  gens(W);  these  are  called  simple  roots,  coroots  and reflections.\n\nsimpleroots(W):  the simple roots as a matrix.\nsimplecoroots(W):  the simple coroots as a matrix.\nreflections(W) gives a list without repetitions of all  reflections  of W  (not only  the distinguished  ones), as objects of type  Reflection, starting with the distinguished reflections in  the  same  order  as  unique_refls.  These  objects  contain more information on each reflection.\n\nThe  finite irreducible complex  reflection groups have  been classified in (Shephard and Todd, 1954). They consist of one infinite family G(de,e,r) depending on 3  parameters, and 34 exceptional groups  which have been given by Shephard and Todd names which range from Gâ‚„ to Gâ‚ƒâ‚‡. The function complex_reflection_group,    abbreviated   crg,    returns   an irreducible complex reflection group in terms of the classification. In the context  of  finite  Coxeter  groups  groups,  one  wants  to  describe the particular  root  system  chosen  in  term  of  the  classification of root systems.  This is done  via calls to  the function coxeter_group, abbreviated coxgroup (see the module Weyl).\n\nThe  group  G(de,e,r)  consists  of  the  rÃ—r  monomial  matrices whose non-zero  coefficients  are  de-th  roots  of  unity and whose product of coefficients  is a d-th root of unity. We have the following isomorphisms with infinite families of finite Coxeter groups:\n\ncrg(1,1,r)  coxgroup(:A,r-1)\ncrg(2,1,r)  coxgroup(:B,r)\ncrg(2,2,r)  coxgroup(:D,r)\ncrg(e,e,2)  coxgroup(:I,2,e)\n\nThe  exceptional groups include  the exceptional finite  Coxeter groups; we have the following isomorphisms:\n\ncrg(23)     coxgroup(:H,3)\ncrg(28)     coxgroup(:F,4)\ncrg(30)     coxgroup(:H,4)\ncrg(35)     coxgroup(:E,6)\ncrg(36)     coxgroup(:E,7)\ncrg(37)     coxgroup(:E,8)\n\nWe  can also build any  finite reflection group by  giving a list of simple roots  and simple coroots  (see PRG). We  can get non-irreducible groups  by  the  *  operation  (they  also naturally appear as reflection subgroups).\n\nAn irreducible complex reflection group in rank r can always be generated by   r+1  reflections,  but   is  often  generated   by  r  reflections (\"well-generated\").  The  non  well-generated  groups  are G(de,e,r) when dâ‰ 1 and eâ‰ 1, and Gâ‚‡, Gâ‚â‚, Gâ‚â‚‚, Gâ‚â‚ƒ, Gâ‚â‚…, Gâ‚â‚‰, Gâ‚‚â‚‚, Gâ‚ƒâ‚.\n\nThere  is not yet a general theory on  how to construct a nice set of roots for  a  non-real  reflection  group;  the  roots chosen here where obtained case-by-case; however, they satisfy several important properties:\n\nThe simple reflections  satisfy braid relations  which present the braid group associated to W (see diagram).\nThe field  of definition  of W  is the  field K generated by the traces  of the elements of W acting on  V. It is a theorem that W may be realized as a reflection group over K.\nThe Cartan matrix ráµ›(r') where r and r' runs over the simple roots and  coroots has entries in  the ring â„¤â‚– of  integers of K, and the other  roots (resp. coroots) are  linear combinations with coefficients in â„¤â‚– of a linearly independent subset of them.\n\nIt  turns out that all representations of W are defined over the field of definition  K, see  (Benard, 1976) and  D.~Bessis' thesis.  This has been known  for a long time in  the case K=â„š, the  case of Weyl groups, whose representations are all integral.\n\njulia> W=complex_reflection_group(4)\nGâ‚„\n\njulia> gens(W) # as permutations of the 24 roots\n2-element Vector{Perm{Int16}}:\n (1,3,9)(2,4,7)(5,10,18)(6,11,16)(8,12,19)(13,15,20)(14,17,21)(22,23,24)\n (1,5,13)(2,6,10)(3,7,14)(4,8,15)(9,16,22)(11,12,17)(18,19,23)(20,21,24)\n\njulia> length(unique(refls(W))) # the number of distinguished reflections\n4\n\njulia> length(refls(W)) # 24=4*(number of roots of unity in â„š (Î¶â‚ƒ))\n24\n\njulia> reflrep(W) # the generators as matrices\n2-element Vector{Matrix{Cyc{Rational{Int64}}}}:\n [1 0; 0 Î¶â‚ƒ]\n [âˆš-3/3 -Î¶â‚ƒÂ²âˆš-3/3; (-3+âˆš-3)/3 -Î¶â‚ƒâˆš-3/3]\n\nFor  almost  all  irreducible  complex  reflection  groups,  the generating matrices  for W we give have coefficients in the field of definition K. Further,  the set of matrices for all elements of W is globally invariant under  the  Galois  group  of  K/â„š,  thus  the  Galois  action  induces automorphisms  of W. The exceptions are Gâ‚‚â‚‚, Gâ‚‚â‚‡ where the matrices are in  a  degree  two  extension  of  K  (this  is needed to have a globally invariant  model, see (Marin and Michel, 2010)) and  some dihedral groups, as well  as  Hâ‚ƒ  and  Hâ‚„,  where  the  matrices  given  (the usual Coxeter reflection representation over K) are not globally invariant (but one can get invariant ones by chevieget(:H4,:InvariantModel)).\n\njulia> braid_relations(W) # as pairs of equal words in the generators\n1-element Vector{Tuple{Vector{Int64}, Vector{Int64}}}:\n ([1, 2, 1], [2, 1, 2])\n\njulia> diagram(W) # presentation of W in pictures\nâ‘¢ â€”â€”â‘¢ Gâ‚„\n1   2\n\njulia> cartan(W)  # Cartan matrix of W\n2Ã—2 Matrix{Cyc{Rational{Int64}}}:\n Î¶â‚ƒÂ²âˆš-3     Î¶â‚ƒÂ²\n   -Î¶â‚ƒÂ²  Î¶â‚ƒÂ²âˆš-3\n\njulia> simpleroots(W)\n2Ã—2 Matrix{Cyc{Rational{Int64}}}:\n    0  Î¶â‚ƒÂ²âˆš-3\n 2Î¶â‚ƒÂ²     Î¶â‚ƒÂ²\n\njulia> simplecoroots(W)\n2Ã—2 Matrix{Cyc{Rational{Int64}}}:\n     0      1\n âˆš-3/3  âˆš-3/3\n\nLet SV be the symmetric algebra of V. The invariants of W in SV are called the polynomial invariants of W. If n=dim V, they are generated as   a  polynomial  ring  by   n  homogeneous  algebraically  independent polynomials fâ‚,â€¦,fâ‚™. The polynomials fáµ¢ are not uniquely determined but their  degrees are. The fáµ¢ are called  the basic invariants of W, and their degrees the reflection degrees of W; the function degrees returns these invariants.\n\nLet  I be the  ideal generated by  the homogeneous invariants of positive degree  in SV. Then SV/I is isomorphic to the regular representation of W  as a  W-module. It  is thus  a graded  (by the degree of elements of SV)  version of the  regular representation of  W. The polynomial which gives  the graded  multiplicity of  a character  Ï† of  W in  the graded module   SV/I  is  called   the  fake  degree   of  Ï†.  The  function fakedegrees returns these polynomials.\n\njulia> degrees(W)\n2-element Vector{Int64}:\n 4\n 6\n\njulia> fakedegrees(W,Pol(:x))\n7-element Vector{Pol{Int64}}:\n 1\n xâ´\n xâ¸\n xâ·+xâµ\n xâµ+xÂ³\n xÂ³+x\n xâ¶+xâ´+xÂ²\n\n\n\n\n\n","category":"module"},{"location":"permroot/#Chevie.PermRoot.asreflection","page":"Finite reflection groups","title":"Chevie.PermRoot.asreflection","text":"asreflection(s::Matrix [,r::AbstractVector])\n\ns  should be is a square  matrix, and if given r  should be a vector of length  size(s,1).  The  function  determines  if  s is the matrix of a complex  reflection  (resp.  if  r  is  given  if  it  is the matrix of a reflection  of root r; the point of  giving r is to specify exactly the desired root and coroot, which otherwise are determined only up to a scalar and  its  inverse).  The  function  returns  nothing  if  s if is not a reflection  (resp. not a reflection with root r), and otherwise returns a named tuple with four fields:\n\nroot:   the root of the reflection s (equal to r if given)\ncoroot:  the coroot of s\neigenvalue:  the non-trivial eigenvalue of s\nisunitary: a boolean which is true if and only if s is unitary with respect to the usual scalar product (then s is determined by the root and the eigenvalue as reflectionMatrix(.root,.eigenvalue))\n\njulia> asreflection([-1 0 0;1 1 0;0 0 1])\n(root = [2, 0, 0], coroot = Rational{Int64}[1, -1//2, 0], eig = -1, isunitary = false)\n\njulia> asreflection([-1 0 0;1 1 0;0 0 1],[1,0,0])\n(root = [1, 0, 0], coroot = Rational{Int64}[2, -1, 0], eig = -1, isunitary = false)\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Chevie.PermRoot.reflectionMatrix","page":"Finite reflection groups","title":"Chevie.PermRoot.reflectionMatrix","text":"reflectionMatrix(root,  coroot) the matrix of the reflection with a given root and coroot.\n\nA (complex) reflection is a finite order element s of GL(V), the linear group of a vector space over a subfield of the complex numbers, whose fixed points  form  a  hyperplane  H  (the  reflecting hyperplane of s); an eigenvector  r for  the non-trivial  eigenvalue Î¶  (a root of unity) is called  a root of s. If we choose  a linear form ráµ› defining H such that ráµ›(r)=1-Î¶ (a coroot of s) then s is given by xâ†¦ x-ráµ›(x)r.\n\nA  way  of  specifying  s  is  by  giving  a root and a coroot, which are uniquely determined by s up to multiplication of the root by a scalar and of  the coroot by the inverse scalar. The function reflectionMatrix gives the  matrix of the  corresponding reflection in  the standard basis of V, where  the root and the coroot are  vectors given in the standard bases of V and Váµ›, so the pairing ráµ›(r) is obtained as transpose(root)*coroot.\n\njulia> r=reflectionMatrix([1,0,0],[2,-1,0])\n3Ã—3 Matrix{Int64}:\n -1  0  0\n  1  1  0\n  0  0  1\n\njulia> r==reflrep(coxgroup(:A,3),1)\ntrue\n\njulia> r*[2,-1,0]\n3-element Vector{Int64}:\n -2\n  1\n  0\n\njulia> [1 0 0]*r\n1Ã—3 Matrix{Int64}:\n -1  0  0\n\nAs  we see in the last lines, in  Julia a matrix operates from the right on the  vector space V  of row vectors  and from the  left on the dual space Váµ› of column vectors.\n\n\n\n\n\nreflectionMatrix(r, Î¶=-1)\n\nreturns the matrix of the unitary complex reflection determined by the root r and the eigenvalue Î¶, that is, when the vector space and its dual are identified  via the scalar product <x,y>=transpose(x)*conj(y); the coroot ráµ› is then equal to the linear form x->(1-Î¶)<x,r>/<r,r>.\n\njulia> reflectionMatrix([1,0,-E(3,2)])\n3Ã—3 Matrix{Cyc{Rational{Int64}}}:\n  0  0  Î¶â‚ƒÂ²\n  0  1    0\n Î¶â‚ƒ  0    0\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Chevie.PermRoot.PermRootGroup","page":"Finite reflection groups","title":"Chevie.PermRoot.PermRootGroup","text":"PermRootGroup   is  the  type  of  reflection  groups  represented  as  a permutation group on a set of roots.\n\n\n\n\n\n","category":"type"},{"location":"permroot/#Chevie.Cosets.complex_reflection_group","page":"Finite reflection groups","title":"Chevie.Cosets.complex_reflection_group","text":"complex_reflection_group(STnumber) or crg(STnumber)\n\ncomplex_reflection_group(p,q,r) or crg(p,q,r)\n\nThe  first form of complex_reflection_group returns the primitive complex reflection   group   which   has   Shephard-Todd   number  STnumber,  see (Shephard and Todd, 1954).  The second form returns  the imprimitive complex reflection group G(p,q,r).\n\njulia> G=complex_reflection_group(4)\nGâ‚„\n\njulia> degrees(G)\n2-element Vector{Int64}:\n 4\n 6\n\njulia> length(G)\n24\n\njulia> G*coxgroup(:A,2) # how to make a non-irreducible group\nGâ‚„Ã—Aâ‚‚\n\njulia> complex_reflection_group(1,1,3) # another way to enter Aâ‚‚\nglâ‚ƒ\n\njulia> crg(4) # there is also a short alias\nGâ‚„\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Chevie.PermRoot.PRG","page":"Finite reflection groups","title":"Chevie.PermRoot.PRG","text":"PRG(roots,coroots) complex reflection group with given roots and coroots\n\n\n\n\n\n","category":"type"},{"location":"permroot/#Chevie.InitChevie.TypeIrred","page":"Finite reflection groups","title":"Chevie.InitChevie.TypeIrred","text":"a  TypeIrred object  classifies an  irreducible finite complex reflection group,  or an  irreducible coset  (the latter  means that  the group  has a single orbit of irreducible components under .phi).\n\nFor an irreducible group a TypeIrred has the properties:\n\n.rank  the semisimplerank of the group\n.series which takes one of the values :A,:B,:D,:E,:F,:G,:H,:I for an    irreducible Coxeter group, and is :ST for non-real groups.\n.ST for a primitive non-real group holding the Shepard-Todd number\n.p and .q for an imprimitive non-real group, holding .p=de and .q=e for G(de,e,r).\n\na  TypeIrred may  also contain  information specifying  a specific Cartan matrix  for  the  given  type.  When  there  are  two  conjugacy classes of generators,  .cartanType  (assumed  to  be  1  if  this  key is absent) contains  the ratio  of the  root lengths  compared to  the standard cartan matrix  for  that  type;  that  is,  the  Cartan matrix is conjugate to the standard  Cartan matrix by Diagonal([1,â€¦,1,c,â€¦,c]) where c=.cartanType. This  this  how  type  B  (with  .cartanType==2)  and  type  C  (with .cartanType==1), which have both .series==:B,  are distinguished.\n\nFor an irreducible coset a TypeIrred has the properties\n\n.orbit a Vector{TypeIrred} holding the types of the groups in the orbit under .phi, such that .phi send each item to the next.\n.phi if k is the length of .orbit, contains the permutation effected by .phi^k on the simple roots of the first item of the orbit.\n\nIn addition, a TypeIrred t for a group W or a t appearing in a .orbit for a coset of a group W contains a property\n\n.indices giving the indices in gens(W) represented by the generators of the irreducible component described by t.\n\nThe .indices of a TypeIrred are always in a canonical order for a given component, such that the associated Cartan matrix is the \"canonical\" one. For instance, in type C, the longest root is always the first one, etcâ€¦\n\n\n\n\n\n","category":"type"},{"location":"permroot/#Chevie.InitChevie.TypeIrred-Tuple{PermRootGroup}","page":"Finite reflection groups","title":"Chevie.InitChevie.TypeIrred","text":"TypeIrred(W::PermRootGroup)\n\nW must be an irreducible finite complex reflection group, computed as a permutation   group  of  a  set  of  roots,  generated  by  a  set  S  of distinguished   reflections.   TypeIrred   classifies   W   (returns  a TypeIrred object) by using the following algorithm. It computes in order:\n\nr=semisimplerank(W), the dimension of the space spanned by the roots\ni=length(W)/factorial(r)\no=the maximum order of a reflection=max_s So(s)\nD=all distinguished reflections of W, the W-orbit of S\nh=the Coxeter number=(_s Do(s))r\n\n(r,i,o)  are sufficient  to determine  a G_deer  excepted for the ambiguity  between G_2ee2 and Iâ‚‚(4e),  which is resolved by h (excepted   for   e=1,   where   the   two   solutions  are  isomorphic). G_deer has i=(de)Ê³e, o=max(2d), h=ed(r-1)+d-Î´_d1\n\n(r,i,o)  are also sufficient  to distinguish primitive  groups except for the tuples (which are resolved by h):\n\n(Gâ‚‰, Gâ‚‚â‚„â€šâ‚†â€šâ‚‚)\n(Gâ‚â‚‚, Gâ‚â‚‚â€šâ‚†â€šâ‚‚, Iâ‚‚(24))\n(Gâ‚â‚ƒ, Gâ‚‚â‚„â€šâ‚â‚‚â€šâ‚‚, Iâ‚‚(48))\n(Gâ‚‚â‚‚, Gâ‚†â‚€â€šâ‚ƒâ‚€â€šâ‚‚, Iâ‚‚(120))\n(Gâ‚‡, Gâ‚â‚„, Gâ‚‚â‚„â€šâ‚ˆâ€šâ‚‚)\n(Gâ‚ˆ, Gâ‚â‚‚â€šâ‚ƒâ€šâ‚‚)\n(Gâ‚â‚…, Gâ‚„â‚ˆâ€šâ‚â‚†â€šâ‚‚)\n(Gâ‚â‚‡, Gâ‚â‚‚â‚€â€šâ‚‚â‚„â€šâ‚‚)\n(Gâ‚‚â‚, Gâ‚â‚‚â‚€â€šâ‚„â‚€â€šâ‚‚)\n\n\n\n\n\n","category":"method"},{"location":"permroot/#Chevie.PermRoot.refltype","page":"Finite reflection groups","title":"Chevie.PermRoot.refltype","text":"refltype(W::ComplexReflectionGroup or coset) or reflection_type(W)\n\nreturns the Vector{TypeIrred} which classifies W (see TypeIrred).  The  refltype  is  used  for displaying W at the repl,  and to  compute information  on W  from data on irreducible groups (for  example the  CharTable). The  function indices  on the  result of refltypeor on a TypeIrred tells the index in gens(W) of each standard generator of the irreducible components. In the REPL display of W, these indices  are omitted when they  are the expected ones  (the component is in order at the expected indices).\n\njulia> W=coxgroup(:D,3) # a Dâ‚ƒ is an Aâ‚ƒ in disorder\nAâ‚ƒâ‚â‚â‚ƒâ‚‚â‚\n\njulia> t=refltype(W)\nAâ‚ƒâ‚â‚â‚ƒâ‚‚â‚\n\njulia> indices(t)\n3-element Vector{Int64}:\n 1\n 3\n 2\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Chevie.Symbols.rank-Tuple{PermRootGroup}","page":"Finite reflection groups","title":"Chevie.Symbols.rank","text":"rank(W::ComplexReflectionGroup)\n\nreturns  the rank of  W, which is  the dimension of  the space where it acts.\n\njulia> rank(complex_reflection_group(31))\n4\n\n\n\n\n\n","category":"method"},{"location":"permroot/#Chevie.PermRoot.semisimplerank","page":"Finite reflection groups","title":"Chevie.PermRoot.semisimplerank","text":"semisimpleRank(W::ComplexReflectionGroup)\n\nreturns  the semisimple rank of W, which  is the dimension of the space where  it effectively acts. If W is  a reflection group on the space V, and  Vâ‚ is the subspace generated by roots(W), then semisimplerank(W) is the dimension of Vâ‚. The reflection group W is called essential if Vâ‚=V.\n\njulia> W=reflection_subgroup(coxgroup(:A,3),[1,3])\nAâ‚ƒâ‚â‚â‚ƒâ‚=Aâ‚Ã—Aâ‚Î¦â‚\n\njulia> semisimplerank(W)\n2\n\njulia> rank(W)\n3\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Chevie.PermRoot.number_of_reflections","page":"Finite reflection groups","title":"Chevie.PermRoot.number_of_reflections","text":"number_of_reflections(W::ComplexReflectionGroup) or nref(W)\n\nthe number of reflections of W\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Chevie.PermRoot.number_of_hyperplanes","page":"Finite reflection groups","title":"Chevie.PermRoot.number_of_hyperplanes","text":"number_of_hyperplanes(W::ComplexReflectionGroup) or nhyp(W)\n\nThe number of reflecting hyperplanes of W\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Chevie.PermRoot.coxeter_number","page":"Finite reflection groups","title":"Chevie.PermRoot.coxeter_number","text":"coxeter_number(W::PermRootGroup,i) or coxnum\n\n(Gordon and Griffeth, 2012) have defined the Coxeter number of an irreducible character Ï†  of  a  complex  reflection  group  as  the scalar by which the central element  âˆ‘_{s  in  reflections(W)}(1-s)  acts  on  the  representation of character  Ï†. The  function coxnum  returns the  Coxeter number  of the i-th irreducible character of W.\n\n\n\n\n\ncoxeter_number(W::PermRootGroup) or coxnum\n\n(Gordon and Griffeth, 2012)  have defined the Coxeter  number of an irreducible complex reflection  group as the Coxeter number  of its reflection character. It is also given by the formula (nref(W)+nhyp(W))/rank(W); for a well-generated group  it is equal to the  highest reflection degree. For a non-irreducible group,  the  Coxeter  number  is  the  sum  of  those  of  its  irreducible components.\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Chevie.PermRoot.roots-Tuple{PRG}","page":"Finite reflection groups","title":"Chevie.PermRoot.roots","text":"roots(W::PermRootGroup) the roots of W\n\n\n\n\n\n","category":"method"},{"location":"permroot/#Chevie.PermRoot.roots-Tuple{PRG, Any}","page":"Finite reflection groups","title":"Chevie.PermRoot.roots","text":"roots(W::PermRootGroup,i) same as roots(W)[i]\n\n\n\n\n\n","category":"method"},{"location":"permroot/#Chevie.PermRoot.coroots","page":"Finite reflection groups","title":"Chevie.PermRoot.coroots","text":"coroots(W) the list of coroots of W (listed in the same order as the roots)\n\n\n\n\n\ncoroots(W,i) same as but better than coroots(W)[i]\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Chevie.PermRoot.coroot","page":"Finite reflection groups","title":"Chevie.PermRoot.coroot","text":"coroot(r,Î»=-1)\n\nthe coroot for a unitary reflection of root r and eigenvalue Î».\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Chevie.PermRoot.simpleroots","page":"Finite reflection groups","title":"Chevie.PermRoot.simpleroots","text":"simpleroots(W::ComplexReflectionGroup) a matrix whose rows are the simple roots of W, that is roots(W,1:ngens(W)).\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Chevie.PermRoot.simplecoroots","page":"Finite reflection groups","title":"Chevie.PermRoot.simplecoroots","text":"simplecoroots(W::ComplexReflectionGroup)  a  matrix  whose  rows  are the simple coroots of W, that is coroots(W,1:ngens(W)).\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Chevie.PermRoot.baseX","page":"Finite reflection groups","title":"Chevie.PermRoot.baseX","text":"baseX(W::ComplexReflectionGroup)\n\nreturns  as the rows of a matrix a  particular basis of the space V where W acts: the first semisimplerank(W) rows contain the coordinates on the basis of V of a basis of the root lattice (given by simpleroots(W)[independent_roots(W)]) and the last rank(W)-semisimplerank(W) ones contain the same for the orthogonal of the coroots.\n\nWhen W represents a rootdatum for a reductive group, the first lines are the same as simpleroots(W).\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Chevie.PermRoot.independent_roots","page":"Finite reflection groups","title":"Chevie.PermRoot.independent_roots","text":"independent_roots(W::ComplexReflectionGroup)\n\nA vector of indices of length semisimplerank(W) such that simpleroots(W)[independent_roots(W)]  is  a  basis  of  the  vector space spanned by the roots of W.\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Chevie.PermRoot.cartan-Tuple{PermRootGroup}","page":"Finite reflection groups","title":"Chevie.PermRoot.cartan","text":"cartan(W::PermRootGroup)    Cartan matrix of W.\n\nLet  sâ‚,â€¦,sâ‚™ be reflections with associated  roots ráµ¢ and coroots cáµ¢. The  matrix C with  entries Cáµ¢,â±¼=cáµ¢(râ±¼) is  called a Cartan matrix of sâ‚,â€¦,sâ‚™.  Since a reflection determines up to scalar a root and a coroot, C  is uniquely  determined by  sâ‚,â€¦,sâ‚™ up  to conjugation by a diagonal matrix.\n\nIf sâ‚,â€¦,sâ‚™ generate a reflection group W, then C up to conjugation by a  diagonal matrix is an invariant of the reflection representation of W. If invertible, the matrix C determines this representation since then the ráµ¢  form a basis in  which the matrix for  sáµ¢ differs from the identity only  on  the  i-th  row,  where  the  corresponding  row of C has been subtracted.\n\nIn general cartan(W)==simplecoroots(W)*permutedims(simpleroots(W)).\n\njulia> W=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> cartan(W)\n3Ã—3 Matrix{Int64}:\n  2  -1   0\n -1   2  -1\n  0  -1   2\n\n\n\n\n\n","category":"method"},{"location":"permroot/#Chevie.PermRoot.cartan-Tuple{PermRootGroup, Any, Any}","page":"Finite reflection groups","title":"Chevie.PermRoot.cartan","text":"cartan(W::PermRootGroup,i,j) the  cartan coefficient cáµ¢(râ±¼), the value of the linear form given by the i-th coroot cáµ¢ on the j-th root ráµ¢ of W\n\n\n\n\n\n","category":"method"},{"location":"permroot/#Chevie.PermRoot.refls","page":"Finite reflection groups","title":"Chevie.PermRoot.refls","text":"refls(W::ComplexReflectionGroup)\n\na  list of same length as W.roots giving the corresponding element of W representing  a distinguished reflection.  In particular this  list is much longer  than unique(refls(W))  since in  general there  are several roots corresponding to a reflection.\n\n\n\n\n\nrefls(W::ComplexReflectionGroup,i)\n\nthe  element of W representing  the distinguished reflection around the i-th root of W (i can be an index or a vector of indices)\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Chevie.PermRoot.unique_refls","page":"Finite reflection groups","title":"Chevie.PermRoot.unique_refls","text":"unique_refls(W::ComplexReflectionGroup) A  sublist of 1:length(roots(W)) such  that the distinguished reflections around  the  corresponding  roots  reach  one  time only each distinguished reflection of W.\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Chevie.PermRoot.Reflection","page":"Finite reflection groups","title":"Chevie.PermRoot.Reflection","text":"Reflection is a struct representing a reflection in a reflection group.\n\njulia> W=crg(8);\n\njulia> r=reflections(W)[7] # shows (r.W,r.rootno,r.eigen)\nReflection(Gâ‚ˆ,1,-1)\n\njulia> r.rootno # r is a reflection for the first root\n1\n\njulia> r.eigen # the non-trival eigenvalue, as a Root1\nRoot1: -1\n\njulia> r.W # the group of which r is a reflection\nGâ‚ˆ\n\njulia> r==Reflection(W,1,-1) # specify r with .rootno and .eigen\ntrue\n\njulia> Reflection(W,1) # specify with .rootno gets the distinguished reflection\nReflection(Gâ‚ˆ,1,Î¶â‚„)\n\njulia> root(r)\n2-element Vector{Cyc{Rational{Int64}}}:\n  0\n Î¶â‚„\n\njulia> coroot(r)\n2-element Vector{Cyc{Int64}}:\n    0\n -2Î¶â‚„\n\njulia> Matrix(r)\n2Ã—2 Matrix{Cyc{Rational{Int64}}}:\n 1   0\n 0  -1\n\njulia> hyperplane(r) # the fixed hyperplane, as a rowspace\n1Ã—2 Matrix{Cyc{Rational{Int64}}}:\n 1  0\n\njulia> hyperplane(r)*Matrix(r)==hyperplane(r)\ntrue\n\njulia> isdistinguished(r) # r is not distinguished\nfalse\n\njulia> exponent(r) # which power of a distinguished reflection it is\n2\n\njulia> Perm(r)\n(1,8)(2,9)(3,16)(4,15)(5,17)(6,18)(7,19)(10,22)(11,21)(12,23)\n\njulia> hyperplane_orbit(r) # r is in the first hyperplane orbit\n1\n\njulia> position_class(r) # the index of the conjugacy class of r in W \n15\n\njulia> simple_rep(r) # smallest root index affording a conjugate reflection\n1\n\njulia> word(r) # a word in the generators of r.W for r\n2-element Vector{Int64}:\n 1\n 1\n\n\n\n\n\n","category":"type"},{"location":"permroot/#Chevie.PermRoot.reflections","page":"Finite reflection groups","title":"Chevie.PermRoot.reflections","text":"reflections(W)   a  Vector{Reflection}   of  all   reflections  of  the reflection   group   W   (including   the   non-distinguished  ones;  see Reflection).  reflections(W)[1:nhyp(W)]  are  the distinguished reflections.\n\njulia> W=crg(4)\nGâ‚„\n\njulia> reflections(W)\n8-element Vector{Reflection{PRG{Cyc{Rational{Int64}}, Int16}}}:\n Reflection(Gâ‚„,1,Î¶â‚ƒ)\n Reflection(Gâ‚„,2,Î¶â‚ƒ)\n Reflection(Gâ‚„,4,Î¶â‚ƒ)\n Reflection(Gâ‚„,5,Î¶â‚ƒ)\n Reflection(Gâ‚„,1,Î¶â‚ƒÂ²)\n Reflection(Gâ‚„,2,Î¶â‚ƒÂ²)\n Reflection(Gâ‚„,4,Î¶â‚ƒÂ²)\n Reflection(Gâ‚„,5,Î¶â‚ƒÂ²)\n\n\n\n\n\n","category":"function"},{"location":"permroot/#PermGroups.Perms.reflection_length-Tuple{PermRootGroup, Perm}","page":"Finite reflection groups","title":"PermGroups.Perms.reflection_length","text":"reflection_length(W::PermRootGroup,w::Perm) or reflength\n\nThis  function returns the  number of eigenvalues  of w in the reflection representation  which are not equal to 1.  For a finite Coxeter group, this is  equal to the  reflection length of  w, that is  the minimum number of reflections  of which w  is a product.  This also holds  in general for a well-generated  complex reflection group if  w divides for the reflection length a Coxeter element.\n\njulia> W=coxgroup(:A,4)\nAâ‚„\n\njulia> reflength(W,longest(W))\n2\n\njulia> reflength(W,W(1,2,3,4))\n4\n\n\n\n\n\n","category":"method"},{"location":"permroot/#Chevie.PermRoot.simple_reps","page":"Finite reflection groups","title":"Chevie.PermRoot.simple_reps","text":"simple_reps(W)\n\nfor  each root, the index  of the first simple  root conjugate to it (it is the index of a generator of W).\n\n\n\n\n\nsimple_reps(W,i)\n\nthe  smallest index of a root in the  same W-orbit as the i-th root (it is the index of a generator of W).\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Chevie.PermRoot.simple_conjugating","page":"Finite reflection groups","title":"Chevie.PermRoot.simple_conjugating","text":"simple_conjugating(W::ComplexReflectionGroup)\n\nFor each index i of a root, an element wâˆˆ W such that action(W,simple_reps(W,i),w)==i. \n\n\n\n\n\nsimple_conjugating(W,i)\n\nan element wâˆˆ W such that action(W,simple_reps(W,i),w)==i. In particular W(simple_reps(W,i))^simple_conjugating(W,i)==refls(W,i).\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Chevie.Diagrams.diagram","page":"Finite reflection groups","title":"Chevie.Diagrams.diagram","text":"diagram(W)  prints  a  diagram  describing  a  presentation of the finite reflection group or spets W\n\njulia> diagram(coxgroup(:E,8))\n    O 2\n    ï¿¨\nOâ€”Oâ€”Oâ€”Oâ€”Oâ€”Oâ€”O Eâ‚ˆ\n1 3 4 5 6 7 8\n\njulia> diagram(crg(33))\n    3 â‘¡       Gâ‚ƒâ‚ƒ\n     /^\\\nâ‘¡ â€”â€”â‘¡ â€”â€”â‘¡ â€”â€”â‘¡ \n1   2   4   5     423423=342342\n\nThe  nodes of the diagram represent  the generating reflections of W. For complex  reflection groups, the nodes circle an integer noting the order of the corresponding reflection.\n\nThe  edges of the diagram represent braid  relations in the same way as for Dynkin  diagrams  (see  Weyl). Nodes  not  adjacent  by  an  edge represent  commuting  generators.  Braid  relations  using  more  than  two generators are listed separately.\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Chevie.PermRoot.hyperplane_orbits","page":"Finite reflection groups","title":"Chevie.PermRoot.hyperplane_orbits","text":"hyperplane_orbits(W::ComplexReflectionGroup)\n\nreturns  a  list  of  named  tuples,  one  for each hyperplane orbit of the reflection  group W. If o is the named tuple for such an orbit, and s is  the first  element of  gens(W) whose  hyperplane is  in the orbit, it contains the following fields\n\ns:     index of s in gens(W)\norder: order of s\ncl_s:  for i in 1:order-1, position_class(W,W(s)^i)\nN_s:    size of hyperplane orbit\ndet_s:  for i in 1:order-1, position in CharTable(W) of detâ‚›â±, where detâ‚›  is the linear character taking the value det(reflrep(W,s)) on s and 1 on non-conjugate reflections.\n\njulia> W=coxgroup(:B,2)\nBâ‚‚\n\njulia> hyperplane_orbits(W)\n2-element Vector{@NamedTuple{s::Int64, cl_s::Vector{Int64}, order::Int64, N_s::Int64, det_s::Vector{Int64}}}:\n (s = 1, cl_s = [2], order = 2, N_s = 2, det_s = [5])\n (s = 2, cl_s = [4], order = 2, N_s = 2, det_s = [1])\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Chevie.CoxGroups.braid_relations","page":"Finite reflection groups","title":"Chevie.CoxGroups.braid_relations","text":"braid_relations(W)\n\nthis  function returns the  relations which present  the braid group of the reflection group W. These are homogeneous (both sides of the same length) relations  between generators in bijection  with the generating reflections of  W. A presentation  of W is  obtained by adding relations specifying the order of the generators.\n\njulia> W=complex_reflection_group(29)\nGâ‚‚â‚‰\n\njulia> braid_relations(W)\n7-element Vector{Tuple{Vector{Int64}, Vector{Int64}}}:\n ([1, 2, 1], [2, 1, 2])\n ([2, 4, 2], [4, 2, 4])\n ([3, 4, 3], [4, 3, 4])\n ([2, 3, 2, 3], [3, 2, 3, 2])\n ([1, 3], [3, 1])\n ([1, 4], [4, 1])\n ([4, 3, 2, 4, 3, 2], [3, 2, 4, 3, 2, 4])\n\neach  relation  is  represented  as  a  pair  of lists, specifying that the product  of the  generators according  to the  indices on  the left side is equal  to the product according to the  indices on the right side. See also diagram.\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Chevie.PermRoot.reflection_representation-Tuple{PermRootGroup, Any}","page":"Finite reflection groups","title":"Chevie.PermRoot.reflection_representation","text":"reflection_representation(W::ComplexReflectionGroup,w) or reflrep(W,w)\n\nLet  V be the space on  which W acts as a  reflection group and let wâˆˆ W,  represented  as  a  permutation  of  the roots. The function reflrep returns  the matrix of w acting on  V (from the right on the elements of  V seen as  row vectors by  our conventions in  Chevie). This is the linear  transformation of V which acts trivially on the orthogonal of the coroots  and has same effect as w on the simple roots. The function makes sense  more generally for a permutation of  the roots induced by an element of  GL(V) which stabilizes the roots (thus in particular normalizes W); thus   it   works   for   reflection   cosets.  For  a  rootdatum corresponding to a coset WÏƒ we get the action of WÏƒ on X(ğ“).\n\njulia> W=reflection_subgroup(rootdatum(\"E7sc\"),1:6)\nEâ‚‡â‚â‚â‚‚â‚ƒâ‚„â‚…â‚†â‚=Eâ‚†Î¦â‚\n\njulia> reflrep(W,longest(W))\n7Ã—7 Matrix{Int64}:\n  0   0   0   0   0  -1  2\n  0  -1   0   0   0   0  2\n  0   0   0   0  -1   0  3\n  0   0   0  -1   0   0  4\n  0   0  -1   0   0   0  3\n -1   0   0   0   0   0  2\n  0   0   0   0   0   0  1\n\n\n\n\n\n","category":"method"},{"location":"permroot/#Chevie.PermRoot.reflection_representation-Tuple{PRG}","page":"Finite reflection groups","title":"Chevie.PermRoot.reflection_representation","text":"reflection_representation(W::ComplexReflectionGroup) or reflrep(W)\n\nreturns  reflrep.(Ref(W),gens(W)),  that  is  the  generators  of  W as matrices.\n\n\n\n\n\n","category":"method"},{"location":"permroot/#Chevie.PermRoot.reflection_representation-Tuple{PRG, Integer}","page":"Finite reflection groups","title":"Chevie.PermRoot.reflection_representation","text":"reflection_representation(W,i::Integer)  or reflrep(W,i)\n\nthe matrix for the distinguished reflection around the i-th root of W.\n\n\n\n\n\n","category":"method"},{"location":"permroot/#Chevie.PermRoot.reflection_character","page":"Finite reflection groups","title":"Chevie.PermRoot.reflection_character","text":"reflection_character(W::ComplexReflectionGroup,w) or reflchar\n\nReturns  the trace  of the  element w  of W  as an  endomorphism of the vector space V on which W acts.\n\njulia> W=coxgroup(:B,3)\nBâ‚ƒ\n\njulia> reflchar(W,longest(W))\n-3\n\n\n\n\n\nreflection_character(W::ComplexReflectionGroup) or reflchar\n\nReturns  the reflection  character of  W. When  W is irreducible, it is CharTable(W).irr[charinfo(W).extRefl[2]].\n\njulia> reflchar(coxgroup(:A,3))\n5-element Vector{Int64}:\n  3\n  1\n -1\n  0\n -1\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Chevie.PermRoot.YMatrix","page":"Finite reflection groups","title":"Chevie.PermRoot.YMatrix","text":"YMatrix(W,w)\n\nLet  W be a finite reflection group on  the space V and let wâˆˆ W. The function  YMatrix returns the  matrix of w  acting on the  dual V* of V.  This is the linear transformation of V* which acts trivially on the orthogonal  of the roots and has same  effect as w on the simple coroots. The function makes sense more generally for an element of the normalizer of W  in the whole permutation group of the coroots. The resulting matrix is the  transposed  of  the  matrix  reflrep(W,w),  which,  according to our conventions  acts on the right (on the row vectors representing elements of the  dual of V). For  a rootdatum corresponding to  a coset WÏƒ we get the action of WÏƒ on Y(ğ“).\n\njulia> W=reflection_subgroup(rootdatum(\"E7sc\"),1:6)\nEâ‚‡â‚â‚â‚‚â‚ƒâ‚„â‚…â‚†â‚=Eâ‚†Î¦â‚\n\njulia> YMatrix(W,longest(W))\n7Ã—7 transpose(::Matrix{Int64}) with eltype Int64:\n  0   0   0   0   0  -1  0\n  0  -1   0   0   0   0  0\n  0   0   0   0  -1   0  0\n  0   0   0  -1   0   0  0\n  0   0  -1   0   0   0  0\n -1   0   0   0   0   0  0\n  2   2   3   4   3   2  1\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Chevie.PermRoot.PermX","page":"Finite reflection groups","title":"Chevie.PermRoot.PermX","text":"PermX(W::ComplexReflectionGroup,M::AbstractMatrix)\n\nLet M be an invertible linear map of the reflection representation of W which  preserves the set of  roots of parent(W), and normalizes W  (for  the  action  of  matrices  on  the  right).  PermX returns the corresponding permutation of the roots of parent(W); it returns nothing if M does not normalize the set of roots of parent(W).\n\njulia> W=reflection_subgroup(rootdatum(\"E7sc\"),1:6)\nEâ‚‡â‚â‚â‚‚â‚ƒâ‚„â‚…â‚†â‚=Eâ‚†Î¦â‚\n\njulia> PermX(W,reflrep(W,longest(W)))==longest(W)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Chevie.PermRoot.PermY","page":"Finite reflection groups","title":"Chevie.PermRoot.PermY","text":"PermY(W::ComplexReflectionGroup,M::AbstractMatrix)\n\nLet  M  be  an  invertible  linear  map  on  the  dual  of the reflection representation of W which preserves the set of coroots of parent(W),  and normalizes W  (for the action  of matrices on the right). PermY returns the corresponding permutation of the coroots of parent(W);  it returns  nothing if  M does  not normalize  the set of coroots of parent(W).\n\njulia> W=reflection_subgroup(rootdatum(\"E7sc\"),1:6)\nEâ‚‡â‚â‚â‚‚â‚ƒâ‚„â‚…â‚†â‚=Eâ‚†Î¦â‚\n\njulia> PermY(W,YMatrix(W,longest(W)))==longest(W)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Chevie.PermRoot.reflection_eigenvalues","page":"Finite reflection groups","title":"Chevie.PermRoot.reflection_eigenvalues","text":"reflection_eigenvalues(W) or refleigen(W)\n\nLet W be a reflection group on the vector space V. reflection_eigenvalues(W) returns for each conjugacy class representative x  of W (see classreps)  the eigenvalues of x  on V, as a list of Root1.\n\njulia> refleigen(coxgroup(:B,2))\n5-element Vector{Vector{Root1}}:\n [1, 1]\n [-1, 1]\n [-1, -1]\n [-1, 1]\n [Î¶â‚„Â³, Î¶â‚„]\n\n\n\n\n\nrefleigen(W,i) faster than refleigen(W)[i]\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Chevie.PermRoot.degrees-Tuple{PermRootGroup}","page":"Finite reflection groups","title":"Chevie.PermRoot.degrees","text":"degrees(W::ComplexReflectionGroup)\n\nreturns  a list  holding the  degrees of  W as  a reflection group on the vector  space V on which  it acts. These are  the degrees dâ‚,â€¦,dâ‚™ where n  is the dimension of  V of the basic  invariants of W in SV. They reflect  various properties  of W;  in particular,  their product  is the cardinality of W.\n\njulia> W=complex_reflection_group(30)\nHâ‚„\n\njulia> degrees(W)\n4-element Vector{Int64}:\n  2\n 12\n 20\n 30\n\njulia> length(W)\n14400\n\n\n\n\n\n","category":"method"},{"location":"permroot/#Chevie.PermRoot.codegrees-Tuple{PermRootGroup}","page":"Finite reflection groups","title":"Chevie.PermRoot.codegrees","text":"codegrees(W::ComplexReflectionGroup)\n\nreturns  the vector of codegrees of W  as a reflection group on the space V  of reflrep(W).  These are  one less  than the  degrees of  the basic derivations of W on SVâŠ— V^vee.\n\njulia> W=complex_reflection_group(4)\nGâ‚„\n\njulia> codegrees(W)\n2-element Vector{Int64}:\n 0\n 2\n\n\n\n\n\n","category":"method"},{"location":"permroot/#Chevie.PermRoot.invariants","page":"Finite reflection groups","title":"Chevie.PermRoot.invariants","text":"invariants(W::ComplexReflectionGroup)\n\nreturns  the fundamental invariants of W in its reflection representation V.  That is, returns  a set of  algebraically independent elements of the symmetric  algebra  of  the  dual  of  V which generate the W-invariant polynomial  functions on V. Each such invariant function is returned as a function:  if eâ‚,â€¦,eâ‚™ is a basis of V and f is the function, then the value  of the polynomial  function on aâ‚eâ‚+â€¦+aâ‚™eâ‚™  is obtained by calling f(aâ‚,â€¦,aâ‚™). This function depends on the classification, and is dependent on the exact reflection representation of W. So for the moment it is only implemented   when  the  reflection   representation  for  the  irreducible components has the same Cartan matrix as the one provided by Chevie for the corresponding  irreducible  group.  The  polynomials  are invariant for the natural   action  of   the  group   elements  as   matrices;  that  is,  if m==reflrep(W,w)  for some  w in  W, then  an invariant  f satisfies f(aâ‚,â€¦,aâ‚™)=f(vâ‚,â€¦,vâ‚™)   where  [vâ‚,â€¦,vâ‚™]=[aâ‚,â€¦,aâ‚™]Ã—m.  This  action  is implemented on Mvps by the function ^.\n\njulia> W=coxgroup(:A,2)\nAâ‚‚\n\njulia> @Mvp x,y,z\n\njulia> i=invariants(W);\n\njulia> map(f->f(x,y),i)\n2-element Vector{Mvp{Int64, Int64}}:\n -2xÂ²+2xy-2yÂ²\n 6xÂ²y-6xyÂ²\n\njulia> W=complex_reflection_group(24)\nGâ‚‚â‚„\n\njulia> p=invariants(W)[1](x,y,z)\nMvp{Rational{Int64}}: (14//1)xâ´+(-12//1)xÂ²yÂ²+(-42//1)xÂ²yz+(21//2)xÂ²zÂ²+(18//7)yâ´+(-6//1)yÂ³z+(-9//2)yÂ²zÂ²+(-21//8)zâ´\n\njulia> map(v->^(v,reflrep(W,1);vars=[:x,:y,:z]),(x,y,z))\n((1//2)x+(3âˆš-7/14)y, (-âˆš-7/2)x+(-1//2)y, z)\n\njulia> p^reflrep(W,1)-p\nMvp{Cyc{Rational{Int64}}}: 0\n\n\n\n\n\n","category":"function"},{"location":"permroot/#LaurentPolynomials.discriminant","page":"Finite reflection groups","title":"LaurentPolynomials.discriminant","text":"discriminant(W)\n\nreturns  the  discriminant  of  the  complex  reflection  group  W,  as a polynomial in the fundamental invariants. The discriminant is the invariant obtained  by  taking  the  product  of  the  linear  forms  describing  the reflecting   hyperplanes  of  W,   each  raised  to   the  order  of  the corresponding  reflection. The discriminant  is returned as  a function f such  that  the  discriminant  in  the  variables  aâ‚,â€¦,aâ‚™ is obtained by calling f(aâ‚,â€¦,aâ‚™). For the moment, this function is implemented only for the exceptional complex reflection groups Gâ‚„ to Gâ‚ƒâ‚ƒ.\n\njulia> W=complex_reflection_group(4);@Mvp x,y\n\njulia> discriminant(W)(x,y)\nMvp{Int64}: xÂ³-yÂ²\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Chevie.PermRoot.invariant_form","page":"Finite reflection groups","title":"Chevie.PermRoot.invariant_form","text":"invariant_form(W::ComplexReflectionGroup)\n\nThis  function  returns  the  matrix  F  (defined  up  to a scalar) of an Hermitian form invariant under the action of the reflection group W. That is, if M is the matrix of an element of W, then M*F*M'=F.\n\njulia> W=complex_reflection_group(4)\nGâ‚„\n\njulia> invariant_form(W)\n2Ã—2 Matrix{Int64}:\n 1  0\n 0  2\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Chevie.PermRoot.bipartite_decomposition","page":"Finite reflection groups","title":"Chevie.PermRoot.bipartite_decomposition","text":"bipartite_decomposition(W)\n\nReturns  a bipartite decomposition [L,R] of the indices of the generators of the reflection group W, such that reflection_subgroup(W,L) and reflection_subgroup(W,R) are abelian subgroups, and W=reflection_subgroup(W,   vcat(L,R)).   Gives   an   error  if  no  such decomposition is possible.\n\njulia> bipartite_decomposition(coxgroup(:E,8))\n([1, 4, 6, 8], [3, 2, 5, 7])\n\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Combinat.catalan-Tuple{Group, Any}","page":"Finite reflection groups","title":"Combinat.catalan","text":"catalan(W::ComplexReflectionGroup)\n\nreturns the Catalan Number of the irreducible complex reflection group W. For well-generated groups, this number is equal to the number of simples in the  dual Braid monoid.  For other groups  it was defined by (Gordon and Griffeth, 2012). For Weyl groups, it also counts the number of antichains of roots.\n\njulia> catalan(coxgroup(:A,7))\n1430\n\ncatalan(W,i)\n\nreturns   the  i-th  Fuss-Catalan  Number   of  the  irreducible  complex reflection  group W. For  well-generated groups, this  number is equal to the  number of chains  sâ‚,â€¦,sáµ¢ of simples  in the dual  monoid where sâ±¼ divides  sâ±¼â‚Šâ‚. For these groups, it is also equal to âˆâ±¼(ih+dâ±¼)/dâ±¼ where the  product runs over the reflection degrees  of W, and where h is the Coxeter  number of W. For non-well generated groups, the definition is in (Gordon and Griffeth, 2012).\n\njulia> catalan(complex_reflection_group(7),2)\n16\n\ncatalan(W;q=1), resp. catalan(W,i;q=1)\n\nfor  q  a  variable,  like  Pol()  or an Mvp, returns the q-Catalan number  (resp.  the  i-th  q-Fuss  Catalan  number)  of  W. Again the definitions in general are in (Gordon and Griffeth, 2012).\n\njulia> catalan(complex_reflection_group(7),2;q=Pol())\nPol{Int64}: qâ·Â²+2qâ¶â°+3qâ´â¸+4qÂ³â¶+3qÂ²â´+2qÂ¹Â²+1\n\n\n\n\n\n","category":"method"},{"location":"permroot/#Chevie.PermRoot.generic_order","page":"Finite reflection groups","title":"Chevie.PermRoot.generic_order","text":"generic_order(W,q=Pol())\n\nreturns  the  generic  order  of  the  reflection  group  or coset W as a polynomial  in q (the order of the associated semisimple finite reductive group  over the filed with  q elements for a  rootdatum, or the \"compact\" order  of the Spets in general).  This is q^Nâ‚•Î áµ¢(q^dáµ¢-1) where dáµ¢ are the reflection degrees and Nâ‚• the number of reflecting hyperplanes.\n\njulia> PermRoot.generic_order(complex_reflection_group(4),Pol(:q))\nPol{Int64}: qÂ¹â´-qÂ¹â°-qâ¸+qâ´\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Chevie.PermRoot.torus_order","page":"Finite reflection groups","title":"Chevie.PermRoot.torus_order","text":"torus_order(W::ComplexReflectionGroup,i,q=Pol())\n\nreturns  as a  polynomial in  q the  toric order  of the i-th conjugacy class  of W. This is the characteristic  polynomial of an element of that class  on  the  reflection  representation  of  W.  It is the same as the generic  order  of  the  reflection  subcoset torus(W,i) of W determined  by  the  trivial  subgroup  and  a representative of the i-th conjugacy class.\n\njulia> W=complex_reflection_group(4)\n\njulia> torus_order.(Ref(W),1:nconjugacy_classes(W),Pol(:q))\n7-element Vector{Pol{Cyc{Int64}}}:\n qÂ²-2q+1\n qÂ²+2q+1\n qÂ²+1\n qÂ²-Î¶â‚ƒq+Î¶â‚ƒÂ²\n qÂ²+Î¶â‚ƒq+Î¶â‚ƒÂ²\n qÂ²+Î¶â‚ƒÂ²q+Î¶â‚ƒ\n qÂ²-Î¶â‚ƒÂ²q+Î¶â‚ƒ\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Chevie.PermRoot.reflection_subgroup-Tuple{PRG, AbstractVector}","page":"Finite reflection groups","title":"Chevie.PermRoot.reflection_subgroup","text":"reflection_subgroup(W,r)\n\nreturns  the  reflection  subgroup  of  the  complex  reflection  group W generated by refls(W,r).\n\nA  reflection subgroup H of  W is a permutation  subgroup with the same additional  information as  W, and  some new  one added which express the relationship with parent(W):\n\ninclusion(H):   the indices of the roots of H in the roots of W\nparent(H):  is set to W.\nrestriction(H):  a list of length length(roots(W)) with non-zero entries in positions inclusion(H) bound to eachindex(roots(H)).\n\nA  reflection  group  which  is  not  a  subgroup  actually  also  has this information, set to the trivial values: inclusion(W)==restriction(W)==eachindex(roots(W)),   and  parent(W)==W. This  allows a lot of code to be  written in the same way for parent groups or reflection subgroups.\n\nreflection_subgroup(R) where R is itself a reflection subgroup returns a  reflection subgroup of parent(R).\n\njulia> W=coxgroup(:F,4)\nFâ‚„\n\njulia> H=reflection_subgroup(W,[1,2,11,20])\nFâ‚„â‚â‚‰â€šâ‚‚â€šâ‚â€šâ‚â‚†â‚=Dâ‚„â‚â‚ƒâ‚‚â‚â‚„â‚\n\njulia> [restriction(H)]\n1-element Vector{Vector{Int64}}:\n [1, 2, 0, 0, 5, 0, 0, 0, 3, 0  â€¦  0, 16, 0, 19, 0, 21, 0, 22, 23, 24]\n\njulia> reflection_subgroup(H,[1,2,3])\nFâ‚„â‚â‚‰â‚â‚‚â‚=Aâ‚ƒâ‚â‚ƒâ‚â‚‚â‚Î¦â‚\n\n\n\n\n\n","category":"method"},{"location":"permroot/#Chevie.PermRoot.inclusion","page":"Finite reflection groups","title":"Chevie.PermRoot.inclusion","text":"inclusion(W::ComplexReflectionGroup)\n\nthe indices of the roots of W in the roots of parent(W).\n\ninclusion(W::PermRootGroup,i::Integer) inclusion(W::PermRootGroup,v::AbstractVector{<:Integer})\n\nsame as inclusion(W)[i] or inclusion(W)[v] (but more efficient).\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Chevie.PermRoot.inclusiongens","page":"Finite reflection groups","title":"Chevie.PermRoot.inclusiongens","text":"inclusion(W::ComplexReflectionGroup)\n\nthe indices of simpleroots(W) in the roots of parent(W).\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Chevie.PermRoot.restriction","page":"Finite reflection groups","title":"Chevie.PermRoot.restriction","text":"restriction(W::PermRootGroup)\n\nA  list for each root of parent(W), which holds 0 if the root is not a root of W and i if the root is the i-th root of W.\n\nrestriction(W::PermRootGroup,i::Integer) restriction(W::PermRootGroup,v::AbstractVector{<:Integer})\n\nsame as restriction(W)[i] or restriction(W)[v] (but more efficient).\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Chevie.PermRoot.action","page":"Finite reflection groups","title":"Chevie.PermRoot.action","text":"action(W::ComplexReflectionGroup,i::Integer,p::Perm)\n\nThe elements of a PermRootGroup permute the roots of parent(W), that is are permutations on eachindex(roots(parent(W))). The function action translates this action of  pâˆˆW  to  eachindex(roots(W)).  For  a  reflection  subgroup we have action(W,i,p)==restriction(W,inclusion(W,i)^p)  and  for  a  parent group action(W,i,p)==i^p.  The first formula is always valid since for a parent group restriction(W)==inclusion(W)==eachindex(roots(W)).\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Chevie.Weyl.standard_parabolic-Tuple{PermRootGroup, Any}","page":"Finite reflection groups","title":"Chevie.Weyl.standard_parabolic","text":"standard_parabolic(W::PermRootGroup, H)\n\nLet  H be a  reflection subgroup of  W. Returns an  element wâˆˆ W such that  H^w is a standard  parabolic subgroup of W  (or nothing if H is not parabolic or not conjugate to a standard parabolic).\n\n\n\n\n\n","category":"method"},{"location":"permroot/#Chevie.PermRoot.parabolic_reps","page":"Finite reflection groups","title":"Chevie.PermRoot.parabolic_reps","text":"parabolic_reps(W)\n\nFor  a Coxeter group or finite complex reflection group W, returns a list of  indices  of  roots  of  W  describing  representatives  of  orbits of parabolic  subgroups  under  conjugation  by  W. For Coxeter groups, each orbit  has a representative which is a standard parabolic subgroup, that is whose indices is a subset of eachindex(gens(W)). This may not be the case in general.\n\njulia> parabolic_reps(coxgroup(:A,4))\n7-element Vector{Vector{Int64}}:\n []\n [1]\n [1, 2]\n [1, 3]\n [1, 2, 3]\n [1, 2, 4]\n [1, 2, 3, 4]\n\njulia> parabolic_reps(complex_reflection_group(3,3,3))\n7-element Vector{Vector{Int64}}:\n []\n [1]\n [1, 2]\n [1, 3]\n [1, 9]\n [2, 3]\n [1, 2, 3]\n\nparabolic_reps(W,r)\n\nIf  a second  argument r  is given,  returns only  representatives of the parabolic subgroups of semisimple rank r.\n\njulia> parabolic_reps(coxgroup(:A,4),2)\n2-element Vector{Vector{Int64}}:\n [1, 2]\n [1, 3]\n\njulia> parabolic_reps(complex_reflection_group(3,3,3),2)\n4-element Vector{Vector{Int64}}:\n [1, 2]\n [1, 3]\n [1, 9]\n [2, 3]\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Chevie.PermRoot.parabolic_closure","page":"Finite reflection groups","title":"Chevie.PermRoot.parabolic_closure","text":"parabolic_closure(W,I)\n\nI  should be a  list of indices  of reflections of  W. Returns J such that  reflection_subgroup(W,J) is the smallest  parabolic subgroup of W containing reflection_subgroup(W,I).\n\njulia> W=complex_reflection_group(7)\nGâ‚‡\n\njulia> parabolic_closure(W,[1])\n1-element Vector{Int64}:\n 1\n\njulia> parabolic_closure(W,[1,2])\n3-element Vector{Int64}:\n 1\n 2\n 3\n\n\n\n\n\n","category":"function"},{"location":"permroot/#Chevie.PermRoot.isparabolic","page":"Finite reflection groups","title":"Chevie.PermRoot.isparabolic","text":"isparabolic(W)\n\nwhether   the  reflection   subgroup  W   is  a   parabolic  subgroup  of parent(W).\n\njulia> W=complex_reflection_group(7)\nGâ‚‡\n\njulia> isparabolic(reflection_subgroup(W,[1,2]))\nfalse\n\njulia> isparabolic(reflection_subgroup(W,[1]))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"ct/#Classtypes","page":"Classtypes","title":"Classtypes","text":"","category":"section"},{"location":"ct/#Chevie.Gt.closed_subsystems","page":"Classtypes","title":"Chevie.Gt.closed_subsystems","text":"closed_subsystems(W) \n\nW  should  be  a  Weyl  group.  The  function returns the Poset of closed subsystems  of the root system of W. Each closed subsystem is represented by  the list of indices of its simple roots.  If W is the Weyl group of a reductive  group  ğ†,  then  closed  subsystem  correspond  to reductive subgroups of maximal rank. And all such groups are obtained this way, apart from  some exceptions  in characteristics  2 and  3, see (Malle and Testerman, 2011; Proposition 13.4).\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> closed_subsystems(W)\n1 2<1 4<4<âˆ…\n1 2<1 5<1<âˆ…\n1 2<2 6<6<âˆ…\n1 2<3 5<5<âˆ…\n1 4<1\n1 5<6\n1 5<5\n2 6<2<âˆ…\n3 5<3<âˆ…\n\n\n\n\n\n","category":"function"},{"location":"ct/#Chevie.Gt.ClassTypes","page":"Classtypes","title":"Chevie.Gt.ClassTypes","text":"ClassTypes(G[,p])\n\nG  should be a root  datum or a twisted  root datum representing a finite reductive  group ğ† ^F and  p should be a  prime. The function returns the class types of G in characteristic p (in good characteristic if p is  omitted). Two elements  of ğ† ^F  have the same  class type if their centralizers  are  conjugate.  If  su  is  the Jordan decomposition of an element  x, the class type of x is  determined by the class type of its semisimple part s and the unipotent class of u in C_ğ† (s).\n\nThe   function  ClassTypes  is  presently  only  implemented  for  simply connected  groups, where  C_ğ† (s)  is connected.  This section is a bit experimental and may change in the future.\n\nClassTypes  returns a  struct which  contains a  list of classtypes for semisimple  elements,  which  are  represented  by  subspets  and contain additionnaly information on the unipotent classes of C_ğ† (s).\n\nLet us give some examples:\n\njulia> t=ClassTypes(rootdatum(:sl,3))\nClassTypes(Aâ‚‚,good characteristic)\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚C_G(s)    â”‚ |C_G(s)|â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚Aâ‚‚â‚â‚=Î¦â‚Â²  â”‚      Î¦â‚Â²â”‚\nâ”‚Aâ‚‚â‚â‚=Î¦â‚Î¦â‚‚ â”‚     Î¦â‚Î¦â‚‚â”‚\nâ”‚Aâ‚‚â‚â‚=Î¦â‚ƒ   â”‚       Î¦â‚ƒâ”‚\nâ”‚Aâ‚‚â‚â‚â‚=Aâ‚Î¦â‚â”‚   qÎ¦â‚Â²Î¦â‚‚â”‚\nâ”‚Aâ‚‚        â”‚qÂ³Î¦â‚Â²Î¦â‚‚Î¦â‚ƒâ”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nBy   default,  only  information  about  semisimple  centralizer  types  is returned:   the type, and its generic order.\n\njulia> xdisplay(t;unip=true)\nClassTypes(Aâ‚‚,good characteristic)\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚C_G(s)    â”‚    u |C_G(su)|â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚Aâ‚‚â‚â‚=Î¦â‚Â²  â”‚    1       Î¦â‚Â²â”‚\nâ”‚Aâ‚‚â‚â‚=Î¦â‚Î¦â‚‚ â”‚    1      Î¦â‚Î¦â‚‚â”‚\nâ”‚Aâ‚‚â‚â‚=Î¦â‚ƒ   â”‚    1        Î¦â‚ƒâ”‚\nâ”‚Aâ‚‚â‚â‚â‚=Aâ‚Î¦â‚â”‚   11    qÎ¦â‚Â²Î¦â‚‚â”‚\nâ”‚          â”‚    2       qÎ¦â‚â”‚\nâ”‚Aâ‚‚        â”‚  111 qÂ³Î¦â‚Â²Î¦â‚‚Î¦â‚ƒâ”‚\nâ”‚          â”‚   21      qÂ³Î¦â‚â”‚\nâ”‚          â”‚    3       3qÂ²â”‚\nâ”‚          â”‚ 3_Î¶â‚ƒ       3qÂ²â”‚\nâ”‚          â”‚3_Î¶â‚ƒÂ²       3qÂ²â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nHere  we  have  displayed  information  on  unipotent  classes,  with their centralizer.\n\njulia> xdisplay(t;nClasses=true)\nClassTypes(Aâ‚‚,good characteristic)\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚C_G(s)    â”‚       nClasses  |C_G(s)|â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚Aâ‚‚â‚â‚=Î¦â‚Â²  â”‚(qÂ²-5q+2qâ‚ƒ+4)/6       Î¦â‚Â²â”‚\nâ”‚Aâ‚‚â‚â‚=Î¦â‚Î¦â‚‚ â”‚       (qÂ²-q)/2      Î¦â‚Î¦â‚‚â”‚\nâ”‚Aâ‚‚â‚â‚=Î¦â‚ƒ   â”‚  (qÂ²+q-qâ‚ƒ+1)/3        Î¦â‚ƒâ”‚\nâ”‚Aâ‚‚â‚â‚â‚=Aâ‚Î¦â‚â”‚       (q-qâ‚ƒ-1)    qÎ¦â‚Â²Î¦â‚‚â”‚\nâ”‚Aâ‚‚        â”‚             qâ‚ƒ qÂ³Î¦â‚Â²Î¦â‚‚Î¦â‚ƒâ”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nHere  we have added information on how many semisimple conjugacy classes of ğ†  ^F have a given type. The  answer in general involves variables of the form qâ‚ which represent gcd(q-1,a).\n\nFinally an example in bad characteristic:\n\njulia> t=ClassTypes(coxgroup(:G,2),2);xdisplay(t;nClasses=true)\nClassTypes(Gâ‚‚,char. 2)\nClassTypes(Gâ‚‚,char. 2)\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚C_G(s)    â”‚         nClasses     |C_G(s)|â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚Gâ‚‚â‚â‚=Î¦â‚Â²  â”‚(qÂ²-8q+2qâ‚ƒ+10)/12          Î¦â‚Â²â”‚\nâ”‚Gâ‚‚â‚â‚=Î¦â‚Î¦â‚‚ â”‚        (qÂ²-2q)/4         Î¦â‚Î¦â‚‚â”‚\nâ”‚Gâ‚‚â‚â‚=Î¦â‚Î¦â‚‚ â”‚        (qÂ²-2q)/4         Î¦â‚Î¦â‚‚â”‚\nâ”‚Gâ‚‚â‚â‚=Î¦â‚†   â”‚    (qÂ²-q-qâ‚ƒ+1)/6           Î¦â‚†â”‚\nâ”‚Gâ‚‚â‚â‚=Î¦â‚ƒ   â”‚    (qÂ²+q-qâ‚ƒ+1)/6           Î¦â‚ƒâ”‚\nâ”‚Gâ‚‚â‚â‚=Î¦â‚‚Â²  â”‚ (qÂ²-4q+2qâ‚ƒ-2)/12          Î¦â‚‚Â²â”‚\nâ”‚Gâ‚‚â‚â‚â‚=Aâ‚Î¦â‚â”‚       (q-qâ‚ƒ-1)/2       qÎ¦â‚Â²Î¦â‚‚â”‚\nâ”‚Gâ‚‚â‚â‚â‚=Aâ‚Î¦â‚‚â”‚       (q-qâ‚ƒ+1)/2       qÎ¦â‚Î¦â‚‚Â²â”‚\nâ”‚Gâ‚‚â‚â‚‚â‚=AÌƒâ‚Î¦â‚â”‚          (q-2)/2       qÎ¦â‚Â²Î¦â‚‚â”‚\nâ”‚Gâ‚‚â‚â‚‚â‚=AÌƒâ‚Î¦â‚‚â”‚              q/2       qÎ¦â‚Î¦â‚‚Â²â”‚\nâ”‚Gâ‚‚        â”‚                1 qâ¶Î¦â‚Â²Î¦â‚‚Â²Î¦â‚ƒÎ¦â‚†â”‚\nâ”‚Gâ‚‚â‚â‚â‚…â‚=Aâ‚‚ â”‚         (qâ‚ƒ-1)/2    qÂ³Î¦â‚Â²Î¦â‚‚Î¦â‚ƒâ”‚\nâ”‚Gâ‚‚â‚â‚â‚…â‚=Â²Aâ‚‚â”‚         (qâ‚ƒ-1)/2    qÂ³Î¦â‚Î¦â‚‚Â²Î¦â‚†â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nWe  notice that if q is  a power of 2 such  that qâ‰¡2 (mod 3), so that qâ‚ƒ=1,  some class types do not exist. We can see what happens by giving a specific value to qâ‚ƒ:\n\njulia> xdisplay(t(;q_3=1);nClasses=true)\nClassTypes(Gâ‚‚,char. 2) qâ‚ƒ=1\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚C_G(s)    â”‚     nClasses     |C_G(s)|â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚Gâ‚‚â‚â‚=Î¦â‚Â²  â”‚(qÂ²-8q+12)/12          Î¦â‚Â²â”‚\nâ”‚Gâ‚‚â‚â‚=Î¦â‚Î¦â‚‚ â”‚    (qÂ²-2q)/4         Î¦â‚Î¦â‚‚â”‚\nâ”‚Gâ‚‚â‚â‚=Î¦â‚Î¦â‚‚ â”‚    (qÂ²-2q)/4         Î¦â‚Î¦â‚‚â”‚\nâ”‚Gâ‚‚â‚â‚=Î¦â‚†   â”‚     (qÂ²-q)/6           Î¦â‚†â”‚\nâ”‚Gâ‚‚â‚â‚=Î¦â‚ƒ   â”‚     (qÂ²+q)/6           Î¦â‚ƒâ”‚\nâ”‚Gâ‚‚â‚â‚=Î¦â‚‚Â²  â”‚   (qÂ²-4q)/12          Î¦â‚‚Â²â”‚\nâ”‚Gâ‚‚â‚â‚â‚=Aâ‚Î¦â‚â”‚      (q-2)/2       qÎ¦â‚Â²Î¦â‚‚â”‚\nâ”‚Gâ‚‚â‚â‚â‚=Aâ‚Î¦â‚‚â”‚          q/2       qÎ¦â‚Î¦â‚‚Â²â”‚\nâ”‚Gâ‚‚â‚â‚‚â‚=AÌƒâ‚Î¦â‚â”‚      (q-2)/2       qÎ¦â‚Â²Î¦â‚‚â”‚\nâ”‚Gâ‚‚â‚â‚‚â‚=AÌƒâ‚Î¦â‚‚â”‚          q/2       qÎ¦â‚Î¦â‚‚Â²â”‚\nâ”‚Gâ‚‚        â”‚            1 qâ¶Î¦â‚Â²Î¦â‚‚Â²Î¦â‚ƒÎ¦â‚†â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n\n\n\n\n","category":"type"},{"location":"urad/#Unipotent-Elements","page":"Unipotent Elements","title":"Unipotent Elements","text":"Pages=[\"urad.md\"]","category":"section"},{"location":"urad/#Chevie.Urad","page":"Unipotent Elements","title":"Chevie.Urad","text":"This  module contains  functions for  computing with  unipotent elements of reductive  groups; specifically to  compute with elements  of the unipotent radical of a Borel subgroup of a connected algebraic reductive group; these functions  were initially written by Olivier Dudas in GAP3, partly inspired by older C code of Jean Michel.\n\nThe  unipotent radical of a  Borel subgroup is the  product in any order of the root subgroups associated to the positive roots. We fix an order, which gives a canonical form to display elements and to compare them.\n\nThe  computations use the Steinberg relations between root subgroups, which come from the choice of a Chevalley basis of the Lie algebra. The reference we  follow is (Carter, 1972; chapters  4 to 6), but  it is possible to use another   choice   of   Chevalley   basis,   see   the   documentation  for UnipotentGroup.\n\nWe  start with  a root  datum specified  by a  Weyl group  W and  build a struct  UnipotentGroup  which  contains  information  about  the  maximal unipotent  subgroup  of  the  corresponding  reductive  group,  that is the unipotent radical of the Borel subgroup determined by the positive roots.\n\njulia> W=coxgroup(:E,6)\nEâ‚†\n\njulia> U=UnipotentGroup(W)\nUnipotentGroup(Eâ‚†)\n\nNow, if Î±=roots(W,2), we construct the element u_Î±(4) of the root subgroup u_Î±:\n\njulia> U(2=>4)\nu2(4)\n\nIf we do not specify the coefficient we make by default u_Î±(1), so we have also:\n\njulia> U(2)^4\nu2(4)\n\nWe can make more complicated elements:\n\njulia> U(2=>4)*U(4=>5)\nu2(4)u4(5)\n\njulia> U(2=>4,4=>5)\nu2(4)u4(5)\n\nIf the roots are not in order the element is normalized:\n\njulia> U(4=>5,2=>4)\nu2(4)u4(5)u8(-20)\n\nIt is possible to display the decomposition of the roots in simple roots instead of their index:\n\njulia> xprint(U(4=>5,2=>4);root=true)\nuâ‚€â‚â‚€â‚€â‚€â‚€(4)uâ‚€â‚€â‚€â‚â‚€â‚€(5)uâ‚€â‚â‚€â‚â‚€â‚€(-20)\n\nThe coefficients in the root subgroups can be elements of arbitrary rings. Here is an example using Mvp's:\n\njulia> W=coxgroup(:E,8);U=UnipotentGroup(W)\nUnipotentGroup(Eâ‚ˆ)\n\njulia> u=U(map(i->i=>Z(2)*Mvp(Symbol(\"x\",Char(i+0x2080))),1:8)...)\nu1(xâ‚)u2(xâ‚‚)u3(xâ‚ƒ)u4(xâ‚„)u5(xâ‚…)u6(xâ‚†)u7(xâ‚‡)u8(xâ‚ˆ)\n\njulia> cut(xrepr(u^16;limit=true,root=true),before=\"u\",width=60)\nuâ‚‚â‚‚â‚ƒâ‚„â‚ƒâ‚‚â‚â‚€(xâ‚Â²xâ‚‚Â²xâ‚ƒÂ³xâ‚„â´xâ‚…Â³xâ‚†Â²xâ‚‡)\nuâ‚â‚‚â‚ƒâ‚„â‚ƒâ‚‚â‚â‚(xâ‚xâ‚‚Â²xâ‚ƒÂ³xâ‚„â´xâ‚…Â³xâ‚†Â²xâ‚‡xâ‚ˆ)\nuâ‚â‚‚â‚‚â‚„â‚ƒâ‚‚â‚‚â‚(xâ‚xâ‚‚Â²xâ‚ƒÂ²xâ‚„â´xâ‚…Â³xâ‚†Â²xâ‚‡Â²xâ‚ˆ)\nuâ‚â‚‚â‚‚â‚ƒâ‚ƒâ‚ƒâ‚‚â‚(xâ‚xâ‚‚Â²xâ‚ƒÂ²xâ‚„Â³xâ‚…Â³xâ‚†Â³xâ‚‡Â²xâ‚ˆ)\nuâ‚‚â‚‚â‚ƒâ‚„â‚ƒâ‚‚â‚â‚(xâ‚Â²xâ‚‚Â²xâ‚ƒÂ³xâ‚„â´xâ‚…Â³xâ‚†Â²xâ‚‡xâ‚ˆ)\nuâ‚â‚‚â‚‚â‚„â‚ƒâ‚ƒâ‚‚â‚(xâ‚xâ‚‚Â²xâ‚ƒÂ²xâ‚„â´xâ‚…Â³xâ‚†Â³xâ‚‡Â²xâ‚ˆ)\nuâ‚â‚‚â‚‚â‚„â‚„â‚ƒâ‚‚â‚(xâ‚xâ‚‚Â²xâ‚ƒÂ²xâ‚„â´xâ‚…â´xâ‚†Â³xâ‚‡Â²xâ‚ˆ)\nuâ‚‚â‚‚â‚ƒâ‚„â‚ƒâ‚ƒâ‚‚â‚(xâ‚Â²xâ‚‚Â²xâ‚ƒÂ³xâ‚„â´xâ‚…Â³xâ‚†Â³xâ‚‡Â²xâ‚ˆ)\nuâ‚â‚‚â‚ƒâ‚„â‚„â‚ƒâ‚‚â‚(xâ‚xâ‚‚Â²xâ‚ƒÂ³xâ‚„â´xâ‚…â´xâ‚†Â³xâ‚‡Â²xâ‚ˆ)\nuâ‚‚â‚‚â‚ƒâ‚„â‚„â‚ƒâ‚‚â‚(xâ‚Â²xâ‚‚Â²xâ‚ƒÂ³xâ‚„â´xâ‚…â´xâ‚†Â³xâ‚‡Â²xâ‚ˆ)\nuâ‚‚â‚ƒâ‚ƒâ‚…â‚„â‚ƒâ‚‚â‚(xâ‚Â²xâ‚‚Â³xâ‚ƒÂ³xâ‚„âµxâ‚…â´xâ‚†Â³xâ‚‡Â²xâ‚ˆ)\nuâ‚‚â‚‚â‚„â‚…â‚„â‚ƒâ‚‚â‚(xâ‚Â²xâ‚‚Â²xâ‚ƒâ´xâ‚„âµxâ‚…â´xâ‚†Â³xâ‚‡Â²xâ‚ˆ)\nuâ‚‚â‚ƒâ‚„â‚†â‚…â‚„â‚ƒâ‚‚(xâ‚Â²xâ‚‚Â³xâ‚ƒâ´xâ‚„â¶xâ‚…âµxâ‚†â´xâ‚‡Â³xâ‚ˆÂ²)\n\njulia> u^32\n()\n\nThe  above computation shows  that in characteristic  2 the exponent of the unipotent  group of Eâ‚ˆ is 32. More precisely, squaring doubles the height of  the involved roots, so in the above uÂ¹â¶ involves only roots of height 16 or more.\n\nVarious  actions are  defined on  unipotent elements.  Elements of the Weyl group  act (through certain representatives) as long as no root subgroup is in their inversion set:\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> U=UnipotentGroup(W);@Mvp x,y\n\njulia> u=U(1=>x,3=>y)\nu1(x)u3(y)\n\njulia> u^W(2,1)\nu4(y)u5(x)\n\njulia> u^W(1)\nERROR: u1(x)u3(y) should have no coefficient on root 1\n\nSemisimple elements act by conjugation:\n\njulia> s=SemisimpleElement(W,[E(3),2])\nSemisimpleElement{Cyc{Int64}}: <Î¶â‚ƒ,2>\n\njulia> u^s\nu1(Î¶â‚ƒx)u3(2Î¶â‚ƒy)\n\nAs well as unipotent elements:\n\njulia> u^U(2)\nu1(x)u3(x+y)u4(-x-2y)u5(x+3y)u6(xÂ²+3xy+3yÂ²)\n\n\n\n\n\n","category":"module"},{"location":"urad/#Chevie.Urad.UnipotentGroup","page":"Unipotent Elements","title":"Chevie.Urad.UnipotentGroup","text":"A  struct UnipotentGroup represents  the unipotent  radical ğ” of a Borel subgroup of a reductive group G.\n\nSee  (Carter, 1972; section 4.2) for details on the following. A Chevalley basis  of the Lie algebra of ğ” is a basis eáµ£, where each eáµ£ is in the corresponding  root  subspace,  such  that  [eáµ£,eâ‚›]=Náµ£â‚›  e_{r+s} for some integer constants Náµ£â‚›. The constants Náµ£â‚› for general roots are computed from  the case where  r and s  are positive roots  whose sum is a root; such a pair (r,s) is called special.\n\nConstants  Cáµ£â‚›áµ¢â±¼ are defined, see (Carter, 1972; 5.2.3), by\n\nu_s(u)u_r(t)=u_r(t)u_s(u)prod_ij0u_ir+js(C_rsij(-t)^iu^j)\n\nWhere  ir+js runs over the positive  integral combinations of r and s which  are roots,  taken in  lexicographic order  on (i,j). The constants Cáµ£â‚›áµ¢â±¼  are computed from the constants Náµ£â‚›, see (Carter, 1972; bottom of page 61 and top of page 76).\n\nThe fields of struct Unipotent Group are:\n\nW:         the Weyl group of G\norder:     the total order on the roots used to normalize products of root subgroups (by default 1:nref(W))\nspecial:    aNamedTuplefor each special pair of roots(r,s)`\nr  index of r\ns  index of s\nrs index of r+s\nN: the constant Náµ£â‚›\ncomm: stores the Cáµ£â‚›áµ¢â±¼ as the list of quadruples (i,j,ir+js,Cáµ£â‚›áµ¢â±¼).\n\njulia> U=UnipotentGroup(coxgroup(:G,2))\nUnipotentGroup(Gâ‚‚)\n\njulia> U.special\n10-element Vector{@NamedTuple{r::Int64, s::Int64, rs::Int64, N::Int64, comm::Vector{NTuple{4, Int64}}}}:\n (r = 1, s = 2, rs = 3, N = 1, comm = [(1, 1, 3, 1), (1, 2, 4, -1), (1, 3, 5, 1), (2, 3, 6, 2)])\n (r = 2, s = 3, rs = 4, N = 2, comm = [(1, 1, 4, 2), (2, 1, 5, 3), (1, 2, 6, -3)])\n (r = 2, s = 4, rs = 5, N = 3, comm = [(1, 1, 5, 3)])\n (r = 1, s = 5, rs = 6, N = 1, comm = [(1, 1, 6, 1)])\n (r = 3, s = 4, rs = 6, N = 3, comm = [(1, 1, 6, 3)])\n (r = 2, s = 1, rs = 3, N = -1, comm = [(1, 1, 3, -1), (2, 1, 4, -1), (3, 1, 5, -1), (3, 2, 6, -1)])\n (r = 3, s = 2, rs = 4, N = -2, comm = [(1, 1, 4, -2), (2, 1, 6, -3), (1, 2, 5, 3)])\n (r = 4, s = 2, rs = 5, N = -3, comm = [(1, 1, 5, -3)])\n (r = 5, s = 1, rs = 6, N = -1, comm = [(1, 1, 6, -1)])\n (r = 4, s = 3, rs = 6, N = -3, comm = [(1, 1, 6, -3)])\n\n\n\n\n\n","category":"type"},{"location":"urad/#Chevie.Urad.UnipotentGroup-Tuple{FiniteCoxeterGroup}","page":"Unipotent Elements","title":"Chevie.Urad.UnipotentGroup","text":"UnipotentGroup(W;chevalley=nothing;order=1:nref(W))\n\nW should be a Weyl group. This function returns a struct UnipotentGroup associated  to the reductive group of Weyl group W. \n\nIf  the keyword order is given it is  a total order on the positive roots used to normalize unipotent elements.\n\nBy  default the structure constants Náµ£â‚›  are computed using the method of (Carter, 1972) from extraspecial pairs. Another set of structure constants can be specified by giving for the keyword chevalley a Dict associating to  a pair (r,s) of root indices  some object p such that first(p) is the  corresponding  N_{r,s}.  Here  is  an  example  of  using  different constants from the package ChevLie of Meinolf Geck.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> using ChevLie: LieAlg, structconsts\n\njulia> l=LieAlg(:g,2)\n#I dim = 14\nLieAlg('G2')\n\njulia> U=UnipotentGroup(W;chevalley=structconsts(l))\n#I calculating structconsts\n#I calculating eps-canonical base (100/.) \nUnipotentGroup(Gâ‚‚)\n\n\n\n\n\n","category":"method"},{"location":"urad/#Chevie.Urad.reorder","page":"Unipotent Elements","title":"Chevie.Urad.reorder","text":"reorder(U,l[,order])\n\nThis  function  takes  a  list  of  pairs  r=>c  representing a unipotent element,  where r  is a  root and  c the corresponding coefficient, and puts  it in  canonical form,  reordering the  terms to agree with U.order using  the commutation  relations. If  a second  argument is given, this is used instead of U.order.\n\njulia> U=UnipotentGroup(coxgroup(:G,2))\nUnipotentGroup(Gâ‚‚)\n\njulia> l=reorder(U,[2=>4,1=>2])\n6-element Vector{Pair{Int64, Int64}}:\n 1 => 2\n 2 => 4\n 3 => -8\n 4 => 32\n 5 => -128\n 6 => 512\n\njulia> reorder(U,l,6:-1:1)\n2-element Vector{Pair{Int64, Int64}}:\n 2 => 4\n 1 => 2\n\n\n\n\n\n","category":"function"},{"location":"urad/#Chevie.Urad.abelianpart","page":"Unipotent Elements","title":"Chevie.Urad.abelianpart","text":"abelianpart(u::UnipotentElement)\n\nIf  ğ” is the unipotent subgroup and D(ğ”) its derived subgroup, this function   returns  the  projection   of  the  unipotent   element  u  on ğ”/D(ğ”), that is its coefficients on the simple roots.\n\njulia> U=UnipotentGroup(coxgroup(:G,2));@Mvp x,y\n\njulia> u=U(2=>y,1=>x)\nu1(x)u2(y)u3(-xy)u4(xyÂ²)u5(-xyÂ³)u6(2xÂ²yÂ³)\n\njulia> abelianpart(u)\nu1(x)u2(y)\n\n\n\n\n\n","category":"function"},{"location":"urad/#Chevie.Chars.decompose-Tuple{Any, UnipotentElement}","page":"Unipotent Elements","title":"Chevie.Chars.decompose","text":"decompose(w,u::UnipotentElement)\n\nw  should  be  an  element  of  the  Weyl  group  of  the reductive group containing  u.  If  ğ”  is  the  unipotent radical of the Borel subgroup determined  by the positive roots, and ğ”â» the opposite unipotent radical, this  function  decomposes  u  into  its  component  in ğ” âˆ© Ê·ğ”â» and its component in ğ” âˆ© Ê·ğ”.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> U=UnipotentGroup(W);@Mvp x,y\n\njulia> u=U(2=>y,1=>x)\nu1(x)u2(y)u3(-xy)u4(xyÂ²)u5(-xyÂ³)u6(2xÂ²yÂ³)\n\njulia> decompose(W(1),u)\n2-element Vector{UnipotentElement{Mvp{Int64, Int64}}}:\n u1(x)\n u2(y)u3(-xy)u4(xyÂ²)u5(-xyÂ³)u6(2xÂ²yÂ³)\n\njulia> decompose(W(2),u)\n2-element Vector{UnipotentElement{Mvp{Int64, Int64}}}:\n u2(y)\n u1(x)\n\n\n\n\n\n","category":"method"},{"location":"murphy/#Murphy-basis","page":"Murphy basis","title":"Murphy basis","text":"","category":"section"},{"location":"murphy/#Chevie.Murphy","page":"Murphy basis","title":"Chevie.Murphy","text":"This module Murphy.jl has been ported in december 2020 from\n\nmurphy.g Copyright (C) July 1998  Andrew Mathas     mathas@maths.usyd.edu.au University of Sydney\n\nIt allows computations with the Murphy basis of an Hecke algebra of type A.\n\nMultiplication  of Murphy basis elements is  done using the Garnir tableaux as  described in (Murphy, 1995). This also lets us convert from the T-basis to the Murphy basis since T_w = M([[1],â€¦,[n]], [[1],â€¦,[n]]) * T_w; we use \"M\" for the Murphy basis.\n\nAs with the T-basis, Murphy basis elements are implemented by ModuleElts. Here the keys are standard tableaux pairs. These are represented by a tuple (mu,s,t)  where mu,  s and  t are  integers encoding  the partition H.Murphy.partitions[mu]  and the  named tuples H.Murphy.tableaux[mu][s] (resp   t)  describing  tableaux  as  explained  in  the  helpstring  for initMurphy.\n\nThroughout memory considerations are thrown to the wind as we cache many of the  more horrible expansions as we go along  in order to save time when we next need them.\n\njulia> W=coxgroup(:A,2)\nAâ‚‚\n\njulia> H=hecke(W,Pol(:q))\nhecke(Aâ‚‚,q)\n\njulia> l=Tbasis(H).(elements(W))\n6-element Vector{HeckeTElt{HeckeAlgebra{Pol{Int64}, Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}, Pol{Int64}, Perm{Int16}}}:\n T.\n Tâ‚\n Tâ‚‚\n Tâ‚â‚‚\n Tâ‚‚â‚\n Tâ‚â‚‚â‚\n\njulia> Murphy.SpechtModules(H,false);Murphybasis(H).(l)\n6-element Vector{Chevie.Murphy.HeckeMElt{Pol{Int64}, HeckeAlgebra{Pol{Int64}, Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:\n M(1/2/3,1/2/3)\n -M(1/2/3,1/2/3)+M(12/3,12/3)\n -M(1/2/3,1/2/3)+qâ»Â¹M(12/3,12/3)+qâ»Â¹M(12/3,13/2)+qâ»Â¹M(13/2,12/3)+qâ»Â¹M(13/2,13/2)-qâ»Â¹M(123,123)\n M(1/2/3,1/2/3)-qâ»Â¹M(12/3,12/3)+(1-qâ»Â¹)M(12/3,13/2)-qâ»Â¹M(13/2,12/3)-qâ»Â¹M(13/2,13/2)+qâ»Â¹M(123,123)\n M(1/2/3,1/2/3)-qâ»Â¹M(12/3,12/3)-qâ»Â¹M(12/3,13/2)+(1-qâ»Â¹)M(13/2,12/3)-qâ»Â¹M(13/2,13/2)+qâ»Â¹M(123,123)\n -M(1/2/3,1/2/3)+(-1+qâ»Â¹)M(12/3,12/3)+(-1+qâ»Â¹)M(12/3,13/2)+(-1+qâ»Â¹)M(13/2,12/3)+qâ»Â¹M(13/2,13/2)+(1-qâ»Â¹)M(123,123)\n\n\n\n\n\n","category":"module"},{"location":"murphy/#Chevie.Murphy.initMurphy","page":"Murphy basis","title":"Chevie.Murphy.initMurphy","text":"initMurphy(H) for hecke(coxgroup(:A,n-1),q)\n\nCalled the first time that the Murphy basis is used. Creates H.Murphy with  various components.\n\nH.Murphy.partitions contains the partitions of n\nH.Murphy.Tableaux[mu] contains the tableaux for H.Murphy.partitions[mu]\nH.Murphy.InfoTableaux[mu] contains InfoTableaux for H.Murphy.Tableaux[mu]\n\nCreating  a list  of all  of the  standard tableaux  is a  big overhead for Specht  modules of  large dimension  so the  above arrays  work as  a cache filled  as  needed.  The  bookkeeping  to  maintain these caches is done in InfoTableau.\n\n\n\n\n\n","category":"function"},{"location":"cosets/#Reflection-cosets-and-Spets","page":"Reflection cosets and Spets","title":"Reflection cosets and Spets","text":"Pages=[\"cosets.md\"]","category":"section"},{"location":"cosets/#Chevie.Cosets","page":"Reflection cosets and Spets","title":"Chevie.Cosets","text":"Let  R be a  root system in  the real vector  space V. We say that Fâ‚€âˆˆ GL(V)  is an  automorphism of  R if  it permutes  R and is of finite order  (finite  order  is  automatic  if  R generates V). It follows by (Bourbaki, 1968; chap.  VI,  Â§1.1,  lemme  1)  that  the  dual Fâ‚€áµ›âˆˆ GL(Váµ›) permutes  the coroots Ráµ›âŠ‚  Váµ›; thus Fâ‚€  normalizes the reflection group W associated to R, that is wâ†¦ Fâ‚€wFâ‚€â»Â¹ is an automorphism of W. Thus we get a reflection coset WFâ‚€, which we call a Coxeter coset.\n\nThe  motivation for introducing Coxeter  cosets comes from automorphisms of algebraic  reductive groups, giving rise to non-split reductive groups over finite fields. Let ğ† be a connected reductive algebraic group ğ† over an algebraic  closure ğ”½Ì„_q of a finite field ğ”½_q, defined over ğ”½_q; this corresponds  to a  Frobenius endomorphism  F so  that the finite group of rational  points ğ†(ğ”½_q) identifies to the  subgroup ğ†^F of fixed points under F.\n\nLet  ğ“  be  a  maximal  torus  of  ğ†, and let (X(ğ“),Î¦,Y(ğ“),Î¦áµ›) be the corresponding  root datum (see Rootdata)  which determines ğ† up to  isomorphism; this corresponds to give a root system in the vector space V=â„š âŠ— X(ğ“) and a rational reflection group W=N_ğ†(ğ“)/ğ“ acting on it.\n\nIf  ğ“ is F-stable the Frobenius endomorphism F acts also naturally on X(T)  and defines thus  an endomorphism of  V, which is  of the form q Fâ‚€, where Fâ‚€âˆˆ GL(V) is of finite order and normalizes W. We get thus a Coxeter  coset WFâ‚€âŠ‚GL(V).  The data  (X(ğ“), Î¦,  Y(ğ“), Î¦áµ›,  Fâ‚€), and the integer   q  completely  determine  up   to  isomorphism  the  associated reductive  finite  group  ğ†^F.  Thus  these  data  hold  the  essential information  which determines a  finite reductive group.  All properties of Chevalley  groups that  we provide  are computed  from that  datum: symbols representing conjugacy classes, characters, and finally the whole character table of ğ†^F.\n\nIt  turns out that  many interesting objects  attached to this datum depend only on (V,W, Fâ‚€): the order of the maximal tori, the fakedegrees,  the order of  ğ†^F, symbols representing unipotent characters, Deligne-Lusztig induction in terms of almost_characters,  the  Fourier  matrix  relating characters and almost  characters, etcâ€¦ see, e.g., (BrouÃ© et al., 2014).  It is thus possible to extend  their construction to non-crystallographic  groups (or even to more general complex reflection groups, see spets); this is why we did not include a root system in the definition of a reflection coset. However, unipotent conjugacy classes for instance depend on the root system.\n\nWe assume now that ğ“ is contained in an F-stable Borel subgroup of ğ†. This  defines an order  on the roots,  and there is  a unique element Ï•âˆˆ W Fâ‚€,  the  reduced  element  of  the  coset,  which  preserves the set of positive  roots.  It  thus  defines  a  diagram  automorphism, that is an automorphism  of the Coxeter system (W,S).  This element is stored in the component  .phi of the coset record. It may be defined without mentioning the  roots,  as  follows:  (W,Fâ‚€(S))  is  another  Coxeter  system,  thus conjugate to S by a unique element of W, thus there is a unique element Ï•âˆˆ  WFâ‚€ which  stabilizes S;  a proof  follows from (Bourbaki, 1968; Theoreme 1, chap.  V, Â§3). We  consider thus cosets  of the form  WÏ• where Ï• stabilizes  S. The coset  W Ï• is  completely defined by the permutation .phi  when ğ† is semi-simple â€“- equivalently when Î¦ generates V; in this case we just need to specify phi to define the coset.\n\nThere is a slight generalisation of the above setup, covering in particular the  case of the Ree  and Suzuki groups. We  consider ğ†^F where F not a Frobenius  endomorphism, but  an isogeny  such that  some power  F^n is a Frobenius endomorphism. Then F still defines an endomorphism of V which normalizes  W; we define a real number q such that F^n is attached to an  ğ”½_{qâ¿}-structure. Then we still have F=q Fâ‚€ where Fâ‚€ is of finite order  but q is no more an integer.  Thus Fâ‚€âˆˆ GL(VâŠ— â„) but Fâ‚€âˆ‰ GL(V). For  instance, for the  Ree and Suzuki  groups, Fâ‚€ is  an automorphism of order  2 of W, which is  of type Gâ‚‚, Bâ‚‚ or  Fâ‚„, and q is an odd power  of âˆš2 for Bâ‚‚ and Fâ‚„ and an odd power of âˆš3 for Gâ‚‚ This can be  constructed starting from root systems for Gâ‚‚, Bâ‚‚ or Fâ‚„ where all the   roots  have   the  same   length;  these   root  systems   are  not crystallographic.  We will call here Weyl cosets the cosets corresponding to rational forms of algebraic groups, which include thus some non-rational roots systems for Bâ‚‚, Gâ‚‚ and Fâ‚„.\n\nSpets\n\nWe  now extend the above notions  to general complex reflection groups. Let WâŠ‚  GL(V) be a complex reflection group  on the vector space V. Let Ï• be  an element  of GL(V)  which normalizes  W. Then  the coset  WÏ• is called a reflection coset.\n\nA  reference for  these cosets  is (BrouÃ© et al., 1999).  When W is a so-called Spetsial  group,  they  are  the  basic  object for the construction of a Spetses,  which is an object attached  to a complex reflection group from which  one can  derive combinatorially  some attributes  shared with finite reductive groups, like unipotent degrees, etcâ€¦.\n\nWe  say that  a reflection  coset is  irreducible if  W is irreducible. A general  coset is a direct  product of descents of  scalars, which is the case  where Ï•  is transitive  on the  irreducible components  of W. The irreducible   cosets  have   been  classified   in  (BrouÃ© et al., 1999):  up  to multiplication  of  Ï•  by  a  scalar,  there  is  usually only one or two possible cosets for a given irreducible group.\n\nWe  deal only  with finite  order cosets,  that is,  we assume there is a (minimal) integer Î´ such that (WÏ•)^Î´=W. Then the group generated by W and Ï• is finite, of order Î´|W|.\n\nA  subset C  of a  WÏ• is  called a  conjugacy class  if one of the following equivalent conditions is fulfilled:\n\nC is the orbit of an element in WÏ• under the conjugation action of W.\nC is a conjugacy class of âŸ¨W,Ï•âŸ© contained in WÏ•.\nThe set {wâˆˆ W|wÏ•âˆˆ C} is  a Ï•-conjugacy  class of W (two elements\n\nv,wâˆˆ  W are called Ï•-conjugate, if and only if there exists xâˆˆ W with v=xwÏ•(xâ»Â¹)).\n\nAn irreducible character of âŸ¨W,Ï•âŸ© has some non-zero values on WÏ• if and only if its restriction to W is irreducible. Further, two characters Ï‡â‚ and  Ï‡â‚‚  which  have  same  irreducible  restriction  to  W differ by a character  of  the  cyclic  group  âŸ¨Ï•âŸ©  (which identifies to the quotient âŸ¨W,Ï•âŸ©/W). A set containing one extension to âŸ¨W,Ï•âŸ© of each Ï•-invariant character  of W is called a set  of irreducible characters of WÏ•. Two such  characters  are  orthogonal  for  the  scalar  product  on  the class functions on WÏ• given by Ï‡Ïˆ=WÂ¹_w WÏ‡(wÏ•)overlineÏˆ(wÏ•) For rational groups (Weyl groups), Lusztig has defined a choice of a set of irreducible  characters for  WÏ• (called  the preferred extensions), but for  more  general  reflection  cosets  we  have made some rather arbitrary choices,  which  however  have  the  property  that their values lie in the smallest possible field.\n\nThe  character  table  of  WÏ•  is  the  table  of  values  of  a set of irreducible characters on the conjugacy classes.\n\nA subcoset LwÏ• of WÏ• is given by a reflection subgroup L of W and an element w of W such that wÏ• normalizes L.\n\nWe  then have a natural notion of  restriction of class functions on WÏ• to  class  functions  on  LwÏ•  as  well  as  of  induction in the other direction.  These  maps  are  adjoint  with  respect  to the scalar product defined above, see (BrouÃ© et al., 1999).\n\nIn  this package the most general construction  of a reflection coset is by starting  from a reflection datum, and giving in addition the matrix F of the map Ï•:Vâ†’ V (see spets). However, at present, general cosets are  only implemented for groups represented as permutation groups on a set of roots, and it is required that the automorphism given preserves this set up  to a scalar (it is allowed that  these scalars depend on the pair of an irreducible  component and its image). It is also allowed to specify Ï• by the  permutation it induces on  the roots; in this  case it is assumed that Ï•  acts trivially on the orthogonal of  the roots, but the roots could be those  of a parent  group, generating a  larger space. Thus  in any case we have  a permutation representation of âŸ¨W,Ï•âŸ©  and we consider the coset to be a set of permutations.\n\nReflection  cosets  are  implemented  in  by  a  struct which points to a reflection  group  record  and  has  additional  fields holding F and the corresponding  permutation phi. In the general case, on each component of W  which is  a descent  of scalars,  F will  permute the components and differ  by a scalar on each  component from an automorphism which preserves the  roots. In this case, we have  a permutation phi and a scalar which is stored for that component.\n\nThe  most common situation where cosets  with non-trivial phi arise is as sub-cosets  of reflection groups. Here is an \"exotic\" example, see the next chapter for more classical examples involving Coxeter groups.\n\njulia> W=complex_reflection_group(14)\nGâ‚â‚„\n\njulia> R=reflection_subgroup(W,[2,4])\nGâ‚â‚„â‚â‚‚â‚„â‚=G(-Î¶â‚ƒÂ²âˆš-2)â‚…\n\njulia> RF=spets(R,W(1))\nGâ‚â‚„â‚â‚‚â‚„â‚=Â²G(-Î¶â‚ƒÂ²âˆš-2)â‚…\n\njulia> diagram(RF)\nÏ• acts as (1,2) on the component below\nâ‘¢ â•â•â‘¢ Gâ‚…\n1   2\n\njulia> degrees(RF)\n2-element Vector{Tuple{Int64, Cyc{Int64}}}:\n (6, 1)\n (12, -1)\n\nThe  last line shows for each  reflection degree the corresponding factor of  the coset, which is  the scalar by which  Ï• acts on the corresponding fundamental reflection invariant. The factors characterize the coset.\n\nA  spets by default is  printed in an abbreviated  form which describes its type,  as above (Gâ‚… twisted by 2, with a Cartan matrix which differs from the  standard one by  a factor of  âˆš6). The function  repr gives a form which could be input back in Julia. With the same data as above we have:\n\njulia> print(RF)\nspets(reflection_subgroup(complex_reflection_group(14),[2, 4]),perm\"(1,3)(2,4)(5,9)(6,10)(7,11)(8,12)(13,21)(14,22)(15,23)(16,24)(17,25)(18,26)(19,27)(20,28)(29,41)(30,42)(31,43)(32,44)(33,45)(34,46)(35,47)(36,48)(37,49)(38,50)(39,51)(40,52)(53,71)(54,72)(55,73)(56,74)(57,75)(58,76)(59,77)(60,78)(62,79)(64,80)(65,81)(66,82)(67,69)(68,70)(83,100)(84,101)(85,102)(87,103)(89,99)(90,97)(91,98)(92,96)(93,104)(94,95)(105,113)(106,114)(109,111)(110,112)(115,118)(116,117)(119,120)\")\n\nConjugacy  classes and irreducible characters of Coxeter cosets are defined as  for  general  reflection  cosets.  For  irreducible  characters of Weyl cosets,  we choose (following Lusztig) for each Ï•-stable character of W a  particular extension to a character of  Wâ‹Š âŸ¨Ï•âŸ©, which we will call the preferred extension. The character table of the coset WÏ• is the table of  the restrictions to  WÏ• of the  preferred extensions. The question of finding the conjugacy classes and character table of a Coxeter coset can be reduced to the case of irreducible root systems R.\n\nThe automorphism Ï• permutes the irreducible components of W, and WÏ•  is a direct  product of cosets  where Ï• permutes cyclically the irreducible components of W. The preferred extension is defined to be the  direct  product  of  the  preferred  extension  in  each  of these situations.\nAssume now that WÏ• is a descent of scalars, that is the decomposition in irreducible components W=Wâ‚Ã— â‹¯ Ã— Wâ‚– is cyclically permuted by Ï•. Then there are natural bijections from the Ï•-conjugacy classes of W to  the Ï•áµ-conjugacy classes  of Wâ‚ as  well as from the Ï•-stable characters  of W to the Ï•áµ-stable  characters of Wâ‚, which reduce the  definition of preferred  extensions on WÏ•  to the definition for Wâ‚Ï•áµ.\nAssume now  that W  is the  Coxeter group  of an  irreducible root system.   Ï•  permutes  the  simple   roots,  hence  induces  a  graph automorphism  on  the  corresponding  Dynkin  diagram.  If  Ï•=1  then conjugacy  classes and  characters coincide  with those  of the Coxeter group W.\n\nThe  nontrivial cases for crystallographic roots  systems are (the order of Ï•  is written as left exponent to  the type): Â²Aâ‚™, Â²Dâ‚™, Â³Dâ‚„, Â²Eâ‚†. For  non-crystallographic root  systems where  all the  roots have the same length the additional cases Â²Bâ‚‚, Â²Gâ‚‚, Â²Fâ‚„ and Â²Iâ‚‚(k) arise.\n\nIn  case  Â³Dâ‚„  the  group  Wâ‹Š âŸ¨Ï•âŸ©  can be embedded into the Coxeter  group of type Fâ‚„, which induces a labeling for the conjugacy classes of the coset. The preferred extension is chosen as the (single) extension with rational values.\nIn case  Â²Dâ‚™ the  group Wâ‹Š âŸ¨Ï•âŸ©  is isomorphic  to a Coxeter group of type Bâ‚™. This induces a canonical labeling for the conjugacy classes  of the coset and allows to define the preferred extension in a combinatorial  way  using  the  labels  (pairs  of  partitions) for the characters of the Coxeter group of type Bâ‚™.\nIn the remaining crystallographic cases Ï• identifies to -wâ‚€ where wâ‚€  is the longest element of W.  So, there is a canonical labeling of  the conjugacy classes and characters of  the coset by those of W. The  preferred extensions  are defined  by describing  the signs of the character values on -wâ‚€.\n\nThe  most general  construction of  a Coxeter  coset is  by starting from a Coxeter   datum   specified   by   the   matrices   of   simpleRoots  and simplecoroots,  and  giving  in  addition  the  matrix F0Mat of the map Fâ‚€:Vâ†’ V (see the commands  CoxeterCoset and CoxeterSubCoset). As for Coxeter  groups,  the  elements  of  WÏ•  are  uniquely  determined by the permutation  they  induce  on  the  set  of  roots  R.  We consider these permutations as elements of the Coxeter coset.\n\nCoxeter  cosets are implemented by a struct which points to a Coxeter datum record  and  has  additional  fields  holding F0Mat and the corresponding element  phi. Functions on the coset (for example, classinfo) are about properties  of  the  group  coset  W  Ï•  ;  however, most definitions for elements of untwisted Coxeter groups apply without change to elements in W Ï•:  e.g., if we define the length of  an element wÏ•âˆˆ WÏ• as the number of positive  roots it sends to negative ones, it  is the same as the length of w,  i.e., Ï• is of length 0, since Ï• has been chosen to preserve the set of positive roots. Similarly, the Coxeter word describing wÏ• is the same as the one for w, etcâ€¦\n\nWe associate to a Coxeter coset WÏ• a twisted Dynkin diagram, consisting of  the Dynkin diagram of W and  the graph automorphism induced by Ï• on this  diagram (this  specifies the  group Wâ‹Š  âŸ¨FâŸ©, mentioned above, up to isomorphism).  See  the  functions  refltype,  print  and diagram for Coxeter cosets.\n\nBelow  is an example showing first how to not define, then how to define, the Weyl coset for a Suzuki group:\n\njulia> W=coxgroup(:B,2)\nBâ‚‚\n\njulia> spets(W,Perm(1,2))\nERROR: matrix F must preserve the roots\nStacktrace:\n [1] error(::String) at ./error.jl:33\n [2] spets(::Chevie.Weyl.FCG{Int16,Int64,PRG{Int64,Int16}}, ::Matrix{Int64}) at /home/jmichel/julia/Chevie/src/Cosets.jl:241 (repeats 2 times)\n [3] top-level scope at REPL[19]:1\n\njulia> W=coxgroup(:Bsym,2)\nBsymâ‚‚\n\njulia> WF=spets(W,Perm(1,2))\nÂ²Bsymâ‚‚\n\njulia> CharTable(WF)\nCharTable(Â²Bsymâ‚‚)\nâ”Œâ”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚   â”‚    1 121â”‚\nâ”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚2. â”‚1   1   1â”‚\nâ”‚.11â”‚1  -1  -1â”‚\nâ”‚1.1â”‚. -âˆš2  âˆš2â”‚\nâ””â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nA subcoset HwÏ• of WÏ• is given by a reflection subgroup H of W and an  element w of W  such that wÏ• induces  an automorphism of the root system of H. For algebraic groups, this corresponds to a rational form of a  reductive subgroup of maximal rank.  For example, if WÏ• corresponds to the  algebraic group ğ† and  H is the trivial  subgroup, the coset HwÏ• corresponds to a maximal torus ğ“_w of type w.\n\njulia> W=coxgroup(:Bsym,2)\nBsymâ‚‚\n\njulia> WF=spets(W,Perm(1,2))\nÂ²Bsymâ‚‚\n\njulia> subspets(WF,Int[],W(1))\nÂ²Bsymâ‚‚â‚â‚=Î¦â€´â‚ˆ\n\nA subgroup H which is a parabolic subgroup corresponds to a rational form of  a Levi  subgroup of  ğ†. The  command twistings  gives all rational forms of such a Levi.\n\njulia> W=coxgroup(:B,2)\nBâ‚‚\n\njulia> twistings(W,[1])\n2-element Vector{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}}:\n Bâ‚‚â‚â‚â‚=AÌƒâ‚Î¦â‚\n Bâ‚‚â‚â‚â‚=AÌƒâ‚Î¦â‚‚\n\njulia> twistings(W,[2])\n2-element Vector{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}}:\n Bâ‚‚â‚â‚‚â‚=Aâ‚Î¦â‚\n Bâ‚‚â‚â‚‚â‚=Aâ‚Î¦â‚‚\n\nNotice how we distinguish between subgroups generated by short roots and by long  roots. A general  H corresponds to  a reductive subgroup of maximal rank.  Here we consider the subgroup generated  by the long roots in Bâ‚‚, which  corresponds to a  subgroup of type  SLâ‚‚Ã— SLâ‚‚ in SPâ‚„, and show its possible rational forms.\n\njulia> W=coxgroup(:B,2)\nBâ‚‚\n\njulia> twistings(W,[2,4])\n2-element Vector{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}}:\n Bâ‚‚â‚â‚‚â‚„â‚=Aâ‚Ã—Aâ‚\n Bâ‚‚â‚â‚‚â‚„â‚=(Aâ‚Aâ‚)\n\n\n\n\n\n","category":"module"},{"location":"cosets/#Chevie.Weyl.rootdatum-Tuple{Symbol, Int64}","page":"Reflection cosets and Spets","title":"Chevie.Weyl.rootdatum","text":"rootdatum(type::String or Symbol[,dimension or bond::Integer]) \n\nroot datum from type. The known types are\n\n2B2, 2E6, 2E6sc, 2F4, 2G2, 2I2, 3D4, 3D4sc, 3gpin8, CE6, CE7, E6, E6sc, E7, E7sc, E8, F4, G2, cso, csp, gl, gpin, gpin-, halfspin, pgl, pso, pso-, psp, psu,  ree, sl, slmod, so, so-, sp,  spin, spin-, su, suzuki, tgl, triality, u\n\nThis returns a group or a coset depending if the type is twisted or not.\n\n\n\n\n\n","category":"method"},{"location":"cosets/#Chevie.PermRoot.degrees-Tuple{Spets}","page":"Reflection cosets and Spets","title":"Chevie.PermRoot.degrees","text":"degrees(WF::Spets) the generalized degrees of WF.\n\nLet  W be  the group  of the  reflection coset  WF, and  let V be the vector  space  of  dimension  rank(W)  on  which W acts as a reflection group.  Let  fâ‚,â€¦,fâ‚™  be  the  basic  invariants  of W on the symmetric algebra  SV of V;  they can be  chosen so they  are eigenvectors of the matrix  WF.F. The corresponding  eigenvalues are called  the factors of F acting on V; they characterize the coset â€“- they are equal to 1 only for  the trivial  coset. The  generalized degrees  of WF  are the pairs formed of the reflection degrees and the corresponding factor.\n\njulia> W=coxgroup(:E,6)\nEâ‚†\n\njulia> WF=spets(W)\nEâ‚†\n\njulia> phi=W(6,5,4,2,3,1,4,3,5,4,2,6,5,4,3,1);\n\njulia> HF=subspets(WF,2:5,phi)\nEâ‚†â‚â‚‚â‚ƒâ‚„â‚…â‚=Â³Dâ‚„Î¦â‚ƒ\n\njulia> diagram(HF)\nÏ• acts as (1,2,4) on the component below\n  O 2\n  ï¿¨\nOâ€”Oâ€”O Dâ‚„\n1 3 4\n\njulia> degrees(HF)\n6-element Vector{Tuple{Int64, Cyc{Int64}}}:\n (1, Î¶â‚ƒ)\n (1, Î¶â‚ƒÂ²)\n (2, 1)\n (4, Î¶â‚ƒ)\n (6, 1)\n (4, Î¶â‚ƒÂ²)\n\n\n\n\n\n","category":"method"},{"location":"cosets/#Chevie.Cosets.spets","page":"Reflection cosets and Spets","title":"Chevie.Cosets.spets","text":"spets(W::ComplexReflectionGroup, Fâ‚€::Matrix=I(rank(W)))\n\nThis  function returns a CoxeterCoset or a  Spets. Let V be the space on which W acts. The matrix Fâ‚€ must be in GL(V), for a finite Coxeter group  induce  an  automorphism  of  the  root  system of parent(W) which stabilizes the roots of W, or for a more general complex reflection group just stabilize parent(W) and W.\n\nThe returned struct has in particular the following fields:\n\n.W: the group W\n.F: the matrix acting on V which represents the unique element phi in WFâ‚€ which preserves the positive roots (for finite Coxeter groups) or some \"canonical\" representative of the coset for more general complex reflection groups.\n.phi:  a Perm, the permutation of the roots of W induced by .F (for general  complex reflection groups this may be a permutation up to scalars) (also   for  Coxeter  groups   the  element  of   smallest  length  in  the NormalCoset W .phi).\n\nIn the first example we create a Coxeter coset corresponding to the general unitary group GU_3(q) over the finite field FF(q).\n\njulia> W=rootdatum(:gl,3)\nglâ‚ƒ\n\njulia> gu3=spets(W,-reflrep(W,W()))\nÂ²Aâ‚‚Î¦â‚‚\n\njulia> F4=coxgroup(:F,4);D4=reflection_subgroup(F4,[1,2,16,48])\nFâ‚„â‚â‚â€šâ‚‚â€šâ‚‰â€šâ‚â‚†â‚=Dâ‚„â‚â‚ƒâ‚‚â‚â‚„â‚\n\njulia> spets(D4,[1 0 0 0;0 1 2 0;0 0 0 1;0 0 -1 -1])\nFâ‚„â‚â‚‰â€šâ‚â‚†â€šâ‚â€šâ‚‚â‚=Â³Dâ‚„â‚â‚ƒâ‚„â‚â‚‚â‚\n\nspets(W::ComplexReflectionGroup,p::Perm)\n\nIn  this version F is  defined by the permutation  of the simple roots it does.\n\njulia> W=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> spets(W,Perm(1,3))\nÂ²Aâ‚ƒ\n\n\n\n\n\nspets(s::String) builds some exceptional spets\n\njulia> spets(\"3G422\")\nÂ³Gâ‚„â€šâ‚‚â€šâ‚‚\n\njulia> spets(\"2G5\")\nÂ²G(Î¶â‚ƒÂ²âˆš-2)â‚…\n\njulia> spets(\"3G333\")\nGâ‚ƒâ€šâ‚ƒâ€šâ‚ƒâ‚â‚â€šâ‚‚â€šâ‚ƒâ€šâ‚„â‚„â‚=Â³Gâ‚ƒâ€šâ‚ƒâ€šâ‚ƒâ‚â‚â€šâ‚‚â€šâ‚ƒâ€šâ‚„â‚„â‚\n\njulia> spets(\"3pG333\")\nGâ‚ƒâ€šâ‚ƒâ€šâ‚ƒâ‚â‚â€šâ‚‚â€šâ‚ƒâ€šâ‚„â‚„â‚=Â³Gâ‚ƒâ€šâ‚ƒâ€šâ‚ƒâ‚â‚â€šâ‚‚â€šâ‚ƒâ€šâ‚„â‚„â‚\n\njulia> spets(\"4G333\")\nGâ‚ƒâ€šâ‚ƒâ€šâ‚ƒâ‚â‚‚â€šâ‚â‚‚â€šâ‚â‚â€šâ‚â‚†â€šâ‚…â‚ƒâ€šâ‚â‚€â€šâ‚„â‚ƒâ€šâ‚ƒâ‚†â‚=â´Gâ‚ƒâ€šâ‚ƒâ€šâ‚ƒâ‚â‚â€šâ‚‚â€šâ‚ƒâ€šâ‚ƒâ‚‚â€šâ‚â‚†â€šâ‚ƒâ‚†â€šâ‚ƒâ‚€â€šâ‚â‚€â‚\n\n\n\n\n\n","category":"function"},{"location":"cosets/#Chevie.Cosets.twistings","page":"Reflection cosets and Spets","title":"Chevie.Cosets.twistings","text":"twistings(W,I)\n\nW  should be a  complex reflection group.\n\nThe  function returns  the list,  up to  W-conjugacy, of  subspets of W whose  group is reflection_subgroup(W,I) â€“- In  the case of Weyl groups, it  corresponds to  representatives of  the possible  twisted forms  of the reductive subgroup of maximal rank L corresponding to reflection_subgroup(W,I).   These  are  classified   by  the  classes  of N_W(L)/L.\n\nW  could also be a coset WÏ•; then the subgroup L must be conjugate to Ï•(L)  for a  rational form  to exist.  If wÏ•  normalizes L,  then the rational forms are classified by the the wÏ•-classes of N_W(L)/L.\n\njulia> W=coxgroup(:E,6)\nEâ‚†\n\njulia> WF=spets(W,Perm(1,6)*Perm(3,5))\nÂ²Eâ‚†\n\njulia> twistings(W,2:5)\n3-element Vector{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}}:\n Eâ‚†â‚â‚‚â‚ƒâ‚„â‚…â‚=Dâ‚„Î¦â‚Â²\n Eâ‚†â‚â‚‚â‚ƒâ‚„â‚…â‚=Â³Dâ‚„Î¦â‚ƒ\n Eâ‚†â‚â‚‚â‚ƒâ‚„â‚…â‚=Â²Dâ‚„Î¦â‚Î¦â‚‚\n\n\njulia> twistings(WF,2:5)\n3-element Vector{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}}:\n Â²Eâ‚†â‚â‚‚â‚ƒâ‚„â‚…â‚=Â²Dâ‚„â‚â‚â‚„â‚ƒâ‚‚â‚Î¦â‚Î¦â‚‚\n Â²Eâ‚†â‚â‚‚â‚ƒâ‚„â‚…â‚=Â³Dâ‚„â‚â‚â‚„â‚ƒâ‚‚â‚Î¦â‚†\n Â²Eâ‚†â‚â‚‚â‚ƒâ‚„â‚…â‚=Dâ‚„Î¦â‚‚Â²\n\n\n\n\n\ntwistings(W)\n\nW  should be a Coxeter group which is not a proper reflection subgroup of another reflection group (so that inclusion(W)==eachindex(roots(W))). The function returns all spets representing twisted forms of algebraic groups of type W.\n\njulia> twistings(coxgroup(:A,3)*coxgroup(:A,3))\n8-element Vector{Spets{FiniteCoxeterGroup{Perm{Int16},Int64}}}:\n Aâ‚ƒÃ—Aâ‚ƒ\n Aâ‚ƒÃ—Â²Aâ‚ƒ\n Â²Aâ‚ƒÃ—Aâ‚ƒ\n Â²Aâ‚ƒÃ—Â²Aâ‚ƒ\n (Aâ‚ƒAâ‚ƒ)\n Â²(Aâ‚ƒAâ‚ƒ)\n Â²(Aâ‚ƒAâ‚ƒ)â‚â‚â‚‚â‚ƒâ‚†â‚…â‚„â‚\n (Aâ‚ƒAâ‚ƒ)â‚â‚â‚‚â‚ƒâ‚†â‚…â‚„â‚\n\njulia> twistings(coxgroup(:D,4))\n6-element Vector{Spets{FiniteCoxeterGroup{Perm{Int16},Int64}}}:\n Dâ‚„\n Â²Dâ‚„â‚â‚‚â‚„â‚ƒâ‚â‚\n Â²Dâ‚„\n Â³Dâ‚„\n Â²Dâ‚„â‚â‚â‚„â‚ƒâ‚‚â‚\n Â³Dâ‚„â‚â‚â‚„â‚ƒâ‚‚â‚\n\njulia> W=rootdatum(:so,8)\nsoâ‚ˆ\n\njulia> twistings(W)\n2-element Vector{Spets{FiniteCoxeterGroup{Perm{Int16},Int64}}}:\n Dâ‚„\n Â²Dâ‚„\n\n\n\n\n\n\n","category":"function"},{"location":"cosets/#Chevie.Rootdata.torus-Tuple{AbstractMatrix}","page":"Reflection cosets and Spets","title":"Chevie.Rootdata.torus","text":"torus(m::AbstractMatrix)\n\nm  should be a matrix of finite order. The function returns the coset T of  the  trivial  group  such  that  T.F==m.  When  m  is  integral his corresponds to an algebraic torus ğ“ of rank size(m,1), with an isogeny which acts by m on X(ğ“).\n\njulia> torus([0 -1;1 -1])\nÎ¦â‚ƒ\n\n\n\n\n\n","category":"method"},{"location":"cosets/#Chevie.Rootdata.torus-Tuple{Spets, Integer}","page":"Reflection cosets and Spets","title":"Chevie.Rootdata.torus","text":"torus(W,i)\n\nwhere  W is  a Spets  or a  ComplexReflectionGroup. This  returns the torus  twisted by  a representative  of the  i-th conjugacy class of W. This is the same as twistings(W,Int[])[i].\n\njulia> W=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> twistings(W,Int[])\n5-element Vector{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}}:\n Aâ‚ƒâ‚â‚=Î¦â‚Â³\n Aâ‚ƒâ‚â‚=Î¦â‚Â²Î¦â‚‚\n Aâ‚ƒâ‚â‚=Î¦â‚Î¦â‚‚Â²\n Aâ‚ƒâ‚â‚=Î¦â‚Î¦â‚ƒ\n Aâ‚ƒâ‚â‚=Î¦â‚‚Î¦â‚„\n\njulia> torus(W,2)\nAâ‚ƒâ‚â‚=Î¦â‚Â²Î¦â‚‚\n\njulia> WF=spets(W,Perm(1,3))\nÂ²Aâ‚ƒ\n\njulia> twistings(WF,Int[])\n5-element Vector{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}}:\n Â²Aâ‚ƒâ‚â‚=Î¦â‚‚Â³\n Â²Aâ‚ƒâ‚â‚=Î¦â‚Î¦â‚‚Â²\n Â²Aâ‚ƒâ‚â‚=Î¦â‚Â²Î¦â‚‚\n Â²Aâ‚ƒâ‚â‚=Î¦â‚‚Î¦â‚†\n Â²Aâ‚ƒâ‚â‚=Î¦â‚Î¦â‚„\n\njulia> torus(WF,2)\nÂ²Aâ‚ƒâ‚â‚=Î¦â‚Î¦â‚‚Â²\n\n\n\n\n\n","category":"method"},{"location":"cosets/#Chevie.Cosets.graph_automorphisms","page":"Reflection cosets and Spets","title":"Chevie.Cosets.graph_automorphisms","text":"graph_automorphisms(t::Vector{TypeIrred})\n\nGiven  the refltype of a  finite Coxeter group, returns  the group of all Graph automorphisms of t as a group of permutations of indices(t).\n\njulia> W=coxgroup(:D,4)\nDâ‚„\n\njulia> graph_automorphisms(refltype(W*W))\nGroup((1,5)(2,6)(3,7)(4,8),(1,2),(1,4))\n\n\n\n\n\n","category":"function"},{"location":"cosets/#Chevie.Cosets.subspets","page":"Reflection cosets and Spets","title":"Chevie.Cosets.subspets","text":"subspets(WF,I,w=one(Group(WF)))\n\nReturns   the   reflection   subcoset   of   the   coset  WF  with  group reflection_subgroup(Group(WF),I)  and torsion w*WF.phi.  w must be an element  of Group(WF) such that  w*WF.phi normalizes the subroot system generated by I.\n\njulia> WF=spets(coxgroup(:F,4))\nFâ‚„\n\njulia> w=transporting_elt(Group(WF),[1,2,9,16],[1,9,16,2],ontuples);\n\njulia> LF=subspets(WF,[1,2,9,16],w)\nFâ‚„â‚â‚â€šâ‚‚â€šâ‚‰â€šâ‚â‚†â‚=Â³Dâ‚„â‚â‚ƒâ‚„â‚â‚‚â‚\n\njulia> diagram(LF)\nÏ• acts as (2,3,4) on the component below\n  O 4\n  ï¿¨\nOâ€”Oâ€”O Dâ‚„\n3 1 2\n\n\n\n\n\n","category":"function"},{"location":"cosets/#Chevie.Cosets.Frobenius","page":"Reflection cosets and Spets","title":"Chevie.Cosets.Frobenius","text":"Frobenius(WF)(x,i=1)\n\nIf   WF  is  a  Coxeter  coset  associated  to  the  Coxeter  group  W, Frobenius(WF)  returns a  function F  such that  xâ†¦ F(x,i=1) does the automorphism induced by WF.phi^i on the object x.\n\njulia> W=coxgroup(:D,4)\nDâ‚„\n\njulia> WF=spets(W,Perm(1,2,4))\nÂ³Dâ‚„\n\njulia> u=unichar(W,2)\n[Dâ‚„]:<11->\n\njulia> F=Frobenius(WF);F(u)\n[Dâ‚„]:<.211>\n\njulia> F(u,-1)\n[Dâ‚„]:<11+>\n\njulia> F(1)\n4\n\n\n\n\n\n","category":"function"},{"location":"garside/#Garside-monoids-and-groups,-braids.","page":"Garside monoids and groups, braids.","title":"Garside monoids and groups, braids.","text":"Pages=[\"garside.md\"]","category":"section"},{"location":"garside/#Chevie.Garside","page":"Garside monoids and groups, braids.","title":"Chevie.Garside","text":"Garside  monoids are a general class  of monoids whose most famous examples are  the braid and dual braid monoids. They have groups of fractions, which in  both above examples is the braid  group. We implement braid groups as a special case of a general implementation of Garside monoids and groups.\n\nLet  us first  introduce some  vocabulary about  divisibility in monoids. A left-divisor  of x is a d such that there exists y with x=dy (and then  we say that x is  a right multiple of d,  and write dâ‰¼ x). We say  that a monoid M  is left cancellable if  an equality dx=dy implies x=y.  We  define  symmetrically  right-divisors,  left  multiples,  right cancellability  and the symbol â‰½. We say that x is an atom if 1 and x  are its only left or right divisors. A  left gcd of x and y is a common  left  divisor  d  of  x  and  y  such  that  any other common left-divisor  is a left-divisor of d. Similarly  a right lcm of x and y  is  a  common  multiple  which  is  a left-divisor of any other common multiple.\n\nWe  call Garside a monoid M which:\n\nis left and right cancellable.\nis generated by its atoms.\nadmits left and  right  gcds  and  lcms.\nis such that any element has only finitely many left (or right) divisors.\nadmits a Garside element, which is an element Î” whose set of left and right-divisors coincide and generate M.\n\nGarside  elements are not  unique, but there  is a unique  minimal one (for divisibility);  we assume that  a Garside element  Î” has been chosen. The divisors  of Î” are called  the simples of M.  A Garside monoid embeds into  its group of fractions, which is called a Garside group; the monoid defines  a Garside structure for the group of fractions. A group may have several  different Garside structures, for  instance braid groups of finite Coxeter groups have an ordinary and a dual braid monoid.\n\nWe  implement more generally locally Garside monoids, which have the same axioms,  excepted the  existence of  Garside elements  and that lcms do not always  exist, but exist if any common  multiple exists. The set of simples is not defined by a Garside element, but by the condition that they contain the   atoms  and   are  closed   under  lcms   and  taking   divisors,  see (Bessis et al., 2002);  each element is still  divisible by finitely many simples, but  the set  of simples  may be  infinite. The  main example  is the Artin monoid  of  an  infinite  Coxeter  group.  It  is not known whether locally Garside  monoids embed in their group  of fractions, although this has been proved  for Artin  monoids of  Coxeter groups  by (Paris, 2002). In this case  computing in the monoid does not  help for computing in the group; we implement for these cases only the monoid.\n\nThere  is another  generalization, quasi-Garside  monoids, where we relax the  axiom  that  an  element  has  finititely  many divisors (there may me infinitely atoms). We do not implement this in this module, but the package AffineA  implements, following the work of FranÃ§ois Digne, the dual braid monoid of the affine Coxeter group W(AÌƒâ‚™) which is quasi-Garside.\n\nWhat allows computing with Garside and locally Garside monoids, and Garside groups, is the fact that their elements admit normal forms â€“- these normal forms were exhibited for braid monoids of Coxeter groups by (Deligne, 1972), who extended earlier work of (Brieskorn and Saito, 1972) and (Garside, 1969):\n\nLet M be a locally Garside monoid. Then for any bâˆˆ M there is a unique  maximal (for divisibility) simple left-divisor Î±(b) of b. In a Garside monoid it is the leftgcd(b,Î”).\nLet M be a Garside monoid with Garside element Î” and group of fractions G. Then for any xâˆˆ  G, for large enough i we have Î”â±xâˆˆ M.\n\nA  consequence  of  1.  is  that  every  element  of  M  has  a canonical decomposition as a product of simples, its left-greedy normal form. If we define   Ï‰(x)  by   x=Î±(x)Ï‰(x),  then   the  normal   form  of  x  is Î±(x)Î±(Ï‰(x))Î±(Ï‰^2(x))â€¦.  For locally Garside monoids  we use this sequence of  simples to represent elements of M. When  M is Garside we use 2. to represent  any element of G:  given xâˆˆ G we  compute the smallest power i  such that Î”â±xâˆˆ M,  and we represent x  by the pair (-i,Î”â±x). The second  term is an element of M,  not divisible by Î”, that we represent by the sequence of simples that make up its normal form (this sequence thus does not contain the identity or Delta).\n\nIn  our implementation a  Garside monoid is  a parametrized type whose most general  instance is the abstract  type LocallyGarsideMonoid{T} where T is the type of the simples.\n\nWe  now describe Artin-Tits braid monoids. Let (W,S) be a Coxeter system, that is W has presentation\n\nâŸ¨sâˆˆ Sâˆ£sÂ²=1, stsâ‹¯ =tstâ‹¯   (mâ‚›â‚œ factors on each side) for s,tâˆˆ SâŸ©\n\nfor some Coxeter matrix mâ‚›â‚œ. The braid group B associated to (W,S) is the group defined by the presentation\n\nâŸ¨ğ¬âˆˆ ğ’âˆ£ ğ¬ğ­ğ¬â‹¯ =ğ­ğ¬ğ­â‹¯  (mâ‚›â‚œ factors on each side) for ğ¬,ğ­âˆˆ ğ’âŸ©\n\nThe  associated positive braid  monoid Bâº is  the monoid defined by the presentation above â€“- it identifies with the submonoid of B generated by ğ’  by (Paris, 2002). This  monoid is locally  Garside, with the set of simples  in bijection with  the elements of  W and with  ğ’ as atoms; we will  denote by  ğ–  the set  of simples,  and by  ğ° â†”  w the bijection between  simples and elements of W. The group W has a length defined in terms of reduced expressions. Similarly, having only homogeneous relations, Bâº  has a natural length function. Then  ğ– can be characterised as the subset of elements of Bâº with the same length as their image in W.\n\nIf  W is finite, then Bâº is Garside with Garside element the element of ğ– whose image is the longest element  of W. \n\nGiven a Coxeter group W,\n\njulia> W=coxgroup(:A,4)\nAâ‚„\n\njulia> B=BraidMonoid(W)\nBraidMonoid(Aâ‚„)\n\nconstructs  the associated braid monoid, and  then, used as a function, B constructs  elements of the braid monoid (or group when W is finite) from a list of generators indices (or negative numbers representing inverses of generators) given as arguments:\n\njulia> w=B(1,2,3,4) # represents ğ¬â‚ğ¬â‚‚ğ¬â‚ƒğ¬â‚„\n1234\n\nThe  operations *  and ^  (exponentiation) are  implemented for locally Garside  elements (and also multiplication of an element by a simple), and, in the Garside case, \\ and / (left and right division), inv and ^, and conjugation of an element by a simple.\n\njulia> w*w\n1213243.4\n\njulia> w*W(1) # multiplication by a simple\n12134\n\njulia> W(1)*w\n1.1234\n\njulia> w^3  # the terms of the normal form are printed separated by a .\n121321432.343\n\njulia> B(1,2)\\w\n34\n\njulia> w/B(3,4)\n12\n\njulia> w^B(1) # conjugation\n2134\n\njulia> w^W(1) # conjugation by a simple\n2134\n\njulia> word(Î±(w^3))\n9-element Vector{Int64}:\n 1\n 2\n 1\n 3\n 2\n 1\n 4\n 3\n 2\n\njulia> w^4\nÎ”.232432\n\njulia> inv(w)\n(1234)â»Â¹\n\njulia> B(-4,-3,-2,-1) # another way of entering the same element\n(1234)â»Â¹\n\nHow  an  element  of  a  Garside  group  is  printed  is  controlled by the IOcontext  attribute  ':greedy'.  By  default,  elements  are  printed as fractions aâ»Â¹b where a and b have no left common divisor, and a and b  are printed using the left-greedy normal form, that is a maximal power of  the Garside element followed by the  rest. One can print the element in the  left-greedy  normal  from  without  writing  it as a fraction first by setting  the IOContext  :greedy=>true; with  the same  w as  above we have:\n\njulia> xrepr(w^-1,greedy=true,limit=true)\n\"Î”â»Â¹.232432\"\n\nBy default,  repr gives   w  back   in  a   form  which   after  assigning B=BraidMonoid(W) can be input back into Julia:\n\njulia> repr(w)\n\"B(1,2,3,4)\"\n\njulia> repr(w^3)\n\"B(1,2,1,3,2,1,4,3,2,3,4,3)\"\n\njulia> repr(w^-1)\n\"B(-4,-3,-2,-1)\"\n\nIn  general elements  of a  Garside monoid  are displayed  as a list of the indices of their constituting atoms.\n\nWe  now describe the  dual braid monoid.  First we define interval monoids. Given a group W and a set S of generators of W as a monoid, for wâˆˆW we  define the  length l_S(w)  as the  minimum number  of elements of S needed  to write w.  We then define  left-divisors of x  as those dâˆˆW such  that there exists y with  x=dy and l_S(d)+l_S(y)=l_S(x). We say that  wâˆˆ W is balanced if its set of left and right divisors coincide; in this  case we denote  this set by  [1,w], an interval  for the poset of S-divisibility.  We say that w  is Garside for l_S  if it is balanced and  [1,w] is a lattice (where upper and lower bounds are lcms and gcds), and generates W. Then we have the theorem:\n\nIf w is Garside for the l_S, the monoid M with generators [1,w] and relations  xy=z whenever xy=z holds  in W and l_S(x)+l_S(y)=l_S(z), is  a Garside monoid, with simples [1,w]  and atoms S. It is called the interval monoid defined by l_S and the interval [1,w].\n\nThe  Artin-Tits braid monoid  is an interval  monoid by taking  for S the Coxeter  generators, in which case l_S  is the Coxeter length, and taking for w the longest element of W. The dual monoid, constructed by Birman, Ko  and  Lee  for  type  A  and  by Bessis for all well-generated complex reflection  groups, is obtained in  a similar way, by  taking this time for w a Coxeter element, for l_S the reflection length (see reflection_length)  and for atoms  the reflections which  divide w for the  reflection length (for Coxeter groups all reflections divide a Coxeter element  but this  is not  the case  for well-generated  complex reflection groups);  the simples of the dual monoid are of cardinality the generalized Catalan numbers (see catalan). An interval monoid has naturally a morphism  image Mâ†’W, which is the quotient map which sends back simple braids to [1,w].\n\nA last pertinent notion is reversible monoids. Since we store left normal forms,  it is easy to compute left lcms and gcds, but hard to compute right lcms  and gcds. But this becomes easy to  do if the monoid has an operation 'reverse',  which has the property that 'a' is a left-divisor of 'b' if and only  if 'reverse(a)'  is a  right-divisor of  'reverse(b)'. This holds for Artin-Tits  and dual braid monoids of groups generated by true reflections; Artin-Tits monoids have a reverse operation which consists of reversing a word,  written  as  a  list  of  atoms.  The above dual monoids also have a reverse  operation defined  in the  same way,  but this operation changes monoid:  it goes from  the dual monoid  for the Coxeter  element w to the dual  monoid for the  Coxeter element wâ»Â¹.  The operations 'rightlcm' and 'rightgcd' for non-simple elements are only implemented if the monoid has a reverse operation.\n\nA  finite Coxeter group is also a  reflection group in a real vector space, thus  in its complexified V, and B also has a topological definition as the  fundamental group of  the space VÊ³áµ‰áµ/W,  where VÊ³áµ‰áµ is  the set of elements  of  V  which  are  not  fixed by any non-identity element. This definition  of  a  braid  group  can  be  extended  to  any  finite complex reflection  group, and following  the work of  Bessis we also implement the dual braid monoid of well-generated complex reflection groups.\n\nThis  module implements also  functions to solve  the conjugacy problem and compute   centralizers   in   Garside   groups,   following   the  work  of (Franco and GonzÃ¡lez-Meneses, 2003) and (Gebhardt and GonzÃ¡lez-Meneses, 2010).\n\nTwo  elements w and w' of a monoid  M are conjugate in M if there exists  xâˆˆ M such that wx=xw'; if  M satisfies the Ã–re conditions, it has  a  group  of  fractions  where  this  becomes  xâ»Â¹wx=w',  the  usual definition  of conjugacy. A special case  which is even closer to conjugacy in  the group is if there exists yâˆˆ  M such that w=xy and w'=yx. This relation  is not transitive in general,  but we call cyclic conjugacy the transitive closure of this relation, a restricted form of conjugacy.\n\nThe next observation is that if w,w'âˆˆM where M is Garside are conjugate in  the group  of fractions  G then  they are  conjugate in M, since if wx=xw'  then there is a  power Î”â± which is  central and such that xÎ”â±âˆˆ M. Then wxÎ”â±=xÎ”â± w' is a conjugation in M.\n\nThe crucial notions for solving the conjugacy problem in Garside groups are inf(w):=sup{i such that Î”â»â±wâˆˆ M} and sup(w):=inf{i such that wâ»Â¹Î”â±âˆˆ M}: the  number of conjugates of w with same inf and sup as w is finite (since  our monoids have a finite number of simples). Further, a theorem of Birman  shows that the maximum inf and minimum sup in a conjugacy class can  be  achieved  simultaneously  (by  iterated cycling and decycling. See Garside.cycle   and   Garside.decycle);   the  elements achieving  this are  called the  super summit  set of w, denoted SS(w). Thus  a  way  to  determine  if  w  and  w'  are  conjugate  is to find representatives  wâ‚âˆˆSS(w), w'â‚âˆˆSS(w'),  and then  enumerate SS(w) and see  if it contains w'â‚. This can also be used to compute the centralizer of  an element:  if we  consider the  super summit  set as a category whose objects  are  its  elements  and  morphisms  are the conjugations by simple elements,  the centralizer  of wâ‚  is given  by the endomorphisms of that object.   For  the  implementation   of  finite  categories   we  use,  see Category and endomorphisms.\n\nWe illustrate this on an example:\n\njulia> b=B(2,1,4,1,4)\n214.14\n\njulia> c=B(1,4,1,4,3)\n14.143\n\njulia> d=conjugating_elt(b,c) # would return nothing if b, c are not conjugate\n(1)â»Â¹21321432\n\njulia> b^d\n14.143\n\njulia> centralizer_gens(b)\n3-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:\n 321432.213243\n 21.1\n 4\n\njulia> C=conjcat(b;ss=Val(:ss)) # SS(b) as a category\ncategory with 10 objects and 32 generating maps\n\njulia> C.obj # the elements of SS(b). Notice it contains c\n10-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:\n 1214.4\n 214.14\n 124.24\n 1343.1\n 14.124\n 143.13\n 24.214\n 134.14\n 13.134\n 14.143\n\nThere is a faster solution to the conjugacy problem given in (Gebhardt and GonzÃ¡lez-Meneses, 2010): for  each bâˆˆM, they  define a particular  simple left-divisor of b, its preferred_prefix  such that the  operation slide which cyclically conjugates  b by  its preferred  prefix, is  eventually periodic, and the period  is contained in the super summit set  of x. We say that x is in its  sliding circuit if some iterated slide of x is equal to x. The set of  sliding circuits in a  given conjugacy class is  smaller than the super summit  set, thus allows to solve  the conjugacy problem faster. Continuing from the above example,\n\njulia> word(W,preferred_prefix(b))\n2-element Vector{Int64}:\n 2\n 1\n\njulia> b^B(preferred_prefix(b))\n1214.4\n\njulia> C=conjcat(b) # with no Val argument computes the sliding circuits\ncategory with 2 objects and 6 generating maps\n\njulia> C.obj # the elements of the sliding circuits\n2-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:\n 1214.4\n 1343.1\n\nFinally, we have implemented the algorithm of (Zheng, 2006) to extract roots in a Garside monoid:\n\njulia> W=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> B=BraidMonoid(W)\nBraidMonoid(Aâ‚ƒ)\n\njulia> Pi=B(B.Î´)^2\nÎ”Â²\n\njulia> root(Pi,2)\nÎ”\n\njulia> root(Pi,3)\n1232\n\njulia> root(Pi,4)\n132\n\n\n\n\n\n","category":"module"},{"location":"garside/#Chevie.Garside.LocallyGarsideMonoid","page":"Garside monoids and groups, braids.","title":"Chevie.Garside.LocallyGarsideMonoid","text":"LocallyGarsideMonoid{T}  is the abstract type of locally Garside monoids, where  T  is  the  type  of  simples.  Such a monoid M needs, for a,b simples, to implement the functions\n\none(M)\nisleftdescent(M,a::T,i::Integer)  whether M.atoms[i]â‰¼ a\nisrightdescent(M,a::T,i::Integer) whether aâ‰½ M.atoms[i]\nisrightascent(M,a::T,i::Integer)  whether a*M.atoms[i] is simple\n*(M,a::T,b::T)  when a*b is simple returns the simple a*b\n\\(M,a::T,b::T) when aâ‰¼ b returns the simple a\b\n/(M,a::T,b::T)  when aâ‰½ b returns the simple a/b\n\n\n\n\n\n","category":"type"},{"location":"garside/#Chevie.Garside.GarsideMonoid","page":"Garside monoids and groups, braids.","title":"Chevie.Garside.GarsideMonoid","text":"GarsideMonoid{T}  is the abstract  type of Garside  monoids, where T is the type of simples. Such a monoid M should implement the same methods as LocallyGarsideMonoid  except  that  isrightascent(M,a) is automatically defined as isleftdescent(M,\\(M,a,M.Î´),i).\n\nAn implementation should have fields M.Î´, M.stringÎ´\n\nAn interval monoid should have a field M.orderÎ´.\n\n\n\n\n\n","category":"type"},{"location":"garside/#Chevie.CoxGroups.isleftdescent-Tuple{BraidMonoid, Any, Int64}","page":"Garside monoids and groups, braids.","title":"Chevie.CoxGroups.isleftdescent","text":"isleftdescent(M,w,i)\n\nreturns true if and only if the i-th atom of the locally Garside monoid M left-divides the simple w.\n\n\n\n\n\n","category":"method"},{"location":"garside/#Chevie.CoxGroups.leftdescents-Tuple{Chevie.Garside.LocallyGarsideElt}","page":"Garside monoids and groups, braids.","title":"Chevie.CoxGroups.leftdescents","text":"leftdescents(b::LocallyGarsideElt) the list of indices of the atoms which left-divide b\n\n\n\n\n\n","category":"method"},{"location":"garside/#Chevie.Garside.rightascents","page":"Garside monoids and groups, braids.","title":"Chevie.Garside.rightascents","text":"rightascents(M,s) where s is a simple return the right ascents of s, that is the list of i such that s*M.atoms[i] is still simple.\n\n\n\n\n\n","category":"function"},{"location":"garside/#Chevie.Garside.left_divisors","page":"Garside monoids and groups, braids.","title":"Chevie.Garside.left_divisors","text":"left_divisors(M::LocallyGarsideMonoid, s)\n\nleft_divisors(M::LocallyGarsideMonoid, s,i)\n\nall  the left-divisors  of the  simple element  s of  M, as a vector of vectors   of  simples,  where  the  i+1-th  vector  of  simples  holds  the left-divisors  of length i in the atoms.  If a third argument i is given, returns the list of divisors of length i.\n\njulia> W=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> B=BraidMonoid(W)\nBraidMonoid(Aâ‚ƒ)\n\njulia> map(x->B.(x),left_divisors(B,W(1,3,2)))\n4-element Vector{Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}}:\n [.]\n [1, 3]\n [13]\n [132]\n\njulia> B=DualBraidMonoid(W)\nDualBraidMonoid(Aâ‚ƒ,c=[1, 3, 2])\n\njulia> map(x->B.(x),left_divisors(B,W(1,3,2)))\n4-element Vector{Vector{GarsideElt{Perm{Int16}, DualBraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}}:\n [.]\n [1, 2, 3, 4, 5, 6]\n [12, 13, 15, 25, 34, 45]\n [Î´]\n\n\n\n\n\nleft_divisors(b::LocallyGarsideElt[, i])\n\nreturns all left-divisors of b (left-divisors of length i if specified)\n\njulia> B=DualBraidMonoid(coxsym(4))\nDualBraidMonoid(ğ”– â‚„,c=[1, 3, 2])\n\njulia> left_divisors(B(1,5,4,3))\n10-element Vector{GarsideElt{Perm{Int16}, DualBraidMonoid{Perm{Int16}, CoxSym{Int16}}}}:\n .\n 1\n 1.4\n 1.4.2\n 1.4.3\n 5\n 6\n 15\n 15.4\n 15.4.3\n\njulia> left_divisors(B(1,5,4,3),1)\n3-element Vector{GarsideElt{Perm{Int16}, DualBraidMonoid{Perm{Int16}, CoxSym{Int16}}}}:\n 1\n 5\n 6\n\n\n\n\n\n","category":"function"},{"location":"garside/#Chevie.Garside.leftgcd","page":"Garside monoids and groups, braids.","title":"Chevie.Garside.leftgcd","text":"leftgcd(M::LocallyGarsideMonoid,sâ‚,â€¦,sâ‚™) leftgcdc(M::LocallyGarsideMonoid,sâ‚,â€¦,sâ‚™)\n\nsâ‚,â€¦,sâ‚™ should be simples of M. The  function returns the left gcd d of the sáµ¢.\n\nleftgcdc returns (d,(dâ»Â¹sâ‚,â€¦,dâ»Â¹sâ‚™))\n\n\n\n\n\nleftgcd(aâ‚,â€¦,aâ‚™) leftgcdc(aâ‚,â€¦,aâ‚™)\n\naâ‚,â€¦,aâ‚™  should be  elements of  the same  (locally) Garside  monoid. The function returns the left gcd d of aâ‚,â€¦,aâ‚™.\n\nleftgcdc returns (d,(dâ»Â¹aâ‚,â€¦,dâ»Â¹aâ‚™)).\n\njulia> W=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> B=BraidMonoid(W)\nBraidMonoid(Aâ‚ƒ)\n\njulia> leftgcdc(B(2,1,2)^2,B(3,2)^2)\n(2, (121.21, 32.2))\n\n\n\n\n\n","category":"function"},{"location":"garside/#Chevie.Garside.rightgcd","page":"Garside monoids and groups, braids.","title":"Chevie.Garside.rightgcd","text":"rightgcd(M::LocallyGarsideMonoid,sâ‚,â€¦,sâ‚™) rightgcdc(M::LocallyGarsideMonoid,sâ‚,â€¦,sâ‚™)\n\nsâ‚,â€¦,sâ‚™ should be simples of M. The  function returns the right gcd d of the sáµ¢.\n\nrightgcdc returns (d,(sâ‚dâ»Â¹,â€¦,sâ‚™dâ»Â¹))\n\n\n\n\n\nrightgcd(aâ‚,â€¦,aâ‚™) rightgcdc(aâ‚,â€¦,aâ‚™)\n\naâ‚,â€¦,aâ‚™  should be  elements of  the same  (locally) Garside  monoid. The function returns the right gcd d of aâ‚,â€¦,aâ‚™\n\nrightgcdc returns (d,(aâ‚/d,â€¦,aâ‚™/d)).\n\njulia> W=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> B=BraidMonoid(W)\nBraidMonoid(Aâ‚ƒ)\n\njulia> rightgcdc(B(2,1,2)^2,B(3,2)^2)\n(2.2, (12.21, 23))\n\n\n\n\n\n","category":"function"},{"location":"garside/#Chevie.Garside.leftlcm","page":"Garside monoids and groups, braids.","title":"Chevie.Garside.leftlcm","text":"leftlcm(M::GarsideMonoid,sâ‚,â€¦,sâ‚™) leftlcmc(M::GarsideMonoid,sâ‚,â€¦,sâ‚™)\n\nsâ‚,â€¦,sâ‚™ should be simples of M. The  function returns the left lcm m of the sáµ¢.\n\nleftlcmc returns (m,(msâ‚â»Â¹,â€¦,msâ‚™â»Â¹))\n\n\n\n\n\nleftlcm(aâ‚,â€¦,aâ‚™) leftlcmc(aâ‚,â€¦,aâ‚™)\n\naâ‚,â€¦,aâ‚™  should  be  elements  of  the  same Garside monoid. The function returns  the least common left multiple  m of aâ‚,â€¦,aâ‚™.\n\nleftlcmc returns '(m,(m/aâ‚,â€¦,m/aâ‚™))`.\n\njulia> B=BraidMonoid(coxgroup(:A,3))\nBraidMonoid(Aâ‚ƒ)\n\njulia> leftlcmc(B(2,1,2)^2,B(3,2)^2)\n(Î”.121, (123, 23.321))\n\n\n\n\n\n","category":"function"},{"location":"garside/#Chevie.Garside.rightlcm","page":"Garside monoids and groups, braids.","title":"Chevie.Garside.rightlcm","text":"rightlcm(M::GarsideMonoid,sâ‚,â€¦,sâ‚™) rightlcmc(M::GarsideMonoid,sâ‚,â€¦,sâ‚™)\n\nsâ‚,â€¦,sâ‚™ should be simples of M. The  function returns the right lcm m of the sáµ¢.\n\nrightlcmc returns (m,(sâ‚â»Â¹m,â€¦,sâ‚™â»Â¹m))\n\n\n\n\n\nrightlcm(aâ‚,â€¦,aâ‚™) rightlcmc(aâ‚,â€¦,aâ‚™)\n\naâ‚,â€¦,aâ‚™  should  be  elements  of  the  same Garside monoid. The function returns  the least common right multiple  m of aâ‚,â€¦,aâ‚™.\n\nrightlcmc returns '(m,(aâ‚â»Â¹m,â€¦,aâ‚™â»Â¹m))`.\n\njulia> B=BraidMonoid(coxgroup(:A,3))\nBraidMonoid(Aâ‚ƒ)\n\njulia> rightlcmc(B(2,1,2)^2,B(3,2)^2)\n(Î”Â², (321.123, 12321.321))\n\n\n\n\n\n","category":"function"},{"location":"garside/#Chevie.Garside.Î±-Tuple{Chevie.Garside.LocallyGarsideElt}","page":"Garside monoids and groups, braids.","title":"Chevie.Garside.Î±","text":"Î±(b::LocallyGarsideElt)\n\nreturns as a Garside element  the first term in  the normal form of  b (the expression b[1] returns this term as a simple).\n\njulia> W=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> b=BraidMonoid(W)(2,1,2,1,1)\n121.1.1\n\njulia> Î±(b)\n121\n\n\n\n\n\n","category":"method"},{"location":"garside/#Chevie.Garside.Î±-Tuple{Chevie.Garside.LocallyGarsideElt, AbstractVector}","page":"Garside monoids and groups, braids.","title":"Chevie.Garside.Î±","text":"Î±(b::LocallyGarsideElt,I)\n\nreturns the longest prefix of b using only b.M.atoms[I]\n\njulia> W=coxgroup(:A,4);B=BraidMonoid(W)\nBraidMonoid(Aâ‚„)\n\njulia> w0=B(longest(W))\nÎ”\n\njulia> Î±(w0,[1,2,3])\n121321\n\n\n\n\n\n","category":"method"},{"location":"garside/#Chevie.Garside.Î´ad","page":"Garside monoids and groups, braids.","title":"Chevie.Garside.Î´ad","text":"Î´ad(M::GarsideMonoid,x,i=1)\n\nreturns the image of the simple x by the i-th power of the automorphism induced by conjugation by M.Î´ (that is x^(M.Î´^i)).\n\n\n\n\n\nÎ´ad(b::GarsideElt,i=1)\n\nreturns the image of b by the i-th power of the automorphism induced by conjugation by b.M.Î´.\n\n\n\n\n\n","category":"function"},{"location":"garside/#Chevie.Garside.Brieskorn_normal_form","page":"Garside monoids and groups, braids.","title":"Chevie.Garside.Brieskorn_normal_form","text":"Brieskorn_normal_form(b::LocallyGarsideElt)\n\nBrieskorn  citeBri71 has noticed that if L(b)  is the left descent set of b  (see leftdescents),  and if  b_(L(b)) is  the right lcm of L(b),  then  b_(L(b))  left-divides  b.  We  can  now  divide  b by b_(L(b))  and continue  this process  with the  quotient. In this way, we obtain  an expression  b=b_(Lâ‚)â‹¯ b_(Láµ£)  where Láµ¢=L(b_(Láµ¢)â‹¯ b_(Láµ£)) for all  i, which we  call the Brieskorn  normal form of  b. The function Brieskorn_normal_form  returns a  description of  this form, by returning the   list  of  sets   L(b)  which  describe   the  above  decomposition.\n\njulia> W=coxgroup(:E,8);B=BraidMonoid(W)\nBraidMonoid(Eâ‚ˆ)\n\njulia> w=B(2,3,4,2,3,4,5,4,2,3,4,5,6,5,4,2,3,4,5,6,7,6,5,4,2,3,4,5,6,7,8)\n2342345423456542345676542345678\n\njulia> Brieskorn_normal_form(w)\n2-element Vector{Vector{Int64}}:\n [2, 3, 4, 5, 6, 7]\n [8]\n\njulia> Brieskorn_normal_form(w^2)\n2-element Vector{Vector{Int64}}:\n [2, 3, 4, 5, 6, 7, 8]\n [2, 3, 4, 5, 6]\n\n\n\n\n\n","category":"function"},{"location":"garside/#Chevie.Garside.BraidMonoid","page":"Garside monoids and groups, braids.","title":"Chevie.Garside.BraidMonoid","text":"BraidMonoid(W::CoxeterGroup)\n\nThe ordinary monoid of the Artin group associated to W\n\n\n\n\n\n(B::BraidMonoid)(D::DualBraidMonoid,i::Integer)\n\nFor  monoids of the  same Coxeter group,  convert to an  element of B the i-th atom of D.\n\n\n\n\n\n(B::BraidMonoid)(D::DualBraidMonoid,s)\n\nFor  monoids of the  same Coxeter group,  convert to an  element of B the simple s of D.\n\n\n\n\n\n(B::BraidMonoid)(b::GarsideElt)\n\nb should be a dual braid. Convert b to an element of B.\n\n\n\n\n\n","category":"type"},{"location":"garside/#Chevie.Garside.DualBraidMonoid","page":"Garside monoids and groups, braids.","title":"Chevie.Garside.DualBraidMonoid","text":"DualBraidMonoid(W;c=xxx)\n\nW  should be a well generated complex  reflection group and c a Coxeter element  of W, given as a  word (a Vector{Int}) specifiying the element W(c...). \n\nIf  no c  is given  a particular  one is  chosen (what the notation xxx above tries to convey). The choice is as follows:\n\nFor  W a Coxeter  group the Coxeter  diagram is partitioned  in two sets where  in each set reflections commute pairwise;  c is the product of the product of the reflections in each set (see bipartite_decomposition).\n\nFor  a complex  reflection group  the representative  stored in the Coxeter class is used for c.\n\nThe  function returns the dual braid monoid  determined by W and c, the interval  monoid  for  W  generated  by  its reflections and the interval [1,c].\n\njulia> W=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> D=DualBraidMonoid(W)\nDualBraidMonoid(Aâ‚ƒ,c=[1, 3, 2])\n\njulia> D(2,1,2,1,1)\n12.1.1.1\n\njulia> D(-1,-2,-3,1,1)\n(25.1)â»Â¹1.1\n\njulia> W=crg(4)\nGâ‚„\n\njulia> D=DualBraidMonoid(W)\nDualBraidMonoid(Gâ‚„,c=[1, 2])\n\njulia> left_divisors(D(D.Î´))\n5-element Vector{GarsideElt{Perm{Int16}, DualBraidMonoid{Perm{Int16}, PRG{Cyc{Rational{Int64}}, Int16}}}}:\n .\n 1\n 2\n 3\n Î´\n\n\n\n\n\n","category":"type"},{"location":"garside/#Chevie.Garside.hurwitz","page":"Garside monoids and groups, braids.","title":"Chevie.Garside.hurwitz","text":"hurwitz(l,i::Integer) the  Hurwitz action of  the generator Ïƒáµ¢  of the braid  group Bâ‚™ on the list  l  of  length  n  of  group elements, which replaces láµ¢,láµ¢â‚Šâ‚ by láµ¢â‚Šâ‚,láµ¢^láµ¢â‚Šâ‚.  If i<0, does the action of inv(Ïƒâ±¼) where j=-i, which replaces lâ±¼,lâ±¼â‚Šâ‚ by lâ±¼â‚Šâ‚^inv(lâ±¼),lâ±¼.\n\nThe  following  expression  computes  the  orbit  of the list l under the various Huwitz actions: orbit(1:length(l)-1,l,hurwitz).\n\n\n\n\n\nhurwitz(l,v::AbstractVector{<:Integer})\n\ndoes successively hurwitz(l,i) for each i in v.\n\n\n\n\n\nhurwitz(l,b) the  Hurwitz action of the braid  bâˆˆ Bâ‚™ on the list  l of length n of group elements.\n\n\n\n\n\n","category":"function"},{"location":"garside/#Chevie.Garside.fraction","page":"Garside monoids and groups, braids.","title":"Chevie.Garside.fraction","text":"fraction(b::GarsideElt)\ndenominator(b::GarsideElt)\nnumerator(b::GarsideElt)\n\nfraction(b)  returns a  tuple (x,y)  of positive  Garside elements with trivial  leftgcd  and  such  that  b=x\\y.  For  such  a decomposition, denominator(b) returns x and numerator(b) returns y.\n\njulia> B=BraidMonoid(coxgroup(:A,3))\nBraidMonoid(Aâ‚ƒ)\n\njulia> b=B( 2, 1, -3, 1, 1)\n(23)â»Â¹321.1.1\n\njulia> fraction(b)\n(23, 321.1.1)\n\n\n\n\n\n","category":"function"},{"location":"garside/#PermGroups.Groups.word-Tuple{LocallyGarsideMonoid, Any}","page":"Garside monoids and groups, braids.","title":"PermGroups.Groups.word","text":"word(M::GarsideMonoid,w)\n\nreturns a word in the atoms of M representing the simple w\n\njulia> B=BraidMonoid(coxgroup(:A,3))\nBraidMonoid(Aâ‚ƒ)\n\njulia> word(B,B.Î´)\n6-element Vector{Int64}:\n 1\n 2\n 1\n 3\n 2\n 1\n\n\n\n\n\n","category":"method"},{"location":"garside/#PermGroups.Groups.word-Tuple{GarsideElt}","page":"Garside monoids and groups, braids.","title":"PermGroups.Groups.word","text":"word(b::GarsideElt)\n\nreturns  a description  of b  as a  list of  the atoms  of which  it is a product.  If b is in the Garside group  but not the Garside monoid, it is represented  in  fraction  normal  form  where  as a special convention the inverses  of  the  atoms  are  represented  by  negating  the corresponding integer.\n\njulia> B=BraidMonoid(coxgroup(:A,3))\nBraidMonoid(Aâ‚ƒ)\n\njulia> b=B(2,1,2,1,1)*inv(B(2,2))\n(21)â»Â¹1.12.21\n\njulia> word(b)\n7-element Vector{Int64}:\n -1\n -2\n  1\n  1\n  2\n  2\n  1\n\n\n\n\n\n","category":"method"},{"location":"garside/#PermGroups.Groups.elements-Tuple{LocallyGarsideMonoid, Integer}","page":"Garside monoids and groups, braids.","title":"PermGroups.Groups.elements","text":"elements(M::LocallyGarsideMonoid,l::Integer) elements(M::LocallyGarsideMonoid,v::AbstractVector{<:Integer})\n\nM  should have  an additive  length function  (that is,  a product of l atoms  is not equal to any product of less than l atoms). elements(M,l) returns the list of elements of length l in M.\n\nIn the second form elements returns all elements of length i for iâˆˆ v.\n\njulia> M=BraidMonoid(coxgroup(:A,2))\nBraidMonoid(Aâ‚‚)\n\njulia> elements(M,4)\n12-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:\n Î”.1\n Î”.2\n 12.21\n 12.2.2\n 1.12.2\n 1.1.12\n 1.1.1.1\n 21.12\n 21.1.1\n 2.21.1\n 2.2.21\n 2.2.2.2\n\n\n\n\n\n","category":"method"},{"location":"garside/#Chevie.Garside.image","page":"Garside monoids and groups, braids.","title":"Chevie.Garside.image","text":"image(b::GarsideElt)\n\nThis  function is defined only if b  is an element of an interval monoid, for instance a braid. It returns the image of b in the group of which the monoid  is an interval  monoid. For instance  it gives the  projection of a braid in an Artin monoid back to the Coxeter group.\n\njulia> W=coxsym(4)\nğ”– â‚„\n\njulia> b=BraidMonoid(W)(2,1,2,1,1)\n121.1.1\n\njulia> p=image(b)\n(1,3)\n\njulia> word(W,p)\n3-element Vector{Int64}:\n 1\n 2\n 1\n\n\n\n\n\n","category":"function"},{"location":"garside/#Chevie.Garside.conjugating_elt","page":"Garside monoids and groups, braids.","title":"Chevie.Garside.conjugating_elt","text":"conjugating_elt(b,bâ‚[,F];ss=Val(:sc))\n\nb  and bâ‚ should  be elements of  the same Garside  group. The function returns  a such that b^a=bâ‚ if such exists, and nothing otherwise. If an  argument ss  is given,  the computation  is done in the corresponding category  â€“- see conjcat. If an  argument F is given it should be  an automorphism of the braid monoid, like the Frobenius of a reflection coset   attached  to  b.M.W;   the  computation  is   then  done  in  the corresponding F-conjugacy category.\n\njulia> W=coxgroup(:D,4)\nDâ‚„\n\njulia> B=BraidMonoid(W)\nBraidMonoid(Dâ‚„)\n\njulia> b=B(2,3,1,2,4,3)\n231243\n\njulia> b1=B(1,4,3,2,2,2)\n1432.2.2\n\njulia> conjugating_elt(b,b1)\n(134312.23)â»Â¹\n\njulia> c=conjugating_elt(b,b1;ss=Val(:cyc))\n232.2\n\njulia> b^c\n1432.2.2\n\njulia> WF=spets(W,Perm(1,2,4))\nÂ³Dâ‚„\n\njulia> F=Frobenius(WF);\n\njulia> c=B(3,4,3,1,2,3)\n343123\n\njulia> conjugating_elt(b,c,F)\n124312\n\njulia> ^(b,B(1,2,4,3,1,2),F)\n343123\n\n\n\n\n\n","category":"function"},{"location":"garside/#Chevie.Garside.centralizer_gens","page":"Garside monoids and groups, braids.","title":"Chevie.Garside.centralizer_gens","text":"centralizer_gens(b[,F];ss=Val(:sc))\n\na  list of generators of the centralizer of b. The computation is done by computing  the  endomorphisms  of  the  object  b  in the category of its sliding  circuits. If an argument ss is given, the computation is done in the corresponding category â€“- see conjcat.\n\nIf  an argument  F is  given it  should be  an automorphism  of the braid monoid,  like the Frobenius of a reflection coset attached to b.M.W; then the F-centralizer is computed.\n\njulia> W=coxgroup(:D,4)\nDâ‚„\n\njulia> B=BraidMonoid(W)\nBraidMonoid(Dâ‚„)\n\njulia> w=B(4,4,4)\n4.4.4\n\njulia> cc=centralizer_gens(w)\n8-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:\n 1\n (31432)â»Â¹231432\n (1)â»Â¹34.431\n (2)â»Â¹34.432\n (32431)â»Â¹132431\n 4\n 34.43\n 2\n\njulia> shrink(cc)\n5-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:\n 4\n 2\n 1\n 34.43\n (3243)â»Â¹13243\n\njulia> centralizer_gens(w;ss=Val(:cyc))\n1-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:\n 4\n\njulia> F=Frobenius(spets(W,Perm(1,2,4)));\n\njulia> centralizer_gens(w,F)\n2-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:\n 124\n 312343123\n\n\n\n\n\n","category":"function"},{"location":"garside/#Chevie.Garside.cycle","page":"Garside monoids and groups, braids.","title":"Chevie.Garside.cycle","text":"cycle(b)\n\nif the normal form of b is Î”â±bâ‚â€¦bâ‚™ then cycle(b)=b^Î´ad(bâ‚,-i). returns (cycle(b),Î´ad(bâ‚,-i)).\n\n\n\n\n\n","category":"function"},{"location":"garside/#Chevie.Garside.decycle","page":"Garside monoids and groups, braids.","title":"Chevie.Garside.decycle","text":"decycle(b)\n\nif the normal form of b is Î”â±bâ‚â€¦bâ‚™ then decycle(b)=b^inv(bâ‚™). returns (decycle(b),inv(bâ‚™)).\n\n\n\n\n\n","category":"function"},{"location":"garside/#Chevie.Garside.preferred_prefix","page":"Garside monoids and groups, braids.","title":"Chevie.Garside.preferred_prefix","text":"preferred_prefix(b)\n\nif the normal form of b is Î”â±bâ‚â€¦bâ‚™ then  preferred_prefix(b)=inv(bâ‚™)*Î±(bâ‚™Î”â»â±(bâ‚)).\n\n\n\n\n\n","category":"function"},{"location":"garside/#Chevie.Garside.Category","page":"Garside monoids and groups, braids.","title":"Chevie.Garside.Category","text":"The struct Category{TO,TM} represents a finite category whose objects are of type TO and maps of type TM. It has two fields:\n\n.obj::Vector{TO} the objects\n.atoms::Vector{Vector{Pair{TM,Int}}} a vector of same length as .obj representing  the atoms (generators)  of the category;  atoms[i] is a Vector of pairs m=>j holding a map m from obj[i] to obj[j].\n\njulia> W=coxsym(4);B=BraidMonoid(W);b=B(1,1,2,2,3)\n1.12.23\n\njulia> print(conjcat(b))\nCategory([B(1,2,2,1,3),B(2,1,3,1,2),B(2,1,3,3,2),B(3,2,2,1,3)],[\n[B(1,2)=>2, B(2,1,3)=>3],\n[B(2,1,3)=>1, B(1,3,2,1)=>4],\n[B(2,1,3)=>4, B(1,2,3,2)=>1],\n[B(2,1,3)=>2, B(3,2)=>3]])\n\njulia> xprint(conjcat(b);graph=true) # show graphically the category\ncategory with 4 objects and 8 generating maps\n      1232       12       213       213       213       32 \n213.32â€•â€•â€•â” 12.213â€•â” 213.12â€•â€•â” 12.213â€•â€•â” 213.32â€•â€•â” 32.213â€•â” 213.32\n      1321       213 \n213.12â€•â€•â€•â” 32.213â€•â€•â” 213.12\n\n\n\n\n\n","category":"type"},{"location":"garside/#Chevie.Garside.Category-Tuple{Function, Any}","page":"Garside monoids and groups, braids.","title":"Chevie.Garside.Category","text":"Category(atomsfrom::Function,o;action::Function=^)\n\nconstructs a category from an initial object o and two functions:\n\natomsfrom(o) given an object o returns  the list of atoms from o. \naction(o,m) returns the target object of the map m starting from o. \n\nIf  action is  not given,  it is  assumed that  o^m does the job. While constructing  the category, action is only applied for atoms m.\n\nThe  result is  a Category{TO,TM}  where TO=typeof(o)  and TM  is the eltype  of the result of  atomsfrom. \n\nAs an example we construct a Garside category associated to the braid group of  Gâ‚ƒâ‚, realized as the  centralizer of a 4th  root of Î´Â³â° in the dual braid  monoid of Eâ‚ˆ; that is the fixed points of Î´adÂ¹âµ in the 2-divided category.\n\njulia> W=coxgroup(:E,8);M=DualBraidMonoid(W)\nDualBraidMonoid(Eâ‚ˆ,c=[1, 4, 6, 8, 3, 2, 5, 7])\n\njulia> s4=left_divisors(M,M.Î´,4); # simples of length 4\n\njulia> s=M(s4[findfirst(x->x*Î´ad(M,x,8)==M.Î´,s4)])#an object of 2-divided cat\n(1 8 17 35)\n\njulia> \"the right-lcms of the `Î´â±`-orbits on `leftdescents(b)`\"\n       function satoms(b,i)\n         M=b.M\n         ld=M.atoms[leftdescents(b)]\n         di=Perm(ld,Î´ad.(Ref(M),ld,i))\n         if isnothing(di) error(b,\" is not Î´^$i-stable\") end\n         map(o->M(rightlcm(M,ld[o]...)),orbits(di,eachindex(ld)))\n       end\nsatoms\n\njulia> Category(x->satoms(x,15),s;action=(o,m)->inv(m)*o*Î´ad(m,8))\ncategory with 88 objects and 660 generating maps\n\n\n\n\n\n","category":"method"},{"location":"garside/#Chevie.Garside.conjcat","page":"Garside monoids and groups, braids.","title":"Chevie.Garside.conjcat","text":"conjcat(b[,F];ss=Val(:sc))\n\nreturns  the conjugacy category  of the summit  set of b  of the required type.\n\nBy default,  computes the  category of  sliding circuits  of b.\nIf ss==Val(:ss),  computes  the  super  summit  set of b..\nIf ss==Val(:cyc), computes the cyclic  conjugacy category of b.\nIf ss==Val(:inf) computes the category of all elements conjugate to b and with at least same Inf.\n\nIf  an argument  F is  given it  should be  the Frobenius of a Reflection coset attached to b.M.W. Then the F-conjugacy category is returned.\n\njulia> W=coxgroup(:A,4)\nAâ‚„\n\njulia> w=BraidMonoid(W)(4,3,3,2,1)\n43.321\n\njulia> C=conjcat(w)\ncategory with 2 objects and 4 generating maps\n\njulia> C.obj # the (sliding circuits) summit set\n2-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:\n 32143\n 21324\n\njulia> xprint(C;graph=true)   # show the conjugations among the summit set\ncategory with 2 objects and 4 generating maps\n     32143      21343      21324      13214\n32143â”€â”€â”€â”€â†’ 32143â”€â”€â”€â”€â†’ 21324â”€â”€â”€â”€â†’ 21324â”€â”€â”€â”€â†’ 32143\n\njulia> conjcat(w;ss=Val(:ss)).obj # the super summit set\n4-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:\n 32143\n 13243\n 21432\n 21324\n\n\n\n\n\n","category":"function"},{"location":"garside/#Chevie.Garside.endomorphisms","page":"Garside monoids and groups, braids.","title":"Chevie.Garside.endomorphisms","text":"endomorphisms(C::Category,o::Integer) Assuming  the atoms of C  are invertible by inv  and maps multiply with *, returns generators of the endomorphisms of C.obj[o]\n\njulia> W=coxsym(4);M=BraidMonoid(W)\nBraidMonoid(ğ”– â‚„)\n\njulia> endomorphisms(conjcat(M(1,1,2,2,3)),1) # generators of centralizer\n2-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, CoxSym{Int16}}}}:\n 213.1232\n 12.213\n\n\n\n\n\n","category":"function"},{"location":"garside/#GroupPresentations.Presentation-Tuple{GarsideMonoid}","page":"Garside monoids and groups, braids.","title":"GroupPresentations.Presentation","text":"Presentation(M::GarsideMonoid;vars=Symbol.(\"x\",eachindex(M.atoms)))\n\nreturns  a presentation of  the Garside group  defined by M  (as given in (Dehornoy and Paris, 1999; theorem 4.1), using vars as names for the generators.\n\njulia> M=DualBraidMonoid(coxgroup(:A,3))\nDualBraidMonoid(Aâ‚ƒ,c=[1, 3, 2])\n\njulia> p=Presentation(M,vars=Symbol.(collect(\"abcdef\")))\nPresentation: 6 generators, 15 relators, total length 62\n\njulia> simplify(p)\n<< presentation with 3 generators, 4 relators of total length 26>>\n<< presentation with 3 generators, 3 relators of total length 16>>\n\njulia> display_balanced(p)\n1: ab=ba\n2: cac=aca\n3: cbc=bcb\n\n\n\n\n\n","category":"method"},{"location":"garside/#Chevie.Garside.shrink","page":"Garside monoids and groups, braids.","title":"Chevie.Garside.shrink","text":"shrink(l::Vector{<:GarsideElt})\n\nThe  list l  is a  list of  elements of  the same Garside group G. This function  tries to find  another set of  generators of the  subgroup of G generated by the elements of l, of smaller total length (the length being counted  as returned by the  function word). This can  be use to simplify the result of centralizer_gens, or other braid subgroups.\n\njulia> B=BraidMonoid(coxsym(3))\nBraidMonoid(ğ”– â‚ƒ)\n\njulia> b=[B(1)^3,B(2)^3,B(-2,-1,-1,2,2,2,2,1,1,2),B(1,1,1,2)]\n4-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, CoxSym{Int16}}}}:\n 1.1.1\n 2.2.2\n (1.12)â»Â¹2.2.2.21.12\n 1.1.12\n\njulia> shrink(b)\n2-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, CoxSym{Int16}}}}:\n 2\n 1\n\n\n\n\n\n","category":"function"},{"location":"garside/#Chevie.Garside.CorranPicantinMonoid","page":"Garside monoids and groups, braids.","title":"Chevie.Garside.CorranPicantinMonoid","text":"CorranPicantinMonoid(e,n,k=1)\n\nreturns the interval monoid defined by G. Neaime, http://arxiv.org/abs/1707.06864,   which  generalizes  the  Corran-Picantin monoid for G(e,e,n).\n\nIn  this monoid Î´ has image  the element of G(e,e,n) corresponding to the  diagonal matrix whose  diagonal entries except  the first are equal to E(e)^k;  this  monoid  is  isomorphic  to  the Corran-Picantin monoid for G(e,e,n) when gcd(k,e)=1.\n\njulia> C=CorranPicantinMonoid(3,3)\nCorranPicantinMonoid(3,3,3)\n\njulia> word(C(C.Î´))\n6-element Vector{Int64}:\n 1\n 3\n 4\n 1\n 3\n 4\n\njulia> Matrix(C,C.Î´)\n3Ã—3 Matrix{Cyc{Int64}}:\n Î¶â‚ƒ   0   0\n  0  Î¶â‚ƒ   0\n  0   0  Î¶â‚ƒ\n\njulia> b=C(1,2,3,4)^3\n1.2.341.2.341.2.34\n\njulia> Matrix(C,b[3])\n3Ã—3 Matrix{Cyc{Int64}}:\n 0    0  Î¶â‚ƒ\n 0  Î¶â‚ƒÂ²   0\n 1    0   0\n\nÂ© July 2017 â€“- Jean Michel and Georges Neaime\n\n\n\n\n\n","category":"function"},{"location":"symfuncs/#Symmetric-functions","page":"Symmetric functions","title":"Symmetric functions","text":"Pages=[\"symfuncs.md\"]","category":"section"},{"location":"symfuncs/#Chevie.SymFuncs","page":"Symmetric functions","title":"Chevie.SymFuncs","text":"This  module  deals  with  symmetric  functions.  The  main  object  is the (truncated) algebra of symmetric functions, and the bases p (power sums), h  (complete symmetric  functions), e  (elementary symmetric functions) and  s (Schur functions). Each of these bases in degree n is indexed by the partitions of n.\n\nA typical session would begin by defining the symmetric functions and these bases:\n\njulia> A=SymFuncAlgebra(10) # truncated in degree >10\nSymFuncAlgebra(10)\n\njulia> p=pbasis(A);h=hbasis(A);e=ebasis(A);s=sbasis(A);\n\nThen making elements in one of these bases. The following forms are equivalent:\n\njulia> p(Partition(3,2,1))\npâ‚ƒâ‚‚â‚\n\njulia> p([3,2,1])\npâ‚ƒâ‚‚â‚\n\njulia> p(3,2,1)\npâ‚ƒâ‚‚â‚\n\nThe functions can be used to convert between bases:\n\njulia> s(p(3,2,1))\n-sâ‚â‚â‚â‚â‚â‚-sâ‚‚â‚‚â‚‚+sâ‚ƒâ‚â‚â‚+sâ‚ƒâ‚ƒ-sâ‚„â‚â‚+sâ‚†\n\njulia> h(p(3,2,1))\n-hâ‚â‚â‚â‚â‚â‚+5hâ‚‚â‚â‚â‚â‚-6hâ‚‚â‚‚â‚â‚-3hâ‚ƒâ‚â‚â‚+6hâ‚ƒâ‚‚â‚\n\nThe following operations are defined on symmetric functions, in addition to + and -:\n\njulia> s(2,1)*s(2,1) # product\nsâ‚‚â‚‚â‚â‚+sâ‚‚â‚‚â‚‚+sâ‚ƒâ‚â‚â‚+2sâ‚ƒâ‚‚â‚+sâ‚ƒâ‚ƒ+sâ‚„â‚â‚+sâ‚„â‚‚\n\njulia> s(2,1)âŠ—s(2,1) # inner product\nsâ‚â‚â‚+sâ‚‚â‚+sâ‚ƒ\n\njulia> scalar_product(p(1,1,1),s(2,1))\n2//1\n\nOne can mix bases in these operations. The basis of the left argument wins:\n\njulia> s(2,1)+p(3)\nsâ‚â‚â‚+sâ‚ƒ\n\nThe plethysm is implemented with two possible notations:\n\njulia> plethysm(p(2,1),s(2,1))\n(1//9)pâ‚‚â‚‚â‚‚â‚â‚â‚+(-1//9)pâ‚ƒâ‚‚â‚‚â‚‚+(-1//9)pâ‚†â‚â‚â‚+(1//9)pâ‚†â‚ƒ\n\njulia> p(2,1)[s(2,1)]  # the same thing\n(1//9)pâ‚‚â‚‚â‚‚â‚â‚â‚+(-1//9)pâ‚ƒâ‚‚â‚‚â‚‚+(-1//9)pâ‚†â‚â‚â‚+(1//9)pâ‚†â‚ƒ\n\njulia> @Mvp u,v\n\njulia> p(2,1)[u*p(2)+v*p(3)] # plethysm acts on Mvp coefficients\nuÂ³pâ‚„â‚‚+uÂ²vpâ‚„â‚ƒ+uvÂ²pâ‚†â‚‚+vÂ³pâ‚†â‚ƒ\n\nfinally one can convert a symmetric function to a symmetric polynomial. The number of variables is the highest degree in the function.\n\njulia> Mvp(p(2)+p(3))\nMvp{Int64}: xâ‚Â³+xâ‚Â²+xâ‚‚Â³+xâ‚‚Â²+xâ‚ƒÂ³+xâ‚ƒÂ²\n\njulia> Mvp(p(2),[u,v]) # one can choose the variables used\nMvp{Int64}: uÂ²+vÂ²\n\n\n\n\n\n","category":"module"},{"location":"symfuncs/#Chevie.SymFuncs.SymFuncAlgebra","page":"Symmetric functions","title":"Chevie.SymFuncs.SymFuncAlgebra","text":"SymFuncAlgebra(n) the algebra of symmetric functions truncated in degree>n\n\n\n\n\n\n","category":"type"},{"location":"symfuncs/#FinitePosets.:âŠ—-Tuple{Chevie.SymFuncs.SymFunc, Chevie.SymFuncs.SymFunc}","page":"Symmetric functions","title":"FinitePosets.:âŠ—","text":"aâŠ—b the inner product of the symmetric functions a and b\n\n\n\n\n\n","category":"method"},{"location":"symfuncs/#Chevie.Chars.scalar_product-Tuple{Chevie.SymFuncs.SymFunc, Chevie.SymFuncs.SymFunc}","page":"Symmetric functions","title":"Chevie.Chars.scalar_product","text":"scalar_product(a,b) the scalar product of the symmetric functions a and b\n\n\n\n\n\n","category":"method"},{"location":"gendec/#Decomposition-Matrices","page":"Decomposition Matrices","title":"Decomposition Matrices","text":"These functions interface with Thomas Breuer's package GenericDecMats.\n\nPages=[\"gendec.md\"]","category":"section"},{"location":"gendec/#Chevie.Chars.decomposition_matrix","page":"Decomposition Matrices","title":"Chevie.Chars.decomposition_matrix","text":"decomposition_matrix(W,p)\n\nThis  provides an interface to some  decomposition matrices for Weyl groups available  in the Chevie  library: those for  W(Eâ‚†), W(Eâ‚‡), W(Eâ‚ˆ) for p dividing |W|.\n\n\n\n\n\n","category":"function"},{"location":"gendec/#GenericDecMats.generic_decomposition_matrix","page":"Decomposition Matrices","title":"GenericDecMats.generic_decomposition_matrix","text":"generic_decomposition_matrix(W,d)\n\nThis  function obtains  the Î¦_d-decomposition  matrix for the reductive group  specified  by  the  Coxeter  group  or  coset  W  from the package GenericDecMats.\n\njulia> W=rootdatum(:psu,5)\npsuâ‚…\n\njulia> generic_decomposition_matrix(W,13)\n!!! Î¦-decomposition matrices available for Â²Aâ‚„: Î¦â‚â‚€ Î¦â‚‚ Î¦â‚„ Î¦â‚†\n\njulia> generic_decomposition_matrix(W,10)\nÎ¦â‚â‚€-decomposition matrix for psuâ‚…\nâ”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚      â”‚ps 21 ps ps ps 2111 11111â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚2.    â”‚ 1  .  .  .  .    .     .â”‚\nâ”‚Â²Aâ‚‚:2 â”‚ .  1  .  .  .    .     .â”‚\nâ”‚11.   â”‚ .  .  1  .  .    .     .â”‚\nâ”‚1.1   â”‚ 1  .  .  1  .    .     .â”‚\nâ”‚.2    â”‚ .  .  .  .  1    .     .â”‚\nâ”‚Â²Aâ‚‚:11â”‚ .  1  .  .  .    1     .â”‚\nâ”‚.11   â”‚ .  .  .  1  .    .     1â”‚\nâ””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nThe matrix itself is stored in the field .scalar of the returned struct.\n\n\n\n\n\n","category":"function"},{"location":"gendec/#Chevie.InducedDecompositionMatrix","page":"Decomposition Matrices","title":"Chevie.InducedDecompositionMatrix","text":"InducedDecompositionMatrix(R,W,d)\n\nreturns the induced from the Levi L to the reductive group W of the generic Î¦_d-decomposition matrix of L.\n\njulia> W=rootdatum(:psu,6)\npsuâ‚†\n\njulia> L=reflection_subgroup(W,[1,2,4,5])\npsuâ‚†â‚â‚â‚‚â‚„â‚…â‚=(Aâ‚‚Aâ‚‚)â‚â‚â‚‚â‚„â‚ƒâ‚Î¦â‚\n\njulia> InducedDecompositionMatrix(L,W,6)\nInduced Î¦â‚†-decomposition matrix from psuâ‚†â‚â‚â‚‚â‚„â‚…â‚=(Aâ‚‚Aâ‚‚)â‚â‚â‚‚â‚„â‚ƒâ‚Î¦â‚ to psuâ‚†\n\nâ”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚    â”‚ps ps Aâ‚‚â”‚\nâ”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚Â²Aâ‚… â”‚ .  .  .â”‚\nâ”‚.3  â”‚ 1  .  .â”‚\nâ”‚3.  â”‚ 1  .  .â”‚\nâ”‚.21 â”‚ 1  1  .â”‚\nâ”‚1.2 â”‚ 2  1  .â”‚\nâ”‚21. â”‚ 1  1  .â”‚\nâ”‚2.1 â”‚ 2  1  .â”‚\nâ”‚.111â”‚ .  1  1â”‚\nâ”‚111.â”‚ .  1  1â”‚\nâ”‚1.11â”‚ 1  2  1â”‚\nâ”‚11.1â”‚ 1  2  1â”‚\nâ””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nThe matrix itself is stored in the field .scalar of the returned struct.\n\n\n\n\n\n","category":"type"},{"location":"coxgroups/#Coxeter-groups","page":"Coxeter groups","title":"Coxeter groups","text":"Pages=[\"coxgroups.md\"]","category":"section"},{"location":"coxgroups/#Chevie.CoxGroups","page":"Coxeter groups","title":"Chevie.CoxGroups","text":"A  suitable  reference  for  the  general  theory of Coxeter groups is, for example, [bou68; chapter 4].\n\nA Coxeter group is a group which has the presentation W=S(st)^m(st)=1text  for  st  S  for some symmetric integer matrix  m(s,t) called the  coxeter_matrix, where m(s,t)>1 for sâ‰ t  and m(s,s)=1; m(s,t)=âˆ  is allowed meaning  there is no relation between  s and  t. It  is true  (but a  non-trivial theorem)  that in a Coxeter  group the order of st is  exactly m(s,t), thus a Coxeter group is  the same as a Coxeter  system, that is a pair  (W,S) of a group W and  a  set  SâŠ‚W  of  involutions,  such  that  the group is presented by generators  S and  relations describing  the order  of the product of two elements of S.\n\nA   Coxeter   group   has   a   natural   representation,  its  reflection representation, on a real vector space V of dimension length(S) (which is  the  Coxeter  rank  of  W),  where  each  element  of  S  acts as a reflection;  the faithfulness of this representation (a theorem of Tits) is the main argument to prove that the order of st is exactly m(s,t). This representation  is defined as follows on a  space V with basis {eâ‚›} for sâˆˆ  S. The Cartan  matrix associated to  the Coxeter matrix m(s,t) is the matrix C with entries C(s,t)=-2cos(Ï€/m(s,t)); we set C(s,t)=-2 if m(s,t)=âˆ. Then the action of sâˆˆ S on V is given by s(eâ‚œ)=eâ‚œ-C(s,t)eâ‚›.\n\nThus, Coxeter groups are  real reflection groups.  The converse need not be true  if the set of reflecting  hyperplanes has bad topological properties, but  it turns out  that finite Coxeter  groups are the  same as finite real reflection  groups. The possible Coxeter matrices for finite Coxeter groups have  been  completely  classified,  see  Weyl; the corresponding finite groups play a deep role in several areas of mathematics.\n\nCoxeter  groups  have  a  nice  solution  to the word problem. The length l(w)  of an element  wâˆˆ W is  the minimum number  of elements of S of which it is a product (since the elements of S are involutions, we do not need inverses). An expression of w of minimum length is called a reduced word  for w. The main property of  reduced words is the exchange lemma which  states that if sâ‚â€¦sâ‚– is a reduced word for w (thus k=l(w)) and sâˆˆ  S is such that l(sw)â‰¤l(w) then one  of the sáµ¢ in the word for w can be deleted to obtain a reduced word for sw. Thus given sâˆˆ S and wâˆˆ W,  either l(sw)=l(w)+1 or l(sw)=l(w)-1 and  in the latter case we say that s belongs to the left descent set of w. Computing a reduced word for  an  element,  and  other  word  problems,  are  easy if we know how to multiply elements and know left descent sets. In each of the Coxeter groups that we implement, the left descent set is easy to compute (see for example coxeter_symmetric_group below), so this suggests how to deal with Coxeter groups generically:\n\nThe  type  CoxeterGroup  is  an  abstract  type;  an  actual struct which implements it must define a function\n\nisleftdescent(W,w,i) which tells whether the i-th element of S is in    the left descent set of w.\n\nthe other functions needed in an instance of a Coxeter group are\n\ngenerators(W), abbreviated gens, which returns the set S (the list of Coxeter generators)\nnumber_of_reflections(W), abbreviated nref, which  returns the  number of  reflections of  W, if  W is finite or nothing if W is infinite.\n\nIt  should  be  noted  that  a  Coxeter  group  can  be any kind of group implementing the above functions.\n\nBecause  of the  easy solution  of the  word problem  in Coxeter  groups, a convenient  way  to  represent  their  elements  is as words in the Coxeter generators,  that  is  lists  of  integers  in 1:length(S). The functions word  and W(...) do the conversion between Coxeter words and elements of the group.\n\nExamples\n\njulia> W=coxsym(4)\nğ”– â‚„\n\njulia> p=W(1,3,2,1,3)\n(1,4)\n\njulia> word(W,p)\n5-element Vector{Int64}:\n 1\n 2\n 3\n 2\n 1\n\nWe  notice that the word we started with and the one that we ended up with, are  not the same, even though they  represent the same element of W. The reason  is that there are several reduced  words for an element of W. The function word calculates a lexicographically smallest word for w. Below are some other possible computations using the same Coxeter group:\n\njulia> word(W,longest(W))  # the (unique) longest element in W\n6-element Vector{Int64}:\n 1\n 2\n 1\n 3\n 2\n 1\n\njulia> w0=longest(W)\n(1,4)(2,3)\n\njulia> length(W,w0)\n6\njulia> map(w->word(W,w),refls(W,1:nref(W)))\n6-element Vector{Vector{Int64}}:\n [1]\n [2]\n [3]\n [1, 2, 1]\n [2, 3, 2]\n [1, 2, 3, 2, 1]\njulia> [length(elements(W,i)) for i in 0:nref(W)]\n7-element Vector{Int64}:\n 1\n 3\n 5\n 6\n 5\n 3\n 1\n\nThe  last list tells us that there is 1 element of length 0, there are 6 of length 3, â€¦\n\nFor  most basic functions the convention is that the input is an element of the  group, rather than a  Coxeter word. The reason  for this is that for a Coxeter  group which is a permutation  group, using the low level functions for   permutations  is   usually  much   faster  than   manipulating  lists representing reduced expressions.\n\nThe  only  Coxeter  group  constructors  implemented  in  this  module  are coxeter_symmetric_group  and  coxeter_group;  the  last constructor  takes  a  Cartan  matrix  and builds the corresponding Coxeter group  as a matrix  group. The module  Weyl defines other methods for  coxgroup building  a finite  Coxeter group  as a  permutation group, given its type.\n\n\n\n\n\n","category":"module"},{"location":"coxgroups/#Chevie.CoxGroups.isleftdescent-Tuple{CoxSym, Any, Int64}","page":"Coxeter groups","title":"Chevie.CoxGroups.isleftdescent","text":"isleftdescent(W::CoxeterGroup,w,i::Integer)\n\nreturns  true iff the  i-th generating reflection  of the Coxeter group W  is in  the left  descent set  of the  element w  of W, that is iff length(W,W(i)*w)<length(W,w).\n\njulia> W=coxsym(3)\nğ”– â‚ƒ\n\njulia> isleftdescent(W,Perm(1,2),1)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"coxgroups/#Chevie.CoxGroups.isrightdescent","page":"Coxeter groups","title":"Chevie.CoxGroups.isrightdescent","text":"isrightdescent(W::CoxeterGroup,w,i::Integer)\n\nreturns  true iff the  i-th generating reflection  of the Coxeter group W  is in the  right descent set  of the element  w of W,  that is iff length(W,w*W(i))<length(W,w).\n\njulia> W=coxsym(3)\nğ”– â‚ƒ\n\njulia> isrightdescent(W,Perm(1,2),1)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"coxgroups/#Chevie.CoxGroups.firstleftdescent","page":"Coxeter groups","title":"Chevie.CoxGroups.firstleftdescent","text":"firstleftdescent(W,w)\n\nreturns the index in gens(W) of the first element of the left descent set of  w â€“- that is, the first  i such that if s=W(i) then l(sw)<l(w). It returnsnothingforone(W)`.\n\njulia> W=coxsym(3)\nğ”– â‚ƒ\n\njulia> firstleftdescent(W,Perm(2,3))\n2\n\n\n\n\n\n","category":"function"},{"location":"coxgroups/#Chevie.CoxGroups.leftdescents-Tuple{CoxeterGroup, Any}","page":"Coxeter groups","title":"Chevie.CoxGroups.leftdescents","text":"leftdescents(W,w)\n\nThe  left descents of the element w of the Coxeter group W, that is the set of i such that length(W,W(i)*w)<length(W,w).\n\njulia> W=coxsym(3)\nğ”– â‚ƒ\n\njulia> leftdescents(W,Perm(1,3))\n2-element Vector{Int64}:\n 1\n 2\n\n\n\n\n\n","category":"method"},{"location":"coxgroups/#PermGroups.Groups.word-Tuple{CoxeterGroup, Any}","page":"Coxeter groups","title":"PermGroups.Groups.word","text":"word(W::CoxeterGroup,w)\n\nreturns  a reduced word in the standard generators of the Coxeter group W for  the  element  w  (represented  as  the  vector  of the corresponding generator indices).\n\njulia> W=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> w=perm\"(1,11)(3,10)(4,9)(5,7)(6,12)\"\n(1,11)(3,10)(4,9)(5,7)(6,12)\n\njulia> w in W\ntrue\n\njulia> word(W,w)\n5-element Vector{Int64}:\n 1\n 2\n 3\n 2\n 1\n\nThe  result  of  Â word  is  the  lexicographically  smallest reduced word for w (for the ordering of the Coxeter generators given by gens(W)).\n\n\n\n\n\n","category":"method"},{"location":"coxgroups/#Base.length-Tuple{CoxeterGroup, Any}","page":"Coxeter groups","title":"Base.length","text":"length(W::CoxeterGroup ,w)\n\nreturns the length of a reduced expression in the Coxeter generators of the element w of W.\n\njulia> W=coxsym(4)\nğ”– â‚„\n\njulia> p=W(1,2,3,1,2,3)\n(1,3)(2,4)\n\njulia> length(W,p)\n4\n\njulia> word(W,p)\n4-element Vector{Int64}:\n 2\n 1\n 3\n 2\n\n\n\n\n\n","category":"method"},{"location":"coxgroups/#Chevie.CoxGroups.longest","page":"Coxeter groups","title":"Chevie.CoxGroups.longest","text":"longest(W)\n\nIf  W is  finite, returns  the unique  element of  maximal length  of the Coxeter group W. May loop infinitely otherwise.\n\njulia> longest(coxsym(4))\n(1,4)(2,3)\n\nlongest(W,I)\n\nreturns  the longest element of the  parabolic subgroup of W generated by the generating reflections of indices in I.\n\njulia> longest(coxsym(4))\n(1,4)(2,3)\n\n\n\n\n\n","category":"function"},{"location":"coxgroups/#PermGroups.Groups.elements-Tuple{CoxeterGroup, Int64}","page":"Coxeter groups","title":"PermGroups.Groups.elements","text":"elements(W::CoxeterGroup[,l])\n\nWhen  l is  not given  this works  only if  W is finite; it returns the elements of W sorted by increasing Coxeter length. If the second argument is an integer l, the elements of W of Coxeter length l are returned.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> e=elements(W,6)\n1-element Vector{Perm{Int16}}:\n (1,7)(2,8)(3,9)(4,10)(5,11)(6,12)\n\njulia> e[1]==longest(W)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"coxgroups/#PermGroups.Groups.words-Union{Tuple{T}, Tuple{CoxeterGroup{T}, T}} where T","page":"Coxeter groups","title":"PermGroups.Groups.words","text":"words(W::CoxeterGroup,w)\n\nreturns  the list  of all  reduced expressions  of the  element w  of the Coxeter group W.\n\njulia> W=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> words(W,longest(W))\n16-element Vector{Vector{Int64}}:\n [1, 2, 1, 3, 2, 1]\n [1, 2, 3, 1, 2, 1]\n [1, 2, 3, 2, 1, 2]\n [1, 3, 2, 1, 3, 2]\n [1, 3, 2, 3, 1, 2]\n [2, 1, 2, 3, 2, 1]\n [2, 1, 3, 2, 1, 3]\n [2, 1, 3, 2, 3, 1]\n [2, 3, 1, 2, 1, 3]\n [2, 3, 1, 2, 3, 1]\n [2, 3, 2, 1, 2, 3]\n [3, 1, 2, 1, 3, 2]\n [3, 1, 2, 3, 1, 2]\n [3, 2, 1, 2, 3, 2]\n [3, 2, 1, 3, 2, 3]\n [3, 2, 3, 1, 2, 3]\n\n\n\n\n\n","category":"method"},{"location":"coxgroups/#PermGroups.Groups.words-Tuple{CoxeterGroup}","page":"Coxeter groups","title":"PermGroups.Groups.words","text":"words(W::CoxeterGroup[,l::Integer])\n\nWith  one argument this works only if W is finite; it returns the reduced Coxeter  words  of  elements  of  W  by  increasing length. If the second argument  is an integer l, only the  elements of length l are returned; this works for infinite Coxeter groups.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> e=elements(W,6)\n1-element Vector{Perm{Int16}}:\n (1,7)(2,8)(3,9)(4,10)(5,11)(6,12)\n\njulia> e[1]==longest(W)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"coxgroups/#Chevie.CoxGroups.bruhatless","page":"Coxeter groups","title":"Chevie.CoxGroups.bruhatless","text":"bruhatless(W, x, y)\n\nwhether xâ‰¤y in the Bruhat order, for x,yâˆˆ W. We have xâ‰¤y if a reduced expression for x can be extracted from one for w. See (Humphreys, 1990; (5.9) and (5.10)) for properties of the Bruhat order.\n\njulia> W=coxgroup(:H,3)\nHâ‚ƒ\n\njulia> w=W(1,2,1,3);\n\njulia> b=filter(x->bruhatless(W,x,w),elements(W));\n\njulia> word.(Ref(W),b)\n12-element Vector{Vector{Int64}}:\n []\n [1]\n [2]\n [3]\n [1, 2]\n [2, 1]\n [1, 3]\n [2, 3]\n [1, 2, 1]\n [1, 2, 3]\n [2, 1, 3]\n [1, 2, 1, 3]\n\n\n\n\n\nbruhatless(W, y)\n\nreturns  a vector  whose i-th  element is  the vector  of elements of W smaller for the Bruhat order than w and of Coxeter length i-1. Thus the first  element  of  the  returned  list  contains  only  one(W)  and  the length(W,w)-th element contains only w.\n\njulia> W=coxsym(3)\nğ”– â‚ƒ\n\njulia> bruhatless(W,Perm(1,3))\n4-element Vector{Vector{Perm{Int16}}}:\n [()]\n [(1,2), (2,3)]\n [(1,2,3), (1,3,2)]\n [(1,3)]\n\nsee also bruhatPoset for Coxeter groups.\n\n\n\n\n\n","category":"function"},{"location":"coxgroups/#FinitePosets.coxeter_matrix","page":"Coxeter groups","title":"FinitePosets.coxeter_matrix","text":"coxeter_matrix(m::AbstractMatrix) or coxmat\n\nreturns  the  Coxeter  matrix  of  the  Coxeter group defined by the cartan matrix m\n\njulia> C=cartan(:H,3)\n3Ã—3 Matrix{Cyc{Int64}}:\n       2  Î¶â‚…Â²+Î¶â‚…Â³   0\n Î¶â‚…Â²+Î¶â‚…Â³        2  -1\n       0       -1   2\n\njulia> coxmat(C)\n3Ã—3 Matrix{Int64}:\n 1  5  2\n 5  1  3\n 2  3  1\n\n\n\n\n\ncoxeter_matrix(W) or coxmat\n\nreturns the Coxeter matrix of the Coxeter group W, that is the matrix m whose  entry m[i,j] contains the order of W(i)*W(j) where W(i) is the i-th  Coxeter generator of  W. An infinite  order is represented by the entry 0.\n\njulia> W=coxsym(4)\nğ”– â‚„\n\njulia> coxmat(W)\n3Ã—3 Matrix{Int64}:\n 1  3  2\n 3  1  3\n 2  3  1\n\n\n\n\n\ncoxeter_matrix(type, rank [,bond]) or coxmat\n\nLike cartan, the function coxmat can be determined from the type and rank of a finite Coxeter group.\n\n\n\n\n\n","category":"function"},{"location":"coxgroups/#Chevie.PermRoot.cartan-Tuple{AbstractMatrix}","page":"Coxeter groups","title":"Chevie.PermRoot.cartan","text":"cartan(M::AbstractMatrix) Cartan matrix from Coxeter matrix\n\nThe  argument should be the Coxeter matrix  M for a Coxeter group W and the   result  is  the  Cartan  Matrix   C  for  the  standard  reflection representation  of W. We have C[s,t]=-2cos(Ï€/M[s,t]), where M[s,s]==1 and  by  convention  Ï€/M[s,t]==0  if  M[s,t]==âˆ,  which we represent by M[s,t]==0.  Since  M  is  symmetric,  the  resulting  C is symmetric, meaning  that all roots  in the constructed  reflection representation have same length.\n\njulia> cartan([1 3;3 1])\n2Ã—2 Matrix{Cyc{Int64}}:\n  2  -1\n -1   2\n\n\n\n\n\n","category":"method"},{"location":"coxgroups/#Chevie.CoxGroups.coxeter_symmetric_group","page":"Coxeter groups","title":"Chevie.CoxGroups.coxeter_symmetric_group","text":"coxeter_symmetric_group(n::Integer) or coxeter_symmetric_group(v::AbstractVector{<:Integer}) or coxsym(n) or coxsym(v::AbstractVector{<:Integer})\n\nThe  symmetric group  on the  numbers 1:n  (or if  a v is given, on the numbers  in v, assumed to be positive and increasing) as a Coxeter group. The Coxeter generators are the Perm(v[i],v[i+1]) for i in 1:length(v)-1.\n\njulia> W=coxsym(3)\nğ”– â‚ƒ\n\njulia> gens(W)\n2-element Vector{Perm{Int16}}:\n (1,2)\n (2,3)\n\njulia> e=elements(W)\n6-element Vector{Perm{Int16}}:\n ()\n (1,2)\n (2,3)\n (1,3,2)\n (1,2,3)\n (1,3)\n\njulia> length.(Ref(W),e) # length in the generators of the elements\n6-element Vector{Int64}:\n 0\n 1\n 1\n 2\n 2\n 3\n\n\n\n\n\n","category":"function"},{"location":"coxgroups/#Chevie.PermRoot.reflection_subgroup-Tuple{CoxSym, AbstractVector{Int64}}","page":"Coxeter groups","title":"Chevie.PermRoot.reflection_subgroup","text":"reflection_subgroup(W::CoxSym,I)\n\nThe  only reflection subgroups defined for  coxsym(n) are for I=a:b for 1â‰¤aâ‰¤bâ‰¤n\n\n\n\n\n\n","category":"method"},{"location":"coxgroups/#Chevie.PermRoot.cartan-Tuple{CoxSym}","page":"Coxeter groups","title":"Chevie.PermRoot.cartan","text":"cartan(W::CoxeterGroup)  The Cartan matrix of W.\n\n\n\n\n\n","category":"method"},{"location":"coxgroups/#Chevie.CoxGroups.coxeter_hyperoctaedral_group","page":"Coxeter groups","title":"Chevie.CoxGroups.coxeter_hyperoctaedral_group","text":"coxeter_hyperoctaedral_group(n)  or coxhyp(n)\n\nThe  Hyperoctaedral group (the group of all signed permutations of Â±1,â€¦,Â±n) as   a  Coxeter   group  of   type  Bâ‚™,   with  generators  (1,-1)  and (i,i+1)(-i,-i-1).\n\njulia> elements(coxhyp(2))\n8-element Vector{SPerm{Int8}}:\n ()\n (1,2)\n (1,-1)\n (1,2,-1,-2)\n (1,-2,-1,2)\n (2,-2)\n (1,-2)\n (1,-1)(2,-2)\n\n\n\n\n\n","category":"function"},{"location":"coxgroups/#Chevie.PermRoot.reflection_subgroup-Tuple{CoxHyp, AbstractVector{Int64}}","page":"Coxeter groups","title":"Chevie.PermRoot.reflection_subgroup","text":"reflection_subgroup(W::CoxHyp,I) is defined only for I=1:m for mâ‰¤ngens(W).\n\n\n\n\n\n","category":"method"},{"location":"coxgroups/#PermGroups.reduced","page":"Coxeter groups","title":"PermGroups.reduced","text":"reduced(W,w)\n\nThe  unique element of  minimal length in  the coset W.w.  This makes sense when  isleftdescent(W,u) makes sense for uâˆˆ  W.w which happens when w is  a Coxeter automorphism of W or  when w lives in a Coxeter overgroup of W.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> H=reflection_subgroup(W,[2,6])\nGâ‚‚â‚â‚‚â‚†â‚=AÌƒâ‚Ã—Aâ‚\n\njulia> word.(Ref(W),unique(reduced.(Ref(H),elements(W))))\n3-element Vector{Vector{Int64}}:\n []\n [1]\n [1, 2]\n\n\n\n\n\nreduced(H::CoxeterGroup,W::CoxeterGroup,i=nref(W))\n\nThe  elements wâˆˆ W which are H-reduced, and of length â‰¤i (by default all of them), grouped by length.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> H=reflection_subgroup(W,[2,6])\nGâ‚‚â‚â‚‚â‚†â‚=AÌƒâ‚Ã—Aâ‚\n\njulia> [word(W,w) for S in reduced(H,W) for w in S]\n3-element Vector{Vector{Int64}}:\n []\n [1]\n [1, 2]\n\n\n\n\n\n","category":"function"},{"location":"coxgroups/#Chevie.CoxGroups.standard_parabolic_class","page":"Coxeter groups","title":"Chevie.CoxGroups.standard_parabolic_class","text":"standard_parabolic_class(W,I)\n\nI  should be a  subset of eachindex(gens(W)).  The function returns the list of such subsets W-conjugate to I.\n\njulia> CoxGroups.standard_parabolic_class(coxgroup(:E,8),[7,8])\n7-element Vector{Vector{Int64}}:\n [7, 8]\n [6, 7]\n [5, 6]\n [4, 5]\n [2, 4]\n [3, 4]\n [1, 3]\n\n\n\n\n\n","category":"function"},{"location":"coxgroups/#Chevie.CoxGroups.coxeter_group-Tuple{AbstractMatrix}","page":"Coxeter groups","title":"Chevie.CoxGroups.coxeter_group","text":"coxeter_group(C) or coxgroup(C)\n\nC  should be  a square  matrix of  integers, rationals or real cyclotomic numbers.  The function returns the Coxeter group whose Cartan matrix is C as  a matrix group with generators the  following reflections: let V be a real  vector space of  dimension size(C,1) and  let eáµ¢ be the canonical basis of V. Then the generators are the reflections sáµ¢(eâ±¼)=eâ±¼-Cáµ¢â±¼ eáµ¢.\n\njulia> W=coxgroup([2 -2;-2 2]) # the affine Weyl group  `AÌƒâ‚`.\ncoxeter_group([2 -2; -2 2])\n\njulia> gens(W) # the matrix generators\n2-element Vector{Matrix{Int64}}:\n [-1 0; 2 1]\n [1 2; 0 -1]\n\n\n\n\n\n","category":"method"},{"location":"coxgroups/#Chevie.CoxGroups.bruhatPoset","page":"Coxeter groups","title":"Chevie.CoxGroups.bruhatPoset","text":"bruhatPoset(W::CoxeterGroup,w=longest(W))\n\nreturns  as a poset the Bruhat interval [1,w]of W. If w is not given, the whole Bruhat Poset of W is returned (W must then be finite).\n\njulia> W=coxsym(3)\nğ”– â‚ƒ\n\njulia> bruhatPoset(W)\n.<1,2<21,12<121\n\nThe  above  poset  is  constructed  efficiently  by  constructing the Hasse diagram, but it could be constructed naively as follows:\n\njulia> p=Poset((x,y)->bruhatless(W,x,y),elements(W))\n()<(1,2),(2,3)<(1,3,2),(1,2,3)<(1,3)\n\nThe  output is not so nice, showing permutations instead of words. This can be fixed by defining:\n\njulia> p.show_element=(io,x,n)->join(io,word(W,x.elements[n]));\n\njulia> p\n<1,2<12,21<121\n\njulia> W=coxsym(4)\nğ”– â‚„\n\njulia> bruhatPoset(W,W(1,3))\n.<3,1<13\n\n\n\n\n\n","category":"function"},{"location":"nf/#Number-fields","page":"Number fields","title":"Number fields","text":"Pages=[\"nf.md\"]","category":"section"},{"location":"nf/#Chevie.Nf","page":"Number fields","title":"Chevie.Nf","text":"Number  fields are the finite extensions of  â„š. The only ones that we can handle  at the  moment are  subfields of  cyclotomic fields,  that is whose elements  are Cycs; they are also  characterized as the number fields K such  that Gal(K/â„š) is abelian.  For example, â„š (âˆš5)  is a number field that is not cyclotomic but contained in the cyclotomic field â„š (Î¶â‚…).\n\nThe default constructor for a number field takes some numbers as arguments and constructs the smallest number field containing its arguments.\n\njulia> F=NF(E(5)) # the full cyclotomic field prints as CF\nCF(5)\n\njulia> K=NF(root(5)) # a subfield\nNF(5,[-1â‚…])\n\njulia> conductor(K) # smallest n such that K is a subfield of CF(n)\n5\n\njulia> E(5)+E(5,-1) in NF(root(5)) # test if an element is in the subfield\ntrue\n\nA  number field K is printed by  giving the conductor c of the smallest cyclotomic field F containing it, and generators of the stabilizer of K in  the  galois  group  of  F.  These  generators  are  elements  of  the multiplicative group of â„¤/câ„¤. Above NF(5,[-1â‚…]) represents the subfield of CF(5) stable by complex conjugacy.\n\njulia> elements(galois(F))\n4-element Vector{Chevie.Nf.NFAut}:\n Aut(CF(5),1â‚…)\n Aut(CF(5),2â‚…)\n Aut(CF(5),-1â‚…)\n Aut(CF(5),-2â‚…)\n\nThe  element of the galois  group of CF(5) printed  -2â‚… acts by raising the  fifth roots of  unity to the  power -2. Thus  -1â‚… represents complex conjugacy.\n\njulia> NF(root(3),root(5)) # here the stabilizer needs 2 generators\nNF(60,[-11â‚†â‚€,-1â‚†â‚€])\n\n\n\n\n\n","category":"module"},{"location":"nf/#Chevie.Nf.NF","page":"Number fields","title":"Chevie.Nf.NF","text":"NF(gens...) or NF(gens::AbstractVector)\n\nreturns the smallest number field containing the elements gens, which may be Cyc, Root1, Integer or Rational{<:Integer}.\n\njulia> NF(E(3),root(5))\nNF(15,[4â‚â‚…])\n\njulia> NF([E(3),root(5)])\nNF(15,[4â‚â‚…])\n\nA number field can also be entered by specifying the conductor and the list of  generators of the stabilizer in the Galois groups. These generators can be entered as Mod or as integers:\n\njulia> NF(15,[Mod(4,15)])\nNF(15,[4â‚â‚…])\n\njulia> NF(15,[4])\nNF(15,[4â‚â‚…])\n\n\n\n\n\nNF(N::Integer, stab::Group{<:Mod})\n\nNumber   field  which  is  the  fixed  field  of  the  subgroup  stab  of galois(CF(N))  in CF(N). stab should not inject in the multiplicative group of a proper divisor of N.\n\n\n\n\n\n","category":"function"},{"location":"nf/#Chevie.Nf.CF","page":"Number fields","title":"Chevie.Nf.CF","text":"CF(N::Integer) the cyclotomic field generated by the N-th roots of unity.\n\n\n\n\n\n","category":"function"},{"location":"nf/#Chevie.Nf.Aut","page":"Number fields","title":"Chevie.Nf.Aut","text":"Aut(F::NumberField,k::Union{Integer,Mod})\n\nThe  Galois  automorphism  Ïƒâ‚–  of  the  cyclotomic field CF(n) raises n-th  roots of unity to the power k; it exists for k prime to n. If F  is a subfield of CF(n), the elements of the orbit of Ïƒâ‚– modulo the stabilizer of F in the Galois group galois(CF(n)) have same restriction to F. An automorphism of F is represented by a canonical representative Ïƒâ‚— of this orbit. This is the result of Aut(F,k). The number k can be given as an integer or as Mod(k,n).\n\njulia> F=NF(root(5))\nNF(5,[-1â‚…])\n\njulia> s=Aut(F,3)\nAut(NF(5,[-1â‚…]),2â‚…)\n\njulia> root(5)^s # action of s on a Cyc\nCyc{Int64}: -âˆš5\n\n\n\n\n\n","category":"function"},{"location":"nf/#CyclotomicNumbers.galois-Tuple{Chevie.Nf.NumberField}","page":"Number fields","title":"CyclotomicNumbers.galois","text":"galois(F::NumberField) Galois group of F over â„š\n\nthe  Galois group of F, a number  field of conductor n, is the quotient of  the Galois  group of  CF(n), isomorphic  to the  multiplicative group (â„¤/n)Ë£,  by  the  stabilizer  of  F.  It  is given as a group of Galois automorphisms (see Aut).\n\njulia> K=CF(5)\nCF(5)\n\njulia> F=NF(root(5))\nNF(5,[-1â‚…])\n\njulia> galois(K)\nGroup(Chevie.Nf.NFAut[Aut(CF(5),2â‚…)])\n\njulia> elements(galois(K))\n4-element Vector{Chevie.Nf.NFAut}:\n Aut(CF(5),1â‚…)\n Aut(CF(5),2â‚…)\n Aut(CF(5),-1â‚…)\n Aut(CF(5),-2â‚…)\n\njulia> elements(galois(F))\n2-element Vector{Chevie.Nf.NFAut}:\n Aut(NF(5,[-1â‚…]),1â‚…)\n Aut(NF(5,[-1â‚…]),2â‚…)\n\n\n\n\n\n","category":"method"},{"location":"dseries/#d-Harish-Chandra-series","page":"d-Harish-Chandra series","title":"d-Harish-Chandra series","text":"Pages=[\"dseries.md\"]","category":"section"},{"location":"dseries/#Chevie.dSeries","page":"d-Harish-Chandra series","title":"Chevie.dSeries","text":"d-Harish-Chandra   series  describe  unipotent  l-blocks  of  a  finite reductive  group ğ†(ğ”½_q) for lÎ¦_d(q) (at least, when l is not too small which means mostly not a bad prime for ğ†). Some of the facts stated below  are still partly conjectural, we do not try to distinguish precisely what has been established and what is still conjectural.\n\nIf  (ğ‹,Î») is  a d-cuspidal  pair then  the constituents  of the Lusztig induced  R_ğ‹^ğ†(Î») are called a d-Harish-Chandra series; they form the unipotent  part  of  an  l-block  of  ğ†^F (BrouÃ© et al., 1993; 5.24). It is conjectured (BrouÃ© and Michel, 1997; 5.7) (and proven in some cases) that the ğ†^F-endomorphism  algebra of the l-adic cohomology of the variety ğ— which  defines  the  Lusztig  induction  is  a d-cyclotomic Hecke algebra H_ğ†(ğ‹Î»)  for the  group W_ğ†(ğ‹Î»)=N_ğ†(ğ‹Î»)ğ‹,  which is  a complex reflection  group  â€“-  here  d-cyclotomic  means  that the parameters of H_ğ†(ğ‹Î»)  are monomials in q and that H_ğ†(ğ‹Î») specializes to the algebra of W_ğ†(ğ‹Î») for qÎ¶_d.\n\nIt  follows that the decomposition of the  Lusztig induction is of the form R_ğ‹^ğ†(Î»)=_Ï•Irr(W_ğ†(ğ‹Î»))(-1)^náµ© Ï•(1)Î³áµ© where Î³áµ© is a unipotent character   of  ğ†^F  attached  to  Ï•  and  where  náµ©  is  the  degree H^náµ©_c(ğ—)  where  Î³áµ©  occurss;  and  further  for  any  Ï• we have R_ğ‹^ğ†(Î»)(1)=  (-1)^náµ© Î³áµ©(1)Sáµ© where Sáµ© is  the Schur element of the character   of   H_ğ†(ğ‹Î»)   which   deforms   to   Ï•.   The  function Series allows to explore a d-Harish-Chandra series.\n\njulia> W=rootdatum(\"3D4\")\nÂ³Dâ‚„\n\njulia> l=cuspidal_data(W,3)\n2-element Vector{@NamedTuple{levi::Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}, cuspidal::Int64, d::Root1}}:\n (levi = Â³Dâ‚„, cuspidal = 8, d = Î¶â‚ƒ)\n (levi = Â³Dâ‚„â‚â‚=Î¦â‚ƒÂ², cuspidal = 1, d = Î¶â‚ƒ)\n\njulia> Series(W,l[2]...)\nÎ¶â‚ƒ-series R^Â³Dâ‚„_{Â³Dâ‚„â‚â‚=Î¦â‚ƒÂ²}(Î»==Id)  H_G(L,Î»)==hecke(Gâ‚„,Vector{Mvp{Cyc{Int64}, Int64}}[[Î¶â‚ƒqÂ², Î¶â‚ƒ, Î¶â‚ƒq]])\nâ”Œâ”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ â”‚    Î³áµ©    Ï†  Îµ family nâ°â”‚\nâ”œâ”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚1â”‚  Ï†â‚â€šâ‚€ Ï†â‚â€šâ‚€  1         1â”‚\nâ”‚2â”‚  Ï†â‚â€šâ‚† Ï†â‚â€šâ‚„  1         2â”‚\nâ”‚3â”‚  Ï†â‚‚â€šâ‚‚ Ï†â‚â€šâ‚ˆ -1         5â”‚\nâ”‚6â”‚ Ï†â€³â‚â€šâ‚ƒ Ï†â‚‚â€šâ‚…  1         4â”‚\nâ”‚5â”‚ Ï†â€²â‚â€šâ‚ƒ Ï†â‚‚â€šâ‚ƒ -1         3â”‚\nâ”‚7â”‚  Ï†â‚‚â€šâ‚ Ï†â‚‚â€šâ‚ -1         5â”‚\nâ”‚4â”‚Â³Dâ‚„[1] Ï†â‚ƒâ€šâ‚‚  1         5â”‚\nâ””â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nAbove  we explore the 3-series corresponding  to R_ğ“^ğ†(Id) where ğ† is the  triality group  and ğ“  is the  torus of  type (qÂ²+q+1)Â². The group W_ğ†(ğ“)  is the complex reflection group Gâ‚„. The displays shows in the column   'Î³áµ©'  the  name  of   the  unipotent  characters  constituents  of R_ğ“^ğ†(Id),  and in the  first column the  number of these characters in the  list  of  unipotent  characters.  In  the  column  'Ï†' the name of the character  of W_ğ†(ğ“) corresponding  to the unipotent  character Î³áµ© is shown;  in the column  'Îµ' we show  the sign (-1)^náµ©.  Finally in the last column we show in which family of unipotent characters is Î³áµ©.\n\nThe theory of d-Harish-Chandra series can be generalized to spetsial complex reflection groups using some axioms. We show below an example.\n\njulia> W=complex_reflection_group(4)\nGâ‚„\n\njulia> l=cuspidal_data(W,3)\n5-element Vector{@NamedTuple{levi::Spets{PRSG{Cyc{Rational{Int64}}, Int16}}, cuspidal::Int64, d::Root1}}:\n (levi = Gâ‚„, cuspidal = 3, d = Î¶â‚ƒ)\n (levi = Gâ‚„, cuspidal = 6, d = Î¶â‚ƒ)\n (levi = Gâ‚„, cuspidal = 7, d = Î¶â‚ƒ)\n (levi = Gâ‚„, cuspidal = 10, d = Î¶â‚ƒ)\n (levi = Gâ‚„â‚â‚=Î¦â‚Î¦â€²â‚ƒ, cuspidal = 1, d = Î¶â‚ƒ)\n\njulia> Series(W,l[5]...)\nÎ¶â‚ƒ-series R^Gâ‚„_{Gâ‚„â‚â‚=Î¦â‚Î¦â€²â‚ƒ}(Î»==Id)  W_G(L,Î»)==Zâ‚†\nâ”Œâ”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ â”‚   Î³áµ© Ï†(mod 3)  Îµ parameter family nâ°â”‚\nâ”œâ”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚1â”‚ Ï†â‚â€šâ‚€        1  1      Î¶â‚ƒqÂ²         1â”‚\nâ”‚5â”‚ Ï†â‚‚â€šâ‚ƒ       Î¶â‚†  1      -Î¶â‚ƒq         2â”‚\nâ”‚2â”‚ Ï†â‚â€šâ‚„       Î¶â‚ƒ -1        Î¶â‚ƒ         4â”‚\nâ”‚8â”‚ Zâ‚ƒ:2       -1 -1     -Î¶â‚ƒÂ²q         2â”‚\nâ”‚9â”‚Zâ‚ƒ:11      Î¶â‚ƒÂ² -1       Î¶â‚ƒÂ²         4â”‚\nâ”‚4â”‚ Ï†â‚‚â€šâ‚…      Î¶â‚†âµ -1       -Î¶â‚ƒ         4â”‚\nâ””â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nAbove  we explore the 3-series corresponding  to the trivial character of the  torus of type (q-1)(q-Î¶â‚ƒ). For cyclic groups W_ğ†(ğ‹Î») we display the  parameters in  the table  since they  are associated  to characters of W_ğ†(ğ‹Î»). Finally the mention (mod 3) which appears in the Ï† column means that in this case the axioms leave an ambiguity in the correspondence between  unipotent  characters  Î³áµ©  and  characters  Ï• (as well as with parameters):  the correspondence is known only up to a translation by 3 (in this case, the same as a global multiplication of all Ï• by -1).\n\nFinally,  we should note that  if the reflection group  or coset W is not defined  over the integers,  what counts is  not cyclotomic polynomials but factors  of them  over the  field of  definition of  W. In this case, one should not give as argument an integer d representing Î¶_d but specify a  root of unity. For instance, in the above case we get a different answer with:\n\njulia> cuspidal_data(W,E(3,2))\n5-element Vector{@NamedTuple{levi::Spets{PRSG{Cyc{Rational{Int64}}, Int16}}, cuspidal::Int64, d::Root1}}:\n (levi = Gâ‚„, cuspidal = 2, d = Î¶â‚ƒÂ²)\n (levi = Gâ‚„, cuspidal = 5, d = Î¶â‚ƒÂ²)\n (levi = Gâ‚„, cuspidal = 7, d = Î¶â‚ƒÂ²)\n (levi = Gâ‚„, cuspidal = 10, d = Î¶â‚ƒÂ²)\n (levi = Gâ‚„â‚â‚=Î¦â‚Î¦â€³â‚ƒ, cuspidal = 1, d = Î¶â‚ƒÂ²)\n\n\n\n\n\n","category":"module"},{"location":"dseries/#Chevie.Uch.cuspidal_data","page":"d-Harish-Chandra series","title":"Chevie.Uch.cuspidal_data","text":"cuspidal_data(W[,d[,ad]];proper=false,all=false)\n\nreturns  named tuples (levi=LF,cuspidal=Î»,d=d) where  LF is a d-split Levi  (with d-center  of dimension  ad if  ad is  given) and Î» is a d-cuspidal  character of  LF. If  d=1 this  returns ordinary cuspidal characters.  The  character  Î»  is  given  as  its  index  in the list of unipotent  characters. If d was given as  an integer, it is returned as a Root1 representing E(d).\n\nIf  the keyword  proper=true is  given, only  the data  where LF!=W (or equivalently ad>0) are returned.\n\nIf  d is omitted, data  for all d orders  of eigenvalues of elements of W  is returned. If in addition  the keyword argument all=true is given, data for all eigenvalues of elements of W is returned.\n\njulia> cuspidal_data(coxgroup(:F,4),1)\n9-element Vector{@NamedTuple{levi::Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}, cuspidal::Int64, d::Root1}}:\n (levi = Fâ‚„, cuspidal = 31, d = 1)\n (levi = Fâ‚„, cuspidal = 32, d = 1)\n (levi = Fâ‚„, cuspidal = 33, d = 1)\n (levi = Fâ‚„, cuspidal = 34, d = 1)\n (levi = Fâ‚„, cuspidal = 35, d = 1)\n (levi = Fâ‚„, cuspidal = 36, d = 1)\n (levi = Fâ‚„, cuspidal = 37, d = 1)\n (levi = Fâ‚„â‚â‚‚â‚ƒâ‚=Bâ‚‚â‚â‚‚â‚â‚Î¦â‚Â², cuspidal = 6, d = 1)\n (levi = Fâ‚„â‚â‚=Î¦â‚â´, cuspidal = 1, d = 1)\n\njulia> cuspidal_data(complex_reflection_group(4),3)\n5-element Vector{@NamedTuple{levi::Spets{PRSG{Cyc{Rational{Int64}}, Int16}}, cuspidal::Int64, d::Root1}}:\n (levi = Gâ‚„, cuspidal = 3, d = Î¶â‚ƒ)\n (levi = Gâ‚„, cuspidal = 6, d = Î¶â‚ƒ)\n (levi = Gâ‚„, cuspidal = 7, d = Î¶â‚ƒ)\n (levi = Gâ‚„, cuspidal = 10, d = Î¶â‚ƒ)\n (levi = Gâ‚„â‚â‚=Î¦â‚Î¦â€²â‚ƒ, cuspidal = 1, d = Î¶â‚ƒ)\n\n\n\n\n\n","category":"function"},{"location":"dseries/#Chevie.dSeries.Series","page":"d-Harish-Chandra series","title":"Chevie.dSeries.Series","text":"Series(W, L, cuspidal, d)\n\nIf the reflection coset or group W corresponds to the algebraic group ğ† and  cuspidal is the  index of a  d-cuspidal unipotent character Î» of the  d-split Levi ğ‹, constructs the d-series R_ğ‹^ğ†(Î»). The result s has the following properties and functions:\n\ns.spets: the reflection group or coset W.\ns.levi: the subcoset L.\ns.cuspidal: the index of Î» in UnipotentCharacters(L).\ns.d: the value of d (a Root1).\nrelative_group(s): the group W_ğ†(ğ‹Î»).\ns.e: the order of W_ğ†(ğ‹Î»).\ndSeries.RLG(s): the UnipotentCharacter given by R_ğ‹^ğ†(Î»).\nsigns(s):  for each  character Ï†  of relative_group(s) the sign (-1)^n_Ï†  in RLG(s) of the corresponding constituent Î³áµ© of RLG(s).\ndegree(s): the generic degree of RLG(s), as a CycPol.\ncharnumbers(s):  the indices in  UnipotentCharacters(W) of the\n\nconstituents of RLG(s).\n\nhecke(s): the hecke algebra H_ğ†(ğ‹Î»).\n\nThe function Series has another form:\n\nSeries(W [,d [,ad]];k...)\n\nwhere it returns a vector of Series corresponding to the cuspidal_data described by the arguments and the keywords.\n\njulia> W=complex_reflection_group(4)\nGâ‚„\n\njulia> Series(W,3;proper=true)\n1-element Vector{Series}:\n Î¶â‚ƒ-series R^Gâ‚„_{Gâ‚„â‚â‚=Î¦â‚Î¦â€²â‚ƒ}(Î»==Id)  W_G(L,Î»)==Zâ‚†\n\njulia> s=Series(W,3,1)[1]\nÎ¶â‚ƒ-series R^Gâ‚„_{Gâ‚„â‚â‚=Î¦â‚Î¦â€²â‚ƒ}(Î»==Id)  W_G(L,Î»)==Zâ‚†\nâ”Œâ”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ â”‚   Î³áµ© Ï†(mod 3)  Îµ parameter family nâ°â”‚\nâ”œâ”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚1â”‚ Ï†â‚â€šâ‚€        1  1      Î¶â‚ƒqÂ²         1â”‚\nâ”‚5â”‚ Ï†â‚‚â€šâ‚ƒ       Î¶â‚†  1      -Î¶â‚ƒq         2â”‚\nâ”‚2â”‚ Ï†â‚â€šâ‚„       Î¶â‚ƒ -1        Î¶â‚ƒ         4â”‚\nâ”‚8â”‚ Zâ‚ƒ:2       -1 -1     -Î¶â‚ƒÂ²q         2â”‚\nâ”‚9â”‚Zâ‚ƒ:11      Î¶â‚ƒÂ² -1       Î¶â‚ƒÂ²         4â”‚\nâ”‚4â”‚ Ï†â‚‚â€šâ‚…      Î¶â‚†âµ -1       -Î¶â‚ƒ         4â”‚\nâ””â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\njulia> s.spets\nGâ‚„\n\njulia> s.levi\nGâ‚„â‚â‚=Î¦â‚Î¦â€²â‚ƒ\n\njulia> s.cuspidal\n1\n\njulia> s.d\nRoot1: Î¶â‚ƒ\n\njulia> hecke(s)\nhecke(Gâ‚†â€šâ‚â€šâ‚,Vector{Mvp{Cyc{Int64}, Int64}}[[Î¶â‚ƒqÂ², -Î¶â‚ƒq, Î¶â‚ƒ, -Î¶â‚ƒÂ²q, Î¶â‚ƒÂ², -Î¶â‚ƒ]])\n\njulia> degree(s)\nÎ¶â‚ƒÎ¦â‚Î¦â‚‚Â²Î¦â€³â‚ƒÎ¦â‚„Î¦â‚†\n\njulia> dSeries.RLG(s)\n[Gâ‚„]:<Ï†â‚â€šâ‚€>-<Ï†â‚â€šâ‚„>-<Ï†â‚‚â€šâ‚…>+<Ï†â‚‚â€šâ‚ƒ>-<Zâ‚ƒ:2>-<Zâ‚ƒ:11>\n\njulia> charnumbers(s)\n6-element Vector{Int64}:\n 1\n 5\n 2\n 8\n 9\n 4\n\njulia> signs(s)\n6-element Vector{Int64}:\n  1\n  1\n -1\n -1\n -1\n -1\n\njulia> relative_group(s)\nGâ‚†â€šâ‚â€šâ‚\n\n\n\n\n\n","category":"type"},{"location":"dseries/#Chevie.Symbols.ennola","page":"d-Harish-Chandra series","title":"Chevie.Symbols.ennola","text":"ennola(S::CharSymbol)\n\nEnnola of e-symbol S (of content 1 or 0) The order of Ennola (order of  center of  reflection group)  is computed  automatically: it is e for content 1 and gcd(e,rank(S)) for content 0.\n\n\n\n\n\nennola(W[,z=E(gcd(degrees(W)))])\n\nLet  W be an irreducible spetsial reflection  group or coset, and z the generator of the center of W, viewed as the root of unity E(gcd(degrees(W)))]).  Let ğ”¾ be  the spets attached  to W. A property checked  case-by case is  that, for a  unipotent character Î³  of ğ”¾ with polynomial generic degree deg Î³(q) , deg Î³(zq) is equal to Â±deg Î³'(q) for  another unipotent character Î³'; Â±Î³' is called the Ennola transform of Î³. For W a Weyl group, the spets ğ”¾ is a finite reductive group, in which  case z=-1  if -1  is in  W and  z=1 otherwise.  The function returns  the  signed  permutation  e  done  by  ennola on the unipotent degrees (as an SPerm of 1:length(UnipotentCharacters(W))).\n\nThe SPerm e is not uniquely determined by the degrees since two degrees may  be equal, but is uniquely determined by some additional axioms that we do not recall here (they include a description of the Ennola-permutation in terms of the Z-based rings attached to each Lusztig family).\n\nIf  a second argument z is given, it should be a power of the default z and the corresponding power of e is returned.\n\njulia> ennola(rootdatum(\"3D4\"))\nSPerm{Int64}: (3,-4)(5,-5)(6,-6)(7,-8)\n\njulia> ennola(complex_reflection_group(14))\nSPerm{Int64}: (2,43,-14,16,41,34)(3,35,40,18,-11,42)(4,-37,25,-17,-26,-36)(5,-6,-79)(7,-7)(8,-74)(9,-73)(10,-52,13,31,-50,29)(12,53,15,32,-51,-30)(19,71,70,21,67,68,20,69,72)(22,-39,27,-33,-28,-38)(23,24,-66,-23,-24,66)(44,46,49,-44,-46,-49)(45,48,47,-45,-48,-47)(54,-63,-55,-57,62,-56)(58,-65,-59,-61,64,-60)(75,-77)(76,-76)(78,-78)\n\n\nThe  above example shows  that it may  happen that the  order of z-Ennola (here 18) is greater than the order of z (here 6); this is related to the presence  of irrationalities  qâ…“ in  the character  table of the spetsial Hecke algebra of W.\n\nFor a non-irreducible group, z-ennola is defined if z can be considered an element of the the centre of each irreducible component.\n\n\n\n\n\n","category":"function"},{"location":"sscoset/#Non-connected-reductive-groups","page":"Non-connected reductive groups","title":"Non-connected reductive groups","text":"Pages=[\"sscoset.md\"]","category":"section"},{"location":"sscoset/#Chevie.Sscoset","page":"Non-connected reductive groups","title":"Chevie.Sscoset","text":"Quasi-Semisimple elements of non-connected reductive groups\n\nWe also use Coxeter cosets to represented non-connected reductive groups of the  form ğ† â‹Š Ïƒ where  ğ† is a connected  reductive group and Ïƒ is an algebraic automorphism of ğ†; more specifically to represent the coset ğ† .Ïƒ.  We may always choose Ïƒâˆˆğ†â‹…Ïƒ quasi-semisimple, which means that Ïƒ preserves  a pair ğ“ âŠ‚ ğ of a maximal  torus and a Borel subgroup of ğ†, and  further quasi-central, which means that the Weyl group of C_ğ†(Ïƒ) is W^Ïƒ. Then Ïƒ defines an automorphism Fâ‚€ of the root datum (X(ğ“), Î¦, Y(ğ“), Î¦áµ›), thus a Coxeter coset. We refer to (Digne and Michel, 2018) for details.\n\nWe  have  extended  the  functions  for  semi-simple  elements to work with quasi-semisimple  elements tÏƒâˆˆ  ğ“ â‹…Ïƒ.  Here, as  in (Digne and Michel, 2018), Ïƒ is a quasi-central  automorphism uniquely  defined by  a diagram automorphism of (W,S), taking Ïƒ symplectic in type Aâ‚‚â‚™.\n\nHere are some examples:\n\njulia> WF=rootdatum(:u,6)\nuâ‚†\n\nWe  can  see  WF  as  the  coset  GLâ‚†â‹…Ïƒ  where  Ïƒ  is the composed of transpose, inverse and the longest element of W.\n\njulia> l=quasi_isolated_reps(WF)\n4-element Vector{SemisimpleElement{Root1}}:\n <1,1,1,1,1,1>\n <Î¶â‚„,Î¶â‚„,Î¶â‚„,Î¶â‚„Â³,Î¶â‚„Â³,Î¶â‚„Â³>\n <Î¶â‚„,Î¶â‚„,1,1,Î¶â‚„Â³,Î¶â‚„Â³>\n <Î¶â‚„,1,1,1,1,Î¶â‚„Â³>\n\nwe  define an element tÏƒâˆˆ ğ“ â‹…Ïƒ to  be quasi-isolated if the Weyl group of C_ğ†  (tÏƒ)  is  not  in  any  proper  parabolic  subgroup of W^Ïƒ. This generalizes  the  definition  for  connected  groups.  The  above shows the elements  t  where  tÏƒ  runs  over  representatives  of  quasi-isolated quasi-semisimple  classes of  ğ† â‹…Ïƒ.  The given  representatives have been chosen Ïƒ-stable.\n\njulia> centralizer.(Ref(WF),l)\n4-element Vector{ExtendedCox{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Rational{Int64}}}}:\n Câ‚ƒâ‚â‚ƒâ‚‚â‚â‚\n Â²Aâ‚ƒâ‚â‚ƒâ‚â‚‚â‚\n (Aâ‚Aâ‚)â‚â‚â‚ƒâ‚Ã—Aâ‚â‚â‚‚â‚\n Bâ‚‚Î¦â‚\n\nin  the above example,  the groups C_ğ†(tÏƒ)  are computed and displayed as extended  Coxeter groups (following the same convention as for centralisers in connected reductive groups).\n\nWe  define an element  tÏƒâˆˆ ğ“â‹…Ïƒ to  be isolated if  the Weyl group of C_ğ† (tÏƒ)â° is not in any proper parabolic subgroup of W^Ïƒ. This generalizes the definition for connected groups.\n\njulia> isisolated.(Ref(WF),l)\n4-element BitVector:\n 1\n 1\n 1\n 0\n\n\n\n\n\n","category":"module"},{"location":"sscoset/#PermGroups.Groups.centralizer-Tuple{Spets, SemisimpleElement{Root1}}","page":"Non-connected reductive groups","title":"PermGroups.Groups.centralizer","text":"centralizer(WF::Spets,t::SemisimpleElement{Root1})  \n\nWF  should be  a Coxeter  coset representing  an algebraic  coset ğ† â‹…Ïƒ, where  ğ† is a connected reductive group (represented by W:=Group(WF)), and  Ïƒ  is  a  quasi-central  automorphism  of  ğ† defined by WF. The element t should be a semisimple element of ğ†. The function returns an extended reflection group describing C_ğ†(tÏƒ), with the reflection group part  representing C_ğ†(tÏƒ)â°,  and the  diagram automorphism  part being those induced by C_ğ†(tÏƒ)C_ğ†(tÏƒ)â° on C_ğ†(tÏƒ)â°.\n\njulia> WF=rootdatum(:u,6)\nuâ‚†\n\njulia> s=ss(Group(WF),[1//4,0,0,0,0,3//4])\nSemisimpleElement{Root1}: <Î¶â‚„,1,1,1,1,Î¶â‚„Â³>\n\njulia> centralizer(WF,s)\nBâ‚‚Î¦â‚\n\njulia> centralizer(WF,one(s))\nCâ‚ƒâ‚â‚ƒâ‚‚â‚â‚\n\n\n\n\n\n","category":"method"},{"location":"sscoset/#Chevie.Semisimple.quasi_isolated_reps-Tuple{Spets}","page":"Non-connected reductive groups","title":"Chevie.Semisimple.quasi_isolated_reps","text":"quasi_isolated_reps(WF::Spets,p=0)\n\nWF  should be  a Coxeter  coset representing  an algebraic  coset ğ† â‹…Ïƒ, where  ğ† is a connected  reductive group (represented by W=Group(WF)), and  Ïƒ  is  a  quasi-central  automorphism  of  ğ† defined by WF. The function returns a list of semisimple elements of ğ† such that tÏƒ, when t  runs over this  list, are representatives  of the conjugacy classes of quasi-isolated quasisemisimple elements of ğ† â‹…Ïƒ (an element tÏƒâˆˆ ğ“ â‹…Ïƒ is quasi-isolated  if  the  Weyl  group  of  C_ğ†  (tÏƒ)  is not in any proper parabolic  subgroup of W^Ïƒ). If a second  argument p is given, it lists only those representatives which exist in characteristic p.\n\njulia> WF=rootdatum(\"2E6sc\")\nÂ²Eâ‚†sc\n\njulia> quasi_isolated_reps(WF)\n5-element Vector{SemisimpleElement{Root1}}:\n <1,1,1,1,1,1>\n <1,-1,Î¶â‚„,1,Î¶â‚„,1>\n <1,1,1,-1,1,1>\n <1,Î¶â‚ƒÂ²,1,Î¶â‚ƒ,1,1>\n <1,Î¶â‚„Â³,1,-1,1,1>\n\njulia> quasi_isolated_reps(WF,2)\n2-element Vector{SemisimpleElement{Root1}}:\n <1,1,1,1,1,1>\n <1,Î¶â‚ƒÂ²,1,Î¶â‚ƒ,1,1>\n\njulia> quasi_isolated_reps(WF,3)\n4-element Vector{SemisimpleElement{Root1}}:\n <1,1,1,1,1,1>\n <1,-1,Î¶â‚„,1,Î¶â‚„,1>\n <1,1,1,-1,1,1>\n <1,Î¶â‚„Â³,1,-1,1,1>\n\n\n\n\n\n","category":"method"},{"location":"sscoset/#Chevie.Semisimple.isisolated-Tuple{Spets, SemisimpleElement{Root1}}","page":"Non-connected reductive groups","title":"Chevie.Semisimple.isisolated","text":"isisolated(WF::Spets,t::SemisimpleElement{Root1})\n\nWF  should be  a Coxeter  coset representing  an algebraic  coset ğ† â‹…Ïƒ, where  ğ† is a connected  reductive group (represented by W=Group(WF)), and  Ïƒ  is  a  quasi-central  automorphism  of  ğ† defined by WF. The element  t should be a semisimple element of ğ†. The function returns a boolean describing whether tÏƒ is isolated, that is whether the Weyl group of C_ğ† (tÏƒ)â° is not in any proper parabolic subgroup of W^Ïƒ.\n\njulia> WF=rootdatum(:u,6)\nuâ‚†\n\njulia> l=quasi_isolated_reps(WF)\n4-element Vector{SemisimpleElement{Root1}}:\n <1,1,1,1,1,1>\n <Î¶â‚„,Î¶â‚„,Î¶â‚„,Î¶â‚„Â³,Î¶â‚„Â³,Î¶â‚„Â³>\n <Î¶â‚„,Î¶â‚„,1,1,Î¶â‚„Â³,Î¶â‚„Â³>\n <Î¶â‚„,1,1,1,1,Î¶â‚„Â³>\n\njulia> isisolated.(Ref(WF),l)\n4-element BitVector:\n 1\n 1\n 1\n 0\n\n\n\n\n\n","category":"method"},{"location":"uch/#Unipotent-characters","page":"Unipotent characters","title":"Unipotent characters","text":"Pages=[\"uch.md\"]","category":"section"},{"location":"uch/#Chevie.Uch","page":"Unipotent characters","title":"Chevie.Uch","text":"Let  ğ† be a connected reductive group over an algebraic closure of the finite  field ğ”½_q,  defined over  ğ”½_q, with corresponding Frobenius automorphism  F. We  want to  study the  irreducible characters  of ğ† ^F.  More generally we consider ğ† ^F where F is a Frobenius root, an  isogeny of  ğ†  such that  a power  is a Frobenius (this covers the Suzuki and Ree groups).\n\nIf  ğ“ is an  F-stable maximal torus  of ğ†, and  ğ is a (not necessarily  F-stable) Borel  subgroup containing  ğ“, we define the Deligne-Lusztig  variety X_ğ=gğğ†ğ  gğF(gğ) . This variety affords  a  natural  action  of  ğ†^F  on the left, so the corresponding Deligne-Lusztig  virtual module  given by  the â„“-adic  cohomology with compact  support  H^*_c(X_ğ)=áµ¢(-1)â±Hâ±_c(X_ğâ„šÌ„_â„“)  has  an  action of ğ†^F  on  the  right.  The  (virtual)  character  of  this module is the Deligne-Lusztig character R_ğ“^ğ†(1); the notation reflects the theorem that  this character does not depend on the choice of ğ. This character can  be parameterized by an F-conjugacy class of W: if ğ“â‚€ğâ‚€ is an F-stable pair, there is an unique w W=N_ğ† (ğ“â‚€)ğ“â‚€ such that the triple  (ğ“ğF)  is  ğ†-conjugate  to  (ğ“â‚€ğâ‚€wF).  We will thus denote  R_w  for  R_ğ“^ğ†(1);  this  character  depends  only  on the F-class of w.\n\nThe  unipotent characters of ğ†^F are the irreducible constituents of the  R_w. In a similar way that the Jordan decomposition shows that the unipotent classes are a building block for describing the conjugacy classes of  a  reductive  group,  Lusztig  has  defined  a  Jordan decomposition of characters  where  the  unipotent  characters  are  the building block. The unipotent  characters are parameterized by  combinatorial data that Lusztig has  defined just  from the  coset WÏ†,  where Ï†  is the  finite order automorphism  of X(ğ“â‚€)  such that  F=qÏ†. Thus,  from our viewpoint, unipotent  characters  are  objects  combinatorially  attached to a Coxeter coset.\n\nA  subset  of  the  unipotent  characters, the principal series unipotent characters,  can  be  described  in  a  more  elementary  way. They are the constituents  of  Râ‚,  or  equivalently  the  characters of the virtual module   H^*_c(X_ğâ‚€),  where  X_ğâ‚€   is  the  discrete  variety (ğ†ğâ‚€)^F;   this   virtual   module   reduces   to  the  actual  module â„šÌ„_â„“(ğ†ğâ‚€)^F.  Thus the  Deligne-Lusztig induction Râ‚=R_ğ“â‚€^ğ†(1) reduces  to Harish-Chandra induction, defined  as follows: let ğ=ğ”ğ‹ be an F-stable Levi decomposition of an F-stable parabolic subgroup of ğ†.  Then the Harish-Chandra induced R_ğ‹^ğ† of a character Ï‡ of ğ‹^F  is the character Ind_ğ^F^ğ† ^FÏ‡Ìƒ,  where Ï‡Ìƒ is the lift to  ğ^F  of  Ï‡  via  the  quotient  ğ^Fğ”^F=ğ‹^F; Harish-Chandra induction  is a  particular case  of Lusztig  induction, which is defined when  ğ  is  not  F-stable  using  the  variety  X_ğ”= gğ”ğ†ğ”  gğ”F(gğ”), and gives for an ğ‹^F-module a virtual ğ† ^F-module. Like  ordinary induction, these  functors have adjoint  functors going from representations    of   ğ†^F    to   representations    (resp.   virtual representations)   of  ğ‹^F  called  Harish-Chandra  restriction  (resp. Lusztig restriction).\n\nThe  commuting algebra of ğ†^F-endomorphisms of Râ‚=R_ğ“â‚€^ğ†(1) is an Iwahori-Hecke  algebra for W^Ï†, with parameters some powers of q; the parameters  are  all  equal  to  q  when W^Ï†=W. Thus principal series unipotent characters are parametrized by characters of W^Ï†.\n\nTo   understand  the  decomposition  of  more  general  R_w,  and  thus parameterize unipotent characters, is is useful to introduce another set of class  functions which are  parameterized by irreducible  characters of the coset  WÏ†.  If  Ï‡  is  such  a  character, we define the associated almost  character by:  Ráµª=WÂ¹_w WÏ‡(wÏ†)  R_w. The  name reflects that these class function are close to irreducible characters. They satisfy Ráµª  R_Ïˆ_ğ†^F=Î´_Ï‡Ïˆ;  for  the  linear  and unitary group they are actually  unipotent characters (up to sign in the latter case). They are in general the sum (with rational coefficients) of a small number of unipotent characters in the same Lusztig family, see Families. The degree of  Ráµª  is  a  polynomial  in  q  equal  to  the fake degree of the character Ï‡ of WÏ† (see fakedegree).\n\nWe   now  describe  the  parameterization   of  unipotent  characters  when W^Ï†=W,  in  which  case  the  coset  WÏ†  identifies with W (the general  situation is  similar but  a bit  more difficult to describe). The (rectangular) matrix of scalar products Ï Ráµª_ğ† ^F, when characters of  W  and  unipotent  characters  are  arranged in the right order, is block-diagonal   with  rather  small  blocks   which  are  called  Lusztig families.\n\nFor  the characters  of W  a family  ğ“• corresponds  to a block of the Hecke  algebra  over  a  ring  called  the  Rouquier  ring.  To ğ“• Lusztig associates  a small group Î“ (equal  to (â„¤2)â¿ for rather small n, or ğ”–áµ¢ for i5) such that the unipotent characters in the family are parameterized  by the  characters of  the Drinfed  double of  Î“, that is pairs(x,Î¸)taken up toÎ“-conjugacy, wherexâˆˆÎ“andÎ¸is an irreducible   character  ofC_Î“(x).  Further,   the  elements  ofğ“•themselves are parameterized by a subset of such pairs, and Lusztig defines a  pairing  between  such  pairs  which  computes  the scalar productâŸ¨Ï, RáµªâŸ©_{ğ†^F},  called  the  *Lusztig  Fourier  matrix*. For more details see [drinfeld_double`](@ref).\n\nA  second parameterization  of unipotent  character is  via Harish-Chandra series.  A character is called cuspidal if all its proper Harish-Chandra restrictions  vanish. There are few  cuspidal unipotent characters (none in GLâ‚™  for  n1,  and  at  most  one  in other classical groups). The ğ†^F-endomorphism algebra of an Harish-Chandra induced R_ğ‹^F^ğ†^FÎ»,  where  Î»  is  a  cuspidal unipotent character is a Hecke algebra associated to the group W_ğ†^F(ğ‹^F)=N_ğ†^F(ğ‹)ğ‹, which turns  out  to  be  a  Coxeter  group.  Thus another parameterization is by triples  (ğ‹Î»Ï†),  where  Î»  is  a  cuspidal unipotent character of ğ‹^F  and  Ï†  is  an  irreducible  character of the relative group W_ğ†^F(ğ‹^F).  Such characters are said to belong to the Harish-Chandra series determined by (ğ‹Î»).\n\nA  final  piece  of  information  attached  to  unipotent characters is the eigenvalues of Frobenius. Let FáµŸ be the smallest power of the isogeny F  which  is  a  split  Frobenius  (that  is, FáµŸ is a Frobenius and Ï†áµŸ=1). Then FáµŸ acts naturally on Deligne-Lusztig varieties and thus on  the  corresponding  virtual  modules,  and  commutes  to  the action of ğ†^F;  thus for  a given  unipotent character  Ï, a submodule of the virtual  module which  affords Ï  affords a  single eigenvalue Î¼ of FáµŸ.  (Lusztig, 1978; 3.9)  and  (Digne and Michel, 1985; II,  2.3)  show that this eigenvalue  is of the form qáµƒáµŸÎ»áµ¨ where 2aâ„¤ and Î»áµ¨ is a root of unity, and where the parity of 2a and Î»áµ¨ depend only on Ï and not the  considered module. This Î»áµ¨ is  called the eigenvalue of Frobenius attached  to Ï. Unipotent characters in the Harish-Chandra series of a pair (ğ‹Î») have the same eigenvalue of Frobenius as Î».\n\nChevie   contains  tables  of  all  this  information,  and  can  compute Harish-Chandra  and Lusztig  induction of  unipotent characters  and almost characters. We illustrate this on some examples:\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> uc=UnipotentCharacters(W)\nUnipotentCharacters(Gâ‚‚)\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚Î³      â”‚nâ‚€    Deg(Î³)  Feg              Symbol Fr(Î³)    labelâ”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚Ï†â‚â€šâ‚€   â”‚ 1         1    1       (0,0,0,0,0,2)     1         â”‚\nâ”‚Ï†â‚â€šâ‚†   â”‚ 2        qâ¶   qâ¶ (01,01,01,01,01,12)     1         â”‚\nâ”‚Ï†â€²â‚â€šâ‚ƒ  â”‚ 3   qÎ¦â‚ƒÎ¦â‚†/3   qÂ³            (0,0,1+)     1    (1,Ï)â”‚\nâ”‚Ï†â€³â‚â€šâ‚ƒ  â”‚ 4   qÎ¦â‚ƒÎ¦â‚†/3   qÂ³            (0,0,1-)     1   (gâ‚ƒ,1)â”‚\nâ”‚Ï†â‚‚â€šâ‚   â”‚ 5  qÎ¦â‚‚Â²Î¦â‚ƒ/6  qÎ¦â‚ˆ       (0,0,0,0,1,1)     1    (1,1)â”‚\nâ”‚Ï†â‚‚â€šâ‚‚   â”‚ 6  qÎ¦â‚‚Â²Î¦â‚†/2 qÂ²Î¦â‚„       (0,0,0,1,0,1)     1   (gâ‚‚,1)â”‚\nâ”‚Gâ‚‚[-1] â”‚ 7  qÎ¦â‚Â²Î¦â‚ƒ/2    0       (01,0,01,,0,)    -1   (gâ‚‚,Îµ)â”‚\nâ”‚Gâ‚‚[1]  â”‚ 8  qÎ¦â‚Â²Î¦â‚†/6    0       (01,01,0,,,0)     1    (1,Îµ)â”‚\nâ”‚Gâ‚‚[Î¶â‚ƒ] â”‚ 9 qÎ¦â‚Â²Î¦â‚‚Â²/3    0       (01,0,0,01,,)    Î¶â‚ƒ  (gâ‚ƒ,Î¶â‚ƒ)â”‚\nâ”‚Gâ‚‚[Î¶â‚ƒÂ²]â”‚10 qÎ¦â‚Â²Î¦â‚‚Â²/3    0       (01,01,,0,0,)   Î¶â‚ƒÂ² (gâ‚ƒ,Î¶â‚ƒÂ²)â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nThe  first column gives  the name of  the unipotent character, derived from its  Harish-Chandra  classification;  the  first  6  characters  are in the principal  series  so  are  named  by  characters  of  W.  The last 4 are cuspidal,  and named by the corresponding eigenvalue of Frobenius, which is displayed  in the fourth  column. For classical  groups, the Harish-Chandra data can be synthesized combinatorially to give a symbol.\n\nThe  first two characters are  each in a Lusztig  family by themselves. The last  eight are in a family associated to the group Î“=ğ”–â‚ƒ: the last column shows  the parameters  (x,Î¸). The  third column  shows the  degree of the unipotent characters, which is transformed by the Lusztig Fourier matrix of the  fourth  column,  which  gives  the  degree of the corresponding almost character,  or equivalently the fake  degree of the corresponding character of W (extended by 0 outside the principal series).\n\nOne  can get  more information  on the  Lusztig Fourier  matrix of  the big family by asking\n\njulia> uc.families[1]\nFamily(D(ğ”– â‚ƒ)) Drinfeld double of ğ”– â‚ƒ, Lusztigâ€²s version\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚label   â”‚no eigen                                               â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚(1,1)*  â”‚ 5     1 1//6  1//2  1//3  1//3  1//6  1//2  1//3  1//3â”‚\nâ”‚(gâ‚‚,1)  â”‚ 6     1 1//2  1//2     .     . -1//2 -1//2     .     .â”‚\nâ”‚(gâ‚ƒ,1)  â”‚ 4     1 1//3     .  2//3 -1//3  1//3     . -1//3 -1//3â”‚\nâ”‚(1,Ï)   â”‚ 3     1 1//3     . -1//3  2//3  1//3     . -1//3 -1//3â”‚\nâ”‚(1,Îµ)-e â”‚ 8     1 1//6 -1//2  1//3  1//3  1//6 -1//2  1//3  1//3â”‚\nâ”‚(gâ‚‚,Îµ)  â”‚ 7    -1 1//2 -1//2     .     . -1//2  1//2     .     .â”‚\nâ”‚(gâ‚ƒ,Î¶â‚ƒ) â”‚ 9    Î¶â‚ƒ 1//3     . -1//3 -1//3  1//3     .  2//3 -1//3â”‚\nâ”‚(gâ‚ƒ,Î¶â‚ƒÂ²)â”‚10   Î¶â‚ƒÂ² 1//3     . -1//3 -1//3  1//3     . -1//3  2//3â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nWe  can also do computations with  individual unipotent characters. Here we construct  the Coxeter torus, and then the identity character of this torus as a unipotent character.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> T=spets(reflection_subgroup(W,Int[]),W(1,2))\nGâ‚‚â‚â‚=Î¦â‚†\n\njulia> u=unipotent_character(T,1)\n[Gâ‚‚â‚â‚=Î¦â‚†]:<Id>\n\nTo construct T one could equivalently do\n\njulia> T=torus(W,position_regular_class(W,6))\nGâ‚‚â‚â‚=Î¦â‚†\n\nHere  are two ways to construct the Deligne-Lusztig character associated to the Coxeter torus:\n\njulia> lusztig_induce(W,u)\n[Gâ‚‚]:<Ï†â‚â€šâ‚€>+<Ï†â‚â€šâ‚†>-<Ï†â‚‚â€šâ‚>+<Gâ‚‚[-1]>+<Gâ‚‚[Î¶â‚ƒ]>+<Gâ‚‚[Î¶â‚ƒÂ²]>\n\njulia> v=deligne_lusztig_character(W,[1,2])\n[Gâ‚‚]:<Ï†â‚â€šâ‚€>+<Ï†â‚â€šâ‚†>-<Ï†â‚‚â€šâ‚>+<Gâ‚‚[-1]>+<Gâ‚‚[Î¶â‚ƒ]>+<Gâ‚‚[Î¶â‚ƒÂ²]>\n\njulia> degree(v)\nPol{Int64}: qâ¶+qâµ-qâ´-2qÂ³-qÂ²+q+1\n\njulia> scalar_product(v,v)\n6\n\nThe  last two lines ask  for the degree of  the virtual character v, then for the scalar product of v with itself.\n\nFinally  we mention  that Chevie  can also  provide unipotent characters of Spetses, as defined in (BrouÃ© et al., 2014). An example:\n\njulia> UnipotentCharacters(complex_reflection_group(4))\nUnipotentCharacters(Gâ‚„)\nâ”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚Î³    â”‚nâ‚€            Deg(Î³)    Feg Fr(Î³)  labelâ”‚\nâ”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚Ï†â‚â€šâ‚€ â”‚ 1                 1      1     1       â”‚\nâ”‚Ï†â‚â€šâ‚„ â”‚ 2  -âˆš-3qâ´Î¦â€³â‚ƒÎ¦â‚„Î¦â€³â‚†/6     qâ´     1   1âˆ§Î¶â‚†â”‚\nâ”‚Ï†â‚â€šâ‚ˆ â”‚ 3   âˆš-3qâ´Î¦â€²â‚ƒÎ¦â‚„Î¦â€²â‚†/6     qâ¸     1 -1âˆ§Î¶â‚ƒÂ²â”‚\nâ”‚Ï†â‚‚â€šâ‚… â”‚ 4         qâ´Î¦â‚‚Â²Î¦â‚†/2   qâµÎ¦â‚„     1  1âˆ§Î¶â‚ƒÂ²â”‚\nâ”‚Ï†â‚‚â€šâ‚ƒ â”‚ 5 -Î¶â‚ƒâˆš-3qÎ¦â€³â‚ƒÎ¦â‚„Î¦â€²â‚†/3   qÂ³Î¦â‚„     1  1âˆ§Î¶â‚ƒÂ²â”‚\nâ”‚Ï†â‚‚â€šâ‚ â”‚ 6 Î¶â‚ƒÂ²âˆš-3qÎ¦â€²â‚ƒÎ¦â‚„Î¦â€³â‚†/3    qÎ¦â‚„     1   1âˆ§Î¶â‚ƒâ”‚\nâ”‚Ï†â‚ƒâ€šâ‚‚ â”‚ 7            qÂ²Î¦â‚ƒÎ¦â‚† qÂ²Î¦â‚ƒÎ¦â‚†     1       â”‚\nâ”‚Zâ‚ƒ:2 â”‚ 8     -âˆš-3qÎ¦â‚Î¦â‚‚Î¦â‚„/3      0   Î¶â‚ƒÂ² Î¶â‚ƒâˆ§Î¶â‚ƒÂ²â”‚\nâ”‚Zâ‚ƒ:11â”‚ 9    -âˆš-3qâ´Î¦â‚Î¦â‚‚Î¦â‚„/3      0   Î¶â‚ƒÂ² Î¶â‚ƒâˆ§Î¶â‚†âµâ”‚\nâ”‚Gâ‚„   â”‚10        -qâ´Î¦â‚Â²Î¦â‚ƒ/2      0    -1  Î¶â‚†âˆ§-1â”‚\nâ””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n\n\n\n\n","category":"module"},{"location":"uch/#Chevie.Uch.UnipotentCharacters","page":"Unipotent characters","title":"Chevie.Uch.UnipotentCharacters","text":"UnipotentCharacters(W)\n\nW  should be a Coxeter group, a  Coxeter Coset or a Spetses. The function gives  back a record containing  information about the unipotent characters of the associated algebraic group (or Spetses). This contains the following fields:\n\n.harishChandra:  information  about  Harish-Chandra  series  of  unipotent characters.  This is itself a list of records, one for each pair (ğ‹,Î») of a  Levi  of  an  F-stable  parabolic  subgroup  and  a cuspidal unipotent character of ğ‹^F. These records themselves have the following fields:\n\n:levi: a list 'l' such that ğ‹ corresponds to 'reflection_subgroup(W,l)'.\n\n:cuspidalName: the name of the unipotent cuspidal character lambda.\n\n:eigenvalue: the eigenvalue of Frobenius for Î».\n\n:relativeType: the reflection type of W_ğ† (ğ‹);\n\n:parameterExponents:  the ğ† ^F-endomorphism  algebra of R_ğ‹^ğ† (Î») is  a  Hecke  algebra  for  W_ğ†  (ğ‹)  with  some parameters of the form q^a_s. This holds the list of exponents a_s.\n\n:charNumbers:  the  indices  of  the  unipotent  characters indexed by the irreducible characters of W_ğ† (ğ‹).\n\n.almostHarishChandra:   information   about   Harish-Chandra   series  of unipotent  character sheaves.  This is  identical to  Ì€harishChandra` for a split  reductive group,  and reflects  the situation  for the corresponding split group for a nonsplit group.\n\n.families:  information  about  Lusztig  families of unipotent characters. This  is itself a list  of records, one for  each family. These records are described in the section about families below.\n\nthe following information is computed on demand from uc=UnipotentCharacters(W):\n\nspets(uc): the reductive group W.\n\njulia> W=coxgroup(:Bsym,2)\nBsymâ‚‚\n\njulia> WF=spets(W,Perm(1,2))\nÂ²Bsymâ‚‚\n\njulia> uc=UnipotentCharacters(WF)\nUnipotentCharacters(Â²Bsymâ‚‚)\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚Î³       â”‚nâ‚€ almostch    Deg(Î³)   Feg        Symbol Fr(Î³) labelâ”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚2       â”‚ 1       2.         1     1     (02,,0,0)     1      â”‚\nâ”‚11      â”‚ 2      .11        qâ´    qâ´ (012,1,01,01)     1      â”‚\nâ”‚Â²Bâ‚‚[1,3]â”‚ 3      1.1 âˆš2qÎ¦â‚Î¦â‚‚/2 qÎ¦â‚Î¦â‚‚     (01,,1,0)   Î¶â‚ˆÂ³     1â”‚\nâ”‚Â²Bâ‚‚[1,5]â”‚ 4       Bâ‚‚ âˆš2qÎ¦â‚Î¦â‚‚/2     0     (01,,0,1)   Î¶â‚ˆâµ     2â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\njulia> uc.families\n3-element Vector{Family}:\n Family(Câ‚,[1])\n Family(Câ‚,[2])\n Family(?4,[3, 4])\n\njulia> uc.families[3]\nFamily(?4) \nâ”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚labelâ”‚no eigen   1*     2â”‚\nâ”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚1*   â”‚ 3   Î¶â‚ˆÂ³ âˆš2/2 -âˆš2/2â”‚\nâ”‚2    â”‚ 4   Î¶â‚ˆâµ âˆš2/2  âˆš2/2â”‚\nâ””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\ncharnames(uc):  the list of names of the unipotent characters.  Using    appropriate keywords, one can control the display in various ways.\n\njulia> uc=UnipotentCharacters(coxgroup(:G,2));\n\njulia> charnames(uc;limit=true)\n10-element Vector{String}:\n \"Ï†â‚â€šâ‚€\"\n \"Ï†â‚â€šâ‚†\"\n \"Ï†â€²â‚â€šâ‚ƒ\"\n \"Ï†â€³â‚â€šâ‚ƒ\"\n \"Ï†â‚‚â€šâ‚\"\n \"Ï†â‚‚â€šâ‚‚\"\n \"Gâ‚‚[-1]\"\n \"Gâ‚‚[1]\"\n \"Gâ‚‚[Î¶â‚ƒ]\"\n \"Gâ‚‚[Î¶â‚ƒÂ²]\"\n\njulia> charnames(uc;TeX=true)\n10-element Vector{String}:\n \"\\phi_{1,0}\"\n \"\\phi_{1,6}\"\n \"\\phi_{1,3}'\"\n \"\\phi_{1,3}''\"\n \"\\phi_{2,1}\"\n \"\\phi_{2,2}\"\n \"G_2[-1]\"\n \"G_2[1]\"\n \"G_2[\\zeta_3]\"\n \"G_2[\\zeta_3^2]\"\n\nOne  can control  the display  of unipotent  characters in  various ways by IOContext properties. In the display, the row labels are the names of the unipotent characters. The possible columns are numbered as follows:\n\nThe index of the character in the list of unipotent characters.\nThe degree of the unipotent character.\nThe degree of the corresponding almost character.\nfor imprimitive groups, the symbol attached to the unipotent character.\nThe eigenvalue of Frobenius attached to the unipotent character.\nThe parameter the character has in its Lusztig family.\n\nWhich  columns  are  displayed  can  be  controlled by the property :cols (default [2,3,5,6] and 4 when applicable).\n\nIn  addition if  ':byfamily=true', the  characters are  displayed family by family  instead  of  in  index  order.  Finally,  the properties rows and columnrepartition  of  format  can  be  set,  giving more tuning of the table.\n\njulia> W=coxgroup(:B,2)\nBâ‚‚\n\njulia> uc=UnipotentCharacters(W)\nUnipotentCharacters(Bâ‚‚)\nâ”Œâ”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚Î³  â”‚nâ‚€ Deg(Î³) Feg   Symbol Fr(Î³) labelâ”‚\nâ”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚11.â”‚ 1  qÎ¦â‚„/2  qÂ²   (12,0)     1   +,-â”‚\nâ”‚1.1â”‚ 2 qÎ¦â‚‚Â²/2 qÎ¦â‚„   (02,1)     1   +,+â”‚\nâ”‚.11â”‚ 3     qâ´  qâ´ (012,12)     1      â”‚\nâ”‚2. â”‚ 4      1   1     (2,)     1      â”‚\nâ”‚.2 â”‚ 5  qÎ¦â‚„/2  qÂ²   (01,2)     1   -,+â”‚\nâ”‚Bâ‚‚ â”‚ 6 qÎ¦â‚Â²/2   0   (012,)    -1   -,-â”‚\nâ””â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\njulia> xdisplay(uc;byfamily=true)\nâ”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚Î³   â”‚nâ‚€ Deg(Î³) Feg   Symbol Fr(Î³) labelâ”‚\nâ”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚11. â”‚ 1  qÎ¦â‚„/2  qÂ²   (12,0)     1   +,-â”‚\nâ”‚1.1Ë¢â”‚ 2 qÎ¦â‚‚Â²/2 qÎ¦â‚„   (02,1)     1   +,+â”‚\nâ”‚.2  â”‚ 5  qÎ¦â‚„/2  qÂ²   (01,2)     1   -,+â”‚\nâ”‚Bâ‚‚  â”‚ 6 qÎ¦â‚Â²/2   0   (012,)    -1   -,-â”‚\nâ”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚2.  â”‚ 4      1   1     (2,)     1      â”‚\nâ”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚.11 â”‚ 3     qâ´  qâ´ (012,12)     1      â”‚\nâ””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\njulia> xdisplay(uc;cols=[1,4])\nUnipotentCharacters(Bâ‚‚)\nâ”Œâ”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚Î³  â”‚nâ‚€   Symbolâ”‚\nâ”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚11.â”‚ 1   (12,0)â”‚\nâ”‚1.1â”‚ 2   (02,1)â”‚\nâ”‚.11â”‚ 3 (012,12)â”‚\nâ”‚2. â”‚ 4     (2,)â”‚\nâ”‚.2 â”‚ 5   (01,2)â”‚\nâ”‚Bâ‚‚ â”‚ 6   (012,)â”‚\nâ””â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n\n\n\n\n","category":"type"},{"location":"uch/#Chevie.PermRoot.degrees-Tuple{UnipotentCharacters, Any}","page":"Unipotent characters","title":"Chevie.PermRoot.degrees","text":"degrees(uc::UnipotentCharacters,q=Pol())\n\nReturns  the  list  of  degrees  of  the unipotent characters of the finite reductive group (or Spetses) with Weyl group (or Spetsial reflection group) W, evaluated at q.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> uc=UnipotentCharacters(W);\n\njulia> degrees(uc)\n10-element Vector{Pol{Rational{Int64}}}:\n 1\n qâ¶\n (1//3)qâµ+(1//3)qÂ³+(1//3)q\n (1//3)qâµ+(1//3)qÂ³+(1//3)q\n (1//6)qâµ+(1//2)qâ´+(2//3)qÂ³+(1//2)qÂ²+(1//6)q\n (1//2)qâµ+(1//2)qâ´+(1//2)qÂ²+(1//2)q\n (1//2)qâµ+(-1//2)qâ´+(-1//2)qÂ²+(1//2)q\n (1//6)qâµ+(-1//2)qâ´+(2//3)qÂ³+(-1//2)qÂ²+(1//6)q\n (1//3)qâµ+(-2//3)qÂ³+(1//3)q\n (1//3)qâµ+(-2//3)qÂ³+(1//3)q\n\n\n\n\n\n","category":"method"},{"location":"uch/#Chevie.Uch.CycPoldegrees","page":"Unipotent characters","title":"Chevie.Uch.CycPoldegrees","text":"CycPoldegrees(uc::UnipotentCharacters)\n\nTaking  advantage that  the degrees  of unipotent  characters of the finite reductive group (or Spetses) with Weyl group (or Spetsial reflection group) W  are products  of cyclotomic  polynomials, this  function returns these degrees as a list of CycPols. It is faster than  CycPol.(degrees(uc)).\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> CycPoldegrees(UnipotentCharacters(W))\n10-element Vector{CycPol{Rational{Int64}}}:\n 1\n qâ¶\n qÎ¦â‚ƒÎ¦â‚†/3\n qÎ¦â‚ƒÎ¦â‚†/3\n qÎ¦â‚‚Â²Î¦â‚ƒ/6\n qÎ¦â‚‚Â²Î¦â‚†/2\n qÎ¦â‚Â²Î¦â‚ƒ/2\n qÎ¦â‚Â²Î¦â‚†/6\n qÎ¦â‚Â²Î¦â‚‚Â²/3\n qÎ¦â‚Â²Î¦â‚‚Â²/3\n\n\n\n\n\n","category":"function"},{"location":"uch/#Chevie.Uch.unipotent_character","page":"Unipotent characters","title":"Chevie.Uch.unipotent_character","text":"unipotent_character(W,l) or unichar(W,l)\n\nConstructs  an object representing the unipotent character specified by l of  the algebraic  group associated  to the  Coxeter group or Coxeter coset specified  by W. There are 3 possibilities  for l: if it is an integer, the  l-th unipotent character of W is  returned. If it is a string, the unipotent  character of W whose name is  l is returned (where the names are as given by charnames(UnipotentCharacters(W))). Finally, l can be a list  of length the number of  unipotent characters of W, which specifies the coefficient to give to each unipotent character.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> u=unichar(W,7)\n[Gâ‚‚]:<Gâ‚‚[-1]>\n\njulia> v=unichar(W,\"G2[E3]\")\n[Gâ‚‚]:<Gâ‚‚[Î¶â‚ƒ]>\n\njulia> w=unichar(W,[1,0,0,-1,0,0,2,0,0,1])\n[Gâ‚‚]:<Ï†â‚â€šâ‚€>-<Ï†â€³â‚â€šâ‚ƒ>+2<Gâ‚‚[-1]>+<Gâ‚‚[Î¶â‚ƒÂ²]>\n\njulia> unichar(W,fourier(UnipotentCharacters(W))[3,:])\n[Gâ‚‚]:2//3<Ï†â€²â‚â€šâ‚ƒ>-1//3<Ï†â€³â‚â€šâ‚ƒ>+1//3<Ï†â‚‚â€šâ‚>+1//3<Gâ‚‚[1]>-1//3<Gâ‚‚[Î¶â‚ƒ]>-1//3<Gâ‚‚[Î¶â‚ƒÂ²]>\n\nThe  last line shows  the almost character  associated to the 3rd unipotent character of W.\n\nsome limited arithmetic is available on unipotent characters:\n\njulia> coefficients(u) # so that u==unichar(W,coefficients(u))\n10-element Vector{Int64}:\n 0\n 0\n 0\n 0\n 0\n 0\n 1\n 0\n 0\n 0\n\njulia> w-2u\n[Gâ‚‚]:<Ï†â‚â€šâ‚€>-<Ï†â€³â‚â€šâ‚ƒ>+<Gâ‚‚[Î¶â‚ƒÂ²]>\n\njulia> scalar_product(w,w)\n7\n\njulia> degree(w)\nPol{Int64}: qâµ-qâ´-qÂ³-qÂ²+q+1\n\n\n\n\n\n","category":"function"},{"location":"uch/#Base.show-Tuple{IO, UniChar}","page":"Unipotent characters","title":"Base.show","text":"Base.show(io::IO,w::UniChar)\n\nThe  formatting  of  unipotent  characters  is  affected  by  IO property :compact .  If true (the default) they are printed in a compact form. Otherwise, they are printed one unipotent character per line:\n\njulia> xdisplay(w;compact=false)\n[Gâ‚‚]:\n<Ï†â‚â€šâ‚€>    1\n<Ï†â‚â€šâ‚†>    0\n<Ï†â€²â‚â€šâ‚ƒ>   0\n<Ï†â€³â‚â€šâ‚ƒ>   -1\n<Ï†â‚‚â€šâ‚>    0\n<Ï†â‚‚â€šâ‚‚>    0\n<Gâ‚‚[-1]>  2\n<Gâ‚‚[1]>   0\n<Gâ‚‚[Î¶â‚ƒ]>  0\n<Gâ‚‚[Î¶â‚ƒÂ²]> 1\n\n\n\n\n\n","category":"method"},{"location":"uch/#Chevie.Uch.deligne_lusztig_character","page":"Unipotent characters","title":"Chevie.Uch.deligne_lusztig_character","text":"deligne_lusztig_character(W,w) or dlchar(W,w)\n\nThis  function returns the Deligne-Lusztig character  R_ğ“ ^ğ† (1) of the algebraic  group ğ† associated to the Coxeter group or Coxeter coset W. The  torus  ğ“  can  be  specified  in  3  ways:  if w is an integer, it represents the w-th conjugacy class (or phi-conjugacy class for a coset WÏ•)  of W. Otherwise  w can be  a word or  an element of  W, and it represents the class (or Ï•-class) of w.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> dlchar(W,3)\n[Gâ‚‚]:<Ï†â‚â€šâ‚€>-<Ï†â‚â€šâ‚†>-<Ï†â€²â‚â€šâ‚ƒ>+<Ï†â€³â‚â€šâ‚ƒ>\n\njulia> dlchar(W,W(1))\n[Gâ‚‚]:<Ï†â‚â€šâ‚€>-<Ï†â‚â€šâ‚†>-<Ï†â€²â‚â€šâ‚ƒ>+<Ï†â€³â‚â€šâ‚ƒ>\n\njulia> dlchar(W,[1])\n[Gâ‚‚]:<Ï†â‚â€šâ‚€>-<Ï†â‚â€šâ‚†>-<Ï†â€²â‚â€šâ‚ƒ>+<Ï†â€³â‚â€šâ‚ƒ>\n\njulia> dlchar(W,[1,2])\n[Gâ‚‚]:<Ï†â‚â€šâ‚€>+<Ï†â‚â€šâ‚†>-<Ï†â‚‚â€šâ‚>+<Gâ‚‚[-1]>+<Gâ‚‚[Î¶â‚ƒ]>+<Gâ‚‚[Î¶â‚ƒÂ²]>\n\n\n\n\n\n","category":"function"},{"location":"uch/#Chevie.Uch.deligne_lusztigCharTable","page":"Unipotent characters","title":"Chevie.Uch.deligne_lusztigCharTable","text":"deligne_lusztigCharTable(W) or dlCharTable(W)\n\nfor  each conjugacy class of W, gives the decomposition of R_{T_w}^G in unipotent characters.\n\njulia> dlCharTable(W)\n6Ã—10 Matrix{Int64}:\n 1   1   1   1   2   2   0   0   0   0\n 1  -1   1  -1   0   0   0   0   0   0\n 1  -1  -1   1   0   0   0   0   0   0\n 1   1   0   0  -1   0   1   0   1   1\n 1   1   0   0   0  -1   0   1  -1  -1\n 1   1  -1  -1   0   0  -2  -2   0   0\n\n\n\n\n\n","category":"function"},{"location":"uch/#Chevie.Uch.almost_character","page":"Unipotent characters","title":"Chevie.Uch.almost_character","text":"almost_character(W,i) or almostchar(W,i)\n\nThis  function  returns  the  i-th  almost  unipotent  character  of  the algebraic  group ğ† associated to the Coxeter group or Coxeter coset W. If Ï† is the i-th irreducible character of W, the i-th almost character is  R_Ï†=WÂ¹_w W  Ï†(w) R_ğ“_w^ğ†  (1) where  ğ“_w is  the maximal torus  associated  to  the  conjugacy  class  (or Ï•-conjugacy class for a coset) of w.\n\njulia> W=coxgroup(:B,2)\nBâ‚‚\n\njulia> almostchar(W,3)\n[Bâ‚‚]:<.11>\n\njulia> almostchar(W,1)\n[Bâ‚‚]:1//2<11.>+1//2<1.1>-1//2<.2>-1//2<Bâ‚‚>\n\n\n\n\n\n","category":"function"},{"location":"uch/#Chevie.Uch.on_unipotents","page":"Unipotent characters","title":"Chevie.Uch.on_unipotents","text":"on_unipotents(W,aut)\n\nW  is  a  reflection  group  or  reflection  coset  representing a finite reductive group ğ† ^F, and aut is an automorphism of ğ† ^F (for W a  permutation group, this can be given as a permutation of the roots). The function  returns the permutation  of the unipotent  characters of ğ† ^F induced  by aut. This makes sense  for Spetsial complex reflection groups and is implemented for them.\n\njulia> WF=rootdatum(\"3D4\")\nÂ³Dâ‚„\n\njulia> on_unipotents(Group(WF),WF.phi)\n(1,7,2)(8,12,9)\n\n\n\n\n\n","category":"function"},{"location":"uch/#Chevie.Uch.deligne_lusztig_lefschetz","page":"Unipotent characters","title":"Chevie.Uch.deligne_lusztig_lefschetz","text":"deligne_lusztig_lefschetz(h,m=0) or dllefschetz(h,m=0)\n\nHere h is an element of a Hecke algebra associated to a Coxeter group W or  Coxeter coset WÏ• which itself is  associated to an algebraic group ğ†.  By (Digne and Michel, 1985), for g ğ†^F, the number of fixed points of Fáµ on the Deligne-Lusztig variety associated to the element wÏ•âˆˆWÏ•, have for m divisible   by   a   sufficently   large   integer   d,  the  form  _Ï† Ï†_(qáµ)(T_wÏ•)R_Ï†(g)  where Ï†  runs over  the irreducible characters of WÏ•,  where  R_Ï†  is  the  corresponding almost character, and where Ï†_(qáµ)  is a  character value  of the  Hecke algebra  H(WÏ•qáµ) of WÏ•  with  parameter  qáµ.  This  expression  is  called the Lefschetz character  of  the  Deligne-Lusztig  variety.  If  we  consider qáµ as an indeterminate  x, it can  be seen as  a sum of  unipotent characters with coefficients  character values of the  generic Hecke algebra H(WÏ•x). A more complicated formula involving the eigenvalues of Frobenius attached to unipotent characters applies for m not prime to d. The function returns this formula when a second parameter mâ‰ 0 is given.\n\nThe  function 'dllefschetz' takes  as argument a  Hecke element and returns the  corresponding Lefschetz character. This is defined on the whole of the Hecke  algebra by linearity.  The Lefschetz character  of various varieties related   to   Deligne-Lusztig   varieties,   like   their  completions  or desingularisation,  can be  obtained by  taking the  Lefschetz character at various elements of the Hecke algebra.\n\njulia> W=coxgroup(:A,2)\nAâ‚‚\n\njulia> H=hecke(W,Pol(:q))\nhecke(Aâ‚‚,q)\n\njulia> T=Tbasis(H);\n\njulia> dllefschetz(T(1,2))\n[Aâ‚‚]:<111>-q<21>+qÂ²<3>\n\njulia> dllefschetz((T(1)+T())*(T(2)+T()))\n[Aâ‚‚]:q<21>+(qÂ²+2q+1)<3>\n\nThe   last  line  shows  the   Lefschetz  character  of  the  Samelson-Bott desingularisation of the Coxeter element Deligne-Lusztig variety.\n\nWe now show an example with a coset (corresponding to the unitary group).\n\njulia> H=hecke(spets(W,Perm(1,2)),Pol(:q)^2)\nhecke(Â²Aâ‚‚,qÂ²)\n\njulia> T=Tbasis(H);dllefschetz(T(1))\n[Â²Aâ‚‚]:-<11>-q<Â²Aâ‚‚>+qÂ²<2>\n\nFinally,  there is a second form dllefschetz(H::HeckeAlgebra,w,i=0) where the  arguments are a Hecke algebra and an  element of w. This may be used for  Spetses where we know the column of the CharTable of H for w but not other columns of the spetsial Hecke algebra charcater table.\n\n\n\n\n\n","category":"function"},{"location":"uch/#Chevie.Uch.lusztig_induce","page":"Unipotent characters","title":"Chevie.Uch.lusztig_induce","text":"lusztig_induce(W,u)\n\nu  should be a unipotent character of a parabolic subcoset of the Coxeter coset  W. It represents  a unipotent character  Î» of a  Levi ğ‹ of the algebraic  group  ğ†  attached  to  W.  The  program returns the Lusztig induced R_ğ‹^ğ†(Î»).\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> WF=spets(W)\nGâ‚‚\n\njulia> T=subspets(WF,Int[],W(1))\nGâ‚‚â‚â‚=Î¦â‚Î¦â‚‚\n\njulia> u=unichar(T,1)\n[Gâ‚‚â‚â‚=Î¦â‚Î¦â‚‚]:<Id>\n\njulia> lusztig_induce(WF,u)\n[Gâ‚‚]:<Ï†â‚â€šâ‚€>-<Ï†â‚â€šâ‚†>-<Ï†â€²â‚â€šâ‚ƒ>+<Ï†â€³â‚â€šâ‚ƒ>\n\njulia> dlchar(W,W(1))\n[Gâ‚‚]:<Ï†â‚â€šâ‚€>-<Ï†â‚â€šâ‚†>-<Ï†â€²â‚â€šâ‚ƒ>+<Ï†â€³â‚â€šâ‚ƒ>\n\n\n\n\n\n","category":"function"},{"location":"uch/#Chevie.Uch.lusztig_restrict","page":"Unipotent characters","title":"Chevie.Uch.lusztig_restrict","text":"lusztig_restrict(R,u)\n\nu  should be a unipotent character of a parent Coxeter coset W of which R is a parabolic subcoset. It represents a unipotent character Î³ of the algebraic  group ğ† attached to W,  while R represents a Levi subgroup L. The program returns the Lusztig restriction *R_ğ‹^ğ†(Î³).\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> WF=spets(W)\nGâ‚‚\n\njulia> T=subspets(WF,Int[],W(1))\nGâ‚‚â‚â‚=Î¦â‚Î¦â‚‚\n\njulia> u=dlchar(W,W(1))\n[Gâ‚‚]:<Ï†â‚â€šâ‚€>-<Ï†â‚â€šâ‚†>-<Ï†â€²â‚â€šâ‚ƒ>+<Ï†â€³â‚â€šâ‚ƒ>\n\njulia> lusztig_restrict(T,u)\n[Gâ‚‚â‚â‚=Î¦â‚Î¦â‚‚]:4<Id>\n\njulia> T=subspets(WF,Int[],W(2))\nGâ‚‚â‚â‚=Î¦â‚Î¦â‚‚\n\njulia> lusztig_restrict(T,u)\n[Gâ‚‚â‚â‚=Î¦â‚Î¦â‚‚]:0\n\n\n\n\n\n","category":"function"},{"location":"uch/#Chevie.Lusztig.lusztig_induction_table","page":"Unipotent characters","title":"Chevie.Lusztig.lusztig_induction_table","text":"lusztig_induction_table(R,W)\n\nR  should be a parabolic subgroup of the Coxeter group W or a parabolic subcoset  of  the  Coxeter  coset  W,  in  each  case representing a Levi subgroup  ğ‹ of  the algebraic  group ğ†  associated to W. The function returns  an InductionTable  representing the  Lusztig induction R_ğ‹^ğ† between unipotent characters.\n\njulia> W=coxgroup(:B,3)\nBâ‚ƒ\n\njulia> t=twistings(W,[1,3])\n2-element Vector{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}}:\n Bâ‚ƒâ‚â‚â‚ƒâ‚=AÌƒâ‚Ã—Aâ‚Î¦â‚\n Bâ‚ƒâ‚â‚â‚ƒâ‚=AÌƒâ‚Ã—Aâ‚Î¦â‚‚\n\njulia> lusztig_induction_table(t[2],W)\nLusztig induction from Bâ‚ƒâ‚â‚â‚ƒâ‚=AÌƒâ‚Ã—Aâ‚Î¦â‚‚ to Bâ‚ƒ\nâ”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚     â”‚11âŠ— 11 11âŠ— 2 2âŠ— 11 2âŠ— 2â”‚\nâ”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚111. â”‚     1    -1    -1    .â”‚\nâ”‚11.1 â”‚    -1     .     1   -1â”‚\nâ”‚1.11 â”‚     .     .    -1    .â”‚\nâ”‚.111 â”‚    -1     .     .    .â”‚\nâ”‚21.  â”‚     .     .     .    .â”‚\nâ”‚1.2  â”‚     1    -1     .    1â”‚\nâ”‚2.1  â”‚     .     1     .    .â”‚\nâ”‚.21  â”‚     .     .     .    .â”‚\nâ”‚3.   â”‚     .     .     .    1â”‚\nâ”‚.3   â”‚     .     1     1   -1â”‚\nâ”‚Bâ‚‚:2 â”‚     .     .     1   -1â”‚\nâ”‚Bâ‚‚:11â”‚     1    -1     .    .â”‚\nâ””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n\n\n\n\n","category":"function"},{"location":"uch/#Chevie.Families","page":"Unipotent characters","title":"Chevie.Families","text":"Families of unipotent characters\n\nThe blocks of the (rectangular) matrix RáµªÏ_ğ† ^F when Ï‡ runs over Irr(W)  and  Ï  runs  over  the  unipotent  characters,  are called the Lusztig  families. When  ğ†  is split  and W  is a Coxeter group they correspond  on the Irr(W) side to two-sided Kazhdan-Lusztig cells â€“ for split  Spetses they  correspond to  Rouquier blocks  of the  Spetsial Hecke algebra.  The matrix of scalar products  RáµªÏ_ğ† ^F can be completed to   a  square  matrix  A_ÏÏ_ğ†  ^F  where  A_Ï  are  the characteristic  functions of character  sheaves on ğ†  ^F; this square matrix is called the Fourier matrix of the family.\n\nThe  UnipotentCharacters object  in Chevie  has a  property families, a vector of Family objects containing information on each family, including the Fourier matrix. Here is an example.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> uc=UnipotentCharacters(W);\n\njulia> uc.families\n3-element Vector{Family}:\n Family(D(ğ”– â‚ƒ),[5, 6, 4, 3, 8, 7, 9, 10],ennola=-5)\n Family(Câ‚,[1])\n Family(Câ‚,[2])\n\njulia> uc.families[1]\nFamily(D(ğ”– â‚ƒ)) Drinfeld double of ğ”– â‚ƒ, Lusztigâ€²s version\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚label   â”‚no eigen                                               â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚(1,1)*  â”‚ 5     1 1//6  1//2  1//3  1//3  1//6  1//2  1//3  1//3â”‚\nâ”‚(gâ‚‚,1)  â”‚ 6     1 1//2  1//2     .     . -1//2 -1//2     .     .â”‚\nâ”‚(gâ‚ƒ,1)  â”‚ 4     1 1//3     .  2//3 -1//3  1//3     . -1//3 -1//3â”‚\nâ”‚(1,Ï)   â”‚ 3     1 1//3     . -1//3  2//3  1//3     . -1//3 -1//3â”‚\nâ”‚(1,Îµ)-e â”‚ 8     1 1//6 -1//2  1//3  1//3  1//6 -1//2  1//3  1//3â”‚\nâ”‚(gâ‚‚,Îµ)  â”‚ 7    -1 1//2 -1//2     .     . -1//2  1//2     .     .â”‚\nâ”‚(gâ‚ƒ,Î¶â‚ƒ) â”‚ 9    Î¶â‚ƒ 1//3     . -1//3 -1//3  1//3     .  2//3 -1//3â”‚\nâ”‚(gâ‚ƒ,Î¶â‚ƒÂ²)â”‚10   Î¶â‚ƒÂ² 1//3     . -1//3 -1//3  1//3     . -1//3  2//3â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\njulia> charnames(uc)[uc.families[1].charNumbers]\n8-element Vector{String}:\n \"phi2,1\"\n \"phi2,2\"\n \"phi1,3''\"\n \"phi1,3'\"\n \"G2[1]\"\n \"G2[-1]\"\n \"G2[E3]\"\n \"G2[E3^2]\"\n\nThe Fourier matrix is obtained by fourier(f); charnumbers(f)  returns the indices of the unipotent characters which are in the family. We obtain the list of eigenvalues of Frobenius for these  unipotent characters by eigen(f). special(f) (resp.  cospecial(f)) returns the  index in f  of the special (resp.  cospecial) character.The  Fourier matrix  and vector of eigenvalues satisfy   the   properties   of   fusion   data,  see  below.  The  field f.charLabels  is what is displayed in the column labels when displaying the  family. It contains labels naturally  attached to lines of the Fourier matrix.  In the case of reductive groups,  the family is always attached to the drinfeld_double of a small finite group and the .charLabels come from this construction.\n\nMethods  for  families  include  *  (tensor product), conj (see galois),  length (the number of unipotent characters in the family), Zbasedring\n\n\n\n\n\n","category":"module"},{"location":"uch/#Chevie.Families.Family","page":"Unipotent characters","title":"Chevie.Families.Family","text":"Family(f [, charNumbers] ; opt)\n\nThis function creates a new family in two possible ways.\n\nIn  the first case f is a string or a symbol which denotes a family known to Chevie. Examples are :S3, :S4, :S5 which denote the family obtained as the  Drinfeld double  of the  symmetric group  on 3,4,5  elements, or :C2 which denotes the Drinfeld double of the cyclic group of order 2.\n\nIn the second case f is already a struct Family.\n\nIf given, the second argument becomes f.charNumbers.  If given,  the opt are added as fields to the resulting family.\n\nIf opt has a key signs, this should be a list of '1' and '-1', and then the  Fourier matrix  is conjugated  by the  diagonal matrix of those signs. This  is used  in Spetses  to adjust  the matrix  to the choice of signs of unipotent degrees.\n\njulia> Family(:C2)\nFamily(Câ‚‚) Drinfeld double D(â„¤/2)\nâ”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚label â”‚eigen                       â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚(1,1)*â”‚    1 1//2  1//2  1//2  1//2â”‚\nâ”‚(gâ‚‚,1)â”‚    1 1//2  1//2 -1//2 -1//2â”‚\nâ”‚(1,Îµ) â”‚    1 1//2 -1//2  1//2 -1//2â”‚\nâ”‚(gâ‚‚,Îµ)â”‚   -1 1//2 -1//2 -1//2  1//2â”‚\nâ””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\njulia> Family(:C2,4:7;signs=[1,-1,1,-1])\nFamily(Câ‚‚) Drinfeld double D(â„¤/2)\nâ”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚label â”‚no eigen signs                       â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚(1,1)*â”‚ 4     1     1  1//2 -1//2 1//2 -1//2â”‚\nâ”‚(gâ‚‚,1)â”‚ 5     1    -1 -1//2  1//2 1//2 -1//2â”‚\nâ”‚(1,Îµ) â”‚ 6     1     1  1//2  1//2 1//2  1//2â”‚\nâ”‚(gâ‚‚,Îµ)â”‚ 7    -1    -1 -1//2 -1//2 1//2  1//2â”‚\nâ””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n\n\n\n\n","category":"type"},{"location":"uch/#Chevie.Chars.charnumbers-Tuple{Family}","page":"Unipotent characters","title":"Chevie.Chars.charnumbers","text":"charnumbers(f::Family): the indices of the unipotent characters of the family.\n\n\n\n\n\n","category":"method"},{"location":"uch/#CyclotomicNumbers.galois-Tuple{Family, Int64}","page":"Unipotent characters","title":"CyclotomicNumbers.galois","text":"galois(f::Family,p::Int)\n\nx->galois(x,p)  is  applied  to  the  Fourier  matrix  and eigenvalues of Frobenius of the family.\n\njulia> f=UnipotentCharacters(complex_reflection_group(3,1,1)).families[2]\nFamily(0011) imprimitive family\nâ”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚labelâ”‚no eigen signs      1       2#       3*â”‚\nâ”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚1    â”‚ 4   Î¶â‚ƒÂ²    -1  âˆš-3/3    âˆš-3/3   -âˆš-3/3â”‚\nâ”‚2#   â”‚ 3     1     1  âˆš-3/3 Î¶â‚ƒÂ²âˆš-3/3 -Î¶â‚ƒâˆš-3/3â”‚\nâ”‚3*   â”‚ 2     1     1 -âˆš-3/3 -Î¶â‚ƒâˆš-3/3 Î¶â‚ƒÂ²âˆš-3/3â”‚\nâ””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\njulia> galois(f,-1)\nFamily(conj(0011)) conj(imprimitive family)\nâ”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚labelâ”‚no eigen signs      1       2#       3*â”‚\nâ”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚1    â”‚ 4    Î¶â‚ƒ    -1 -âˆš-3/3   -âˆš-3/3    âˆš-3/3â”‚\nâ”‚2#   â”‚ 3     1     1 -âˆš-3/3 -Î¶â‚ƒâˆš-3/3 Î¶â‚ƒÂ²âˆš-3/3â”‚\nâ”‚3*   â”‚ 2     1     1  âˆš-3/3 Î¶â‚ƒÂ²âˆš-3/3 -Î¶â‚ƒâˆš-3/3â”‚\nâ””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n\n\n\n\n","category":"method"},{"location":"uch/#PermGroups.Perms.invpermute-Tuple{Family, Perm}","page":"Unipotent characters","title":"PermGroups.Perms.invpermute","text":"invpermute(f::Family, p::Union{Perm,SPerm})\n\nreturns  a copy of  f with the  Fourier matrix, eigenvalues of Frobenius, :charLabelsâ€¦ invpermuted by p.\n\njulia> f=UnipotentCharacters(complex_reflection_group(3,1,1)).families[2]\nFamily(0011) imprimitive family\nâ”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚labelâ”‚no eigen signs      1       2#       3*â”‚\nâ”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚1    â”‚ 4   Î¶â‚ƒÂ²    -1  âˆš-3/3    âˆš-3/3   -âˆš-3/3â”‚\nâ”‚2#   â”‚ 3     1     1  âˆš-3/3 Î¶â‚ƒÂ²âˆš-3/3 -Î¶â‚ƒâˆš-3/3â”‚\nâ”‚3*   â”‚ 2     1     1 -âˆš-3/3 -Î¶â‚ƒâˆš-3/3 Î¶â‚ƒÂ²âˆš-3/3â”‚\nâ””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\njulia> invpermute(f,Perm(1,2,3))\nFamily(0011) permuted((1,2,3),imprimitive family)\nâ”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚labelâ”‚no eigen signs       3*      1       2#â”‚\nâ”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚3*   â”‚ 2     1     1 Î¶â‚ƒÂ²âˆš-3/3 -âˆš-3/3 -Î¶â‚ƒâˆš-3/3â”‚\nâ”‚1    â”‚ 4   Î¶â‚ƒÂ²    -1   -âˆš-3/3  âˆš-3/3    âˆš-3/3â”‚\nâ”‚2#   â”‚ 3     1     1 -Î¶â‚ƒâˆš-3/3  âˆš-3/3 Î¶â‚ƒÂ²âˆš-3/3â”‚\nâ””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n\n\n\n\n","category":"method"},{"location":"uch/#Base.conj-Tuple{Family}","page":"Unipotent characters","title":"Base.conj","text":"conj(f::Family): is a synonym for 'galois(f,-1)'.\n\n\n\n\n\n","category":"method"},{"location":"uch/#Chevie.Families.fourier","page":"Unipotent characters","title":"Chevie.Families.fourier","text":"fourier(uc::UnipotentCharacters) the Lusztig Fourier matrix for uc.\n\n\n\n\n\nfourier(f::Family): the Fourier matrix of the family.\n\n\n\n\n\n","category":"function"},{"location":"uch/#LinearAlgebra.eigen-Tuple{Family}","page":"Unipotent characters","title":"LinearAlgebra.eigen","text":"eigen(f::Family): the Frobenius eigenvalues of the characters of the family.\n\n\n\n\n\n","category":"method"},{"location":"uch/#Base.length-Tuple{Family}","page":"Unipotent characters","title":"Base.length","text":"length(f::Family): how many characters are in the family.\n\n\n\n\n\n","category":"method"},{"location":"uch/#Chevie.Families.drinfeld_double","page":"Unipotent characters","title":"Chevie.Families.drinfeld_double","text":"drinfeld_double(g;lu=false,pivotal=nothing)\n\nGiven  a (usually small) finite group  Î“, Lusztig has associated a family (a  Fourier matrix, a list of eigenvalues of Frobenius) which describes the representation ring of the Drinfeld double of the group algebra of Î“, and for   some  appropriate  small  groups  describes  a  family  of  unipotent characters. We do not explain the details of this construction, but explain how its final result building Lusztig's Fourier matrix, and a variant of it that we use in Spetses, from Î“.\n\nThe  elements of the family are in bijection  with the set ğ“œ (Î“) of pairs (x,Ï†)  taken up to  Î“-conjugacy, where xâˆˆÎ“  and Ï† is an irreducible complex-valued   character  of  C_Î“(x).  To  such  a  pair  Ï=(x,Ï†)  is associated  an  eigenvalue  of  Frobenius  defined  by  Ï‰_Ï=Ï†(x)Ï†(1). Lusztig  then defines a Fourier matrix Sâ‚€ whose coefficient is given, for Ï=(x,Ï†) and Ï'=(x', Ï†'), by:\n\nS_0_rhorho=C_Î“(x)Â¹_rho_1=(x_1Ï†_1)Ï†_1(x)Ï†(y_1)\n\nwhere  the sum is over all pairs Ïâ‚âˆˆğ“œ (Î“) which are Î“-conjugate to Ï' and  such that yâ‚ C_Î“(x). This  coefficient also represents the scalar product ÏÏ_ğ†^F of the corresponding unipotent characters.\n\nA  way to understand the formula  for S_0_rhorho better is to consider  another basis  of the  complex vector  space with  basis ğ“œ (Î“), indexed  by the pairs (x,y) taken up  to Î“-conjugacy, where x and y are  commuting elements of  Î“. This basis  is called the  basis of Mellin transforms, and given by:\n\n(xy)=_Ï† Irr(C_Î“(x))Ï†(y)(xÏ†)\n\nIn  the  basis  of  Mellin  transforms,  the  linear  map  Sâ‚€ is given by (x,y)â†¦(xâ»Â¹,yâ»Â¹)  and  the  linear  transformation  T which sends Ï to Ï‰_ÏÏ   becomes  (x,y)â†¦(x,xy).   These  are   particular  cases  of  the permutation  representation of GLâ‚‚(â„¤)  on the basis  of Mellin transforms where beginpmatrixabcr cdendpmatrix acts by (x,y)â†¦(xáµƒyáµ‡,xá¶œyáµˆ).\n\nFourier  matrices in finite reductive groups  are given by the above matrix Sâ‚€.  But for non-rational Spetses, we use a different matrix S which in the  basis of Mellin transforms  is given by (x,y)â†¦(yâ»Â¹,x). Equivalently, the  formula S_ÏÏ differs from  the formula for S_0_ÏÏ in that  there is no complex conjugation of Ï‡â‚; thus the matrix S is equal to Sâ‚€ multiplied on the right by the permutation matrix which corresponds to  (x,Ï†)â†¦(x,Ï†). The advantage  of the matrix  S over Sâ‚€  is that the pair  S,T satisfies directly the axioms for fusion data (see below); also the matrix S is symmetric, while Sâ‚€ is Hermitian.\n\nThus there are two variants of drinfeld_double:\n\ndrinfeld_double(g;lu=false)\n\nreturns  a family  containing Lusztig's  Fourier matrix  Sâ‚€, and an extra field  '.perm'  containing  the  permutation  of  the  indices  induced  by (x,Ï†)â†¦(x,Ï†),  which allows  to recover  S, as  well as  an extra field `:lusztig', set to 'true'.\n\ndrinfeld_double(g)\n\nreturns a family with the matrix S, which does not have fields '.lusztig' or '.perm'.\n\nThe family object 'f' returned also has the properties:\n\n:group: the group Î“.\n:charLabels: a list of labels describing the pairs (x,Ï†), and thus also specifying in which order they are taken.\n:fourierMat: the Fourier matrix (the matrix S or Sâ‚€ depending on the call).\n:eigenvalues: the eigenvalues of Frobenius.\n:xy: a list of pairs (x,y) which are representatives of the Î“-orbits of pairs of commuting elements.\n:mellinLabels: a list of labels describing the pairs (x,y).\n:mellin:  the base change matrix between  the basis (x,Ï†) and the basis of   Mellin  transforms,   so  that   f.fourierMat^(f.mellin^-1)  is  the permutation  matrix (for (x,y)â†¦(yâ»Â¹,x)  or (x,y)â†¦(yâ»Â¹,xâ»Â¹) depending on the call).\n:special: the index of the special element, which is (x,Ï†)=(1,1).\n\njulia> drinfeld_double(coxsym(3)) # needs \"using GAP\"\nFamily(drinfeld_double(coxsym(3))) Drinfeld double D(coxsym(3))\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚label  â”‚eigen                                               â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚(1,1)* â”‚    1  1//6  1//3 1//6 -1//2 -1//2  1//3  1//3  1//3â”‚\nâ”‚(1,X.2)â”‚    1  1//3  2//3 1//3     .     . -1//3 -1//3 -1//3â”‚\nâ”‚(1,X.3)â”‚    1  1//6  1//3 1//6  1//2  1//2  1//3  1//3  1//3â”‚\nâ”‚(21,1) â”‚    1 -1//2     . 1//2  1//2 -1//2     .     .     .â”‚\nâ”‚(21,-1)â”‚   -1 -1//2     . 1//2 -1//2  1//2     .     .     .â”‚\nâ”‚(3,1)  â”‚    1  1//3 -1//3 1//3     .     .  2//3 -1//3 -1//3â”‚\nâ”‚(3,Î¶â‚ƒÂ²)â”‚   Î¶â‚ƒ  1//3 -1//3 1//3     .     . -1//3 -1//3  2//3â”‚\nâ”‚(3,Î¶â‚ƒ) â”‚  Î¶â‚ƒÂ²  1//3 -1//3 1//3     .     . -1//3  2//3 -1//3â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\njulia> drinfeld_double(coxsym(3);lu=true)\nFamily(Ldrinfeld_double(coxsym(3))) Lusztigâ€²sDrinfeld double D(coxsym(3))\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚label  â”‚eigen                                               â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚(1,1)* â”‚    1  1//6  1//3 1//6 -1//2 -1//2  1//3  1//3  1//3â”‚\nâ”‚(1,X.2)â”‚    1  1//3  2//3 1//3     .     . -1//3 -1//3 -1//3â”‚\nâ”‚(1,X.3)â”‚    1  1//6  1//3 1//6  1//2  1//2  1//3  1//3  1//3â”‚\nâ”‚(21,1) â”‚    1 -1//2     . 1//2  1//2 -1//2     .     .     .â”‚\nâ”‚(21,-1)â”‚   -1 -1//2     . 1//2 -1//2  1//2     .     .     .â”‚\nâ”‚(3,1)  â”‚    1  1//3 -1//3 1//3     .     .  2//3 -1//3 -1//3â”‚\nâ”‚(3,Î¶â‚ƒÂ²)â”‚   Î¶â‚ƒ  1//3 -1//3 1//3     .     . -1//3  2//3 -1//3â”‚\nâ”‚(3,Î¶â‚ƒ) â”‚  Î¶â‚ƒÂ²  1//3 -1//3 1//3     .     . -1//3 -1//3  2//3â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nThe  keyword pivotal  describes the  pivotal structure  as a tuple of the pivotal  element and the vector  of values of the  pivotal character on the generators of g.\n\n\n\n\n\n","category":"function"},{"location":"uch/#Chevie.Families.ndrinfeld_double","page":"Unipotent characters","title":"Chevie.Families.ndrinfeld_double","text":"ndrinfeld_double(g)\n\nThis  function returns the number of elements that the family associated to the  Drinfeld double of the group g would have, without computing it. The evident advantage is the speed.\n\njulia> Families.ndrinfeld_double(complex_reflection_group(5))\n378\n\n\n\n\n\n","category":"function"},{"location":"uch/#Chevie.Families.family_imprimitive","page":"Unipotent characters","title":"Chevie.Families.family_imprimitive","text":"family_imprimitive(S)\n\nS should be a symbol for a unipotent characters of an imprimitive complex reflection  group 'G(e,1,n)' or 'G(e,e,n)'. The function returns the family containing S.\n\njulia> family_imprimitive([[0,1],[1],[0]])\nFamily(0011) imprimitive family\nâ”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚labelâ”‚eigen      1       2#       3*â”‚\nâ”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚1    â”‚  Î¶â‚ƒÂ²  âˆš-3/3   -âˆš-3/3    âˆš-3/3â”‚\nâ”‚2#   â”‚    1 -âˆš-3/3 Î¶â‚ƒÂ²âˆš-3/3 -Î¶â‚ƒâˆš-3/3â”‚\nâ”‚3*   â”‚    1  âˆš-3/3 -Î¶â‚ƒâˆš-3/3 Î¶â‚ƒÂ²âˆš-3/3â”‚\nâ””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n\n\n\n\nfamily_imprimitive(ct,e)\n\nreturns  the family  attached to  e-symbols with  entries ct, following (Malle, 1995; Â§4 for G(e,1,n) and Â§6 for G(e,e,n)).\n\nThe  Fourier  matrix  is  as  follows:  Let  F  be  the  set of functions ctâ†’0:e-1  which are  injective restricted  to a  given value in ct, and with  the sum  of their  values mod.  e equal  to m*binomial(e,2) where m=div(length(ct),e).  Then for fâˆˆF  the list of  preimages of f is an e-symbol  S(f). Conversely for a symbol  S there is a 'canonical' map f(S)  which records the increasing positions  in the symbol of each value in  ct.  Then  Fourier(S,T)=Câˆ‘_{fâˆˆFâˆ£S(f)=S}Îµ(f)Îµ(f(T))Î¶â‚‘^{f*f(T)} where for  fâˆˆF with image f.(ct)  Îµ(f)=(-1)^{number of non-inversions in the list  f.(ct)} and f*f(T)  is the scalar  product of vectors f.(ct) and f(T).(ct). Finally C=Î¶â‚„^(-m*(binomial(e+1,2)-1))//âˆše^(e*m).\n\n\n\n\n\n","category":"function"},{"location":"uch/#Chevie.Families.FamiliesClassical","page":"Unipotent characters","title":"Chevie.Families.FamiliesClassical","text":"FamiliesClassical(l)\n\nl  should be a list of symbols which classify the unipotent characters of a  classical reductive group, like symbols(2,r) for type Báµ£ or Cáµ£, or symbols(2,r,0)  for type Dáµ£. The function  returns the list of families determined  by these symbols.\n\njulia> FamiliesClassical(symbols(2,3)) # for a reductive group of type Bâ‚ƒ\n6-element Vector{Family}:\n Family(112,[2])\n Family(022,[6])\n Family(3,[9])\n Family(01123,[1, 3, 8, 11])\n Family(0112233,[4])\n Family(013,[5, 7, 10, 12])\n\n\n\n\n\n","category":"function"},{"location":"uch/#Base.:*-Tuple{Family, Family}","page":"Unipotent characters","title":"Base.:*","text":"f*g:  returns the tensor product of two families f and g; the Fourier matrix  is the Kronecker product  of the matrices for  f and g, and the eigenvalues of Frobenius are the pairwise products.\n\n\n\n\n\n","category":"method"},{"location":"uch/#Chevie.Families.special","page":"Unipotent characters","title":"Chevie.Families.special","text":"special(f::Family) the index of the special character in f\n\n\n\n\n\n","category":"function"},{"location":"uch/#Chevie.Families.cospecial","page":"Unipotent characters","title":"Chevie.Families.cospecial","text":"cospecial(f::Family) the index of the cospecial character in f\n\n\n\n\n\n","category":"function"},{"location":"uch/#Chevie.Families.Zbasedring","page":"Unipotent characters","title":"Chevie.Families.Zbasedring","text":"Zbasedring(f::Family) or Zbasedring(S,special=1)\n\nAll  the Fourier matrices S in Chevie are unitary, that is Sâ»Â¹=conj(S), and  have a  special line  s (the  line of  index s=special(f)  for a family  f) such that no entry Sâ‚›,áµ¢  is equal to 0. Further, they have the  property that  the sums  Cáµ¢,â±¼,â‚–=sumâ‚— Sáµ¢,â‚—  Sâ±¼,â‚— conj(Sâ‚–,â‚—)/Sâ‚›,â‚— take integral  values. Finally,  S has  the property  that complex conjugation does a permutation with signs Ïƒ of the lines of S.\n\nIt  follows that we can define a â„¤-algebra A as follows: it has a basis báµ¢  indexed by the lines of S,  and has a multiplication defined by the fact  that the  coefficient of  báµ¢bâ±¼ on  bâ‚– is  equal to Cáµ¢,â±¼,â‚–. This algebra  can be specified by giving a family f or just its Fourier matrix and the number of its special line.\n\nA  is commutative, and has as unit the element bâ‚›; the basis Ïƒ(báµ¢) is dual to báµ¢ for the linear form (báµ¢,bâ±¼)=Cáµ¢,â±¼,Ïƒâ‚â‚›â‚.\n\njulia> W=complex_reflection_group(4)\nGâ‚„\n\njulia> uc=UnipotentCharacters(W);f=uc.families[4];\n\njulia> A=Zbasedring(fourier(f),1)\nâ„¤-based ring dim.5\n\njulia> b=basis(A)\n5-element Vector{AlgebraElt{Chevie.Families.ZBasedRing, Int64}}:\n Bâ‚\n Bâ‚‚\n Bâ‚ƒ\n Bâ‚„\n Bâ‚…\n\njulia> b*permutedims(b)\n5Ã—5 Matrix{AlgebraElt{Chevie.Families.ZBasedRing, Int64}}:\n Bâ‚  Bâ‚‚      Bâ‚ƒ      Bâ‚„        Bâ‚…\n Bâ‚‚  -Bâ‚„+Bâ‚…  Bâ‚+Bâ‚„   Bâ‚‚-Bâ‚ƒ     Bâ‚ƒ\n Bâ‚ƒ  Bâ‚+Bâ‚„   -Bâ‚„+Bâ‚…  -Bâ‚‚+Bâ‚ƒ    Bâ‚‚\n Bâ‚„  Bâ‚‚-Bâ‚ƒ   -Bâ‚‚+Bâ‚ƒ  Bâ‚+Bâ‚„-Bâ‚…  -Bâ‚„\n Bâ‚…  Bâ‚ƒ      Bâ‚‚      -Bâ‚„       Bâ‚\n\njulia> CharTable(A)\nCharTable(â„¤-based ring dim.5)\nâ”Œâ”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ â”‚1    2    3  4  5â”‚\nâ”œâ”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚1â”‚1  âˆš-3 -âˆš-3  2 -1â”‚\nâ”‚2â”‚1    1    1  .  1â”‚\nâ”‚3â”‚1   -1   -1  .  1â”‚\nâ”‚4â”‚1    .    . -1 -1â”‚\nâ”‚5â”‚1 -âˆš-3  âˆš-3  2 -1â”‚\nâ””â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n\n\n\n\n","category":"function"},{"location":"format/#formatting-facilities","page":"formatting facilities","title":"formatting facilities","text":"Pages=[\"format.md\"]","category":"section"},{"location":"format/#Chevie.Format","page":"formatting facilities","title":"Chevie.Format","text":"Chevie   contains  some   extended  formatting   facilities  for  printing, displaying,  formatting  objects  in  various  ways. For that Chevie uses extensively  IO properties.  We have  several convenience functions which make using IO properties easier to use.\n\nrio(;d...)  makes an IO stream  which always has the property :limit=>true,  to mimic the REPL default printing, and has also the extra properties given by the d... keywords. Using this, for instance\n\nIOContext(stdout,:limit=>true,:compact=>true) becomes rio(compact=true).\n\nWe have versions of display functions which use implicitely rio:\n\nxprint(x...;p...)  is  the  same  as  print(rio(;p...),x...). Similarly    for   println,   display   we   have   xprintln, xdisplay.\n\nxrepr(x;p...) is the same as repr(x;context=IOContext(stdout,p...)).  xrepr(io,x)  is  the  same  as repr(x;context=io).\n\njulia> @Pol q;p=(q^5+1)^2\nPol{Int64}: qÂ¹â°+2qâµ+1\n\njulia> print(p)\nPol([1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1])\njulia> xprint(p)\nqÂ¹â°+2qâµ+1\njulia> xprint(p;varname=:x)\nxÂ¹â°+2xâµ+1\njulia> repr(2E(5,2)+2E(5,3))\n\"Cyc{Int64}(-1-root(5))\"\n\njulia> xrepr(2E(5,2)+2E(5,3);quadratic=false)\n\"Cyc{Int64}(2E(5,2)+2E(5,3))\"\n\nMost  objects in Chevie use  TeX for printing when  given the IO property :TeX=true. This is used as the default display in IJulia and Pluto by giving the property :TeX when defining Base.show(io::IO, ::MIME\"text/latex\", ...) for these objects. Continuing the above example:\n\njulia> xprint(p;TeX=true)\nq^{10}+2q^5+1\n\nA  model we often  adopt for displaying  nicely complex objects is to first write  a nice  display using  TeX output.  This can  be used  directly in IJulia and Pluto. For other environments, we can compute from the TeX representation a suitable one using the following function:\n\nfromTeX(io::IO,s)  takes a TeX source  and tries to give the best  possible rendering on  a given IO.  This uses unicode characters at the  REPL (if  get(io,:limit,false)==true). In  the worse case (stdout) all TeX special characters are stripped.\n\njulia> s=\"E_6[\\zeta_3]:\\phi_{1,6}\"\n\"E_6[\\zeta_3]:\\phi_{1,6}\"\n\njulia> fromTeX(rio(),s)\n\"Eâ‚†[Î¶â‚ƒ]:Ï†â‚â€šâ‚†\"\n\njulia> fromTeX(stdout,s)\n\"E6[E3]:phi1,6\"\n\nprintTeX(io,s) is the same as print(io,fromTeX(io,s)).\n\nOther functions to ease formatting are described below: see  showtable, joindigits,  ordinal,  cut.\n\n\n\n\n\n","category":"module"},{"location":"format/#Chevie.Format.rio","page":"formatting facilities","title":"Chevie.Format.rio","text":"rio(io::IO=stdout;p...) enriches io with the attributes in p. It always enriches with limit=true to mimic display at the REPL.\n\nThus print(rio(),x...) is like printing x... at the REPL.\n\n\n\n\n\n","category":"function"},{"location":"format/#Chevie.Format.xprint","page":"formatting facilities","title":"Chevie.Format.xprint","text":"xprint(x...;p...) is like print but uses the enriched io rio(;p...)\n\n\n\n\n\n","category":"function"},{"location":"format/#Chevie.Format.xprintln","page":"formatting facilities","title":"Chevie.Format.xprintln","text":"xprintln(x...;p...) is like println but uses the enriched io rio(;p...)\n\n\n\n\n\n","category":"function"},{"location":"format/#Chevie.Format.xdisplay","page":"formatting facilities","title":"Chevie.Format.xdisplay","text":"xdisplay(x...;p...) is like display but uses the enriched io rio(;p...)\n\n\n\n\n\nxrepr(x;p...) is repr using as context stdout enriched by p...\n\n\n\n\n\n","category":"function"},{"location":"format/#Chevie.Format.xrepr","page":"formatting facilities","title":"Chevie.Format.xrepr","text":"xrepr(io::IO,x;p...) is repr using as context io enriched by p...\n\n\n\n\n\n","category":"function"},{"location":"format/#Chevie.Format.fromTeX","page":"formatting facilities","title":"Chevie.Format.fromTeX","text":"fromTeX(io::IO,s)  takes  a  TeX  source  and  tries  to  give the best possible  rendering on  a given  IO. This  uses unicode characters at the REPL  (if get(io,:limit,false)==true).  In the  worse case (stdout) all TeX special characters are stripped.\n\njulia> s=\"E_6[\\zeta_3]:\\phi_{1,6}\"\n\"E_6[\\zeta_3]:\\phi_{1,6}\"\n\njulia> fromTeX(rio(),s)\n\"Eâ‚†[Î¶â‚ƒ]:Ï†â‚â€šâ‚†\"\n\njulia> fromTeX(stdout,s)\n\"E6[E3]:phi1,6\"\n\n\n\n\n\n","category":"function"},{"location":"format/#Chevie.Format.printTeX","page":"formatting facilities","title":"Chevie.Format.printTeX","text":"printTeX(io,s) is print(io,fromTeX(io,s))\n\n\n\n\n\n","category":"function"},{"location":"format/#Chevie.Format.showtable","page":"formatting facilities","title":"Chevie.Format.showtable","text":"showtable(io::IO=stdout, table::AbstractMatrix; keywords)\n\nGeneral  routine to format a table at  the REPL, or in IJulia or Pluto. The elements of table and any of the labels in the keywords can be of any type  and are formatted in the context  of io, excepted that a string s is  formatted by  fromTeX(io,s). The  following options  can be passed as properties of the io or as keywords.\n\nrow_labels: labels for rows. A Vector{Any} (can be strings), default axes(table,1)\nrows_label: label for first column of row labels (default none)\ncol_labels: labels for other columns (default none)\nalign:  a character in \"lcr\": alignment of columns (default 'r'); then all columns will be aligned as given except the rows_labels which will always be aligned left. Or if align is a string it should be of length 1+size(table,2) where the first character is the alignment of the row_labels.\nrow_seps: line numbers after which to put a separator. A number of i means before i-th line of the table. So 0 is at the top  of  the  table,  -1  is  before the col_labels. The default is [-1,0,size(table,1)].\ncol_seps: column numbers after which to put a separator. A  number of i means before i-th column  of the table. So 0 is at the  left of the table, -1 is before the row_labels. The default is [-1,0,size(table,2)].  Alternately the col_seps  can be given using an  align string in  LaTeX style |r|llll|.  They should be given by only one of the two ways.\nrows: show only these rows. Default all rows: axes(table,1)\ncols: show only these columns. Default all columns: axes(table,1)\nTeX: default false. If true, give LaTeX output (useful to give nicer output in Jupyter or Pluto)\ncolumn_repartition: a Vector{<:Integer}. Display in vertical pieces of sizes indicated (useful for TeX: otherwise the column_repartition is automatically computed taking in account displaysize(io,2)).\ndotzero: if true replace a '0' by '.' in the table (default false).\n\njulia> m=reshape(1:10:120,3,4)\n3Ã—4 reshape(::StepRange{Int64, Int64}, 3, 4) with eltype Int64:\n  1  31  61   91\n 11  41  71  101\n 21  51  81  111\n\njulia> showtable(m)\nâ”Œâ”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚1â”‚ 1 31 61  91â”‚\nâ”‚2â”‚11 41 71 101â”‚\nâ”‚3â”‚21 51 81 111â”‚\nâ””â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\njulia> labels=[\"x\",\"y\",\"z\",\"t\"];\n\njulia> showtable(m;cols=2:4,col_labels=labels,row_seps=[0,2,3])\n    y  z   t \nâ”Œâ”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚1â”‚31 61  91â”‚\nâ”‚2â”‚41 71 101â”‚\nâ”œâ”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚3â”‚51 81 111â”‚\nâ””â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\njulia> showtable(m;col_labels=labels,rows_label=\"N\",align=\"|r|ll|ll|\")\nâ”Œâ”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”\nâ”‚Nâ”‚ x  yâ”‚ z   tâ”‚\nâ”œâ”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤\nâ”‚1â”‚1  31â”‚61 91 â”‚\nâ”‚2â”‚11 41â”‚71 101â”‚\nâ”‚3â”‚21 51â”‚81 111â”‚\nâ””â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜\n\n\n\n\n\n","category":"function"},{"location":"format/#Chevie.Format.joindigits","page":"formatting facilities","title":"Chevie.Format.joindigits","text":"joindigits(l::AbstractVector{Int},delim=\"()\";sep=\",\")\n\nprint  a list l of  (usually small) numbers as  compactly as possible: no separators if all numbers are smaller than 10.\n\njulia> joindigits([1,9,3,5])\n\"1935\"\n\njulia> joindigits([1,10,3,5])\n\"(1,10,3,5)\"\n\njulia> joindigits([1,10,3,5],\"[]\";sep=\"-\")\n\"[1-10-3-5]\"\n\n\n\n\n\n","category":"function"},{"location":"format/#Chevie.Format.cut","page":"formatting facilities","title":"Chevie.Format.cut","text":"cut(io::IO=stdout,string;width=displaysize(io)[2]-2,after=\",\",before=\"\")\n\nThis  function prints to io the  string argument cut across several lines for improved display. It can take the following keyword arguments:\n\nwidth:  the cutting width\nafter:  cut after these chars\nbefore: cut before these chars\n\njulia> cut(string(collect(1:50)))\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,\n 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,\n 41, 42, 43, 44, 45, 46, 47, 48, 49, 50]\n\n\n\n\n\n","category":"function"},{"location":"format/#Chevie.Format.ordinal","page":"formatting facilities","title":"Chevie.Format.ordinal","text":"ordinal(n::Integer)\n\nstring for an ordinal number respecting english syntax.\n\njulia> ordinal(201)\n\"201st\"\n\njulia> ordinal(202)\n\"202nd\"\n\njulia> ordinal(203)\n\"203rd\"\n\njulia> ordinal(204)\n\"204th\"\n\n\n\n\n\n","category":"function"},{"location":"truncs/#Truncated-Laurent-series","page":"Truncated Laurent series","title":"Truncated Laurent series","text":"","category":"section"},{"location":"truncs/#Chevie.Truncs","page":"Truncated Laurent series","title":"Chevie.Truncs","text":"module Trunc: truncated Laurent series\n\nThis module depends on the package LaurentPolynomials.\n\nThe main function to construct a truncated series is:\n\njulia> @Pol x\nPol{Int64}: x\n\njulia> p=(x+x^2)^5\nPol{Int64}: xÂ¹â°+5xâ¹+10xâ¸+10xâ·+5xâ¶+xâµ\n\njulia> tp=Trunc(p,4)\nTrunc(4): xâµ+5xâ¶+10xâ·+10xâ¸+O(xâ¹)\n\nThe result here is a truncated series with 4 terms. You can do various operations with series\n\njulia> inv(tp)\nTrunc(4): xâ»âµ-5xâ»â´+15xâ»Â³-35xâ»Â²+O(xâ»Â¹)\n\njulia> inv(tp)*tp\nTrunc(4): 1+O(xâ´)\n\njulia> tp*2\nTrunc(4): 2xâµ+10xâ¶+20xâ·+20xâ¸+O(xâ¹)\n\nBy default the variable name to print Truncs is the same as for Pols. You can change that:\n\njulia> Truncs.varname=:q\n:q\n\njulia> tp\nTrunc(4): qâµ+5qâ¶+10qâ·+10qâ¸+O(qâ¹)\n\njulia> length(tp) # the number of terms\n4\n\njulia> tp+1  # \"loss of precision\"\nTrunc(4): 1+O(qâ´)\n\njulia> tp+Pol()^5 # ok here\nTrunc(4): 2qâµ+5qâ¶+10qâ·+10qâ¸+O(qâ¹)\n\njulia> tp-Trunc(Pol()^5,4) # true loss of precision\nTrunc(3): 5qâ¶+10qâ·+10qâ¸+O(qâ¹)\n\nAs for Pols, indexing gets the term of a given degree\n\njulia> tp[1]\n0\n\njulia> tp[6]\n5\n\nYou can convert directly to Trunc a rational fraction:\n\njulia> a=(3Pol()^-2+1)/p\nFrac{Pol{Int64}}: (xÂ²+3)/(xÂ¹Â²+5xÂ¹Â¹+10xÂ¹â°+10xâ¹+5xâ¸+xâ·)\n\njulia> Trunc(a,4)\nTrunc(4): 3qâ»â·-15qâ»â¶+46qâ»âµ-110qâ»â´+O(qâ»Â³)\n\njulia> Trunc(a,4)*tp\nTrunc(4): 3qâ»Â²+1+O(qÂ²)\n\nWe provide also convenience functions for Mvps.\n\njulia> @Mvp x,y\n\njulia> den=x-y\nMvp{Int64}: x-y\n\njulia> frac=(x+y)/den\nFrac{Mvp{Int64, Int64}}: (x+y)/(x-y)\n\njulia> Truncs.varname=:x\n:x\n\njulia> tden=Trunc(den,4,:x) # convenience for Trunc(Pol(den,:x),4)\nTrunc(4): -y+x+O(xâ´)\n\njulia> tfrac=Trunc(frac,4,:x)\nTrunc(4): -1-2yâ»Â¹x-2yâ»Â²xÂ²-2yâ»Â³xÂ³+O(xâ´)\n\njulia> tden*tfrac\nTrunc(4): y+x+O(xâ´)\n\nWe also have PadÃ© approximants:\n\nulia> pade(inv(Trunc(p,9)))\nFrac{Pol{Rational{Int64}}}: ((1//70)xâ´+(-1//14)xÂ³+(3//14)xÂ²+(-1//2)x+1)/((9//5)xâ¹+6xâ¸+(54//7)xâ·+(9//2)xâ¶+xâµ)\n\njulia> pade(inv(Trunc(p,10)))\nFrac{Pol{Rational{Int64}}}: 1/(xÂ¹â°+5xâ¹+10xâ¸+10xâ·+5xâ¶+xâµ)\n\n\n\n\n\n","category":"module"},{"location":"truncs/#Chevie.Truncs.Trunc","page":"Truncated Laurent series","title":"Chevie.Truncs.Trunc","text":"Trunc(p::Pol,i::Integer) \n\nreturns the truncated Laurent series for p with i terms\n\njulia> p=Pol([2,0,1],-1)\nPol{Int64}: x+2xâ»Â¹\n\njulia> Trunc(p,4)\nTrunc(4): 2xâ»Â¹+x+O(xÂ³)\n\n\n\n\n\n","category":"type"},{"location":"truncs/#Chevie.Truncs.pade","page":"Truncated Laurent series","title":"Chevie.Truncs.pade","text":"pade(f::Trunc,i=length(f)) PadÃ© approximant\n\nreturns  the PadÃ©  approximant rational  fraction for  f. If i is given then uses only the i first terms of f.\n\njulia> @Pol x\nPol{Int64}: x\n\njulia> f=inv(Trunc(x^3+2x+1,6))\nTrunc(6): 1-2x+4xÂ²-9xÂ³+20xâ´-44xâµ+O(xâ¶)\n\njulia> pade(f)\nFrac{Pol{Rational{Int64}}}: 1/(xÂ³+2x+1)\n\nThe algorithm is based on (Sokal, 2023; refined algorithm 2.7).\n\n\n\n\n\n","category":"function"},{"location":"eigen/#Eigenspaces","page":"Eigenspaces","title":"Eigenspaces","text":"Pages=[\"eigen.md\"]","category":"section"},{"location":"eigen/#Chevie.Eigenspaces","page":"Eigenspaces","title":"Chevie.Eigenspaces","text":"Eigenspaces and d-Harish-Chandra series\n\nLet  WÏ• be a  reflection coset on  a vector space  V; that is Î¦âˆˆGL(V) normalizes  the reflection group  W. Let LwÏ•  be a reflection subcoset; that  is L is a  parabolic subgroup of W  (the fixator of a subspace of V)  and  wâˆˆ  W  is  such  that  wÎ¦  normalizes L. There are several interesting  cases where the relative group N_W(LwÏ•)L, or a subgroup of it normalizing some further data attached to L, is itself a reflection group.\n\nA first example is the case where Ï•=1 and w=1, W is the Weyl group of a   finite  reductive   group  ğ†^F   and  the   Levi  subgroup  ğ‹^F corresponding  to L has a cuspidal unipotent character. Then N_W(L)L is  a  Coxeter  group  acting  on  the  space  X(Zğ‹)âŠ—â„.  A  combinatorial characterization of such parabolic subgroups of Coxeter groups is that they are  normalized by the  longest element of  larger parabolic subgroups, see (Lusztig, 1976; 5.7.1).\n\nA  second  example  is  when  L  is  trivial  and  wÏ• is a Î¶-regular element,  that is  the Î¶-eigenspace  V_Î¶ of  wÏ• contains  a vector outside  all the reflecting hyperplanes of W. Then N_W(LwÏ•)L=C_W(wÏ•) is a reflection group in its action on V_Î¶.\n\nA similar but more general example is when V_Î¶ is the Î¶-eigenspace of some  element of  the reflection  coset WÏ•,  and is  of maximal dimension among  such Î¶-eigenspaces. Then the set of  elements of WÏ• which act by Î¶  on  V_Î¶  is  a  certain  subcoset  LwÏ•,  and N_W(LwÏ•)L is a reflection group in its action on V_Î¶, see (Lehrer and Springer, 1999; 2.5).\n\nFinally,  a  still  more  general  example,  but which only occurs for Weyl groups  or  Spetsial  reflection  groups,  is  when ğ‹ is a Î¶-split Levi subgroup  (which means that  the corresponding subcoset  LwÏ• is formed of all  the elements which act by Î¶ on  some subspace V_Î¶ of V), and Î» is  a  d-cuspidal  unipotent  character  of  ğ‹  (which  means  that the multiplicity  of Î¶  as a  root of  the degree  of Î»  is the same as the multiplicity  of Î¶ as a root of the generic order of the semi-simple part of  ğ†); then N_W(LwÏ•Î»)L is a complex reflection group in its action on V_Î¶.\n\nFurther,  in the above cases the relative group describes the decomposition of a Lusztig induction.\n\nWhen  ğ†^F is  a finite  reductive group,  and Î»  a cuspidal unipotent character  of  the  Levi  subgroup  ğ‹^F,  then the ğ†^F-endomorphism algebra  of  the  Harish-Chandra  induced  representation R_ğ‹^ğ†(Î») is a Hecke algebra attached to the group N_W(L)L, thus the dimension of the characters  of this group describe the multiplicities in the Harish-Chandra induced.\n\nSimilarly, when ğ‹ is a Î¶-split Levi subgroup, and Î» is a d-cuspidal unipotent  character of  ğ‹ then  (conjecturally) the ğ†^F-endomorphism algebra  of the Lusztig induced R_ğ‹^ğ†(Î»)  is a cyclotomic Hecke algebra for  to the  group N_W(LwÏ•Î»)L.  The constituents  of R_ğ‹^ğ†(Î») are called  a  Î¶-Harish-Chandra  series.  In  the  case of rational groups or cosets,  corresponding to finite  reductive groups, the  conjugacy class of LwÏ•  depends  only  on  the  order  d  of  Î¶,  so  one  also talks of d-Harish-Chandra  series. These series correspond to â„“-blocks where l is  a prime divisor of Î¦_d(q) which  does not divide any other cyclotomic factor of the order of ğ†^F.\n\nThe functions  relative_degrees, regular_eigenvalues, eigenspace_projector, position_regular_class, split_levis, cuspidal in this module and the functions in the module dSeries allow to explore these situations.\n\n\n\n\n\n","category":"module"},{"location":"eigen/#Chevie.Eigenspaces.relative_degrees","page":"Eigenspaces","title":"Chevie.Eigenspaces.relative_degrees","text":"relative_degrees(WF,Î¶::Root1=1)\n\nLet  WF be a reflection group or a  reflection coset and Î¶ be a root of unity.  Then if V_Î¶ is the Î¶-eigenspace  of some element of WF, and is of maximal dimension among such Î¶-eigenspaces (and if WF is a coset W  is the group of WF) then N_W(V_Î¶)C_W(V_Î¶) is a reflection group in  its  action  on  V_Î¶.  The  function relative_degrees returns the reflection  degrees of this complex reflection group, which are a subset of those of W. These degrees are computed by an invariant-theoretic formula: if   (dâ‚,Îµâ‚),â€¦,(dâ‚™,Îµâ‚™)  are   the  generalized   degrees  of   WF  (see degrees) they are the dáµ¢ such that Î¶^{dáµ¢}=Îµáµ¢.\n\nThe  eigenvalue Î¶ can also  be specified by giving  an integer d (which then  specifies  Î¶=E(d))  or  a  fraction  a//b  which  then  specifies Î¶=E(b,a). If omitted, Î¶ is taken to be 1.\n\njulia> W=coxgroup(:E,8)\nEâ‚ˆ\n\njulia> relative_degrees(W,4) # the degrees of Gâ‚ƒâ‚‚\n4-element Vector{Int64}:\n  8\n 12\n 20\n 24\n\n\n\n\n\n","category":"function"},{"location":"eigen/#Chevie.Eigenspaces.regular_eigenvalues","page":"Eigenspaces","title":"Chevie.Eigenspaces.regular_eigenvalues","text":"regular_eigenvalues(W)\n\nLet W be a reflection group or a reflection coset. A root of unity Î¶ is a regular eigenvalue for W if some element of W has a Î¶-eigenvector which   lies   outside   of   the   reflecting  hyperplanes.  The  function returns the list of regular eigenvalues for W.\n\njulia> regular_eigenvalues(coxgroup(:G,2))\n6-element Vector{Root1}:\n   1\n  -1\n  Î¶â‚ƒ\n Î¶â‚ƒÂ²\n  Î¶â‚†\n Î¶â‚†âµ\n\njulia> W=complex_reflection_group(6)\nGâ‚†\n\njulia> L=twistings(W,[2])[4]\nGâ‚†â‚â‚‚â‚=Gâ‚ƒâ€šâ‚â€šâ‚[Î¶â‚„]Î¦â€²â‚„\n\njulia> regular_eigenvalues(L)\n3-element Vector{Root1}:\n    Î¶â‚„\n  Î¶â‚â‚‚â·\n Î¶â‚â‚‚Â¹Â¹\n\n\n\n\n\n","category":"function"},{"location":"eigen/#Chevie.Eigenspaces.eigenspace_projector","page":"Eigenspaces","title":"Chevie.Eigenspaces.eigenspace_projector","text":"eigenspace_projector(WF,w,Î¶::Root1=1)\n\nLet WF be a reflection group or a reflection coset, let w be an element of  WF and let  Î¶ be a  root of unity.  The function returns the unique w-invariant projector on the Î¶-eigenspace of w.\n\nThe  eigenvalue Î¶ can also  be specified by giving  an integer d (which then  specifies  Î¶=E(d))  or  a  fraction  a//b  which  then  specifies Î¶=E(b,a). If omitted, Î¶ is taken to be 1.\n\njulia> W=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> w=W(1:3...)\n(1,12,3,2)(4,11,10,5)(6,9,8,7)\n\njulia> p=eigenspace_projector(W,w,1//4)\n3Ã—3 Matrix{Cyc{Rational{Int64}}}:\n  (1+Î¶â‚„)/4   Î¶â‚„/2  (-1+Î¶â‚„)/4\n  (1-Î¶â‚„)/4   1//2   (1+Î¶â‚„)/4\n (-1-Î¶â‚„)/4  -Î¶â‚„/2   (1-Î¶â‚„)/4\n\njulia> GenLinearAlgebra.rank(p)\n1\n\n\n\n\n\n","category":"function"},{"location":"eigen/#Chevie.Eigenspaces.position_regular_class","page":"Eigenspaces","title":"Chevie.Eigenspaces.position_regular_class","text":"position_regular_class(WF,Î¶::Root1=1)\n\nLet  WF be a reflection group or a  reflection coset and Î¶ be a root of unity  such that some element of WF has a non-trivial Î¶-eigenspace. The function   returns  the   index  of   a  conjugacy   class  of  WF  whose Î¶-eigenspace  is  maximal  (amongst  all  Î¶-eigenspaces of elements of W).  If no element of WF  has a non-trivial Î¶-eigenspace the function returns nothing.\n\nThe  eigenvalue Î¶ can also  be specified by giving  an integer d (which then  specifies  Î¶=E(d))  or  a  fraction  a//b  which  then  specifies Î¶=E(b,a). If omitted, Î¶ is taken to be 1.\n\njulia> W=coxgroup(:E,8)\nEâ‚ˆ\n\njulia> position_regular_class(W,30)\n65\n\njulia> W=complex_reflection_group(6)\nGâ‚†\n\njulia> L=twistings(W,[2])[4]\nGâ‚†â‚â‚‚â‚=Gâ‚ƒâ€šâ‚â€šâ‚[Î¶â‚„]Î¦â€²â‚„\n\njulia> position_regular_class(L,7//12)\n2\n\n\n\n\n\n","category":"function"},{"location":"eigen/#Chevie.Eigenspaces.split_levis","page":"Eigenspaces","title":"Chevie.Eigenspaces.split_levis","text":"split_levis(WF,Î¶::Root1=1[,ad])\n\nLet  WF  be  a  reflection  group  or  a  reflection  coset.  If W is a reflection group it is treated as the trivial coset 'Spets(W)'. A  Levi  is  a  subcoset  of  the  form Wâ‚Fâ‚ where Wâ‚ is a parabolic subgroup of W, that is the centralizer of some subspace of V, and Fâ‚âˆˆ WF normalizes Wâ‚.\n\nLet Î¶ be a root of unity. split_levis returns a list of representatives of  conjugacy classes  of Î¶-split  Levis of  W. A  Î¶-split Levi  is a subcoset  of WF formed  of all the  elements which act  by Î¶ on a given subspace  V_Î¶. If the additional argument  ad is given, it returns only those subcosets such that the common Î¶-eigenspace of their elements is of dimension  ad. These notions make sense  and thus are implemented for any complex reflection group.\n\nIn  terms of algebraic groups, an F-stable Levi subgroup of the reductive group  ğ†  is  Î¶-split  if  and  only  if it is the centralizer of the Î¦-part  of its center, where Î¦ is a cyclotomic polynomial with Î¶ as a root. When Î¶=1, we get the notion of a split Levi, which is the same as a Levi sugroup of an F-stable parabolic subgroup of ğ†.\n\nThe  eigenvalue Î¶ can also  be specified by giving  an integer d (which then  specifies  Î¶=E(d))  or  a  fraction  a//b  which  then  specifies Î¶=E(b,a). If omitted, Î¶ is taken to be 1.\n\njulia> W=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> split_levis(W,4)\n2-element Vector{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}}:\n Aâ‚ƒ\n Aâ‚ƒâ‚â‚=Î¦â‚‚Î¦â‚„\n\njulia> W=spets(coxgroup(:D,4),Perm(1,2,4))\nÂ³Dâ‚„\n\njulia> split_levis(W,3)\n3-element Vector{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}}:\n Â³Dâ‚„\n Â³Dâ‚„â‚â‚â‚ƒâ‚=Aâ‚‚Î¦â‚ƒ\n Â³Dâ‚„â‚â‚=Î¦â‚ƒÂ²\n\njulia> W=coxgroup(:E,8)\nEâ‚ˆ\n\njulia> split_levis(W,4,2)\n3-element Vector{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}}:\n Eâ‚ˆâ‚â‚ƒâ‚„â‚‚â‚…â‚=Dâ‚„â‚â‚â‚ƒâ‚‚â‚„â‚Î¦â‚„Â²\n Eâ‚ˆâ‚â‚…â‚‡â‚‚â‚ƒâ‚=(Aâ‚Aâ‚)Ã—(Aâ‚Aâ‚)Î¦â‚„Â²\n Eâ‚ˆâ‚â‚ƒâ‚…â‚†â‚â‚=Â²(Aâ‚‚Aâ‚‚)â‚â‚â‚„â‚‚â‚ƒâ‚Î¦â‚„Â²\n\njulia> split_levis(complex_reflection_group(5))\n4-element Vector{Spets{PRSG{Cyc{Rational{Int64}}, Int16}}}:\n Gâ‚…\n Gâ‚…â‚â‚â‚=Gâ‚ƒâ€šâ‚â€šâ‚Î¦â‚\n Gâ‚…â‚â‚‚â‚=Gâ‚ƒâ€šâ‚â€šâ‚Î¦â‚\n Gâ‚…â‚â‚=Î¦â‚Â²\n\n\n\n\n\n","category":"function"},{"location":"eigen/#Chevie.Uch.cuspidal","page":"Eigenspaces","title":"Chevie.Uch.cuspidal","text":"cuspidal(uc::UnipotentCharacters[,e])\n\nA  unipotent character Î³ of a  finite reductive group ğ† is e-cuspidal if  its  Lusztig  restriction  to  any  proper e-split Levi is zero. When e==1  (the default when  e is omitted)  we recover the  usual notion of cuspidal character. Equivalently the Î¦â‚‘-part of the generic degree of Î³ is equal to the Î¦â‚‘-part of the generic order of the adjoint group of ğ†. This  makes  sense  for  any  Spetsial  complex  reflection  group  and  is implemented for them.\n\nThe  function returns the list of indices of unipotent characters which are e-cuspidal.\n\njulia> W=coxgroup(:D,4)\nDâ‚„\n\njulia> cuspidal(UnipotentCharacters(W))\n1-element Vector{Int64}:\n 14\n\njulia> cuspidal(UnipotentCharacters(W),6)\n8-element Vector{Int64}:\n  1\n  2\n  6\n  7\n  8\n  9\n 10\n 12\n\njulia> cuspidal(UnipotentCharacters(complex_reflection_group(4)),3)\n4-element Vector{Int64}:\n  3\n  6\n  7\n 10\n\n\n\n\n\n","category":"function"},{"location":"weyl/#Finite-Coxeter-groups,-Weyl-groups,-crystallographic-root-systems","page":"Finite Coxeter groups, Weyl groups, crystallographic root systems","title":"Finite Coxeter groups, Weyl groups, crystallographic root systems","text":"Pages=[\"weyl.md\"]","category":"section"},{"location":"weyl/#Chevie.Weyl","page":"Finite Coxeter groups, Weyl groups, crystallographic root systems","title":"Chevie.Weyl","text":"Finite Coxeter groups are the finite complex reflection groups which can be defined on a real vector space V.\n\nWeyl  groups are the  finite Coxeter groups  which can be  defined over a rational vector space V (thus over the integers).\n\nLike   finite  complex   reflection  groups,   finite  Coxeter  groups  are implemented  as groups  of permutations  of a  set of roots. The particular crystallographic  root systems for Weyl groups  play an important role in mathematics as they classify semi-simple Lie algebras and algebraic groups.\n\nLet  us give precise definitions.  Let V be a  real vector space and Vâ±½ its  dual. A root system is a finite set of vectors RâŠ‚ V (the roots), together with a map râ†¦ râ±½ from R to a set Râ±½âŠ‚ Vâ±½ (the coroots) such that:\n\nFor any râˆˆ R,  we have râ±½(r)=2, so  that the formula xâ†¦ x-râ±½(x)r defines  a  reflection  sáµ£:Vâ†’  V  with  root  r  and coroot râ±½ (see reflectionMatrix).\nThe reflection sáµ£ stabilizes R.\n\nThe  subgroup W=W(R) of GL(V) generated by the reflections sáµ£ for râˆˆ R  is a finite Coxeter group. We  use only reduced root systems, that is such  that the only elements of R colinear  with râˆˆ R are r and -r; for Weyl groups, we also require that the root system be crystallographic, that is râ±½(s) is an integer, for any sâˆˆ R,râ±½âˆˆ Râ±½.\n\nIf  we identify  V with  Vâ±½ by  choosing a  W-invariant bilinear form (.;.),  then we have râ±½=2r/(r;r). A root system R is irreducible if R   is  not  the  union  of  two  orthogonal  subsets;  equivalently  the representation  of W on the subspace  generated by R is irreducible. If R is reducible then the corresponding Coxeter group is the direct product of the Coxeter groups associated with the irreducible components of R.\n\nLet  us  now  describe  how  a  root  system  R and a presentation of the corresponding  W are encoded in  a Cartan matrix or  a Dynkin diagram. We can  choose a linear  form on V  which does not  vanish on any element of R.  Depending on the sign of the value of this linear form on a root r âˆˆ R  we call r positive or negative. Then there exists a unique subset Î   of the positive roots, the simple roots, such that any positive root is a linear combination with non-negative coefficients of the roots in Î . Any  two sets of simple roots (corresponding to different choices of linear forms) can be transformed into each other by a unique element of W(R). If S  is  the  set  of  reflections  with  respect to the simple roots, then (W,S)  is  a  Coxeter  system.  These  generating  reflections are called Coxeter generators or simple reflections.\n\nSince the pairing between V and Vâ±½ is W-invariant, if Î  is a set of simple  roots and if we  define the Cartan matrix  as being the n times n  matrix C={râ±½(r')}  for r,r'âˆˆÎ ,  this matrix  is independent of the chosen  linear form  up to  simultaneous permutation  of rows  and columns. Since the action of sáµ£ on r' for r,r'âˆˆÎ  is given by sáµ£(r')=r'-C(r,r')r,   the   Cartan   matrix   determines  the  reflection representation of W.\n\nFor  a crystallographic root system the Cartan matrix has integral entries, and  in the basis Î  (completed by a basis of the orthogonal), sáµ£ has an integral    matrix.   In   general,    all   finite-dimensional   (complex) representations  of a finite Coxeter group  can be realized over the (real) subfield generated by the entries of the Cartan matrix.\n\nAn integral Cartan matrix can be encoded in a Dynkin diagram, a tree with weighted  edges and an orientation on edges  of even weight >2, as follows. The  vertices  are  indexed  by  the  simple  reflections; an edge is drawn between  s and t if the order mâ‚›â‚œ  of st is greater than 2 and is given  the  weight  mâ‚›â‚œ.  These  weights  are encoded by drawing the edge single  for weight  3, double  for weight  4 and  triple for  weight 6. The arrows  indicate the  relative root  lengths (going  from the longer to the shorter  root) which  may differ  between different  orbits of  W on R. Alternately  the Dynkin diagram  can be obtained  from the Cartan matrix as follows: if Cáµ£â‚› and Câ‚›áµ£ are integers such that |Câ‚›áµ£|â‰¥|Cáµ£â‚›|=1 there is an  edge of weight |Câ‚›áµ£| from r to s with an arrow pointing to s if |Câ‚›áµ£|>1.  Note  that  the  Cartan  matrices  we  consider  here  are  not necessarily  symmetric,  contrary  to  the  Cartan  matrices  we considered describing  the reflection representation of a general Coxeter group; being symmetric corresponds to all roots being taken of the same length.\n\nThe  irreducible  crystallographic  root  systems  are  classified  by  the following  list of Dynkin diagrams. The labeling  of the nodes is the order of the generators and is shown by the function diagram.\n\nAâ‚™ Oâ€”Oâ€”Oâ€”â€¦â€”O   Bâ‚™ Oâ‡ Oâ€”Oâ€”â€¦â€”O  Câ‚™ Oâ‡’ Oâ€”Oâ€”â€¦â€”O  Dâ‚™ O 2\n   1 2 3 â€¦ n      1  2 3 â€¦ n     1  2 3 â€¦ n     ï¿¨\n                                              Oâ€”Oâ€”â€¦â€”O\n                                              1 3 â€¦ n\n\nGâ‚‚ Oâ‡› O  Fâ‚„ Oâ€”Oâ‡’Oâ€”O    Eâ‚†  O 2    Eâ‚‡  O 2      Eâ‚ˆ  O 2\n   1  2     1 2 3 4        ï¿¨          ï¿¨            ï¿¨\n                       Oâ€”Oâ€”Oâ€”Oâ€”O  Oâ€”Oâ€”Oâ€”Oâ€”Oâ€”O  Oâ€”Oâ€”Oâ€”Oâ€”Oâ€”Oâ€”O\n                       1 3 4 5 6  1 3 4 5 6 7  1 3 4 5 6 7 8\n\nIf  we ignore the arrows we get  the Coxeter diagram, which describes the underlying  Coxeter system  group: we  see that  the root systems B_n and C_n  correspond to the same Coxeter group (the Coxeter diagram is defined by  the coxeter_matrix). Weyl groups can also be characterized as the finite Coxeter groups such that all off-diagonal entries of the Coxeter matrix are in {2,3,4,6}.\n\nHere  are the Coxeter diagrams for the  finite Coxeter groups which are not rational (Iâ‚‚(e) is not rational if eâˆ‰ {2,3,4,6}).\n\n       e        5         5\nIâ‚‚(e) Oâ€”O   Hâ‚ƒ Oâ€”Oâ€”O  Hâ‚„ Oâ€”Oâ€”Oâ€”O\n      1 2      1 2 3     1 2 3 4\n\nThe  function cartan gives  the cartan matrix  for an irreducible root system\n\njulia> cartan(:D,4)\n4Ã—4 Matrix{Int64}:\n  2   0  -1   0\n  0   2  -1   0\n -1  -1   2  -1\n  0   0  -1   2\n\njulia> cartan(:I,2,5) # for type Iâ‚‚(e) give e as 3rd argument\n2Ã—2 Matrix{Cyc{Int64}}:\n       2  Î¶â‚…Â²+Î¶â‚…Â³\n Î¶â‚…Â²+Î¶â‚…Â³        2\n\nFor  non-irreducible root systems, we can  get their Cartan matrix by using that,   given   Cartan   matrices   câ‚,â€¦,cáµ£,   their  matrix  direct  sum (corresponding  to the  orthogonal direct  sum of  the root systems) can be obtained by cat(câ‚,â€¦,cáµ£;dims=[1,2]).\n\nThe  whole  root  system  can  be  recovered  from the simple roots and the corresponding  coroots, since each root  is in the orbit  of a simple root. The  restriction of the simple reflections to the span of R is determined by the Cartan matrix, so R is determined by the Cartan matrix and the set of simple roots.\n\nThe function rootdatum takes as arguments a matrix r whose rows represents the elements of Î  (given by their coordinates in the canonical basis of V) and another matrix cr whose rows are the coordinates of the corresponding coroots and returns a FiniteCoxeterGroup. Such an object is a  permutation  group  containing  in  addition  the  description of a root system.  cr*transpose(r) should be  a Cartan matrix  for a finite Coxeter group.  Each element of the coxeter group is represented as the permutation it  induces on the roots,  coded as a permutation  of 1:2N where we label the  positive roots  by 1:N,  and the  negative roots  by N+1:2N (these permutations  do not  depend on  the actual  roots but  just on  the Cartan matrix).  For Weyl groups  the ordering of  the roots is  very specific: we order  the positive roots  by the sum  of their coefficients  on the simple roots, and lexicographically according to the decomposition in simple roots for  a given sum, and  order the negative roots  in the same order as their negatives.\n\nIf a single matrix argument is given to rootdatum it is taken as cr and r  is taken  to be  the identity  matrix; we  get thus  a particular root system  where the  roots are  the canonical  basis of V. For convenience, rootdatum(cartan(t))   can  be  simplified  to  coxgroup(t),  giving  a convenient way to get a Coxeter group of a given type.\n\njulia> W=coxgroup(:D,4) # same as rootdatum(cartan(:D,4))\nDâ‚„\n\njulia> cartan(W)\n4Ã—4 Matrix{Int64}:\n  2   0  -1   0\n  0   2  -1   0\n -1  -1   2  -1\n  0   0  -1   2\n\nAlso,  instead  of  using  the  direct  sum  of  the  Cartan  matrices, the FiniteCoxeterGroup associated to a direct sum of irreducible root systems can be obtained as\n\njulia> W=coxgroup(:A,2)*coxgroup(:B,2)\nAâ‚‚Ã—Bâ‚‚\n\njulia> cartan(W) # same as cat(cartan(:A,2), cartan(:B,2),dims=[1,2])\n4Ã—4 Matrix{Int64}:\n  2  -1   0   0\n -1   2   0   0\n  0   0   2  -2\n  0   0  -1   2\n\nThe elements of a Weyl group are permutations of the roots:\n\njulia> W=coxgroup(:D,4)\nDâ‚„\n\njulia> p=W(1,3,2,1,3) # permutes the 24 roots\n(1,14,13,2)(3,17,8,18)(4,12)(5,20,6,15)(7,10,11,9)(16,24)(19,22,23,21)\n\njulia> word(W,p) # get a word in the Coxeter generators\n5-element Vector{Int64}:\n 1\n 3\n 1\n 2\n 3\n\nNote that all the function for reflection groups are available for finite Coxeter groups: rank, semisimplerank, roots, coroots, simpleroots, simplecoroots, simple_reps, simple_conjugating, refls, refltype, invariant_form, YMatrix, PermX, PermY, baseX, inclusion, inclusiongens, restriction, reflection_length,\n\n\n\n\n\n","category":"module"},{"location":"weyl/#Chevie.PermRoot.cartan-Tuple{Symbol, Integer, Integer}","page":"Finite Coxeter groups, Weyl groups, crystallographic root systems","title":"Chevie.PermRoot.cartan","text":"cartan(type, rank [,bond])\n\nthe  Cartan matrix for a  finite Coxeter group described  by type and rank. The  recognized types are :A, :B, :Bsym, :C, :D, :E, :F, :Fsym, :G, :Gsym, :I,  :H. For type :I a third  argument must be given describing the bond between the two generators. The sym types correspond to (non-crystallographic)  root systems where all  roots have the same length; they  afford automorphisms that  the crystallographic root  system does not afford, which allow to define the \"very twisted\" Chevalley groups.\n\njulia> cartan(:F,4)\n4Ã—4 Matrix{Int64}:\n  2  -1   0   0\n -1   2  -1   0\n  0  -2   2  -1\n  0   0  -1   2\n\njulia> cartan(:I,2,5)\n2Ã—2 Matrix{Cyc{Int64}}:\n       2  Î¶â‚…Â²+Î¶â‚…Â³\n Î¶â‚…Â²+Î¶â‚…Â³        2\n\njulia> cartan(:Bsym,2)\n2Ã—2 Matrix{Cyc{Int64}}:\n   2  -âˆš2\n -âˆš2    2\n\n\n\n\n\n","category":"method"},{"location":"weyl/#Chevie.PermRoot.roots-Tuple{AbstractMatrix}","page":"Finite Coxeter groups, Weyl groups, crystallographic root systems","title":"Chevie.PermRoot.roots","text":"roots(C::AbstractMatrix)\n\nreturns the set of positive roots defined by the Cartan matrix C, which should be the Cartan matrix of a finite Coxeter group.\n\nFor  an integer Cartan matrix, the returned  roots are sorted by height and reverse lexicographically for a given height.\n\n\n\n\n\n","category":"method"},{"location":"weyl/#Chevie.Weyl.two_tree","page":"Finite Coxeter groups, Weyl groups, crystallographic root systems","title":"Chevie.Weyl.two_tree","text":"two_tree(m)\n\nGiven  a  square  matrix  m  with  zeroes  symmetric  with respect to the diagonal,  let  G  be  the  graph  with vertices axes(m)[1] and an edge between i and j iff !iszero(m[i,j]).\n\nIf  G  is  linear  this  function  returns  this  linear ordering it as a Vector{Int}.  If G  is a  tree with  one vertex  c of valence 3 the function   returns  (c,b1,b2,b3)   where  b1,b2,b3   are  Vector{Int} representing  the branches  from this  vertex sorted  by increasing length. Otherwise the function returns nothing.\n\nThis function is used when recognizing the type of a Cartan matrix.\n\njulia> two_tree(cartan(:A,4))\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\njulia> two_tree(cartan(:E,8))\n(4, [2], [3, 1], [5, 6, 7, 8])\n\n\n\n\n\n","category":"function"},{"location":"weyl/#Chevie.PermRoot.reflection_subgroup-Tuple{Chevie.Weyl.FCG, AbstractVector{<:Integer}}","page":"Finite Coxeter groups, Weyl groups, crystallographic root systems","title":"Chevie.PermRoot.reflection_subgroup","text":"reflection_subgroup(W::FiniteCoxeterGroup,I)\n\nFor IâŠ†1:nref(W), the subgroup H of W generated by refls(W,I).\n\nA  theorem found independently by (Deodhar, 1989) and (Dyer, 1990) is that a  subgroup H of a Coxeter system  (W,S) generated by reflections has a canonical  Coxeter  generating  set,  formed  of  the  t  âˆˆ  Ref(H)  such length(W,tt')>length(W,t)  for any t'âˆˆ Ref(H)  different from t. This is used by reflection_subgroup to determine the Coxeter system of H.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> diagram(W)\nOâ‡› O Gâ‚‚\n1  2\n\njulia> H=reflection_subgroup(W,[2,6])\nGâ‚‚â‚â‚‚â‚†â‚=AÌƒâ‚Ã—Aâ‚\n\njulia> diagram(H)\nO AÌƒâ‚\n1\nO Aâ‚\n2\n\nThe  notation Gâ‚‚â‚â‚‚â‚†â‚  means that  roots(W,[2,6]) is  a system of simple roots for H.\n\nIf  H is a  standard parabolic subgroup  of a Coxeter  group W then the length  function on  H (with  respect to  its set  of generators)  is the restriction  of the length function on W. This need not no longer be true for  arbitrary reflection subgroups of  W. \n\njulia> elH=word.(Ref(H),elements(H))\n4-element Vector{Vector{Int64}}:\n []\n [1]\n [2]\n [1, 2]\n\njulia> elW=word.(Ref(W),elements(H))\n4-element Vector{Vector{Int64}}:\n []\n [2]\n [1, 2, 1, 2, 1]\n [1, 2, 1, 2, 1, 2]\n\njulia> splat(H).(elH)==splat(W).(elW)\ntrue\n\nWe  implement finite  reflection groups  as permutation  groups on a set of roots.  Consequently,  a  reflection  subgroup  HâŠ†  W  is  a  permutation subgroup, thus its elements are represented as permutations of the roots of the parent group.\n\n\n\n\n\n","category":"method"},{"location":"weyl/#Chevie.CoxGroups.coxeter_group","page":"Finite Coxeter groups, Weyl groups, crystallographic root systems","title":"Chevie.CoxGroups.coxeter_group","text":"coxeter_group(type,rank[,bond];sc=false) (or coxgroup)\n\nConstructs  the finite Coxeter group of given type and rank (and bond for  dihedral  groups).  If  C=cartan(type,rank[,bond]),  the function is equivalent  to rootdatum(C)  (the adjoint  root datum).  If sc=true the function  is equivalent  to rootdatum(permutedims(C),one(C))  (the simply connected root datum).\n\nThe  resulting object W, a  FiniteCoxeterGroup, has an additional entry compared to a PermRootGroup.\n\nW.rootdec:  the roots, given  as linear combinations of simple roots. The  first nref(W) roots  are the positive  roots, the last nref(W) are  the negative of  the first ones.  Moreover, the first rank roots are  the  simple  roots,  so  these  rows form the identity matrix. The positive roots are ordered by increasing height, and for equal height,  lexicographically.\n\nand  roots(W)  is  ordered  is  the  same  way  as W.rootdec. Note that roots(W) is given in a basis of X(T), which is the simple roots for the adjoint  root datum (then  it coincides with  W.rootdec) but is different for other root data.\n\nFor  how to  get various  information on  the root  system and  the Coxeter group,   see  the  functions   nref,  coroots,  rootlengths,  simple_reps, simple_conjugating,  reflrep,  simpleroots,  simplecoroots,  PermX, cartan, inclusion, restriction, action, rank, semisimplerank.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> cartan(W)\n2Ã—2 Matrix{Int64}:\n  2  -1\n -3   2\n\njulia> W.rootdec\n12-element Vector{Vector{Int64}}:\n [1, 0]\n [0, 1]\n [1, 1]\n [1, 2]\n [1, 3]\n [2, 3]\n [-1, 0]\n [0, -1]\n [-1, -1]\n [-1, -2]\n [-1, -3]\n [-2, -3]\n\njulia> reflrep(W) # generators as matrices in the basis `simpleroots(W)`\n2-element Vector{Matrix{Int64}}:\n [-1 0; 1 1]\n [1 3; 0 -1]\n\n\n\n\n\n","category":"function"},{"location":"weyl/#Chevie.CoxGroups.coxeter_group-Tuple{}","page":"Finite Coxeter groups, Weyl groups, crystallographic root systems","title":"Chevie.CoxGroups.coxeter_group","text":"coxeter_group() or coxgroup() the trivial Coxeter group\n\n\n\n\n\n","category":"method"},{"location":"weyl/#Chevie.Weyl.rootlengths","page":"Finite Coxeter groups, Weyl groups, crystallographic root systems","title":"Chevie.Weyl.rootlengths","text":"rootlengths(W::FiniteCoxeterGroup)  the vector  of the (squared)  length of the roots of W.  The  shortest roots in an irreducible subsystem are given the length 1. In  a Weyl group the others then have length 2 (or 3 in type Gâ‚‚). The matrix  of the W-invariant bilinear form is given by  Diagonal(rootlengths(W)[1:ngens(W)])*cartan(W).\n\n\n\n\n\n","category":"function"},{"location":"weyl/#Chevie.Weyl.highest_short_root","page":"Finite Coxeter groups, Weyl groups, crystallographic root systems","title":"Chevie.Weyl.highest_short_root","text":"highest_short_root(W)\n\nIt  is  an  error  if  W  is  not an irreducible Coxeter group. Otherwise HighestShortRoot  returns the index  of the unique  short root of maximal height  of W. If all roots have the same length then this is the index of the unique root of maximal height, equal to nref(W).\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> highest_short_root(W)\n4\n\n\n\n\n\n","category":"function"},{"location":"weyl/#Chevie.Weyl.describe_involution","page":"Finite Coxeter groups, Weyl groups, crystallographic root systems","title":"Chevie.Weyl.describe_involution","text":"describe_involution(W,w)\n\nGiven  an  involution  w  of  a  Coxeter  group  W,  by  a  theorem  of (Richardson, 1982)  there is a unique parabolic  subgroup P of W such that P is finite and w is the longest element of P, and is central in P. The  function  returns  I  such  that  P==reflection_subgroup(W,I)  and w==longest(reflection_subgroup(W,I)).\n\njulia> W=coxgroup(:A,2)\nAâ‚‚\n\njulia> w=longest(W)\n(1,5)(2,4)(3,6)\n\njulia> describe_involution(W,w)\n1-element Vector{Int64}:\n 3\n\njulia> w==longest(reflection_subgroup(W,[3]))\ntrue\n\nFor now only works for finite Coxeter groups.\n\n\n\n\n\n","category":"function"},{"location":"weyl/#Chevie.Weyl.badprimes","page":"Finite Coxeter groups, Weyl groups, crystallographic root systems","title":"Chevie.Weyl.badprimes","text":"badprimes(W)\n\nLet  W  be  a  Weyl  group.  A  prime  is  bad  for W if it divides a coefficient  of some  root on  the simple  roots. The  function badprimes returns the list of primes which are bad for W.\n\njulia> W=coxgroup(:E,8)\nEâ‚ˆ\n\njulia> badprimes(W)\n3-element Vector{Int64}:\n 2\n 3\n 5\n\n\n\n\n\n","category":"function"},{"location":"weyl/#Chevie.Weyl.standard_parabolic-Tuple{Union{Chevie.Weyl.FCG, Chevie.Weyl.FCSG}, AbstractVector{<:Integer}}","page":"Finite Coxeter groups, Weyl groups, crystallographic root systems","title":"Chevie.Weyl.standard_parabolic","text":"standard_parabolic(W,H)\n\nGiven  a reflection subgroup H or the indices of its simple roots returns nothing if H is not parabolic, otherwise returns w such that H^w is a standard parabolic subgroup of W.\n\njulia> W=coxgroup(:E,6)\nEâ‚†\n\njulia> R=reflection_subgroup(W,[20,30,19,22])\nEâ‚†â‚â‚â€šâ‚‰â€šâ‚â‚‰â€šâ‚‚â‚€â‚=Aâ‚„â‚â‚ƒâ‚â‚‚â‚„â‚Î¦â‚Â²\n\njulia> p=standard_parabolic(W,R)\n(1,4,49,12,10)(2,54,62,3,19)(5,17,43,60,9)(6,21,34,36,20)(7,24,45,41,53)(8,65,50,15,22)(11,32,31,27,28)(13,48,46,37,40)(14,51,58,44,29)(16,23,35,33,30)(18,26,39,55,38)(42,57,70,72,56)(47,68,67,63,64)(52,59,71,69,66)\n\njulia> p==standard_parabolic(W,[19,1,9,20]) # can give inclusiongens\ntrue\n\njulia> reflection_subgroup(W,[20,30,19,22].^p) # same as R^p\nEâ‚†â‚â‚‚â‚„â‚…â‚†â‚=Aâ‚„Î¦â‚Â²\n\njulia> R=reflection_subgroup(W,[1,2,3,5,6,35])\nEâ‚†â‚â‚â€šâ‚‚â€šâ‚ƒâ€šâ‚…â€šâ‚†â€šâ‚ƒâ‚…â‚=Aâ‚‚â‚â‚â‚ƒâ‚Ã—Aâ‚‚â‚â‚‚â‚†â‚Ã—Aâ‚‚â‚â‚„â‚…â‚\n\njulia> standard_parabolic(W,R)\n\n\n\n\n\n","category":"method"},{"location":"weyl/#Chevie.CoxGroups.inversions","page":"Finite Coxeter groups, Weyl groups, crystallographic root systems","title":"Chevie.CoxGroups.inversions","text":"inversions(W,w)\n\nReturns  the inversions of the element w of the finite Coxeter group W, that  is, the list of the  indices of reflections r of W such that l(rw)<l(w) where l is the Coxeter length.\n\njulia> W=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> inversions(W,W(1,2,1))\n3-element Vector{Int64}:\n 1\n 2\n 4\n\n\n\n\n\ninversions(W::FiniteCoxeterGroup, w::AbstractVector{<:Integer})\n\nGiven  a word w=[sâ‚,â€¦,sâ‚™] (a vector of integers) representing the element W(w...),  returns the inversions of  w, that is the  list of indices of the reflections of W given by W(sâ‚), W(sâ‚,sâ‚‚,sâ‚), â€¦, W(sâ‚,sâ‚‚,â€¦,sâ‚™,sâ‚™â‚‹â‚,â€¦,sâ‚).\n\njulia> W=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> inversions(W,[2,1,2])\n3-element Vector{Int64}:\n 2\n 4\n 1\n\n\n\n\n\n","category":"function"},{"location":"weyl/#Chevie.Weyl.with_inversions","page":"Finite Coxeter groups, Weyl groups, crystallographic root systems","title":"Chevie.Weyl.with_inversions","text":"with_inversions(W,N)\n\nW  should be  a finite  Coxeter group  and N  a subset  of 1:nref(W). Returns  the  element  w  of  W such that N==inversions(W,w). Returns nothing if no such element exists.\n\njulia> W=coxgroup(:A,2)\nAâ‚‚\n\njulia> with_inversions.(Ref(W),combinations(1:nref(W)))\n8-element Vector{Union{Nothing, Perm{Int16}}}:\n ()\n (1,4)(2,3)(5,6)\n (1,3)(2,5)(4,6)\n nothing\n nothing\n (1,6,2)(3,5,4)\n (1,2,6)(3,4,5)\n (1,5)(2,4)(3,6)\n\n\n\n\n\n","category":"function"},{"location":"weyl/#Chevie.Weyl.relative_group","page":"Finite Coxeter groups, Weyl groups, crystallographic root systems","title":"Chevie.Weyl.relative_group","text":"relative_group(W::FiniteCoxeterGroup,J)\n\nJ  should be a if distinguished subset of S==eachindex(gens(W)), that is if for sâˆˆ S-J we set v(sJ)=wâ‚€^J swâ‚€á´¶ then J is stable by all v(s,J).  Then N_W(W_J)=W_J Nâ‚  where Nâ‚ is  the group generated by the  v(s,J),  which  form  a  Coxeter  system for Nâ‚. Equivalently Nâ‚ consists   of  the   J-reduced  elements   of  N_W(W_J).  The  quotient R=N_W(W_J)/W_J has a natural reflection representation on X(ZL_JZG), using that by (Lusztig, 1976), the images of the roots of W in X(ZL_J) form  a root  system. The  function returns  R as  a reflection  group on X(ZL_JZG), with some extra attributes reflecting its origin\n\nR.relative_indices=setdiff(S,J) in a certain order\nR.toparent= the list of v(s,J) corresponding to .relative_indices;  defines an isomorphism Râ†’ Nâ‚.\nR.fromparent  is  a  function  mapping elements of Nâ‚ to R. The  inverse mapping to .toparent.\n\n\n\n\n\nrelative_group(s::Series)\n\ncomputes  s.WGL  (denoted  W_ğ”¾(ğ•ƒ,Î»)  in  spetses  2014)  as a relgroup, containing  function field .toparent  (lifting reflections to  elts of W) and  field  .reflists  (lifting  a  generator  s  to  reflections  of the parabolic ğ•„ of W such that W_ğ•„ (ğ•ƒ,Î»)=<s>)\n\nfills also .WGLdims:  dimensions of Irr(s.WGL)\n\n\n\n\n\n","category":"function"},{"location":"weyl/#Chevie.Weyl.affine","page":"Finite Coxeter groups, Weyl groups, crystallographic root systems","title":"Chevie.Weyl.affine","text":"A  generalized Cartan matrix C  is a square integer  matrix of size n such  that cáµ¢áµ¢=2, cáµ¢â±¼â‰¤0 if iâ‰ j, and cáµ¢â±¼==0 if and only if câ±¼áµ¢==0. We  say  that  C  is  indecomposable  if  it  does  not admit any block decomposition.\n\nLet  C be a generalized  Cartan matrix. For I  a subset of {1,â€¦,n} we denote  by C_I the square  submatrix with indices i,j  taken in I. If v  is a real vector of length n, we write v>0 if for all iâˆˆ {1,â€¦,n} we  have váµ¢>0. It can be shown that C is a Cartan matrix if and only if for  all sets  I, we  have det  C_I>0; or  equivalently, if and only if there  exists  v>0  such  that  C.v>0.  C is called an affine Cartan matrix  if for all proper subsets I we have det C_I>0, but det C==0; or equivalently if there exists v>0 such that C.v==0.\n\nGiven  an  irreducible  Weyl  group  W  with  Cartan  matrix  C, we can construct  a generalized  Cartan matrix  CÌƒ as  follows. Let  Î±â‚€ be the opposed of the highest root. Then the matrix left(beginarrayccCCÎ±â‚€  Î±â‚€C2endarrayright) is  an  affine  Cartan  matrix.  The  affine  Cartan  matrices which can be obtained  in this way  are those we  are interested in,  which give rise to affine Weyl groups.\n\nLet d=n-rank(C). A realization of a generalized Cartan matrix is a pair V,Váµ›  of vector spaces of dimension n+d together with vectors Î±â‚,â€¦,Î±â‚™âˆˆ V  (the simple roots), Î±áµ›â‚,â€¦,Î±áµ›â‚™âˆˆ Váµ› (the simple coroots), such that (Î±áµ›áµ¢,  Î±â±¼)=c_{i,j}.  Up  to  isomorphism,  a  realization  is obtained as follows: write C=left(beginarraycC_1C_2endarrayright) where  Câ‚ is  of same  rank as  C. Then  take Î±áµ¢  to be the first n vectors  in a basis of V, and take Î±áµ›â±¼ to be given in the dual basis by the rows of the matrix left(beginarrayccCâ‚0 C_2hboxId_d endarrayright) To  C we associate a reflection group  in the space V, generated by the fundamental  reflections  ráµ¢  given  by  ráµ¢(v)=v-(Î±áµ›áµ¢,v)Î±áµ¢. This is a Coxeter  group, called the affine Weyl group WÌƒ associated to W when we start with the affine Cartan matrix associated to a Weyl group W.\n\nThe  affine Weyl  group is  infinite; it  has one additional generator sâ‚€ (the  affine reflection with respect  to Î±â‚€) compared to  W. We can not use  0 as a label by default for  a generator of a Coxeter group (because the default labels are used as indices, and indices start at 1 in Julia) so we label it as n+1 where n is the numbers of generators of W.\n\njulia> W=affine(coxgroup(:A,4))\nAÌƒâ‚„\n\njulia> diagram(W)\n       â€”â€”â€”â€”5â€”â€”â€”â€”\n      /         \\\nAÌƒâ‚„   1â€”â€”â€”2â€”â€”â€”3â€”â€”â€”4\n\n\n\n\n\n","category":"function"},{"location":"weyl/#Chevie.Weyl.rootdatum-Tuple{AbstractMatrix}","page":"Finite Coxeter groups, Weyl groups, crystallographic root systems","title":"Chevie.Weyl.rootdatum","text":"rootdatum(C::AbstractMatrix)  adjoint root datum  from Cartan matrix C. It  is the  same as  rootdatum(one(C),C). The  adjoint group  is also the default  returned for coxeter_group(type,rank). The following methods all define pglâ‚ƒ.\n\njulia> rootdatum(cartan(:A,3))==coxgroup(:A,3)\ntrue\n\njulia> rootdatum(:pgl,3)\npglâ‚ƒ\n\n\n\n\n\n","category":"method"},{"location":"weyl/#Chevie.Weyl.rootdatum-Tuple{AbstractMatrix, AbstractMatrix}","page":"Finite Coxeter groups, Weyl groups, crystallographic root systems","title":"Chevie.Weyl.rootdatum","text":"rootdatum(R::AbstractMatrix,CR::AbstractMatrix)\n\nconstructs  the root datum given by the  simple roots which are the rows of R  and  the  simple  coroots  which  are  the  rows  of CR. This is the reflection  group  on  the  rowspace  of  R  generated by the reflections reflectionMatrix(R[i,:],CR[i,:]).\n\nIn  another interpretation this constructs the  root datum of the algebraic group  such that the rows of R are  the simple roots on a basis of X(T) and  the rows of CR are the simple  coroots on a basis of Y(T). In this interpretation the following methods all define glâ‚ƒ.\n\njulia> rootdatum(:gl,3)==rootdatum(\"gl\",3)\ntrue\n\njulia> rootdatum([1 -1 0;0 1 -1],[1 -1 0;0 1 -1])\nAâ‚‚Î¦â‚\n\n\n\n\n\n","category":"method"},{"location":"rootdata/#Reductive-algebraic-groups-and-root-data","page":"Reductive algebraic groups and root data","title":"Reductive algebraic groups and root data","text":"Pages=[\"rootdata.md\"]","category":"section"},{"location":"rootdata/#Chevie.Rootdata","page":"Reductive algebraic groups and root data","title":"Chevie.Rootdata","text":"Reductive algebraic groups and root data\n\nLet  us fix an  algebraically closed field  K and let  ğ† be a connected reductive  algebraic group over K. Let ğ“ be a maximal torus of ğ†, let X(ğ“)  be the  character group  of ğ“  (resp. Y(ğ“)  the dual lattice of one-parameter  subgroups  of  ğ“)  and  Î¦  (resp  Î¦áµ›) the roots (resp. coroots) of ğ† with respect to ğ“.\n\nThen  ğ† is  determined up  to isomorphism  by the  root datum (X(ğ“),Î¦, Y(ğ“),Î¦áµ›).  In algebraic terms, this consists  in giving a free â„¤-lattice X=X(ğ“) of dimension the rank of ğ“ (which is also called the rank of ğ†),  and a root system Î¦ âŠ‚ X,  and similarly giving the dual roots Î¦^âŠ‚ Y=Y(ğ“).\n\nThis  can be  constructed by  giving integral  matrices as arguments to our function  rootdatum. We  assume that  the canonical  basis of the vector  space V on which W acts is  a â„¤-basis of X, and the rows of the first argument simpleroots(W) of rootdatum are the simple roots  Î  expressed in this basis of X. Similarly the rows of the second argument  simplecoroots(W) describes the  simple coroots in the basis  of Y dual to the chosen  basis of X. The duality pairing between X  and Y is the canonical one,  that is the pairing between vectors xâˆˆ X and yâˆˆ Y is given by transpose(x)*y. Thus, we must have the relation simplecoroots(W)*permutedims(simpleroots(W))=cartan(W).\n\nThe  roots need not generate  V, so the matrices  need not be square. For example, the root datum of the linear group of rank 3 can be obtained as:\n\njulia> W=rootdatum([-1 1 0;0 -1 1],[-1 1 0;0 -1 1])\nAâ‚‚Î¦â‚\n\njulia> reflrep(W,W(1))\n3Ã—3 Matrix{Int64}:\n 0  1  0\n 1  0  0\n 0  0  1\n\nhere  the  Weyl  group  is  the  symmetric  group  on  3  letters acting by permutation of the basis of X. The dimension of X, size(simpleroots(W),2),  is the rank(W)] and the dimension of the  subspace  generated  by  the  roots,  size(simpleroots(W),1), is the semisimplerank(W).  In  the  example  the  rank  is  3  and the semisimple rank is 2.\n\nThe  default representation  obtained as  W=coxgroup(:A,2) corresponds to the  adjoint algebraic group (the group in its isogeny class with a trivial centre).  In this case  Î¦ is a  basis of X,  so simpleroots(W) is the identity  matrix and simplecoroots(W) is the Cartan matrix cartan(W) of the root system.\n\nThe   form  coxgroup(:A,2,sc=true)   constructs  the   semisimple  simply connected  algebraic  group,  where  simpleroots(W)  is the transposed of cartan(W) and simplecoroots(W) is the identity matrix.\n\nAn  extreme form of root data can  be specified more conveniently: when W is  the trivial coxgroup() (in this case ğ† is a torus), the root datum has  no roots, thus  is entirely determined  by the rank  r. The function torus(r)  constructs  such  a  root  datum  (it  could  be also obtained by giving two 0Ã—r matrices to rootdatum).\n\nFinally,  the rootdatum function also understands some familiar names for the  algebraic groups for which it gives the results that could be obtained by giving the appropriate simpleroots(W) and simplecoroots(W) matrices:\n\njulia> rootdatum(:gl,3)   # same as the previous example\nglâ‚ƒ\n\nThe types of root data which are understood are  :gl, :pgl, :sl, :slmod, :tgl :sp, :csp, :psp, :so, :pso, :cso, :halfspin,    :gpin, :spin, :E6, :E6sc, :CE6, :E7, :E7sc, :CE7, :E8, :F4, :G2.\n\nThe  group ğ† is semisimple if the rank is equal to the semisimple rank. In  this case, things  are constrained: the  lattice X having an integral pairing  withe the coroots,  is in the  dual lattice of  the lattice of the coroots.  This dual lattice is called  the weight lattice. The dual basis to  the simple  coroots is  called the  fundamental weights. Similarly we have the coweight lattice and the fundamental coweights. In general the lattice  X is  an intermediate  lattice between  the root  and the weight lattices.\n\nIt  follows  that  the  finite  abelian  group  obtained by quotienting the coweight  lattice by the  coroot lattice describes  all possibilities. This group   is  called  the  fundamental  group   of  the  root  system;  the fundamental  group of ğ† is  the quotient of Y  by the coroot lattice. The  fundamental  group  of  the  root  system  is also called the adjoint fundamental  group since for an adjoint group Y is the coweight lattice. The  fundamental  group  of  ğ†  is  a subgroup of the adjoint fundamental group.   It  turns  out  that  the  non-trivial  elements  of  the  adjoint fundamental  group are in bijection with the minuscule coweights, that is the  coweights whose pairing with every root is in -1,0,1 (this bijection is  compatible  with  the  group  structure,  taking  coweights  modulo the coroots).  The  function  intermediate_group  can  construct  any semisimple group using this.\n\nThe fundamental group has another incarnation which can be more convenient.\n\nThe extended simple roots is Î Ìƒ=Î âˆª{-Î±â‚€} where Î±â‚€ is the highest root.\n\nVia  the theory  of the  affine Weyl  group (see affine), the fundamental group  is  isomorphic  to  the  subgroup  of  W which stabilizes Î Ìƒ. We represent  Î Ìƒ by the  indices of the  roots it contains  and the function fundamental_group  returns it as a group of permutations of these indices.\n\n\n\n\n\n","category":"module"},{"location":"rootdata/#Chevie.Rootdata.torus-Tuple{Integer}","page":"Reductive algebraic groups and root data","title":"Chevie.Rootdata.torus","text":"torus(rank::Integer)\n\nThis  function returns the object corresponding to the notion of a torus of dimension  rank, a Coxeter  group of semisimple  rank 0 and given rank. This  corresponds to a split torus; the extension to Coxeter cosets is more useful.\n\njulia> torus(3)\nÎ¦â‚Â³\n\n\n\n\n\n","category":"method"},{"location":"rootdata/#Chevie.Rootdata.istorus","page":"Reductive algebraic groups and root data","title":"Chevie.Rootdata.istorus","text":"istorus(W) whether W is a torus\n\n\n\n\n\n","category":"function"},{"location":"rootdata/#Chevie.PermRoot.radical","page":"Reductive algebraic groups and root data","title":"Chevie.PermRoot.radical","text":"radical(W)\n\nA torus of dimension rank(W)-semisimplerank(W)).\n\nThe  radical datum of a root datum (X,Î¦,Y,Î¦^âˆ¨) is (X/(Xâˆ© â„š Î¦),âˆ… ,Î¦^âŸ‚,âˆ…), a toral  datum. \n\n\n\n\n\n","category":"function"},{"location":"rootdata/#Chevie.Rootdata.derived_datum","page":"Reductive algebraic groups and root data","title":"Chevie.Rootdata.derived_datum","text":"derived_datum(G)\n\nThe  derived datum of (X,Î¦,Y,Î¦^âˆ¨) is (X/Î¦^{âˆ¨âŸ‚}, Î¦, Yâˆ© â„š Î¦^âˆ¨, Î¦^âˆ¨) where âŸ‚  denotes the orthogonal. This function  starts with a root datum object G and returns the root datum object corresponding to the derived datum.\n\n\n\n\n\n","category":"function"},{"location":"rootdata/#Chevie.Rootdata.SubTorus","page":"Reductive algebraic groups and root data","title":"Chevie.Rootdata.SubTorus","text":"SubTorus(W,Y::Matrix{<:Integer})\n\nThe  function  returns  the  subtorus  ğ’  of  the  maximal torus ğ“ of the reductive  group represented by the Weyl group  W such that Y(ğ’) is the (pure)  sublattice of  Y(ğ“) generated  by the  (integral) vectors  Y. A basis  of Y(ğ’) in  Hermite normal form  (for easy memebership testing) is computed  and stored in the field S.gens of the returned SubTorus struct. A  basis of Y(ğ“) adapted to Y(ğ’) is  also computed. This means a set of integral   vectors,  stored  in  S.complement,   is  computed  such  that M=vcat(S.gens,S.complement)   is   a   basis   of   Y(ğ“)  (equivalently MâˆˆGL(Z^{rank(W)}).  An  error  is  raised  if  Y does not define a pure sublattice.\n\njulia> W=coxgroup(:A,4)\nAâ‚„\n\njulia> SubTorus(W,[1 2 3 4;2 3 4 1;3 4 1 1])\nSubTorus(Aâ‚„,[1 0 3 -13; 0 1 2 7; 0 0 4 -3])\n\njulia> SubTorus(W,[1 2 3 4;2 3 4 1;3 4 1 2])\nERROR: not a pure sublattice\nStacktrace:\n [1] error(::String) at ./error.jl:33\n [2] Chevie.Weyl.SubTorus(::FiniteCoxeterGroup{Perm{Int16},Int64}, ::Matrix{Int64}) at /home/jmichel/julia/Chevie.jl/src/Weyl.jl:1082\n [3] top-level scope at REPL[25]:1\n\n\n\n\n\n","category":"type"},{"location":"rootdata/#Chevie.Rootdata.fundamental_group","page":"Reductive algebraic groups and root data","title":"Chevie.Rootdata.fundamental_group","text":"fundamental_group(W;full=false)\n\nThis  function returns the fundamental group of the algebraic group defined by  the root datum W;  for an adjoint root  datum this is the subgroup of W  which  stabilises  the  extended  root  basis (the set of simple roots enriched  by the  lowest root  of each  irreducible component). By default, this  is returned as a group of permutations of the indices of the roots of the  extended root basis. If full=true is given, then the result is given as  a subgroup  of W  (thus permuting  other roots  besides those  in the extended root basis).\n\nFor a general root datum the result is a subgroup of the group returned for an adjoint root datum. The definition we take of the fundamental group of a (not  necessarily semisimple) reductive group is (Pâˆ© Y(ğ“))/Q where P is the coweight lattice (the dual lattice in Y(ğ“)âŠ— â„š of the root lattice) and Q is the  coroot latice. The bijection between  elements of P/Q and permutations of  the extended root basis is  explained in the context of non-irreducible groups for example in (BonnafÃ©, 2005; Â§3.B).\n\njulia> W=coxgroup(:A,3) # the adjoint group\nAâ‚ƒ\n\njulia> fundamental_group(W) # the 12th root is the lowest one\nGroup((1,2,3,12))\n\njulia> fundamental_group(W;full=true)\nGroup((1,2,3,12)(4,5,10,11)(6,7,8,9))\n\njulia> W=rootdatum(:sl,4) # the semisimple simply connected group\nslâ‚„\n\njulia> fundamental_group(W)\nGroup(Perm{Int16}[])\n\n\n\n\n\n","category":"function"},{"location":"rootdata/#Chevie.Rootdata.intermediate_group","page":"Reductive algebraic groups and root data","title":"Chevie.Rootdata.intermediate_group","text":"intermediate_group(W, indices...)\n\nreturns a rootdatum which represents a semisimple algebraic group between the   adjoint  group,  obtained  by  a  call  like  rootdatum(:pgl,4)  or coxgroup(:A,3), and the simply connected semi-simple group, obtained by a call  like  rootdatum(:sl,4)  or  coxgroup(:A,3;sc=true). This group is specified  by a  subset of  the minuscule  coweights, the coweights whose scalar  product with each root is in  -1,0,1 (a coweight is an element of the  coweight lattice  Páµ›, the  lattice dual  to the root lattice). The non-trivial  characters of the  (algebraic) center of  a semi-simple simply connected  algebraic group are  in bijection with  the minuscule coweights, and also in bijection with Páµ›/Qáµ› where Qáµ› is the coroot lattice. If W is  irreducible,  the  minuscule  coweights  are  part  of the basis of the coweight  lattice given by  the fundamental coweights,  which is the dual basis  of the simple roots. They can  therefore be specified by an index in the  Dynkin diagram.  The indices  of minuscule  coweights in  the dynkin diagram are indices where the coefficient of the highest root on the simple roots  is  1.  The  constructed  intermediate  group  has  lattice Y(ğ“) generated  by the root lattice and the given minuscule coweights. If W is not  irreducible, a minuscule  coweight is a  sum of minuscule coweights in different  components;  an  element  of  indices  is  thus itself a list, interpreted as representing the sum of the corresponding coweights.\n\njulia> W=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> fundamental_group(intermediate_group(W)) # simply connected\nGroup(Perm{Int16}[])\n\njulia> fundamental_group(intermediate_group(W,2)) # intermediate\nGroup((1,3)(2,12))\n\njulia> fundamental_group(intermediate_group(W,1)) # adjoint\nGroup((1,2,3,12))\n\n\n\n\n\n","category":"function"},{"location":"rootdata/#Chevie.Rootdata.weightinfo","page":"Reductive algebraic groups and root data","title":"Chevie.Rootdata.weightinfo","text":"weightinfo(W)\n\nW  is a  Coxeter group  record describing  an algebraic  group ğ†, or a IypeIrred. The function is independent of the isogeny type of ğ†(so just depends  on refltype(W), that is  on the root system).  It returns a dict with the following keys:\n\n:minusculeWeights the minuscule weights, described as their position  in  the  list  of  fundamental  weights.  For non-irreducible groups, a weight  is the sum of at most one weight in each irreducible component. It  is represented as  the list of  its components. For consistency, in the  case  of  an  irreducible  system,  a  weight  is represented as a one-element list.\n:minusculeCoweights the minuscule coweights, represented in the same manner as the minuscule weights\n:decompositions for each coweight, its decomposition in terms of the generators  of the adjoint fundamental group  (given by the list of the exponents  of the generators). Together with  the next field it enables to work out the group structure of the adjoint fundamental group.\n:moduli the list of orders of the generators of the fundamental group.\n:AdjointFundamentalGroup the list of generators of the adjoint fundamental group, given as permutations of the extended root basis.\n:CenterSimplyConnected A list of semisimple elements generating the center of the universal covering of  ğ†\n:chosenAdaptedBasis A basis  of the  weight lattice  adapted to the root lattice. In the basis of the fundamental weights, the root lattice is  given  by  C=transpose(cartan(W)).  The  property  specifying the :chosenAdaptedBasis is that the Hermite normal form of C*chosenAdaptedBasis  is almost in Smith  normal form (it is diagonal but  the diagonal entries may be  permuted compared to the Smith normal form; the non-trivial entries are in the positions corresponding to the generators of the fundamental group as indicated by :decompositions).\n\njulia> weightinfo(coxgroup(:A,2)*coxgroup(:B,2))\nDict{Symbol, Array} with 8 entries:\n  :moduli                  => [3, 2]\n  :minusculeWeights        => [[1, 3], [1], [2, 3], [2], [3]]\n  :decompositions          => [[2, 1], [2, 0], [1, 1], [1, 0], [0, 1]]\n  :highestroot             => [5, 7]\n  :chosenAdaptedBasis      => [1 -1 0 0; 0 1 0 0; 0 0 1 0; 0 0 0 1]\n  :minusculeCoweights      => [[1, 4], [1], [2, 4], [2], [4]]\n  :CenterSimplyConnected   => Vector{Rational{Int64}}[[1//3, 2//3, 0, 0], [0, 0â€¦\n  :AdjointFundamentalGroup => [(1,12,2), (4,14)]\n\n\n\n\n\n","category":"function"},{"location":"rootdata/#Chevie.Rootdata.weights","page":"Reductive algebraic groups and root data","title":"Chevie.Rootdata.weights","text":"weights(W) fundamental weights in the basis of X(T)\n\n\n\n\n\n","category":"function"},{"location":"rootdata/#Chevie.Rootdata.coweights","page":"Reductive algebraic groups and root data","title":"Chevie.Rootdata.coweights","text":"coweights(W) fundamental coweights in the basis of Y(T)\n\n\n\n\n\n","category":"function"},{"location":"kl/#Kazhdan-Lusztig-polynomials-and-bases","page":"Kazhdan-Lusztig polynomials and bases","title":"Kazhdan-Lusztig polynomials and bases","text":"Pages=[\"kl.md\"]","category":"section"},{"location":"kl/#Chevie.KL","page":"Kazhdan-Lusztig polynomials and bases","title":"Chevie.KL","text":"This  module defines Kazhdan-Lusztig polynomials and bases, and computes W-graphs and asymptotic algebras.\n\nLet  H be  the Iwahori-Hecke algebra  of a Coxeter  system (W,S), with quadratic  relations (Tâ‚›-uâ‚›â‚€)(Tâ‚›-uâ‚›â‚)=0  for sâˆˆ  S. If  -uâ‚›â‚€uâ‚›â‚ has a square  root  wâ‚›,  we  can  scale  the  basis  Tâ‚›  to  get  a new basis tâ‚›=-Tâ‚›/wâ‚›    with   quadratic    relations   (tâ‚›-vâ‚›)(tâ‚›+vâ‚›â»Â¹)=0   where vâ‚›=wâ‚›/uâ‚›â‚.   The  most  general  case   when  Kazhdan-Lusztig  bases  and polynomials  can be defined is when the parameters vâ‚› belong to a totally ordered  abelian group Î“  for multiplication, see  (Lusztig, 1983). We set Î“âº= {Î³âˆˆ Î“âˆ£Î³>1} and Î“â»={Î³â»Â¹âˆ£Î³âˆˆ Î“âº}={Î³âˆˆ Î“âˆ£Î³<1}.\n\nThus  we assume H defined over the ring â„¤[Î“], the group algebra of Î“ over  â„¤, and the quadratic  relations of H  associate to each sâˆˆ S a vâ‚›âˆˆ  Î“âº such that  (tâ‚›-vâ‚›)(tâ‚›+vâ‚›â»Â¹)=0. We also  set qâ‚›=vâ‚›Â² and define the  basis Tâ‚›=vâ‚›tâ‚› with quadratic relations (Tâ‚›-qâ‚›)(Tâ‚›+1)=0; for wâˆˆ W with reduced expression w=sâ‚â€¦sâ‚™ we define q_w Î“ by q_w^Â½=v_sâ‚v_sâ‚™ and let q_w=(q_w^Â½)Â²; we have T_w=q_w^Â½t_w.\n\nWe  define the bar involution on H  by linearity: on â„¤[Î“] we define it by  overline_Î³ Î“a_Î³Î³= _Î³ Î“ a_Î³ Î³Â¹ and we extend it to H by  overline T_s=T_s^-1 (equivalently overline t_s=t_s^-1). Then the Kazhdan-Lusztig basis C^_w is defined as the only basis of â„‹  stable by  the bar  involution and  congruent to  t_w modulo _w WÎ“t_w.\n\nThe  basis  C^_w  can  be  computed  as  follows.  We  define  elements R_xy  of â„¤[Î“] by  T_yÂ¹=_x overlineR_xyÂ¹ q_xÂ¹T_x. We then  define inductively  the Kazhdan-Lusztig  polynomials (in this general context  we should say the Kazhdan-Lusztig elements of â„¤[Î“], which belong to the subalgebra of â„¤[Î“] generated by the qâ‚›) by P_xw=Ï„_(q_wq_x)^Â½  (_xywR_xyP_yw)  where  Ï„  is the truncation:  Ï„_nu _Î³  Î“ a_Î³Î³=  _Î³nua_Î³Î³; the  induction is thus on decreasing x for the Bruhat order and starts at P_ww=1. We have then C^_w=_y q_w^-12 P_ywT_y.\n\nThe  Chevie code  for the  Kazhdan-Lusztig bases  C, D, C', D', was originally  written by Andrew  Mathas around 1994,  who also contributed to the  design of bases  of Iwahori-Hecke algebras  and implemented some other bases,  such as the Murphy basis. Our code evolved from that code. The code for  the case of unequal parameters was  written around 1999 by F.Digne and J.Michel.  The Kazhdan-Lusztig  bases are  computed starting  from the Câ€² basis.\n\nWhen  â„¤[Î“] is a Laurent  polynomial ring the bar  operation is taking the inverse of the variables, and truncation is keeping terms of degree smaller or equal to that of Î½. It is possible to use arbitrary groups Î“ as long as  methods  bar:_Î³  Î“  a_Î³Î³  _Î³ Î“ a_Î³Î³Â¹, positive_part : _Î³  Î“ a_Î³Î³  _Î³ 1  a_Î³Î³ and  negative_part: _Î³ Î“ a_Î³Î³  _Î³  1 a_Î³Î³  have been  defined on  â„¤[Î“]. These  operations are used internally by the programs which compute Kazhdan-Lusztig bases.\n\nWe provide also functionality to compute the Kazhdan-Lusztig left cells (for the equal-parameter Hecke algebra).\n\njulia> W=coxgroup(:H,3)\nHâ‚ƒ\n\njulia> c=left_cells(W)\n22-element Vector{LeftCell{FiniteCoxeterGroup{Perm{Int16},Cyc{Int64}}}}:\n LeftCell<Hâ‚ƒ: duflo= character=Ï†â‚â€šâ‚€>\n LeftCell<Hâ‚ƒ: duflo=123 character=Ï†â‚â€šâ‚â‚…>\n LeftCell<Hâ‚ƒ: duflo=(15) character=Ï†â‚…â€šâ‚…>\n LeftCell<Hâ‚ƒ: duflo=(10) character=Ï†â‚…â€šâ‚…>\n LeftCell<Hâ‚ƒ: duflo=(14) character=Ï†â‚…â€šâ‚…>\n LeftCell<Hâ‚ƒ: duflo=7 character=Ï†â‚…â€šâ‚…>\n LeftCell<Hâ‚ƒ: duflo=(12) character=Ï†â‚…â€šâ‚…>\n LeftCell<Hâ‚ƒ: duflo=(9,12) character=Ï†â‚…â€šâ‚‚>\n LeftCell<Hâ‚ƒ: duflo=(5,11) character=Ï†â‚…â€šâ‚‚>\n LeftCell<Hâ‚ƒ: duflo=13 character=Ï†â‚…â€šâ‚‚>\n â‹®\n LeftCell<Hâ‚ƒ: duflo=(8,13) character=Ï†â‚ƒâ€šâ‚†+Ï†â‚ƒâ€šâ‚ˆ>\n LeftCell<Hâ‚ƒ: duflo=(1,15) character=Ï†â‚ƒâ€šâ‚†+Ï†â‚ƒâ€šâ‚ˆ>\n LeftCell<Hâ‚ƒ: duflo=3 character=Ï†â‚ƒâ€šâ‚+Ï†â‚ƒâ€šâ‚ƒ>\n LeftCell<Hâ‚ƒ: duflo=2 character=Ï†â‚ƒâ€šâ‚+Ï†â‚ƒâ€šâ‚ƒ>\n LeftCell<Hâ‚ƒ: duflo=1 character=Ï†â‚ƒâ€šâ‚+Ï†â‚ƒâ€šâ‚ƒ>\n LeftCell<Hâ‚ƒ: duflo=6 character=Ï†â‚„â€šâ‚ƒ+Ï†â‚„â€šâ‚„>\n LeftCell<Hâ‚ƒ: duflo=(13) character=Ï†â‚„â€šâ‚ƒ+Ï†â‚„â€šâ‚„>\n LeftCell<Hâ‚ƒ: duflo=(11) character=Ï†â‚„â€šâ‚ƒ+Ï†â‚„â€šâ‚„>\n LeftCell<Hâ‚ƒ: duflo=9 character=Ï†â‚„â€šâ‚ƒ+Ï†â‚„â€šâ‚„>\n\nsee  also the  functions elements,  character, representation and  Wgraph for left cells.  The operations length, in (which refer  to elements) and == (which  compares Duflo involutions) are also defined  for left cells. When character(c)  has been computed, then c.a also  has been bound which holds the common value of Lusztig's a-function for the elements of c and the irreducible constituents of character(c).\n\nfinally, benchmarks\n\njulia> function test_kl(W)\n         q=Pol(); H=hecke(W,q^2,rootpara=q)\n         C=Cpbasis(H); T=Tbasis(H)\n         [T(C(w)) for w in elements(W)]\n       end\ntest_kl (generic function with 1 method)\n\njulia> @btime test_kl(coxgroup(:F,4));  #julia 1.8\n1.332 s (13934392 allocations: 2.27 GiB)\n\nin GAP3 the following function takes 11s for W=F4\n\ntest_kl:=function(W)local q,H,T,C;\n  q:=X(Rationals);H:=Hecke(W,q^2,q);\n  T:=Basis(H,\"T\");C:=Basis(H,\"C'\");\n  List(Elements(W),e->T(C(e)));\nend;\n\nAnother benchmark:\n\nfunction test_kl2(W)\n  el=elements(W)\n  [KLPol(W,x,y) for x in el, y in el]\nend\n\ntest_kl2 (generic function with 1 method)\n\njulia>@btime test_kl2(coxgroup(:F,4)); # julia 1.9\n4.307 s (42294917 allocations: 5.24 GiB)\n\nin GAP3 the following function takes 42s for F4\n\ntest_kl2:=function(W)local el;\n  el:=Elements(W);\n  List(el,x->List(el,y->KazhdanLusztigPolynomial(W,x,y)));\nend;\n\n\n\n\n\n","category":"module"},{"location":"kl/#Chevie.KL.KLPol","page":"Kazhdan-Lusztig polynomials and bases","title":"Chevie.KL.KLPol","text":"KLPol(W,y,w) returns the Kazhdan-Lusztig polynomial P_{y,w} of W.\n\nTo  compute Kazhdan-Lusztig polynomials in  the one-parameter case it still seems   best  to   use  the   recursion  formula   in  the  original  paper (Kazhdan and Lusztig, 1979).  We first perform a series of  checks on the pair (y,w) to see  if the computation of the corresponding polynomial can be reduced to a similar  calculation  for  elements  of  smaller  length. In particular, we reduce  to the case of critical pairs (see KL.critical_pair), and whenever the polynomial corresponding to such a pair is computed, the value is stored in a Dict W.klpol in the underlying Coxeter group.\n\njulia> W=coxgroup(:B,3)\nBâ‚ƒ\n\njulia> map(i->map(x->KLPol(W,one(W),x),elements(W,i)),1:nref(W))\n9-element Vector{Vector{Pol{Int64}}}:\n [1, 1, 1]\n [1, 1, 1, 1, 1]\n [1, 1, 1, 1, 1, 1, 1]\n [1, 1, 1, 1, 1, x+1, 1, 1]\n [x+1, 1, x+1, x+1, 1, 1, x+1, 1]\n [xÂ²+1, 1, x+1, x+1, x+1, 1, 1]\n [1, 1, xÂ²+x+1, x+1, x+1]\n [1, x+1, xÂ²+1]\n [1]\n\nOur code is based on Meinolf Geck's code for GAP3/Chevie.\n\n\n\n\n\n","category":"function"},{"location":"kl/#Chevie.KL.critical_pair","page":"Kazhdan-Lusztig polynomials and bases","title":"Chevie.KL.critical_pair","text":"critical_pair(W, y, w) returns the critical pair zâ‰¤w associated to yâ‰¤w, see (Alvis, 1987).\n\nLet  â„’ (resp.  â„›)  be the  left (resp.  right) descent  set. A pair of elements yâ‰¤w of W is called critical if â„’(y)âŠƒ â„’(w) and â„› (y)âŠƒ â„› (w). If yâ‰¤w is not critical, y can be multiplied from the left (resp. the right) by an  element of  â„’(w) (resp.  â„› (w))  which is  not in â„’ (y) (resp. â„› (y)) until we get a critical pair zâ‰¤w. The function returns z. If yâ‰¤w then yâ‰¤zâ‰¤w.\n\nThe significance of this construction is that KLPol(W,y,w)==KLPol(W,z,w)\n\njulia> W=coxgroup(:F,4)\nFâ‚„\n\njulia> w=longest(W)*gens(W)[1];length(W,w)\n23\n\njulia> y=W(1:4...);length(W,y)\n4\n\njulia> cr=KL.critical_pair(W,y,w);length(W,cr)\n16\n\njulia> Pol(:x);KLPol(W,y,w)\nPol{Int64}: xÂ³+1\n\njulia> KLPol(W,cr,w)\nPol{Int64}: xÂ³+1\n\n\n\n\n\n","category":"function"},{"location":"kl/#Chevie.HeckeAlgebras.Tbasis-Tuple{Chevie.KL.HeckeCpElt}","page":"Kazhdan-Lusztig polynomials and bases","title":"Chevie.HeckeAlgebras.Tbasis","text":"Tbasis(h::HeckeCpElt) \n\nconverts the element h of the C' basis to the T basis.\n\nFor one-parameter Hecke algebras, we use the formulae: C_w=Î£_ywP_yw(q)q^-l(w)2T_y and if sww then\n\nCâ‚› C_sw=C_w+Î£_yswÎ¼(ysw)C_y=Î£_vwÎ¼áµ¥ Táµ¥\n\nwhere\n\nÎ¼áµ¥=P_vw(q)q^-l(w)2+Î£_vyswÎ¼(ysw)P_vy(q)q^-l(y)2\n\nIt  follows that if deg(Î¼áµ¥)=-l(v)  then deg(Î¼áµ¥)=-l(v) with leading coefficient  Î¼(vsw) (this happens exactly for y=v in the sum which occurs in the formula for Î¼áµ¥).\n\njulia> W=coxgroup(:B,3)\nBâ‚ƒ\n\njulia> @Pol v;H=hecke(W,v^2,rootpara=v)\nhecke(Bâ‚ƒ,vÂ²,rootpara=v)\n\njulia> C=Cpbasis(H); Tbasis(C(1,2))\nvâ»Â²T.+vâ»Â²Tâ‚‚+vâ»Â²Tâ‚+vâ»Â²Tâ‚â‚‚\n\nFor general Hecke algebras, we follow (Lusztig, 1983; formula 2.2)\n\noverlineP_xw-P_xw=_xyw R_xy P_yw\n\nwhere  R_xy=overline(t_y^-1^-1t_x) where t is the basis with  parameters  q_s-q_s^-1.  It  follows  that  P_xw is the negative  part of _xyw R_xy P_yw  which allows to compute it by  induction on l(w)-l(x). The code is based on GAP3/Chevie code of Jean Michel and FranÃ§ois Digne (1999).\n\n\n\n\n\n","category":"method"},{"location":"kl/#Chevie.KL.Cbasis","page":"Kazhdan-Lusztig polynomials and bases","title":"Chevie.KL.Cbasis","text":"Cbasis(H::HeckeAlgebra)\n\nreturns  a function which gives the  C-basis of the Iwahori-Hecke algebra H.  The algebra H should have all entries of H.rootpara defined after calling   rootpara(H).  This  basis  is  defined  as  follows, see  e.g. (Lusztig, 1985; (5.1)).  Let W be the underlying Coxeter group. For x,y âˆˆ W  let P_xy  be the  corresponding Kazhdanâ€“Lusztig  polynomial. If T_w   w  W denotes  the usual  T-basis, then C_x=sum_yle x(-1)^l(x)-l(y)P_yx(q^-1)q_x^12q_y^-1  T_y for x  âˆˆ W. For example,  we have Câ‚›=qâ‚›â»Â½Tâ‚›-qâ‚›Â½Tâ‚  for s âˆˆ  S. Thus, the transformation matrix between the T-basis and the C-basis is lower unitriangular, with monomials  in qâ‚› along the diagonal.  In the one-parameter case (all qâ‚› are equal to vÂ²) the multiplication rules for the C basis are given by:\n\nCâ‚›â‹…Câ‚“ =-(v+vâ»Â¹)Câ‚“, if sx<x, and Câ‚›â‚“+âˆ‘â‚œ Î¼(t,x)Câ‚œ if sx>x.\n\nwhere  the sum  is over  all t  such that  t<x, l(t)  and l(x) have different parity and st<t. The coefficient Î¼(t,x) is the coefficient of degree (l(x)-l(t)-1)/2 in the Kazhdanâ€“Lusztig polynomial P_xt.\n\nThe  returned function can take as argument a list of integers (as a vector or  as a list of arguments), representing a Coxeter word, an element of the Coxeter group, or a Hecke element (converted then to the C' basis).\n\njulia> W=coxgroup(:B,3);H=hecke(W,Pol(:v)^2)\nhecke(Bâ‚ƒ,vÂ²)\n\njulia> T=Tbasis(H);C=Cbasis(H);T(C(1))\n-vT.+vâ»Â¹Tâ‚\n\njulia> C(T(1))\nvÂ²C.+vCâ‚\n\nWe  can  also  compute  character  values  on  elements in the C-basis as follows:\n\njulia> ref=reflrep(H)\n3-element Vector{Matrix{Pol{Int64}}}:\n [-1 0 0; -vÂ² vÂ² 0; 0 0 vÂ²]\n [vÂ² -2 0; 0 -1 0; 0 -vÂ² vÂ²]\n [vÂ² 0 0; 0 vÂ² -1; 0 0 -1]\n\njulia> c=CharTable(H).irr[charinfo(W).extRefl[[2]],:]\n1Ã—10 Matrix{Pol{Int64}}:\n 3  2vÂ²-1  vâ¸-2vâ´  -3vÂ¹Â²  2vÂ²-1  vâ´  vâ´-2vÂ²  -vâ¶  vâ´-vÂ²  0\n\njulia> hcat(char_values.(C.(classreps(W)),Ref(c))...)\n1Ã—10 Matrix{Pol{Int64}}:\n 3  -v-vâ»Â¹  0  0  -v-vâ»Â¹  2  0  0  1  0\n\n\n\n\n\n","category":"function"},{"location":"kl/#Chevie.KL.Cpbasis","page":"Kazhdan-Lusztig polynomials and bases","title":"Chevie.KL.Cpbasis","text":"Cpbasis(H)\n\nreturns  a function which gives the C'-basis of the Iwahori-Hecke algebra H,   see  (Lusztig, 1985; (5.1)).   This  basis   is  defined   by  C_x= _yxP_yxq_x^-12 T_y for x âˆˆ W. We have C_x=(-1)^l(x)alt(C_x)  for  all  x  âˆˆ  W (see alt). The returned function  can take as argument a list of integers (as a vector or as a list of  arguments),  representing  a  Coxeter  word,  an element of the Coxeter group, or a Hecke element (converted then to the C' basis).\n\njulia> W=coxgroup(:B,2);@Pol v;H=hecke(W,[v^4,v^2])\nhecke(Bâ‚‚,Pol{Int64}[vâ´, vÂ²])\n\njulia> Cp=Cpbasis(H);h=Cp(1)^2\n(vÂ²+vâ»Â²)Câ€²â‚\n\njulia> k=Tbasis(h)\n(1+vâ»â´)T.+(1+vâ»â´)Tâ‚\n\njulia> Cp(k)\n(vÂ²+vâ»Â²)Câ€²â‚\n\n\n\n\n\n","category":"function"},{"location":"kl/#Chevie.KL.character","page":"Kazhdan-Lusztig polynomials and bases","title":"Chevie.KL.character","text":"character(c)\n\nReturns  a list l  such that the  character of c.group  afforded by the left cell c is sum(CharTable(c.group).irr[l]).\n\njulia> c=left_cells(coxgroup(:G,2))[3]\nLeftCell<Gâ‚‚: duflo=2 character=Ï†â‚‚â€šâ‚+Ï†â€²â‚â€šâ‚ƒ+Ï†â‚‚â€šâ‚‚>\n\njulia> character(c)\n3-element Vector{Int64}:\n 3\n 5\n 6\n\n\n\n\n\n","category":"function"},{"location":"kl/#Chevie.Chars.representation-Tuple{LeftCell, Any}","page":"Kazhdan-Lusztig polynomials and bases","title":"Chevie.Chars.representation","text":"representation(c::LeftCell,H)\n\nreturns matrices giving the representation of the Iwahori-Hecke algebra H on the left cell c.\n\njulia> W=coxgroup(:H,3)\nHâ‚ƒ\n\njulia> c=left_cells(W)[3]\nLeftCell<Hâ‚ƒ: duflo=(15) character=Ï†â‚…â€šâ‚…>\n\njulia> @Mvp q;H=hecke(W,q)\nhecke(Hâ‚ƒ,q)\n\njulia> representation(c,H)\n3-element Vector{Matrix{Mvp{Int64, Rational{Int64}}}}:\n [-1 0 â€¦ 0 0; 0 -1 â€¦ 0 -qÂ½; â€¦ ; 0 0 â€¦ q 0; 0 0 â€¦ 0 q]\n [-1 -qÂ½ â€¦ 0 0; 0 q â€¦ 0 0; â€¦ ; 0 0 â€¦ -1 0; 0 -qÂ½ â€¦ 0 -1]\n [q 0 â€¦ 0 0; -qÂ½ -1 â€¦ 0 0; â€¦ ; 0 0 â€¦ q 0; 0 0 â€¦ 0 -1]\n\n\n\n\n\n","category":"method"},{"location":"kl/#Chevie.Chars.WGraphToRepresentation","page":"Kazhdan-Lusztig polynomials and bases","title":"Chevie.Chars.WGraphToRepresentation","text":"WGraphToRepresentation(coxrank::Integer,graph,v)\n\nWe  store some  representations of  one-parameter Iwahori-Hecke algebras as W-graphs.  For a Coxeter system (W,S), a  W-graph is defined by a set of  vertices C  with a  function I  which attaches  to xâˆˆ  C a subset I(x)âŠ‚ S, and edge labels which to (x,y)âˆˆ C^2 attach Î¼(x,y)âˆˆ K where K is the field of definition of W; this defines a representation of the Hecke  algebra  with  parameters  v  and  -vâ»Â¹  on  a  space with basis e_y_y C by:\n\nTâ‚›(e_y)=-e_y if sâˆˆ I(y) and otherwise Tâ‚›(e_y)=v^2 e_y+_xs I(x) vÎ¼(xy)eâ‚“.\n\nThe  W-graphs are  stored in  a compact  format to  save space.  They are represented as a pair.\n\nThe  first element is a list describing C. Its  elements are either a vector   I(x)  of  indices  in  eachindex(S),  or  an  integer  n specifying to repeat the previous element n more times.\nThe  second element is a list which  specifies Î¼.\n\nWe   first   describe   the   Î¼-list   for   symmetric  W-graphs  (when Î¼(x,y)=Î¼(y,x)).  There is one  element of the  Î¼-list for each non-zero value m taken by Î¼, which consists of a pair whose first element is m and  whose second element is a list of  lists; if l is one of these lists each  pair [l[1],l[i]]  represents an  edge (x=l[1],y=l[i]) such that Î¼(x,y)=Î¼(y,x)=m.  For non-symmetric W-graphs, the first element of each pair  in the Î¼-list  is a pair  [m1,m2] and each  edge [x,y] obtained from  the lists in the second element  has to be interpreted as Î¼(x,y)=m1 and Î¼(y,x)=m2.\n\njulia> W=coxgroup(:H,3)\nHâ‚ƒ\n\njulia> g=Wgraph(W,3)\n2-element Vector{Vector{Vector{Any}}}:\n [[2], [1, 2], [1, 3], [1, 3], [2, 3]]\n [[-1, [[1, 3], [2, 4], [3, 5], [4, 5]]]]\n\njulia> WGraphToRepresentation(3,g,Pol(:x))\n3-element Vector{Matrix{Pol{Int64}}}:\n [xÂ² 0 â€¦ 0 0; 0 -1 â€¦ 0 0; â€¦ ; 0 0 â€¦ -1 -x; 0 0 â€¦ 0 xÂ²]\n [-1 0 â€¦ 0 0; 0 -1 â€¦ -x 0; â€¦ ; 0 0 â€¦ xÂ² 0; 0 0 â€¦ -x -1]\n [xÂ² 0 â€¦ 0 0; 0 xÂ² â€¦ 0 0; â€¦ ; 0 -x â€¦ -1 0; 0 0 â€¦ 0 -1]\n\n\n\n\n\nWGraphToRepresentation(H::HeckeAlgebra,gr::Vector)\n\nH  should be a  one-parameter Iwahori-Hecke algebra  for a finite Coxeter group where rootpara is defined. The function returns the matrices of the representation of H defined by the W-graph gr.\n\njulia> W=coxgroup(:H,3)\nHâ‚ƒ\n\njulia> H=hecke(W,Pol(:q)^2)\nhecke(Hâ‚ƒ,qÂ²)\n\njulia> g=Wgraph(W,3)\n2-element Vector{Vector{Vector{Any}}}:\n [[2], [1, 2], [1, 3], [1, 3], [2, 3]]\n [[-1, [[1, 3], [2, 4], [3, 5], [4, 5]]]]\n\njulia> WGraphToRepresentation(H,g)\n3-element Vector{Matrix{Pol{Int64}}}:\n [qÂ² 0 â€¦ 0 0; 0 -1 â€¦ 0 0; â€¦ ; 0 0 â€¦ -1 q; 0 0 â€¦ 0 qÂ²]\n [-1 0 â€¦ 0 0; 0 -1 â€¦ q 0; â€¦ ; 0 0 â€¦ qÂ² 0; 0 0 â€¦ q -1]\n [qÂ² 0 â€¦ 0 0; 0 qÂ² â€¦ 0 0; â€¦ ; 0 q â€¦ -1 0; 0 0 â€¦ 0 -1]\n\n\n\n\n\n","category":"function"},{"location":"kl/#Chevie.KL.Wgraph","page":"Kazhdan-Lusztig polynomials and bases","title":"Chevie.KL.Wgraph","text":"Wgraph(c::LeftCell)\n\nreturn the W-graph for a left cell for the one-parameter Hecke algebra of a finite Coxeter group. \n\n\n\n\n\nWgraph(W::CoxeterGroup,i)\n\nreturn the W-graph for the i-th irreducible representation of W (or of the 1-parameter Hecke algebra of W).\n\nOnly implemented for irreducible groups of type E, F or H.\n\n\n\n\n\n","category":"function"},{"location":"kl/#Chevie.KL.left_cells","page":"Kazhdan-Lusztig polynomials and bases","title":"Chevie.KL.left_cells","text":"left_cells(W[,i]) left cells of W [in i-th 2-sided cell] for the 1-parameter Hecke algebra hecke(W,q)\n\nThe  program uses precomputed data  (Geck and Halls, 2015) for exceptional types and for  type :A, so  is quite fast  for these types  (it takes 13 seconds to compute  the 101796 left cells for type  Eâ‚ˆ). For other types, left cells are  computed from  first principles,  thus computing  many Kazhdan-Lusztig polynomials.  It takes 30  seconds to compute  the left cells  of Dâ‚†, for example.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> left_cells(W)\n4-element Vector{LeftCell{FiniteCoxeterGroup{Perm{Int16},Int64}}}:\n LeftCell<Gâ‚‚: duflo= character=Ï†â‚â€šâ‚€>\n LeftCell<Gâ‚‚: duflo=12 character=Ï†â‚â€šâ‚†>\n LeftCell<Gâ‚‚: duflo=2 character=Ï†â‚‚â€šâ‚+Ï†â€²â‚â€šâ‚ƒ+Ï†â‚‚â€šâ‚‚>\n LeftCell<Gâ‚‚: duflo=1 character=Ï†â‚‚â€šâ‚+Ï†â€³â‚â€šâ‚ƒ+Ï†â‚‚â€šâ‚‚>\n\nPrinting such a record displays the character afforded by the left cell and its  Duflo involution; the Duflo involution r  is printed as a subset I of   1:nref(W)   such   that  r=longest(reflection_subgroup(W,I)),  see describe_involution.\n\nIf  a second argument i is given, the program returns only the left cells which  are in the i-th two-sided cell,  that is whose character is in the i-th family of W (see Families).\n\njulia> W=coxgroup(:G,2);\njulia> left_cells(W,1)\n2-element Vector{LeftCell{FiniteCoxeterGroup{Perm{Int16},Int64}}}:\n LeftCell<Gâ‚‚: duflo=2 character=Ï†â‚‚â€šâ‚+Ï†â€²â‚â€šâ‚ƒ+Ï†â‚‚â€šâ‚‚>\n LeftCell<Gâ‚‚: duflo=1 character=Ï†â‚‚â€šâ‚+Ï†â€³â‚â€šâ‚ƒ+Ï†â‚‚â€šâ‚‚>\n\n\n\n\n\n","category":"function"},{"location":"kl/#Chevie.KL.LeftCell","page":"Kazhdan-Lusztig polynomials and bases","title":"Chevie.KL.LeftCell","text":"LeftCell(W,w)\n\nreturns  a  record  describing  the  left  cell  of  W  for  hecke(W,q) containing element w.\n\njulia> W=coxgroup(:E,8)\nEâ‚ˆ\n\njulia> LeftCell(W,W((1:8)...))\nLeftCell<Eâ‚ˆ: duflo=(42,43) character=Ï†â‚ƒâ‚…â€šâ‚‚>\n\n\n\n\n\n","category":"type"},{"location":"kl/#Chevie.KL.Lusztigaw","page":"Kazhdan-Lusztig polynomials and bases","title":"Chevie.KL.Lusztigaw","text":"Lusztigaw(W,w)\n\nFor  w an element  of the Coxeter  groups W, this  function returns the coefficients  on the irreducible characters of the virtual Character ca_w defined in (Lusztig, 1985; 5.10.2). This character has the property that the corresponding almost character is integral and positive.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> l=Lusztigaw(W,W(1))\n6-element Vector{Int64}:\n 0\n 0\n 1\n 0\n 1\n 1\n\njulia> sum(l.*map(i->almostchar(W,i),eachindex(l)))\n[Gâ‚‚]:<Ï†â€²â‚â€šâ‚ƒ>+<Ï†â‚‚â€šâ‚>+<Ï†â‚‚â€šâ‚‚>\n\n\n\n\n\n","category":"function"},{"location":"kl/#Chevie.KL.LusztigAw","page":"Kazhdan-Lusztig polynomials and bases","title":"Chevie.KL.LusztigAw","text":"LusztigAw(W,w)\n\nFor  w an  element of  the Coxeter  group W,  this function returns the coefficients on the irreducible characters of the virtual character A_w defined  in (Lusztig, 1985; 5.11.6). This character has the property that the corresponding almost character is integral and positive.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> l=LusztigAw(W,W(1))\n6-element Vector{Int64}:\n 0\n 0\n 0\n 1\n 1\n 1\n\njulia> sum(l.*map(i->almostchar(W,i),eachindex(l)))\n[Gâ‚‚]:<Ï†â€³â‚â€šâ‚ƒ>+<Ï†â‚‚â€šâ‚>+<Ï†â‚‚â€šâ‚‚>\n\n\n\n\n\n","category":"function"},{"location":"kl/#Chevie.KL.AsymptoticAlgebra","page":"Kazhdan-Lusztig polynomials and bases","title":"Chevie.KL.AsymptoticAlgebra","text":"AsymptoticAlgebra(W,i)\n\nThe  asymptotic algebra A associated to  the algebra H=Hecke(W,q) is an algebra   with   basis   tâ‚“_x   W   and   structure  constants t_xt_y=sum_z  Î³_xyz  t_z  given  by:  let  h_xyz  be  the coefficient  of  C_x  C_y  on  C_z. Then h_xyz=Î³_xyz^-1 q^a(z)2+lower terms, where q^a(z)2 is the maximum over x,y of the degree of h_xyz.\n\nThe  algebra A  is the  direct product  of the subalgebras A_mathcal C  generated  by  the  elements  t_x_xmathcal  C, where mathcal C runs over the two-sided cells of W. If mathcal C is the  i-th  two-sided  cell  of  W, the command AsymptoticAlgebra(W,i) returns  the algebra A_mathcal C. Note  that the function a(z) is constant  over  a  two-sided  cell,  equal  to  the  common value of the a-function   attached  to  the  characters   of  the  two-sided  cell  (see Character for left cells).\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> A=AsymptoticAlgebra(W,1)\nAsymptoticAlgebra(Gâ‚‚,1) dim.10\n\njulia> b=basis(A)\n10-element Vector{AlgebraElt{AsymptoticAlgebra, Int64}}:\n tâ‚‚\n tâ‚â‚‚\n tâ‚‚â‚â‚‚\n tâ‚â‚‚â‚â‚‚\n tâ‚‚â‚â‚‚â‚â‚‚\n tâ‚\n tâ‚‚â‚\n tâ‚â‚‚â‚\n tâ‚‚â‚â‚‚â‚\n tâ‚â‚‚â‚â‚‚â‚\n\njulia> b*permutedims(b)\n10Ã—10 Matrix{AlgebraElt{AsymptoticAlgebra, Int64}}:\n tâ‚‚      0            tâ‚‚â‚â‚‚            â€¦  0               tâ‚‚â‚â‚‚â‚        0\n tâ‚â‚‚     0            tâ‚â‚‚+tâ‚â‚‚â‚â‚‚          0               tâ‚â‚‚â‚+tâ‚â‚‚â‚â‚‚â‚  0\n tâ‚‚â‚â‚‚    0            tâ‚‚+tâ‚‚â‚â‚‚+tâ‚‚â‚â‚‚â‚â‚‚     0               tâ‚‚â‚+tâ‚‚â‚â‚‚â‚    0\n tâ‚â‚‚â‚â‚‚   0            tâ‚â‚‚+tâ‚â‚‚â‚â‚‚          0               tâ‚+tâ‚â‚‚â‚      0\n tâ‚‚â‚â‚‚â‚â‚‚  0            tâ‚‚â‚â‚‚               0               tâ‚‚â‚          0\n 0       tâ‚â‚‚          0               â€¦  tâ‚â‚‚â‚            0            tâ‚â‚‚â‚â‚‚â‚\n 0       tâ‚‚+tâ‚‚â‚â‚‚      0                  tâ‚‚â‚+tâ‚‚â‚â‚‚â‚       0            tâ‚‚â‚â‚‚â‚\n 0       tâ‚â‚‚+tâ‚â‚‚â‚â‚‚    0                  tâ‚+tâ‚â‚‚â‚+tâ‚â‚‚â‚â‚‚â‚  0            tâ‚â‚‚â‚\n 0       tâ‚‚â‚â‚‚+tâ‚‚â‚â‚‚â‚â‚‚  0                  tâ‚‚â‚+tâ‚‚â‚â‚‚â‚       0            tâ‚‚â‚\n 0       tâ‚â‚‚â‚â‚‚        0                  tâ‚â‚‚â‚            0            tâ‚\n\njulia> CharTable(A)\nCharTable(AsymptoticAlgebra(Gâ‚‚,1) dim.10)\nâ”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚     â”‚2 12 212 1212 21212 1 21 121 2121 12121â”‚\nâ”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚Ï†â€²â‚â€šâ‚ƒâ”‚.  .   .    .     . 1  .  -1    .     1â”‚\nâ”‚Ï†â‚‚â€šâ‚ â”‚1  .   2    .     1 1  .   2    .     1â”‚\nâ”‚Ï†â‚‚â€šâ‚‚ â”‚1  .   .    .    -1 1  .   .    .    -1â”‚\nâ”‚Ï†â€³â‚â€šâ‚ƒâ”‚1  .  -1    .     1 .  .   .    .     .â”‚\nâ””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n\n\n\n\n","category":"type"},{"location":"dict/#Dictionary-from-GAP3/Chevie","page":"Dictionary from GAP3/Chevie","title":"Dictionary from GAP3/Chevie","text":"on the left a Chevie/Gap3 expression and on the right the Chevie/Julia translation\n\nAbelianGenerators                           abelian_gens\nAbelianInvariants                           abelian_invariants\nAdd                                         push!\nAffine                                      affine\nAlgebraicCentre                             algebraic_center\nAlmostCharacter                             almost_character or almostchar\nAppend                                      append!\nApplyFunc(f,l)                              f(l...)\nArrangements                                arrangements\nAsFraction                                  fraction\nAsReflection                                reflection\nAsRootOfUnity                               Root1\nAssociatedPartition                         conjugate_partition\nAsWord                                      word\nAsymptoticAlgebra                           AsymptoticAlgebra\nBadPrimes                                   badprimes\nBaseIntMat                                  baseInt\nBasis                                       basis\nBetaSet                                     Î²set\nBigCellDecomposition                        bigcell_decomposition\nBinomial                                    binomial\nBipartiteDecomposition                      bipartite_decomposition\nBlocksMat                                   blocks\nBraid                                       BraidMonoid\nBraidMonoid                                 BraidMonoid\nBraidRelations                              braid_relations\nBrieskornNormalForm                         Brieskorn_normal_form\nBruhat                                      bruhatless\nBruhatPoset                                 bruhatPoset\nBruhatSmaller                               bruhatless\nCartanMat(\"A\",5)                            cartan(:A,5)\nCartanMatFromCoxeterMatrix                  cartan\nCartanMatrix                                cartan\nCartesian                                   cartesian\nCartesianAt                                 lin2cart\nCatalan                                     catalan\nCentralIdempotents                          centralidempotents\nCentralizer                                 centralizer\nCentralizerGenerators                       centralizer_gens\nCharFFE                                     char\nCharNames                                   charnames\nCharParams(W)                               charinfo(W).charparams\nCharRepresentationWords                     traces_words_mats\nCharTable                                   CharTable\nCheckHeckeDefiningRelations                 isrepresentation\nChevieCharInfo                              charinfo\nChevieClassInfo                             classinfo\nClassName                                   see ClassNames\nClassTypes                                  ClassTypes\nCoefficient(p,i)                            p[i]\nCollectBy(l,f)                              collectby(f,l)\nCollected                                   tally\nCombinations                                combinations\nComm                                        comm or commutator\nComplementIntMat                            complementInt\nComplexConjugate                            conj\nComplexReflectionGroup                      complex_reflection_group or crg\nCompositions                                compositions\nConcatenation(s::Vector)                    vcat(s...)\nConcatenationString(s...)                   prod(s)\nConjugacyClasses                            conjugacy_classes\nConjugacySet(b[,F][,type])                  conjcat(b[,F],ss=type).obj\nConjugatePartition                          conjugate_partition\nCopy                                        deepcopy\nCoxeterCoset                                spets\nCoxeterElements(W[,l])                      elements(W[,l])\nCoxeterGroup(\"A\",5)                         coxeter_group(:A,5) or coxgroup\nCoxeterGroupByCartanMatrix(C)               coxeter_group(C) or coxgroup\nCoxeterGroupByCoxeterMatrix(C)              coxeter_group(cartan(C)) or coxgroup\nCoxeterGroupHyperoctaedralGroup(n)          coxeter_hyperoctaedral_group(n) or coxhyp\nCoxeterGroupSymmetricGroup(n)               coxeter_symmetric_group(n) or coxsym\nCoxeterLength(W,w)                          length(W,w)\nCoxeterMatrix                               coxmat or coxeter_matrix\nCoxeterMatrixFromCartanMat                  coxmat or coxeter_matrix\nCoxeterNumber                               coxnum or coxeter_number\nCoxeterSubCoset                             subspets\nCoxeterWord(W,w)                            word(W,w)\nCoxeterWords(W[,l])                         word.(Ref(W),elements(W[,l]))\nCuspidalPairs                               cuspidal_data\nCuspidalUnipotentCharacters(W[,d])          cuspidal(UnipotentCharacters(W)[,d])\nCycle                                       orbit\nCyclePermInt                                orbit\nCycles                                      orbits\nCyclotomicModP(c,p)                         FFE{p}(c)\nCyclotomicPolynomial(R,i)                   cyclotomic_polynomial(i)\nCycPol                                      CycPol\nCycPolFakeDegreeSymbol                      fakedegree\nCycPolGenericDegreeSymbol                   gendeg\nCycPolUnipotentDegrees(W)                   CycPoldegrees(UnipotentCharacters(W))\nDecomposedMat                               diagblocks\nDefectSymbol                                defectsymbol\nDegree(p)                                   degree(p)\nDegreeFFE                                   degree\nDeligneLusztigCharacter                     deligne_lusztig_character or dlchar\nDeligneLusztigLefschetz                     deligne_lusztig_leftschetz or dlleftschetz\nDescribeInvolution                          describe_involution\nDetPerm(W)                                  perm(detPerm(W))\nDiaconisGraham                              diaconis_graham\nDiagonalMat                                 Diagonal or cat\nDiagonalOfMat                               diag\nDigits                                      digits\nDimension                                   dim or dimension\nDistinguishedParabolicSubgroups             distinguished_parabolics\nDominates                                   dominates\nDrinfeldDouble                              drinfeld_double\nDrop                                        deleteat!\nDualBraid                                   DualBraidMonoid\nDualBraidMonoid                             DualBraidMonoid\nEigenspaceProjector                         eigenspace_projector\nEigenvaluesMat                              eigmat\nElements                                    elements\nElementWithInversions(W,l)                  with_inversions(W,l)\nEltBraid                                    image\nEltWord(W,w)                                W(w...)\nER                                          root\nExteriorPower                               exterior_power\nFactorizedSchurElement                      FactorizedSchurElement\nFactorizedSchurElements                     FactorizedSchurElements\nFactors                                     factor\nFakeDegree                                  fakedegree\nFakeDegrees                                 fakedegrees\nFamiliesClassical                           FamiliesClassical\nFamily                                      Family\nFamilyImprimitive                           family_imprimitive\nFiltered(l,f)                               filter(f,l)\nFiniteCoxeterTypeFromCartanMat(m)           fincox_refltype(m)\nFirstLeftDescending(W,w)                    firstleftdescent(W,w)\nForAll(l::list,f::function)                 all(f,l)\nForAny(l::list,f::function)                 any(f,l)\nForEachCoxeterWord(W,f)                     for w in W f(word(W,w)) end\nForEachElement(W,f)                         for w in W f(w) end\nFormatGAP                                   repr\nFormatTable                                 showtable\nFrobenius                                   Frobenius\nFullSymbol                                  fullsymbol\nFundamentalGroup                            fundamental_group\nFusionAlgebra                               Zbasedring\nFusionConjugacyClasses                      fusion_conjugacy_classes\nGaloisCyc                                   galois\nGarsideAlpha                                Î±\nGarsideWords                                elements\nGcdPartitions                               gcd_partitions\nGcdRepresentation(x,y)                      gcdx(x,y)[2:3]\nGenericOrder                                generic_order\nGenericSign                                 generic_sign\nGetRoot                                     root\nGraphAutomorphisms                          graph_automorphisms\nHasse                                       hasse\nHecke                                       hecke\nHeckeCentralMonomials                       central_monomials\nHeckeCharValues                             char_values\nHeckeClassPolynomials                       class_polynomials\nHeckeReflectionRepresentation               reflection_representation or reflrep\nHermiteNormalFormIntegerMat                 hermite\nHermiteNormalFormIntegerMatTransforms(m)    hermite_transforms(m)\nHighestPowerFakeDegrees(W)                  charinfo(W).B\nHighestPowerFakeDegreeSymbol                degree_feg\nHighestPowerGenericDegrees(W)               charinfo(W).A\nHighestPowerGenericDegreeSymbol             degree_gendeg\nHighestShortRoot                            highest_short_root\nHyperplaneOrbits                            hyperplane_orbits\nICCTable                                    ICCTable\nIdempotents                                 idempotents\nIdentityMat(nn)                             Matrix(1I,n,n)\nIncidence                                   incidence\nIndependentLines                            independent_rows\nIndependentRoots                            independent_roots\nInducedLinearForm                           induced_linear_form\nInductionTable                              induction_table\nInherit                                     look at merge for hashes\nIntermediateGroup                           intermediate_group\nIntersection                                intersect\nIntFFE                                      Int\nIntListToString                             joindigits\nInvariantForm                               invariant_form\nInvariants                                  invariants\nInversions                                  inversions\nIsAbelian                                   isabelian\nIsAssociative                               isassociative\nIsCyclic                                    iscyclic\nIsCycPol(p)                                 p isa CycPol\nIsFamily(f)                                 f isa Family\nIsFFE(x)                                    x isa FFE\nIsIsolated                                  isisolated\nIsJoinLattice                               is_join_semilattice\nIsLeftDescending(W,w,i)                     isleftdescent(W,w,i)\nIsMeetLattice                               is_meet_semilattice\nIsomorphismType                             isomorphism_type\nIsParabolic                                 isparabolic\nIsSubset(a,b)                               issubset(b,a)\nIsUnipotentElement(x)                       x isa UnipotentElement\nJInductionTable                             J_induction_table\njInductionTable                             j_induction_table\nJoin                                        join\nKazhdanLusztigPolynomial                    KLPol\nKroneckerProduct                            kron\nLargestMovedPoint                           last_moved\nlast                                        ans\nLcmPartitions                               lcm_partitions\nLeadingCoefficient(p)                       p[end]\nLeftCell                                    LeftCell\nLeftCells                                   left_cells\nLeftDescentSet(W,w)                         leftdescents(W,w)\nLeftDivisorsSimple                          left_divisors\nLeftGcd                                     leftgcd\nLeftLcm                                     leftlcm\nLength(W.generators)                        ngens(W) or number_of_generators(W)\nLinearExtension                             linear_extension\nList(ConjugacyClasses(G),Representative)    classreps(G) or class_representatives(G)\nList(l::list,f::function)                   map(f,l)\nListBlist(a,b)                              a[b]\nListPerm(p)                                 perm(p)\nLoewyLength                                 loewylength\nLogFFE                                      log\nLongestCoxeterElement(W)                    longest(W)\nLongestCoxeterWord(W)                       word(W,longest(W))\nLowestPowerFakeDegrees(W)                   charinfo(W).b\nLowestPowerFakeDegreeSymbol                 valuation_feg\nLowestPowerGenericDegrees(W)                charinfo(W).a\nLowestPowerGenericDegreeSymbol              valuation_gendeg\nLusztigaw                                   Lusztigaw\nLusztigAw                                   LusztigAw\nLusztigInduction                            lusztig_induce\nLusztigInductionTable                       lusztig_induction_table\nLusztigRestriction                          lusztig_restrict\nM.LeftLcmSimples(x...)                      leftlcm(M,...)\nM.RightLcmSimples(x...)                     rightlcm(M,...)\nM.ToOrdinary(i)                             B(M,i)\nM::GarsideMonoid.delta                      M.Î´\nMappingPermListList                         mappingPerm\nMatStab                                     stab_onmats\nMatXPerm(W,p)                               reflection_representation(W,p) or reflrep\nMatYPerm                                    YMatrix\nMaximum                                     max or maximum\nMinimum                                     min or minimum\nMod1                                        modZ\nMovedPoints                                 support\nMvp(\"x\")                                    Mvp(:x)\nNrArrangements                              narrangements\nNrCombinations                              ncombinations\nNrConjugacyClasses                          nconjugacy_classes\nNrDrinfeldDouble                            ndrinfeld_double\nNrPartitions                                npartitions\nNrPartitionsSet                             npartitions\nNrPartitionTuples                           npartition_tuples\nNrRestrictedPartitions                      npartitions\nNullMat(m[,n])                              zeros(Int,m,m) resp. zeros(Int,m,n)\nNullspaceIntMat                             lnullspaceInt\nNumber(l,f)                                 count(f,l)\nOnFamily(f,p::Int)                          galois(f,p)\nOnFamily(f,p::Perm)                         f^p\nOnMatrices                                  onmats\nOnPolynomials(m,p)                          p^m\nOnSets                                      onsets\nOnTuples                                    ontuples\nOrderedPartitions                           compositions\nOrderFFE                                    order\nOrderMod(n,m)                               order(Mod{m}(n))\nParabolicClosure                            parabolic_closure\nParabolicRepresentatives                    parabolic_reps\nPartBeta                                    partÎ²\nPartition                                   partition\nPartitions                                  partitions\nPartitionsSet                               partitions\nPartitionTuples                             partition_tuples\nPartitionTupleToString                      string_partition_tuple\nPermCosetsSubgroup(H,W)                     D=vcat(reduced(H,W)...);map(s->Perm(reduced.(Ref(H),D.*s),D),gens(W))\nPermList(v)                                 Perm(v)\nPermListList(l1,l2)                         Perm(l1,l2)\nPermMatMat(m,n)                             Perm(m,n;dims=(1,2))\nPermMatX                                    PermX\nPermMatY                                    PermY\nPermutationMat(p,dim)                       Matrix(p,dim)\nPermutationOnCharacters                     on_chars\nPermutationOnClasses                        on_classes\nPermutationOnUnipotents                     on_unipotents\nPermuted(v,p)                               invpermute(v,p)\nPermutedByCols(m,p)                         invpermute(m,p;dims=2)\nPoset                                       Poset\nPosition(l,x)                               findfirst(==(x),l)\nPositionCartesian(a,b)                      cart2lin(a,b)=LinearIndices(reverse(Tuple(a)))[reverse(b)...]\nPositionClass                               position_class\nPositionDet                                 charinfo(W).positionDet\nPositionId                                  charinfo(W).positionId\nPositionProperty(l,f)                       findfirst(f,l)\nPositionRegularClass                        position_regular_class\nPositions(l,x)                              findall(==(x),l)\nPositionsProperty(l,f)                      findall(f,l)\nPowerRoot(x,y)                              (Root1(;r=x)^y).r\nPresentation                                Presentation\nPrintDiagram(W)                             diagram(W)\nPrintToString(s,...)                        s*=string(...)\nProduct                                     prod\nProportionalityCoefficient(v,w)             ratio(v,w)\nQuasiIsolatedRepresentatives                quasi_isolated_reps\nQuoInt                                      div\nRadical                                     radical\nRadicalPower                                radicalpower\nRank                                        rank\nRankSymbol                                  rank\nRecFields                                   propertynames\nReducedCoxeterWord(W,w)                     word(W,W(w...))\nReducedExpressions(W,w)                     words(W,w)\nReducedInRightCoset(W,w)                    reduced(W,w)\nReducedRightCosetRepresentatives(W,H)       reduced(H,W)\nReflection                                  refls(W,i) or reflectionMatrix(root,coroot)\nReflectionCharacter                         reflection_character or reflchar\nReflectionCharValue                         tr(reflrep(W,w))\nReflectionCoDegrees(W)                      codegrees(W)\nReflectionDegrees(W)                        degrees(W)\nReflectionEigenvalues                       refleigen\nReflectionGroup                             reflection_group\nReflectionLength(W,w)                       reflength(W,w)\nReflectionName(W)                           xrepr(W;limit=true)\nReflections                                 Perm.(reflections(W)[1:nhyp(W)])\nReflectionSubgroup                          reflection_subgroup\nReflectionType                              refltype\nRegularEigenvalues                          regular_eigenvalues\nRelativeDegrees                             relative_degrees\nRelativeGroup                               relative_group\nReplace                                     replace\nRepresentations                             representations\nRepresentativeConjugation(b,b'[,F][,type])  conjugating_elt(b,b'[,F],ss=type)\nRepresentativeDiagonalConjugation           diagconj_elt\nRepresentativeOperation                     transporting_elt or transporting_element\nRepresentativeRowColPermutation             Perm_rowcol\nRestricted                                  restricted\nRestrictedPartitions                        partitions\nRestrictedPerm(p,d)                         restricted(p,d)\nReversed                                    reverse\nReversedWord                                reverse\nRightDescentSet(W,w)                        rightdescents(W,w)\nRightGcd                                    rightgcd\nRightLcm                                    rightlcm\nRootDatum                                   rootdatum\nRootsCartan(m)                              roots(m)\nRotation(v,i)                               circshift(v,-i)\nRotations(v)                                circshift.(Ref(v),length(v):-1:1)\nScalarProduct                               Chars.scalarproduct\nScalMvp                                     scalar\nSchurElements                               schur_elements\nSchurFunctor                                schur_functor\nSemisimpleCentralizerRepresentatives        semisimple_centralizer_representatives or sscentralizer_reps\nSemisimpleElement                           ss\nSemisimpleRank                              semisimplerank\nSemisimpleSubgroup                          torsion_subgroup\nShallowCopy                                 copy\nShiftBeta                                   shiftÎ²\nShrinkGarsideGeneratingSet                  shrink\nSignedMatStab                               sstab_onmats\nSignedPerm                                  SPerm\nSignedPermListList                          SPerm\nSignedPermMatMat(M,N)                       SPerm(M,N;dims=(1,2))\nSize(W)                                     length(W)\nSmallestMovedPoint                          first_moved\nSmithNormalFormIntegerMat                   smith\nSmithNormalFormIntegerMatTransforms(m)      smith_transforms(m)\nSolutionIntMat                              solutionmatInt\nSolutionMat                                 solutionmat\nSort                                        sort!\nSortBy(l,f)                                 sort!(l,by=f)\nSortingPerm(a)                              inv(sortPerm(a))\nSortParallel(a,b)                           b=b[sortperm(a)];sort!(a)\nSpecialPieces                               special_pieces\nSpets                                       spets\nSplit                                       split\nSplitLevis                                  split_levis\nSprint                                      string\nStabilizer                                  stabilizer\nStandardParabolic                           standard_parabolic\nStandardParabolicClass                      standard_parabolic_class\nString                                      string\nString(s,-10)                               rpad(s,10)\nString(s,10)                                lpad(s,10)\nStructureRationalPointsConnectedCentre      structure_rational_points_connected_centre\nSubSpets                                    subspets\nSubTorus                                    SubTorus\nSum                                         sum\nSumIntersectionMat(m,n)                     (rowspace(vcat(m,n)),intersect_rowspace(m,n))\nSymbols                                     BDSymbols\nSymbolsDefect(e,r,def,ct)                   symbols(e,r,ct,def)\nSymmetricDifference                         symdiff\nSymmetricPower                              symmetric_power\nTableaux                                    tableaux\nTensored(c,d)                               vec([i.*j for i in c,j ind])\nTorus                                       torus\nTorusOrder                                  torus_order\nTraceMat                                    tr\nTransitiveClosure                           transitive_closure\nTransporter                                 transporter\nTransposedMat                               transpose or permutedims\nTransversals                                related to transversal and orbits\nTriangulizeMat                              echelon!\nTwistings                                   twistings\nTwoTree(m)                                  twotree(m)\nUnipotentAbelianPart                        abelianpart\nUnipotentCharacter                          unipotent_character or unichar\nUnipotentCharacters                         UnipotentCharacters\nUnipotentClasses                            UnipotentClasses\nUnipotentDecompose                          decompose\nUnipotentDegrees(W,q)                       degrees(UnipotentCharacters(W),q)\nUnipotentGroup                              UnipotentGroup\nUnorderedTuples                             multisets\nValuation(p)                                valuation(p)\nValue(p,x)                                  p(x)\nValuePol                                    evalpoly\nW.generators                                gens(W) or generators(W)\nW.matgens                                   reflection_representation(W) or reflrep\nW.matgens[i]                                reflection_representation(W,i) or reflrep\nW.N                                         nref(W) or number_of_reflections(W)\nW.Nhyp                                      number_of_hyperplanes(W) or nyp(W)\nW.orbitRepresentative                       simple_reps(W)\nW.orbitRepresentativeElements[i]            simple_conjugating(W,i)\nW.OrdersGeneratingReflections               ordergens(W) or orders_of_generators(W)\nW.rootInclusion                             inclusion(W)\nW.rootLengths                               rootlengths(W)\nW.rootRestriction                           restriction(W)\nW.roots                                     W.rootdec\nW.simpleCoroots                             simplecoroots(W)\nW.simpleRoots                               simpleroots(W)\nWeightInfo                                  weightinfo\nWGraph                                      Wgraph\nWGraphToRepresentation                      WGraphToRepresentation\nZip(a1,..,an,f)                             map(f,a1,...,an)","category":"section"},{"location":"algebras/#Algebras","page":"Algebras","title":"Algebras","text":"Pages=[\"algebras.md\"]","category":"section"},{"location":"algebras/#Chevie.Algebras","page":"Algebras","title":"Chevie.Algebras","text":"This  is a port of the GAP3 package Algebras by CÃ©dric BonnafÃ©. \n\nFinite  dimensional algebras are of the abstract type FiniteDimAlgebra{C} where the parameter C is the type of the coefficients.\n\nThere  are few generic methods for such an  algebra A. By default, it is assumed  there is  a method  dim (which  can also be spelled dimension) giving  the  dimension,  and  that  A  has  some canonical basis index by 1:dim(A).  Elements of  A, of  type AlgebraElt{TA}  where TA is the type  of A, are internally ModuleElts containing pairs i=>c where i is  the integer index in 1:dim(A) specifiying  an element of the basis of A  and  c  is  the  coefficient  of  that  basis  element. The function basis(A,i) returns the AlgebraElt with only non-zero coefficient on i and  equal to 1. It is assumed  that basis(A,1) is the identity of A. The function basis(A) returns basis.(A,1:dim(A)). Addition, subtraction and  multiplication by scalars (anything of type <:Number or of type C) of AlgebraElts works.\n\nIf  A has  a method  basismult(A,i,j) returning basis(A,i)*basis(A,j) then  the multiplication of elements is implemented using this function. If A  has  a  field  .multable  containing  a  matrix  dim(A)Ã—dim(A)  of AlgebraElts,  then basismult by  default uses this  table understood as giving the multiplication table of basis(A).\n\nAnother  view of algebra elements is as the vector of their coefficients on each  basis  element.  If  a  is an AlgebraElt then v=coefficients(a) returns  this  vector  and  AlgebraElt(A,v)  recovers  a.  The function Matrix(a)  will  transform  a  to  a  matrix  whose  i-th  row is the coefficients  of a times the i-th basis  element (such a matrix acts on the left on the vector space underlying A).\n\nGeneric  functions  are  left_ideal  and  twosided_ideal  which take as argument A and a list of AlgebraElt and return the generated ideal.\n\nradical   is  not  defined  generically,  but,  if  defined,  it  defines automatically radicalpower and loewylength.\n\nSome of the implemented algebras in this module are  the PolynomialQuotientAlgebra of a polynomial,  the GrothendieckRing  and the GroupAlgebra  of a group,  and the ZeroHecke and SolomonAlgebra of a Coxeter group.\n\n\n\n\n\n","category":"module"},{"location":"algebras/#Chevie.Algebras.coefftype","page":"Algebras","title":"Chevie.Algebras.coefftype","text":"coefftype(A::FiniteDimAlgebra{C}) where C=C returns the type of the coefficients of the algebra A.\n\n\n\n\n\n","category":"function"},{"location":"algebras/#PermGroups.Groups.gens","page":"Algebras","title":"PermGroups.Groups.gens","text":"gens(A::FiniteDimAlgebra)\n\nThe generators of the algebra A. By default basis(A) but should be specialized when a more efficient answer is known.\n\n\n\n\n\n","category":"function"},{"location":"algebras/#PermGroups.Groups.isabelian-Tuple{FiniteDimAlgebra}","page":"Algebras","title":"PermGroups.Groups.isabelian","text":"isabelian(A::FiniteDimAlgebra) whether A is commutative\n\n\n\n\n\n","category":"method"},{"location":"algebras/#Chevie.Algebras.isassociative","page":"Algebras","title":"Chevie.Algebras.isassociative","text":"isassociative(A::FiniteDimAlgebra) whether A is associative\n\n\n\n\n\n","category":"function"},{"location":"algebras/#Chevie.Algebras.PolynomialQuotientAlgebra","page":"Algebras","title":"Chevie.Algebras.PolynomialQuotientAlgebra","text":"PolynomialQuotientAlgebra(p::Pol)\n\nThe quotient of the polynomial algebra with coefficients of type eltype(p) by the polynomial p.\n\njulia> A=PolynomialQuotientAlgebra(Pol(:x)^2+1)\nInt64[x]/xÂ²+1\n\njulia> basis(A)\n2-element Vector{AlgebraElt{PolynomialQuotientAlgebra{Int64}, Int64}}:\n â‹…1\n x\n\n\n\n\n\n","category":"type"},{"location":"algebras/#Chevie.Algebras.GrothendieckRing","page":"Algebras","title":"Chevie.Algebras.GrothendieckRing","text":"GrothendieckRing(G::Group,T=Int)\n\nconstructs the Grothendieck ring of the group G with coefficients of type T.  The only condition  is to be  able to compute  the character table of G.\n\njulia> A=GrothendieckRing(coxsym(3))\nGrothendieckRing(ğ”– â‚ƒ,Int64)\n\njulia> basis(A).*permutedims(basis(A))\n3Ã—3 Matrix{AlgebraElt{GrothendieckRing{Int64}, Int64}}:\n [3]    [21]            [111]\n [21]   [111]+[21]+[3]  [21]\n [111]  [21]            [3]\n\njulia> A=GrothendieckRing(coxsym(3),FFE{2})\nGrothendieckRing(ğ”– â‚ƒ,FFE{2})\n\njulia> radical(A)\nTwoSidedIdeal(GrothendieckRing(ğ”– â‚ƒ,FFE{2}),[[111]+[3]])\n\n\n\n\n\n","category":"type"},{"location":"algebras/#Chevie.Algebras.GroupAlgebra","page":"Algebras","title":"Chevie.Algebras.GroupAlgebra","text":"GroupAlgebra(G,T=Int) group algebra of G with coefficients T\n\njulia> W=Group(Perm(1,2))\nGroup((1,2))\n\njulia> A=GroupAlgebra(W)\nAlgebra(Group((1,2)),Int64)\n\njulia> basis(A)\n2-element Vector{AlgebraElt{GroupAlgebra{Int64, Perm{Int16}, PermGroups.PG{Int16}}, Int64}}:\n e\n eâ‚\n\n\n\n\n\n","category":"type"},{"location":"algebras/#Chevie.Algebras.Quaternions","page":"Algebras","title":"Chevie.Algebras.Quaternions","text":"Quaternions() The quaternion algebra.\n\njulia> b=basis(Quaternions())\n4-element Vector{AlgebraElt{Quaternions{Int64}, Int64}}:\n 1\n i\n j\n k\n\njulia> b*permutedims(b)\n4Ã—4 Matrix{AlgebraElt{Quaternions{Int64}, Int64}}:\n 1  i   j   k\n i  -1  k   -j\n j  -k  -1  i\n k  j   -i  -1\n\n\n\n\n\n","category":"type"},{"location":"algebras/#Chevie.Algebras.SolomonAlgebra","page":"Algebras","title":"Chevie.Algebras.SolomonAlgebra","text":"SolomonAlgebra(W,K)\n\nLet  (W,S)  be  a  finite  Coxeter  group.  For  wâˆˆW,  let R(w)={sâˆˆS | l(ws)>l(w)}.  If I is a subset  of S, we set Y_I=wWR(w)=I, X_I=wWR(w) I.\n\nNote  that X_I is the set  of minimal length left coset representatives of WW_I. \n\nLet  y_I=_wY_Iw, x_I=_wX_Iw. They are elements of the group algebra â„¤W of W over â„¤.\n\nNow,  let  Î£(W)  =  _I    S  â„¤  y_I  =  _I   S â„¤ x_I. This is a sub-â„¤-module of â„¤W. In fact, Solomon proved that it is a sub-algebra of â„¤W  called  the  Solomon  descent  algebra.  Now,  let  K(W)  be  the Grothendieck  ring of  W and  let Î¸:Î£(W)â†’  K(W) be  the map  defined by Î¸(x_I)  = Ind_W_I^W 1. Solomon proved that this is an homomorphism of algebras. We call it the Solomon homomorphism.\n\nSolomonAlgebra  returns the Solomon descent algebra of the finite Coxeter group (W,S) over K. If S=[sâ‚,â€¦,sáµ£], the element x_I corresponding to  the  subset  I=[sâ‚,sâ‚‚,sâ‚„]  of  S  is  printed  as Xâ‚â‚‚â‚„. Note that A:=SolomonAlgebra(W,K) is endowed with the following fields:\n\nA.W: the group W\n\nA.basis: the basis (x_I)_{I âŠ‚ S}.\n\nA.xbasis: the  function   sending   I   to   x_I  (for  instance                      A.xbasis(1,2,4)=Xâ‚â‚‚â‚„)\n\nA.ybasis: the function sending the subset I to y_I.\n\nA.injection:  the injection of A in the group algebra of W, obtained by calling SolomonAlgebraOps.injection(A).\n\nNote that SolomonAlgebra(W,K) endows W with the field W.solomon which is a record containing the following fields:\n\nW.solomon_subsets: the set of subsets of S\n\nW.solomon_conjugacy:  conjugacy classes  of parabolic  subgroups of W (a conjugacy   class  is  represented  by  the   list  of  the  positions,  in W.solomon.subsets, of the subsets I of S such that W_I lies in this conjugacy class).\n\nW.solomon_mackey:  essentially  the  structure  constants  of  the Solomon algebra over the rationals.\n\njulia> W=coxgroup(:B,4)\nBâ‚„\n\njulia> A=SolomonAlgebra(W)\nSolomonAlgebra(Bâ‚„,Int64)\n\njulia> X=A.xbasis; X(1,2,3)*X(2,4)\n2Xâ‚‚+2Xâ‚„\n\njulia> W.solomon_subsets\n16-element Vector{Vector{Int64}}:\n [1, 2, 3, 4]\n [1, 2, 3]\n [1, 2, 4]\n [1, 3, 4]\n [2, 3, 4]\n [1, 2]\n [1, 3]\n [1, 4]\n [2, 3]\n [2, 4]\n [3, 4]\n [1]\n [2]\n [3]\n [4]\n []\n\njulia> W.solomon_conjugacy\n12-element Vector{Vector{Int64}}:\n [1]\n [2]\n [3]\n [4]\n [5]\n [6]\n [7, 8]\n [9, 11]\n [10]\n [12]\n [13, 14, 15]\n [16]\n\njulia> Algebras.injection(A)(X(1,2,3))\ne+eâ‚„+eâ‚ƒâ‚„+eâ‚‚â‚ƒâ‚„+eâ‚â‚‚â‚ƒâ‚„+eâ‚‚â‚â‚‚â‚ƒâ‚„+eâ‚ƒâ‚‚â‚â‚‚â‚ƒâ‚„+eâ‚„â‚ƒâ‚‚â‚â‚‚â‚ƒâ‚„\n\n\n\n\n\n","category":"type"},{"location":"algebras/#Chevie.Algebras.ZeroHecke","page":"Algebras","title":"Chevie.Algebras.ZeroHecke","text":"ZeroHecke(W::CoxeterGroup,T=Int) create the Hecke algebra of W with parameters 0 and 1.\n\njulia> A=ZeroHecke(coxsym(3))\n0-Hecke(ğ”– â‚ƒ)\n\njulia> radical(A)\nTwoSidedIdeal(0-Hecke(ğ”– â‚ƒ),[(1//1)Tâ‚â‚‚+(-1//1)Tâ‚â‚‚â‚,(1//1)Tâ‚‚â‚+(-1//1)Tâ‚â‚‚â‚])\n\n\n\n\n\n","category":"type"},{"location":"hecke/#Hecke-algebras","page":"Hecke algebras","title":"Hecke algebras","text":"Pages=[\"hecke.md\"]","category":"section"},{"location":"hecke/#Chevie.HeckeAlgebras","page":"Hecke algebras","title":"Chevie.HeckeAlgebras","text":"This  module  implements  Hecke  algebras associated to finite complex reflection  groups and arbitrary Coxeter  groups (these algebras are called Iwahori-Hecke  algebras  in  this  last  case),  and  also  implements  the character  tables, Schur elements and representations of Hecke algebras for finite  groups. For Iwahori-Hecke  algebras and for  G(d,1,1) this module also  implements the  standard T  basis; see  the module KL for Kazhdan-Lusztig bases.\n\nLet  (W,S) be  a Coxeter  system and  let mâ‚›â‚œ  be the order of st for s,tâˆˆ S. Let R be a commutative ring with 1 and for sâˆˆ S let uâ‚›â‚€,uâ‚›â‚âˆˆ R be elements which depend only on the conjugacy class of s in W (this is  the  same  as  requiring  that  uâ‚›áµ¢=uâ‚œáµ¢  whenever  mâ‚›â‚œ is odd). The Iwahori-Hecke   algebra  of  W  over  R  with  parameters  uâ‚›áµ¢  is  a deformation  of the group algebra of W over R defined as follows: it is the  unitary  associative  R-algebra  generated  by  elements  Tâ‚›, sâˆˆ S subject to the relations:\n\n(Tâ‚›-uâ‚›â‚€)(Tâ‚›-uâ‚›â‚)=0 for all sâˆˆ S (the quadratic relations)\n\nTâ‚›Tâ‚œTâ‚›= Tâ‚œTâ‚›Tâ‚œ with mâ‚›â‚œ factors on each side (the braid relations)\n\nIf  uâ‚›â‚€=1 and  uâ‚›â‚=-1 for  all s  then the quadratic relations become Tâ‚›Â²=1 and the deformation of the group algebra is trivial.\n\nSince  the generators Tâ‚›  satisfy the braid  relations, H is  in fact a quotient  of the group algebra of the  braid group associated with W. The braid relations also imply that for any reduced expression s_1â‹¯ s_m of w âˆˆ  W the product Tâ‚›_â‚â‹¯ Tâ‚›_â‚˜ has the same value, that we denote T_w. We have  Tâ‚=1; if one of the uâ‚›áµ¢ is invertible, the {T_w}_{wâˆˆ W} form an R-basis  of the Iwahori-Hecke algebra  which specializes to the canonical basis of the group algebra R[W] for uâ‚›â‚€â†¦1 and uâ‚›â‚â†¦-1.\n\nThe  structure constants (the  decomposition of a  product T_vT_w in the T_w)  basis are obtained as follows.  Choose a reduced expression for v, say v=s_1 â‹¯ s_k and apply inductively the formula:\n\nT_sT_w=T_sw               if l(sw)=l(w)+1\n\nT_sT_w=-uâ‚›â‚€uâ‚›â‚T_sw+(uâ‚›â‚€+uâ‚›â‚)T_w if l(sw)=l(w)-1.\n\nIf  one of uâ‚›â‚€ or uâ‚›â‚ is invertible  in R, for example uâ‚›â‚, then by changing  the generators  to Tâ€²â‚›=-Tâ‚›/uâ‚›â‚,  and setting qâ‚›=-uâ‚›â‚€/uâ‚›â‚, the braid  relations do no change  (since when mâ‚›â‚œ is  odd we have uâ‚›áµ¢=uâ‚œáµ¢) but  the quadratic relations become (Tâ€²â‚›-qâ‚›)(Tâ€²â‚›+1)=0. This normalisation is  the most common form considered  in the literature. Another common form in  the context of  Kazhdan-Lusztig theory, is  uâ‚›â‚€=âˆšqâ‚› and uâ‚›â‚=-âˆšqâ‚›â»Â¹. The  form provided, with two parameters per generator, is often useful, for instance  when constructing  the Jones  polynomial. If  for all s we have uâ‚›â‚€=q,   uâ‚›â‚=-1   then   we   call   the   corresponding   algebra  the \"one-parameter\" or \"Spetsial\" Iwahori-Hecke algebra associated with W.\n\nFor  some  Iwahori-Hecke  algebras  the  character  table,  and  in general Kazhdan-Lusztig  bases, require  a square  root of  -uâ‚›â‚€uâ‚›â‚. These square roots  can  be  specified  with  the  keyword  rootpara  of  the function hecke  constructing  the  algebra;  after  this H.rootpara will return  the  chosen  roots.  If  not  specified,  we  try  to extract roots automatically  when needed; rootpara(H) informs on the choices made. Note that some mathematical results require an explicit choice of one of the two possible  roots which cannot  be automatically made  thus require a keyword initialisation.\n\nThere  is a universal choice  for R and uâ‚›áµ¢:  Let uâ‚›áµ¢:sâˆˆ S,iâˆˆ[0,1] be indeterminates   such  that  uâ‚›áµ¢=uâ‚œáµ¢  whenever  mâ‚›â‚œ  is  odd,  and  let A=â„¤[uâ‚›áµ¢] be the corresponding polynomial ring. Then the Hecke algebra H of  W over A with parameters uâ‚›áµ¢ is called the generic Iwahori-Hecke algebra  of W (we work  often with the ring  â„¤[uâ‚›áµ¢^{Â±1}] so that basis elements have an inverse). Any Hecke algebra Hâ‚ with parameters vâ‚›áµ¢ can be  obtained  by  specialization  from  H,  since  there is a unique ring homomorphism  f:A â†’ R such that f(uâ‚›áµ¢)=vâ‚›áµ¢ for all i. Then via f we can identify Hâ‚ to R _A H.\n\nCertain invariants of the irreducible characters of the one-parameter Hecke algebra  play a special role in the representation theory of the underlying finite  Coxeter  groups,  namely  the  a-  and  A-invariants. For basic properties   of  Iwahori-Hecke   algebras  and   their  relevance   to  the representation  theory of finite groups of Lie type, see for example (Curtis and Reiner, 1987; Sections 67 and 68).\n\nIn  the  following  example,  we  compute  the multiplication table for the 0-Iwahoriâ€“Hecke algebra associated with the Coxeter group of type A_2.\n\njulia> W=coxgroup(:A,2)\nAâ‚‚\n\njulia> H=hecke(W,0)            # One-parameter algebra with `q=0`\nhecke(Aâ‚‚,0)\n\njulia> T=Tbasis(H);            # Create the `T` basis\n\njulia> b=T.(elements(W))       # the basis\n6-element Vector{HeckeTElt{HeckeAlgebra{Int64, Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}, Int64, Perm{Int16}}}:\n T.\n Tâ‚\n Tâ‚‚\n Tâ‚â‚‚\n Tâ‚‚â‚\n Tâ‚â‚‚â‚\n\njulia> b*permutedims(b)       # multiplication table\n6Ã—6 Matrix{HeckeTElt{HeckeAlgebra{Int64, Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}, Int64, Perm{Int16}}}:\n T.    Tâ‚     Tâ‚‚     Tâ‚â‚‚    Tâ‚‚â‚    Tâ‚â‚‚â‚\n Tâ‚    -Tâ‚    Tâ‚â‚‚    -Tâ‚â‚‚   Tâ‚â‚‚â‚   -Tâ‚â‚‚â‚\n Tâ‚‚    Tâ‚‚â‚    -Tâ‚‚    Tâ‚â‚‚â‚   -Tâ‚‚â‚   -Tâ‚â‚‚â‚\n Tâ‚â‚‚   Tâ‚â‚‚â‚   -Tâ‚â‚‚   -Tâ‚â‚‚â‚  -Tâ‚â‚‚â‚  Tâ‚â‚‚â‚\n Tâ‚‚â‚   -Tâ‚‚â‚   Tâ‚â‚‚â‚   -Tâ‚â‚‚â‚  -Tâ‚â‚‚â‚  Tâ‚â‚‚â‚\n Tâ‚â‚‚â‚  -Tâ‚â‚‚â‚  -Tâ‚â‚‚â‚  Tâ‚â‚‚â‚   Tâ‚â‚‚â‚   -Tâ‚â‚‚â‚\n\nThus,  we work  with algebras  with arbitrary  parameters. We will see that this also works on the level of characters and representations.\n\nFor  general complex reflection  groups, the picture  is similar. The Hecke algebras  are deformations  of the  group algebras,  generalizing those for real reflection groups.\n\nThe  definition is  as a  quotient of  the algebra  of the  braid group. We assume  now that W is  a finite reflection group  in the complex vector space  V. The braid group associated  is the fundamental group Î â‚ of the  space Â (V-bigcup_Hinmathcal H  H)W, where mathcal H is  the set of  reflecting hyperplanes of  W. This group  is generated by braid reflections, elements which by the natural map from the braid group to  the reflection  group project  to distinguished  reflections. The braid reflections   which  project  to  a  given  W-orbit  of  reflections  are conjugate.  Let ğ¬ be a representative of  such a conjugacy class of braid reflections,  let e  be the  order of  the image  of ğ¬  in W, and let u_ğ¬0u_ğ¬e-1 be indeterminates. The generic Hecke algebra of W is  the  â„¤u_ğ¬i^  1_ğ¬i-algebra  quotient  of  the braid group algebra  by the relations (ğ¬-u_ğ¬0)(ğ¬-u_ğ¬e-1)=0, and an arbitrary Hecke  algebra for W is an algebra  obtained from this generic algebra by specializing some of the parameters.\n\nThe  generic Hecke algebras are explicitely  described by a presentation of the  braid group. The braid group can be presented by homogeneous relations in   the  braid   reflections,  called   braid  relations,  described  in (BrouÃ© et al., 1998)  and (Bessis and Michel, 2004)  (some of  which were  obtained using the VKCURVE   GAP3-package,   also   ported   to   Julia).  Furthermore,  these presentations  are such that the reflection  group is presented by the same relations,   plus  relations   describing  the   order  of  the  generating reflections,  called the  order relations.  Thus the  Hecke algebra has a presentation  similar to that of W, with the same braid relations but the order relations replaced by a deformed version.\n\nIf  SâŠ‚ W  is the  set of  distinguished reflections  of W which lift to generating  braid reflections in the braid  group, for each conjugacy class of  an  s  of  order  e  we take indeterminates uâ‚›â‚€,â€¦,uâ‚›â‚‘â‚‹â‚. Then the generic  Hecke algebra is the â„¤uâ‚›áµ¢^1â‚›áµ¢-algebra H with generators T_s  for each sâˆˆ  S presented by  the braid relations  and the deformed order relations (T_s-u_s0)(T_s-u_se-1)=0.\n\nAriki and Koike have described models of representations for these algebras corresponding  to imprimitive complex  reflection groups, and Halverson-Ram and  some other  authors have  computed the  character tables in this case. Malle has given representation models and the character table for the other 2-dimensional  reflection groups, see (BrouÃ© and Malle, 1993) and (Malle, 1994); our data  has models  of all  representations, and  character tables,  for real reflection  groups; it  contains the  same for  imprimitive groups  and for primitive groups of dimension 2 and 3 (these last representations have been computed  in  (Malle and Michel, 2010))  and  the  situation  is  as follows for other primitive complex groups:\n\nGâ‚‚â‚‰ and Gâ‚ƒâ‚ƒ character table and representations computed by Michel.\nGâ‚ƒâ‚ character table and partial list of representations computed by Michel.\nGâ‚ƒâ‚‚ character table and partial list of representations computed by Malle and Michel.\nGâ‚ƒâ‚„ partial character table and partial list of representations computed by  Michel.\n\nThe quotient of the Hecke algebra obtained by the specialisation u_ğ¬i Î¶â‚‘â±  is isomorphic to the group algebra of W. It was conjectured for 25 years  that over a splitting ring the Hecke algebra is itself isomorphic to the  group algebra of W over the  same ring. This was called the freeness conjecture since the main problem is to show that the Hecke algebra is free of dimension |W|. This has finally been proved in 2020 thanks to the work of  many people including (Marin and Pfeiffer, 2017; Chavli, 2018; Tsuchioka, 2020) for exceptional groups. Along  the way it has been proven that there exists a set {b_w}_{wâˆˆ W} of elements  of the Braid group such that b_1=1 and b_w maps to w by the natural  quotient map,  such that  their images  T_w form  a basis of the Hecke algebra.\n\nIt  is  conjectured  that  such  a  basis  T_w  can  be  chosen such that additionnaly  the  linear  form  t  defined  by  t(T_w)=0 if wâ‰  1 and t(1)=1 is a symmetrizing form for the symmetric algebra H. This is well known  for all real reflection groups  and has been proved in (Malle and Mathas, 1998) for  imprimitive reflection groups and  in (Malle and Michel, 2010) for some primitive groups  of dimension 2 and 3. (Boura et al., 2020; Boura et al., 2020) have handled some other 2-dimensional  cases. For each  irreducible character Ï†  of H we define the  Schur element Sáµ© associated  to Ï† by the  condition that for any element  T of  H we  have t(T)=âˆ‘áµ©  Ï†(T)/Sáµ©. It  can be shown that the Schur  elements  are  Laurent  polynomials,  and  they do not depend on the choice of a basis having the above property. Malle has computed these Schur elements, assuming the above conjecture; they are in the Chevie data.\n\nSee hecke for various ways of specifying the parameters of a Hecke   algebra.  Look  also  at central_monomials, char_values, class_polynomials, schur_elements, isrepresentation, factorized_schur_elements and  at  the  methods  for  Hecke  algebras of CharTable, representations, reflrep.\n\nTaking  apart  Hecke  elements  is  done  with  the  functions  getindex, setindex!, keys, values, iterate.\n\njulia> H=hecke(W,Pol(:q))\nhecke(Aâ‚‚,q)\n\njulia> T=Tbasis(H);\n\njulia> h=T(1,2)^2\nqTâ‚‚â‚+(q-1)Tâ‚â‚‚â‚\n\njulia> length(h) # h has 2 terms\n2\n\njulia> h[W(2,1)] # coefficient of W(2,1)\nPol{Int64}: q\n\njulia> collect(h) # pairs perm=>coeff\n2-element Vector{Any}:\n  (1,2,6)(3,4,5) => q\n (1,5)(2,4)(3,6) => q-1\n\njulia> collect(values(h)) # the coefficients\n2-element Vector{Pol{Int64}}:\n q\n q-1\n\njulia> collect(keys(h)) # the corresponding Perms\n2-element Vector{Perm{Int16}}:\n (1,2,6)(3,4,5)\n (1,5)(2,4)(3,6)\n\njulia> h[W(2,1)]=Pol(3)\nPol{Int64}: 3\n\njulia> h\n3Tâ‚‚â‚+(q-1)Tâ‚â‚‚â‚\n\nFinally,  Hecke \"algebras\" can also be  attached to reflection cosets; they are  not algebras  but modules  for the  Hecke algebra of the corresponding group.   But  they  also  have  character  tables,  class  polynomials  and representations.\n\nfinally, benchmarks on julia 1.8\n\njulia> function test_w0(n)\n         W=coxgroup(:A,n)\n         Tbasis(hecke(W,Pol(:q)))(longest(W))^2\n       end\ntest_w0 (generic function with 1 method)\n\njulia> @btime test_w0(7);\n   97.210 ms (1776476 allocations: 127.52 MiB)\n\nin GAP3 the analogous function takes 920ms\n\ntest_w0:=function(n)local W,T,H;\n  W:=CoxeterGroup(\"A\",n);H:=Hecke(W,X(Rationals));T:=Basis(H,\"T\");\n  return T(LongestCoxeterWord(W))^2;\nend;\n\n\n\n\n\n","category":"module"},{"location":"hecke/#Chevie.HeckeAlgebras.hecke-Union{Tuple{C}, Tuple{Group, Vector{<:Vector{C}}}} where C","page":"Hecke algebras","title":"Chevie.HeckeAlgebras.hecke","text":"hecke(W,parameter=1;rootpara=missing)\n\nHecke  algebra for the complex reflection group or Coxeter group W. If no parameter is given, 1 is assumed which gives the group algebra of W.\n\nThe  following forms are accepted for  parameter: if parameter is not a vector or a tuple, it is replaced by the vector fill(parameter,ngens(W)). If it is a vector with one entry, it is replaced with fill(parameter[1],ngens(W)).  If parameter  is a  vector with more than one  entry, it should  have length ngens(W),  each entry representing the parameters   for   the   corresponding   generator   of  W,  and  entries corresponding  to  the  same  W-orbit  of generators should be identical. Finally, if parameter is a Tuple, the tuple should have as many entries as  there are hyperplane  orbits in W  and each entry  will represent the parameters for the corresponding conjugacy class of braid reflections.\n\nAn  entry in  parameter for  a reflection  of order  e can  be either a single scalar value or a Vector of length 'e'. If it is a Vector, it is interpreted as the list [uâ‚€,â€¦,uâ‚‘â‚‹â‚] of parameters for that reflection. If it  is  not  a  vector,  let  q  be  its value; it is then interpreted as specifying  the  list  of  parameters  for  the Spetsial algebra, which are [q,Î¶â‚‘,â€¦,Î¶â‚‘áµ‰â»Â¹]  (thus the list [q,-1]  of the one-parameter algebra for Coxeter groups).\n\nWhen  printing an Hecke algebra the parameter list is abbreviated using the same conventions.\n\nComputing characters or representations of Hecke algebra needs sometimes to extract  roots of the  parameters. These roots  are extracted automatically (when  possible). To control the roots, which is needed for example to have composable  specializations  or  make  sure  the  same  root  is  used  for subgroups,  for Coxeter  groups it  is possible  to give  explicit roots by giving  a keyword argument rootpara: if it  is a vector it should contain at  the i-th position a square root of -parameter[i][1]*parameter[i][2] (that  is, a square root of q  if parameter[i]==[q,-1]); if a scalar it is  replaced by fill(rootpara,ngens(W)). If  not specified the entries in rootpara  start  as  missing.  The  function  rootpara(H) tries to fill automatically  missing entries in H.rootpara  and returns the result. The same  mechanism  has  been  extended  to  some  complex  reflection  groups generated  by 2-reflections and needing only square roots of the parameters to split the Hecke algebra, that is to Gâ‚‚â‚„, Gâ‚‚â‚‰, Gâ‚ƒâ‚, Gâ‚ƒâ‚ƒ and Gâ‚„,â‚‚,áµ£.\n\nExample\n\njulia> W=coxgroup(:B,2)\nBâ‚‚\n\njulia> @Pol q\nPol{Int64}: q\n\njulia> H=hecke(W,q)\nhecke(Bâ‚‚,q)\n\njulia> H.para\n2-element Vector{Vector{Pol{Int64}}}:\n [q, -1]\n [q, -1]\n\njulia> H=hecke(W,q^2,rootpara=-q)\nhecke(Bâ‚‚,qÂ²,rootpara=-q)\n\njulia> H=hecke(W,q^2)\nhecke(Bâ‚‚,qÂ²)\n\njulia> rootpara(H) # automatically computed\n2-element Vector{Pol{Int64}}:\n q\n q\n\njulia> H\nhecke(Bâ‚‚,qÂ²,rootpara=q)\n\njulia> H=hecke(W,[q^2,q^4],rootpara=[q,q^2])\nhecke(Bâ‚‚,Pol{Int64}[qÂ², qâ´],rootpara=Pol{Int64}[q, qÂ²])\n\njulia> H.para,H.rootpara\n(Vector{Pol{Int64}}[[qÂ², -1], [qâ´, -1]], Pol{Int64}[q, qÂ²])\n\njulia> H=hecke(W,9,rootpara=3)\nhecke(Bâ‚‚,9,rootpara=3)\n\njulia> H.para,H.rootpara\n([[9, -1], [9, -1]], [3, 3])\n\njulia> @Mvp x,y,z,t\n\njulia> H=hecke(W,[[x,y]])\nhecke(Bâ‚‚,Vector{Mvp{Int64, Int64}}[[x, y]])\n\njulia> rootpara(H);H\nhecke(Bâ‚‚,Vector{Mvp{Int64, Int64}}[[x, y]],rootpara=Î¶â‚„xÂ½yÂ½)\n\njulia> H=hecke(W,[[x,y],[z,t]])\nhecke(Bâ‚‚,Vector{Mvp{Int64, Int64}}[[x, y], [z, t]])\n\njulia> rootpara(H);H\nhecke(Bâ‚‚,Vector{Mvp{Int64, Int64}}[[x, y], [z, t]],rootpara=Mvp{Cyc{Int64}, Rational{Int64}}[Î¶â‚„xÂ½yÂ½, Î¶â‚„tÂ½zÂ½])\n\njulia> hecke(coxgroup(:F,4),(q,q^2)).para\n4-element Vector{Vector{Pol{Int64}}}:\n [q, -1]\n [q, -1]\n [qÂ², -1]\n [qÂ², -1]\n\njulia> hecke(complex_reflection_group(3,1,2),q).para # spetsial parameters\n2-element Vector{Vector{Pol{Cyc{Int64}}}}:\n [q, Î¶â‚ƒ, Î¶â‚ƒÂ²]\n [q, -1]\n\n\n\n\n\n","category":"method"},{"location":"hecke/#Chevie.HeckeAlgebras.Tbasis-Tuple{HeckeAlgebra}","page":"Hecke algebras","title":"Chevie.HeckeAlgebras.Tbasis","text":"Tbasis(H::HeckeAlgebra) The  T basis of  H. It is  defined currently for Iwahori-Hecke algebras and  for Hecke algebras of cyclic  complex reflection groups G(d,1,1). It returns  a function, say T,  which can take an  argument of the following forms\n\nT(i::Integer): the generator T_s where s=H.W(i).\nT(iâ‚,â€¦,iáµ£): the product T(iâ‚)â€¦T(iáµ£)\nT([iâ‚,â€¦,iáµ£]): same as T(iâ‚,â€¦,iáµ£)\nT(w) where wâˆˆ H.W: returns T_w\n\njulia> H=hecke(coxgroup(:A,2),Pol(:q))\nhecke(Aâ‚‚,q)\n\njulia> T=Tbasis(H);T(longest(H.W))^2\nqÂ³T.+(qÂ³-2qÂ²+q)Tâ‚‚â‚+(qÂ³-qÂ²)Tâ‚‚+(qÂ³-qÂ²)Tâ‚+(qÂ³-2qÂ²+2q-1)Tâ‚â‚‚â‚+(qÂ³-2qÂ²+q)Tâ‚â‚‚\n\njulia> W=crg(3,1,1)\nGâ‚ƒâ€šâ‚â€šâ‚\n\njulia> H=hecke(crg(3,1,1),Pol(:q))\nhecke(Gâ‚ƒâ€šâ‚â€šâ‚,q)\n\njulia> T=Tbasis(H);T(1)^3\n(q-1)T.+(q-1)Tâ‚+qTâ‚â‚\n\n\n\n\n\n","category":"method"},{"location":"hecke/#Chevie.HeckeAlgebras.alt","page":"Hecke algebras","title":"Chevie.HeckeAlgebras.alt","text":"alt(a::HeckeTElt)\n\na should be an element of an Iwahori-Hecke algebra H. the involution on H   defined  by  xâ†¦  bar(x)   on  coefficients  and  Tâ‚›â†¦  uâ‚›,â‚€uâ‚›,â‚Tâ‚›. Essentially it corresponds to tensoring with the sign representation.\n\njulia> W=coxgroup(:G,2);H=hecke(W,Pol(:q))\nhecke(Gâ‚‚,q)\n\njulia> T=Tbasis(H);h=T(1,2)*T(2,1)\nqÂ²T.+(qÂ²-q)Tâ‚+(q-1)Tâ‚â‚‚â‚\n\njulia> alt(h)\nqâ»Â²T.+(qâ»Â²-qâ»Â³)Tâ‚+(qâ»Â³-qâ»â´)Tâ‚â‚‚â‚\n\n\n\n\n\n","category":"function"},{"location":"hecke/#Chevie.Garside.Î±-Tuple{HeckeTElt}","page":"Hecke algebras","title":"Chevie.Garside.Î±","text":"Î±(a::HeckeTElt)\n\nthe anti-involution on the Hecke algebra defined by T_w T_inv(w).\n\n\n\n\n\n","category":"method"},{"location":"hecke/#Chevie.Chars.CharTable-Tuple{HeckeAlgebra}","page":"Hecke algebras","title":"Chevie.Chars.CharTable","text":"CharTable(H::HeckeAlgebra or HeckeCoset)\n\nreturns the CharTable of the Hecke algebra H. For the primitive complex reflection group Gâ‚ƒâ‚„ there are missing entries. If W=H.W, the columns of  the  CharTable  are  labelled  by  classnames(W); the i-th column contains   the  character  values   for  the  lift   to  H  of  the  word classinfo(W).classreps[i]   for   the   element   classreps(W)[i]  (see char_values for more information).\n\njulia> H=hecke(crg(4),Pol())\nhecke(Gâ‚„,q)\n\njulia> CharTable(H)\nCharTable(hecke(Gâ‚„,q))\nâ”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚    â”‚.    z 2c    c     zc     1        1zâ”‚\nâ”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚Ï†â‚â€šâ‚€â”‚1   qâ¶ qÂ³   qÂ²     qâ¸     q        qâ·â”‚\nâ”‚Ï†â‚â€šâ‚„â”‚1    1  1  Î¶â‚ƒÂ²    Î¶â‚ƒÂ²    Î¶â‚ƒ        Î¶â‚ƒâ”‚\nâ”‚Ï†â‚â€šâ‚ˆâ”‚1    1  1   Î¶â‚ƒ     Î¶â‚ƒ   Î¶â‚ƒÂ²       Î¶â‚ƒÂ²â”‚\nâ”‚Ï†â‚‚â€šâ‚…â”‚2   -2  .    1     -1    -1         1â”‚\nâ”‚Ï†â‚‚â€šâ‚ƒâ”‚2 -2qÂ³  . Î¶â‚ƒÂ²q -Î¶â‚ƒÂ²qâ´ q+Î¶â‚ƒÂ² -qâ´-Î¶â‚ƒÂ²qÂ³â”‚\nâ”‚Ï†â‚‚â€šâ‚â”‚2 -2qÂ³  .  Î¶â‚ƒq  -Î¶â‚ƒqâ´  q+Î¶â‚ƒ  -qâ´-Î¶â‚ƒqÂ³â”‚\nâ”‚Ï†â‚ƒâ€šâ‚‚â”‚3  3qÂ² -q    .      .   q-1     qÂ³-qÂ²â”‚\nâ””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n\n\n\n\n","category":"method"},{"location":"hecke/#Chevie.HeckeAlgebras.central_monomials","page":"Hecke algebras","title":"Chevie.HeckeAlgebras.central_monomials","text":"central_monomials(H)\n\nLet  H  be  an  Hecke  algebra  for  the finite reflection group W. The function  returns the scalars by which the image  in H of Ï€ acts on the irreducible representations of H.\n\nWhen  W is irreducible,  Ï€ is the  generator of the  center of the pure braid  group.  In  general,  it  is  the  product of such elements for each irreducible  component. When  W is  a Coxeter  group, the  image of  Ï€ in H is T_w_0^2.\n\njulia> H=hecke(coxgroup(:H,3),Pol(:q))\nhecke(Hâ‚ƒ,q)\n\njulia> central_monomials(H)\n10-element Vector{Pol{Cyc{Int64}}}:\n 1\n qÂ³â°\n qÂ¹Â²\n qÂ¹â¸\n qÂ¹â°\n qÂ¹â°\n qÂ²â°\n qÂ²â°\n qÂ¹âµ\n qÂ¹âµ\n\n\n\n\n\n","category":"function"},{"location":"hecke/#Chevie.HeckeAlgebras.class_polynomials","page":"Hecke algebras","title":"Chevie.HeckeAlgebras.class_polynomials","text":"class_polynomials(h::HeckeElt)\n\nreturns  the  class  polynomials  of  the  element h of the Iwahori-Hecke algebra or coset given by h.H with respect to the T basis for a set R of  representatives  of  minimal  length  in  the  conjugacy classes of the Coxeter group or coset H.W. Such minimal length representatives are given by  classreps(H.W). The vector p of  these polynomials has the property that  if X is the  matrix of the values  of the irreducible characters of H  on T_w (for wâˆˆ R), then the product X*p is the list of values of the irreducible characters on h.\n\njulia> W=coxsym(4)\nğ”– â‚„\n\njulia> H=hecke(W,Pol(:q))\nhecke(ğ”– â‚„,q)\n\njulia> h=Tbasis(H,longest(W))\nTâ‚â‚‚â‚â‚ƒâ‚‚â‚\n\njulia> p=class_polynomials(h)\n5-element Vector{Pol{Int64}}:\n 0\n 0\n qÂ²\n qÂ³-2qÂ²+q\n qÂ³-qÂ²+q-1\n\nThe class polynomials were introduced in (Geck and Pfeiffer, 1993).\n\n\n\n\n\n","category":"function"},{"location":"hecke/#Chevie.HeckeAlgebras.char_values","page":"Hecke algebras","title":"Chevie.HeckeAlgebras.char_values","text":"char_values(h::HeckeTElt)\n\nh is an element of an Iwahori-Hecke algebra H. The function returns the values  of the irreducible characters of H  on h (the method used is to convert to the T basis, and then use class_polynomials).\n\njulia> W=coxgroup(:B,2)\nBâ‚‚\n\njulia> H=hecke(W,q^2;rootpara=q)\nhecke(Bâ‚‚,qÂ²,rootpara=q)\n\njulia> char_values(Cpbasis(H)(1,2,1))\n5-element Vector{Pol{Int64}}:\n -q-qâ»Â¹\n q+qâ»Â¹\n 0\n qÂ³+2q+2qâ»Â¹+qâ»Â³\n 0\n\n\n\n\n\nchar_values(H::HeckeAlgebra,v::Vector{<:Integer})\n\nFor an Iwahori-Hecke algebra this computes the character values of H on Tbasis(H)(v).\n\nFor  H the Hecke algebra  of a complex reflection  group W this routine computes  character values on a  lift of the element  of W defined by the word v in gens(W).\n\nFor  complex reflection  groups the  character table  of the  generic Hecke algebra of W has been computed (excepted for Gâ‚ƒâ‚„) in the sense that, if sâ‚,â€¦,sâ‚™ are generators of the braid group lifting the BrouÃ©-Malle-Rouquier-Bessis-Michel generators of W, there is at least one element  v  in  each  conjugacy  class  of  W and one expression in the generators  for it such that the character  values of the image Táµ¥ in the Hecke  algebra of the lift to the braid group are known. Such an expression in the generators will be called a known word (the list of known words is obtained  by word.(conjugacy_classes(W))  or classinfo(W).classtext. If the  word v is known, the computation is quick using the character table. If  not,  the  function  computes  the  trace  of  Táµ¥ in each irreducible representation.   The   values   returned   are   missing   for   missing representations    (see   representation;   there   are   missing representations for Gâ‚ƒâ‚, Gâ‚ƒâ‚‚ and Gâ‚ƒâ‚„).\n\njulia> W=crg(4)\nGâ‚„\n\njulia> H=hecke(W,Pol(:q))\nhecke(Gâ‚„,q)\n\njulia> char_values(H,[2,1,2])\n7-element Vector{Pol{Cyc{Int64}}}:\n qÂ³\n 1\n 1\n 0\n 0\n 0\n -q\n\n\n\n\n\n","category":"function"},{"location":"hecke/#Chevie.HeckeAlgebras.schur_elements","page":"Hecke algebras","title":"Chevie.HeckeAlgebras.schur_elements","text":"schur_elements(H)\n\nreturns the list of Schur elements for the Hecke algebra H\n\njulia> H=hecke(complex_reflection_group(4),Pol(:q))\nhecke(Gâ‚„,q)\n\njulia> s=schur_elements(H)\n7-element Vector{Pol{Cyc{Int64}}}:\n qâ¸+2qâ·+3qâ¶+4qâµ+4qâ´+4qÂ³+3qÂ²+2q+1\n 2âˆš-3+(6+4âˆš-3)qâ»Â¹+12qâ»Â²+(6-4âˆš-3)qâ»Â³-2âˆš-3qâ»â´\n -2âˆš-3+(6-4âˆš-3)qâ»Â¹+12qâ»Â²+(6+4âˆš-3)qâ»Â³+2âˆš-3qâ»â´\n 2+2qâ»Â¹+4qâ»Â²+2qâ»Â³+2qâ»â´\n Î¶â‚ƒÂ²âˆš-3qÂ³+(3-âˆš-3)qÂ²+3q+3+âˆš-3-Î¶â‚ƒâˆš-3qâ»Â¹\n -Î¶â‚ƒâˆš-3qÂ³+(3+âˆš-3)qÂ²+3q+3-âˆš-3+Î¶â‚ƒÂ²âˆš-3qâ»Â¹\n qÂ²+2q+2+2qâ»Â¹+qâ»Â²\n\njulia> CycPol.(s)\n7-element Vector{CycPol{Cyc{Int64}}}:\n Î¦â‚‚Â²Î¦â‚ƒÎ¦â‚„Î¦â‚†\n 2âˆš-3qâ»â´Î¦â‚‚Â²Î¦â€²â‚ƒÎ¦â€²â‚†\n -2âˆš-3qâ»â´Î¦â‚‚Â²Î¦â€³â‚ƒÎ¦â€³â‚†\n 2qâ»â´Î¦â‚ƒÎ¦â‚„\n Î¶â‚ƒÂ²âˆš-3qâ»Â¹Î¦â‚‚Â²Î¦â€²â‚ƒÎ¦â€³â‚†\n -Î¶â‚ƒâˆš-3qâ»Â¹Î¦â‚‚Â²Î¦â€³â‚ƒÎ¦â€²â‚†\n qâ»Â²Î¦â‚‚Â²Î¦â‚„\n\n\n\n\n\n","category":"function"},{"location":"hecke/#Chevie.HeckeAlgebras.factorized_schur_element","page":"Hecke algebras","title":"Chevie.HeckeAlgebras.factorized_schur_element","text":"factorized_schur_element(H,phi)\n\nreturns the factorized schur_element (see factorized_schur_elements)  of  the  Hecke  algebra  H  for the irreducible character of H of parameter phi (see charinfo(W).charparams)\n\njulia> W=complex_reflection_group(4)\nGâ‚„\n\njulia> @Mvp x,y; H=hecke(W,[[1,x,y]])\nhecke(Gâ‚„,Vector{Mvp{Int64, Int64}}[[1, x, y]])\n\njulia> factorized_schur_element(H,[[2,5]])\n-xâ»Â¹y(xy+1)(x-1)Î¦â‚†(xyâ»Â¹)(y-1)\n\n\n\n\n\n","category":"function"},{"location":"hecke/#Chevie.HeckeAlgebras.factorized_schur_elements","page":"Hecke algebras","title":"Chevie.HeckeAlgebras.factorized_schur_elements","text":"factorized_schur_elements(H)\n\nLet  H be  a Hecke  algebra for  the complex  reflection group W, whose parameters are all (Laurent) monomials in some variables xâ‚,â€¦,xâ‚™, and let K  be the field of definition of  W. Then (Chlouveraki, 2009) has shown that the  Schur elements of H take the  particular form M âˆáµ© Ï†(Máµ©) where Ï† runs  over  a  list  of  K-cyclotomic  polynomials,  and  M  and Máµ© are (Laurent)  monomials (in possibly some  fractional powers) of the variables xáµ¢.  The  function  factorized_schur_elements  returns a data structure (see HeckeAlgebras.FactSchur) which shows this factorization.\n\njulia> W=complex_reflection_group(4)\nGâ‚„\n\njulia> @Mvp x,y; H=hecke(W,[[1,x,y]])\nhecke(Gâ‚„,Vector{Mvp{Int64, Int64}}[[1, x, y]])\n\njulia> factorized_schur_elements(H)\n7-element Vector{Chevie.HeckeAlgebras.FactSchur}:\n xâ»â´yâ»â´(xy+1)Î¦â‚Î¦â‚†(x)Î¦â‚Î¦â‚†(y)\n (xÂ²yâ»Â¹+1)Î¦â‚Î¦â‚†(x)Î¦â‚Î¦â‚†(xyâ»Â¹)\n -xâ»â´yâµÎ¦â‚Î¦â‚†(xyâ»Â¹)(xyâ»Â²+1)Î¦â‚Î¦â‚†(y)\n -xâ»Â¹y(xy+1)(x-1)Î¦â‚†(xyâ»Â¹)(y-1)\n -xâ»â´y(xÂ²yâ»Â¹+1)(x-1)(xyâ»Â¹-1)Î¦â‚†(y)\n xâ»Â¹yâ»Â¹Î¦â‚†(x)(xyâ»Â¹-1)(xyâ»Â²+1)(y-1)\n xâ»Â²y(xÂ²yâ»Â¹+1)(xy+1)(xyâ»Â²+1)\n\n\n\n\n\n","category":"function"},{"location":"hecke/#Chevie.HeckeAlgebras.FactSchur","page":"Hecke algebras","title":"Chevie.HeckeAlgebras.FactSchur","text":"A  FactSchur representing  a Schur  element of  the form  Mâˆáµ©Ï†(Máµ©) (see factorized_schur_element)  is  a  struct  with a field factor which  holds the  monomial M,  and a  field vcyc  which holds a list of NamedTuples  describing each  factor Máµ©  in the  product. An element of vcyc  representing a  term Ï†(Máµ©)  is itself  a NamedTuple with fields monomial holding Máµ© (as an Mvp with a single term), and a field pol holding a CycPol (see CycPol) representing Ï†.\n\nA  few operations are implemented for  FactSchur, like *, lcm. They can be  evaluated  partially  or  completely  keeping  as  much as possible the factored form.\n\njulia> @Mvp x,y; W=crg(4); H=hecke(W,[[1,x,y]])\nhecke(Gâ‚„,Vector{Mvp{Int64, Int64}}[[1, x, y]])\n\njulia> p=factorized_schur_element(H,[[2,5]])\n-xâ»Â¹y(xy+1)(x-1)Î¦â‚†(xyâ»Â¹)(y-1)\n\njulia> q=p(;x=E(3)) # partial evaluation\nÎ¶â‚ƒÂ²âˆš-3yâ»Â¹Î¦â‚Î¦â‚‚Î¦â€²â‚†Â²(y)\n\njulia> q(;y=2//1)\n-9âˆš-3/2\n\nIn contrast, the next operation expands p to an Mvp:\n\njulia> HeckeAlgebras.expand(p)\nMvp{Cyc{Rational{Int64}},Rational{Int64}}: -xÂ³y+xÂ³+xÂ²yÂ²-2xÂ²+xÂ²yâ»Â¹-xyÂ³+2xy-xyâ»Â¹+yÂ³-2yÂ²+1+xâ»Â¹yÂ²-xâ»Â¹y\n\n\n\n\n\n","category":"type"},{"location":"hecke/#Chevie.Chars.representation-Tuple{HeckeAlgebra, Integer}","page":"Hecke algebras","title":"Chevie.Chars.representation","text":"representation(H::HeckeAlgebra or HeckeCoset,i)\n\nreturns,  for the i-th irreducible representation of the Hecke algebra or Hecke  coset H, a list  of matrices images of  the generators of H in a model of the representation (for Hecke cosets, the result is a NamedTuple with fields gens, a representation of hecke(H), and F, the matrix for the automorphism of H in the representation).\n\nThis  function  is  based  on  the  classification,  and  is  not yet fully implemented for the Hecke algebras of the groups Gâ‚ƒâ‚, Gâ‚ƒâ‚‚ and Gâ‚ƒâ‚„: we have 50 representations out of 59 for type Gâ‚ƒâ‚, 30 representations out of 102  for  type  Gâ‚ƒâ‚‚  and  38  representations  out of 169 for type Gâ‚ƒâ‚„; nothing is returned for a missing representation.\n\njulia> W=crg(24)\nGâ‚‚â‚„\n\njulia> H=hecke(W,Pol(:q))\nhecke(Gâ‚‚â‚„,q)\n\njulia> representation(H,3)\n3-element Vector{Matrix{Pol{Cyc{Int64}}}}:\n [q 0 0; -q -1 0; -q 0 -1]\n [-1 0 -1; 0 -1 ((1-âˆš-7)/2)q; 0 0 q]\n [-1 -1 0; 0 q 0; 0 (1+âˆš-7)/2 -1]\n\nThe  models  implemented  for  imprimitive  types G(de,e,n) for n>2 and de>1 (this includes Coxeter type Dâ‚™), excepted for G(2,2,4), G(3,3,3), G(3,3,4), G(3,3,5) and G(4,4,3), involve rational fractions.\n\njulia> H=hecke(coxgroup(:D,5),Pol(:q))\nhecke(Dâ‚…,q)\n\njulia> representation(H,7)\n5-element Vector{Matrix{Frac{Pol{Int64}}}}:\n [q 0 0 0; 0 -1 0 0; 0 0 -1 0; 0 0 0 -1]\n [q 0 0 0; 0 -1 0 0; 0 0 -1 0; 0 0 0 -1]\n [1/(-q-1) q/(q+1) 0 0; (qÂ²+q+1)/(q+1) qÂ²/(q+1) 0 0; 0 0 -1 0; 0 0 0 -1]\n [-1 0 0 0; 0 1/(-qÂ²-q-1) (-qÂ²-q)/(-qÂ²-q-1) 0; 0 (qÂ³+qÂ²+q+1)/(qÂ²+q+1) qÂ³/(qÂ²+q+1) 0; 0 0 0 -1]\n [-1 0 0 0; 0 -1 0 0; 0 0 1/(-qÂ³-qÂ²-q-1) (-qÂ³-qÂ²-q)/(-qÂ³-qÂ²-q-1); 0 0 (qâ´+qÂ³+qÂ²+q+1)/(qÂ³+qÂ²+q+1) qâ´/(qÂ³+qÂ²+q+1)]\n\n\n\n\n\n","category":"method"},{"location":"hecke/#Chevie.Chars.representation-Tuple{HeckeElt, Any}","page":"Hecke algebras","title":"Chevie.Chars.representation","text":"representation(h::HeckeElt,r)\n\nr  should be a representation  of h.H, or an  integer, in which case it means  representation(h.H,r). The value of that representation applied to h is returned. Here h.H can be an Hecke algebra or an Hecke coset.\n\njulia> H=hecke(coxsym(4),Pol(:q));T=Tbasis(H);\n\njulia> representation(T(1,2)^2,2)\n3Ã—3 Matrix{Pol{Rational{Int64}}}:\n -qÂ²  -qÂ²   0\n qÂ²   0     0\n -q   -q+1  1\n\n\n\n\n\n","category":"method"},{"location":"hecke/#Chevie.Chars.representations-Tuple{Union{HeckeAlgebra, HeckeCoset}}","page":"Hecke algebras","title":"Chevie.Chars.representations","text":"representations(H)\n\nreturns  the list  of representations  of the  Hecke algebra or Hecke coset H (see representation).\n\njulia> WF=rootdatum(\"2B2\")\nÂ²Bâ‚‚\n\njulia> H=hecke(WF,Pol(:x)^2;rootpara=Pol())\nhecke(Â²Bâ‚‚,xÂ²,rootpara=x)\n\njulia> representations(H)\n3-element Vector{NamedTuple{(:gens, :F)}}:\n (gens = Matrix{Pol{Int64}}[[xÂ²;;], [xÂ²;;]], F = [1;;])\n (gens = Matrix{Pol{Int64}}[[-1;;], [-1;;]], F = [1;;])\n (gens = Matrix{Pol{Cyc{Int64}}}[[-1 0; âˆš2x xÂ²], [xÂ² âˆš2x; 0 -1]], F = [0 -1; -1 0])\n\n\n\n\n\n","category":"method"},{"location":"hecke/#Chevie.HeckeAlgebras.isrepresentation","page":"Hecke algebras","title":"Chevie.HeckeAlgebras.isrepresentation","text":"isrepresentation(H::HeckeAlgebra,r;details=false) or\n\nisrepresentation(W::ComplexReflectionGroup,r;details=false)\n\nreturns true or false, according to whether a given set r of elements in bijection with gens(H.W) defines a representation of the Hecke algebra H or not; isrepresentation(W,r) is equivalent to isrepresentation(hecke(W)),r).   If  details=true  the  function  gives details of the cause of a failure.\n\njulia> H=hecke(coxgroup(:F,4))\nhecke(Fâ‚„,1)\n\njulia> isrepresentation(H,reflrep(H))\ntrue\n\njulia> isrepresentation(H,Tbasis(H).(1:4))\ntrue\n\n\n\n\n\nisrepresentation(H::HeckeCoset,r;details=false) or\n\nisrepresentation(W::Spets,r;details=false)\n\nreturns true or false, according to whether NamedTuple r defines a representation of H or not. If details=true the function gives details of the cause of a failure. ```\n\n\n\n\n\n","category":"function"},{"location":"hecke/#Chevie.PermRoot.reflection_representation-Tuple{HeckeAlgebra}","page":"Hecke algebras","title":"Chevie.PermRoot.reflection_representation","text":"reflection_representation(H::HeckeAlgebra) or reflrep(H)\n\nreturns  a  list  of  matrices  for  the  generators  of H which give the reflection  representation of the Iwahori-Hecke  algebra H. This is based on a general formula and does not necessarily agree with representation(H,i)   where   i   is   the   index  of  the  reflection representation,   and   does   not   either   necessarily   specialises  to reflrep(H.W).\n\njulia> W=coxgroup(:B,2);H=hecke(W,Pol(:q))\nhecke(Bâ‚‚,q)\n\njulia> reflrep(H)\n2-element Vector{Matrix{Pol{Int64}}}:\n [-1 0; -q q]\n [q -2; 0 -1]\n\njulia> H=hecke(coxgroup(:H,3))\nhecke(Hâ‚ƒ,1)\n\njulia> reflrep(H)\n3-element Vector{Matrix{Cyc{Int64}}}:\n [-1 0 0; -1 1 0; 0 0 1]\n [1 (-3-âˆš5)/2 0; 0 -1 0; 0 -1 1]\n [1 0 0; 0 1 -1; 0 0 -1]\n\n\n\n\n\n","category":"method"},{"location":"hecke/#Chevie.HeckeAlgebras.HeckeCoset","page":"Hecke algebras","title":"Chevie.HeckeAlgebras.HeckeCoset","text":"HeckeCosets  are  HÏ•  where  H  is  an  Iwahori-Hecke algebra of some Coxeter  group W on which the automorphism Ï• of some Spets WÏ• acts by Ï•(T_w)=T_{Ï•(w)}.  For Weyl groups, this corresponds  to the action of the Frobenius  automorphism  on  the  commuting  algebra  of the induced of the trivial  representation from the  rational points of  some F-stable Borel subgroup to ğ† ^F.\n\njulia> WF=rootdatum(:u,3)\nuâ‚ƒ\n\njulia> HF=hecke(WF,Pol(:v)^2;rootpara=Pol())\nhecke(uâ‚ƒ,vÂ²,rootpara=v)\n\njulia> CharTable(HF)\nCharTable(hecke(uâ‚ƒ,vÂ²,rootpara=v))\nâ”Œâ”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚   â”‚ 111 21  3â”‚\nâ”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚111â”‚  -1  1 -1â”‚\nâ”‚21 â”‚-2vÂ³  .  vâ”‚\nâ”‚3  â”‚  vâ¶  1 vÂ²â”‚\nâ””â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nThanks  to the work  of (He and Nie, 2012), 'class_polynomials'  also make sense for these cosets. This is used to compute such character tables.\n\n\n\n\n\n","category":"type"},{"location":"hecke/#Chevie.HeckeAlgebras.hecke-Tuple{HeckeCoset}","page":"Hecke algebras","title":"Chevie.HeckeAlgebras.hecke","text":"hecke(HF::HeckeCoset) returns the underlying Hecke algebra\n\n\n\n\n\n","category":"method"},{"location":"hecke/#Chevie.HeckeAlgebras.hecke-Tuple{Spets, HeckeAlgebra}","page":"Hecke algebras","title":"Chevie.HeckeAlgebras.hecke","text":"hecke(WF::Spets, H)\n\nhecke(WF::Spets, params)\n\nConstruct  a HeckeCoset  from a  Coxeter coset  WF and an Hecke algebra associated to Group(WF). The second form is equivalent to Hecke(WF,Hecke(Group(WF),params)). See the doc for HeckeCoset.\n\n\n\n\n\n","category":"method"}]
}
