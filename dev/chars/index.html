<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Classes/characters of reflection groups Â· Chevie.jl documentation</title><meta name="title" content="Classes/characters of reflection groups Â· Chevie.jl documentation"/><meta property="og:title" content="Classes/characters of reflection groups Â· Chevie.jl documentation"/><meta property="twitter:title" content="Classes/characters of reflection groups Â· Chevie.jl documentation"/><meta name="description" content="Documentation for Chevie.jl documentation."/><meta property="og:description" content="Documentation for Chevie.jl documentation."/><meta property="twitter:description" content="Documentation for Chevie.jl documentation."/><meta property="og:url" content="https://juliadocs.github.io/Chevie.jl/chars/"/><meta property="twitter:url" content="https://juliadocs.github.io/Chevie.jl/chars/"/><link rel="canonical" href="https://juliadocs.github.io/Chevie.jl/chars/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Chevie.jl documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Chevie</a></li><li><span class="tocitem">Infrastructure</span><ul><li><a class="tocitem" href="../format/">formatting facilities</a></li><li><a class="tocitem" href="../symbols/">Symbols</a></li><li><a class="tocitem" href="../nf/">Number fields</a></li></ul></li><li><span class="tocitem">Reflection groups</span><ul><li><a class="tocitem" href="../permroot/">Finite reflection groups</a></li><li><a class="tocitem" href="../coxgroups/">Coxeter groups</a></li><li><a class="tocitem" href="../weyl/">Finite Coxeter groups, Weyl groups, crystallographic root systems</a></li><li class="is-active"><a class="tocitem" href>Classes/characters of reflection groups</a></li></ul></li><li><span class="tocitem">Hecke algebras</span><ul><li><a class="tocitem" href="../hecke/">Hecke algebras</a></li><li><a class="tocitem" href="../kl/">Kazhdan-Lusztig polynomials and bases</a></li><li><a class="tocitem" href="../algebras/">Algebras</a></li></ul></li><li><a class="tocitem" href="../garside/">Garside monoids and groups, braids.</a></li><li><span class="tocitem">Reductive groups</span><ul><li><a class="tocitem" href="../rootdata/">Reductive algebraic groups and root data</a></li><li><a class="tocitem" href="../semisimple/">Semisimple elements</a></li><li><a class="tocitem" href="../cosets/">Reflection cosets and Spets</a></li><li><a class="tocitem" href="../sscoset/">Non-connected reductive groups</a></li><li><a class="tocitem" href="../uch/">Unipotent characters</a></li><li><a class="tocitem" href="../ct/">Classtypes</a></li></ul></li><li><span class="tocitem">Eigenspaces</span><ul><li><a class="tocitem" href="../eigen/">Eigenspaces</a></li><li><a class="tocitem" href="../dseries/">d-Harish-Chandra series</a></li></ul></li><li><span class="tocitem">Unipotent elements</span><ul><li><a class="tocitem" href="../ucl/">Unipotent classes of reductive groups</a></li><li><a class="tocitem" href="../urad/">Unipotent Elements</a></li></ul></li><li><a class="tocitem" href="../gendec/">Decomposition Matrices</a></li><li><a class="tocitem" href="../references/">References</a></li><li><a class="tocitem" href="../dict/">Dictionary from GAP3/Chevie</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reflection groups</a></li><li class="is-active"><a href>Classes/characters of reflection groups</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Classes/characters of reflection groups</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jmichel7/Chevie.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ï‚›</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jmichel7/Chevie.jl/blob/main/docs/src/chars.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ï„</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Classes/characters-of-reflection-groups"><a class="docs-heading-anchor" href="#Classes/characters-of-reflection-groups">Classes/characters of reflection groups</a><a id="Classes/characters-of-reflection-groups-1"></a><a class="docs-heading-anchor-permalink" href="#Classes/characters-of-reflection-groups" title="Permalink"></a></h1><ul><li><a href="#Chevie.Chars"><code>Chevie.Chars</code></a></li><li><a href="#Chevie.Chars.CharTable"><code>Chevie.Chars.CharTable</code></a></li><li><a href="#Chevie.Chars.J_induction_table"><code>Chevie.Chars.J_induction_table</code></a></li><li><a href="#Chevie.Chars.charinfo"><code>Chevie.Chars.charinfo</code></a></li><li><a href="#Chevie.Chars.charnames-Tuple{IO, Union{Coset, Group}}"><code>Chevie.Chars.charnames</code></a></li><li><a href="#Chevie.Chars.classinfo"><code>Chevie.Chars.classinfo</code></a></li><li><a href="#Chevie.Chars.classnames"><code>Chevie.Chars.classnames</code></a></li><li><a href="#Chevie.Chars.conjPerm"><code>Chevie.Chars.conjPerm</code></a></li><li><a href="#Chevie.Chars.decompose-Tuple{CharTable, AbstractVector}"><code>Chevie.Chars.decompose</code></a></li><li><a href="#Chevie.Chars.detPerm"><code>Chevie.Chars.detPerm</code></a></li><li><a href="#Chevie.Chars.fakedegrees"><code>Chevie.Chars.fakedegrees</code></a></li><li><a href="#Chevie.Chars.induction_table"><code>Chevie.Chars.induction_table</code></a></li><li><a href="#Chevie.Chars.j_induction_table"><code>Chevie.Chars.j_induction_table</code></a></li><li><a href="#Chevie.Chars.on_chars"><code>Chevie.Chars.on_chars</code></a></li><li><a href="#Chevie.Chars.representation-Tuple{Union{Spets, FiniteCoxeterGroup, PermRootGroup}, Integer}"><code>Chevie.Chars.representation</code></a></li><li><a href="#Chevie.Chars.representations-Tuple{Union{Spets, FiniteCoxeterGroup, PermRootGroup}}"><code>Chevie.Chars.representations</code></a></li><li><a href="#Chevie.Chars.schur_functor"><code>Chevie.Chars.schur_functor</code></a></li><li><a href="#Chevie.Symbols.fakedegree-Tuple{Any, Any, Any}"><code>Chevie.Symbols.fakedegree</code></a></li></ul><article><details class="docstring" open="true"><summary id="Chevie.Chars"><a class="docstring-binding" href="#Chevie.Chars"><code>Chevie.Chars</code></a> â€” <span class="docstring-category">Module</span></summary><section><div><p>Characters and conjugacy classes of complex reflection groups.</p><p>The  <a href="#Chevie.Chars.CharTable"><code>CharTable</code></a>  of  a  finite  complex  reflection  group  <code>W</code> is computed  using  the  decomposition  of  <code>W</code>  in  irreducible  groups,  see <a href="../permroot/#Chevie.PermRoot.refltype"><code>refltype</code></a>.  For an irreducible group the character table is either computed  using recursive formulas for the  infinite series, or read from a library  file  for  the  exceptional  types.  Thus, character tables can be obtained  quickly  even  for  very  large  groups  like <code>W(Eâ‚ˆ)</code> or <span>$ğ”–â‚â‚…$</span>. Similar remarks apply for conjugacy classes.</p><p>The  conjugacy  classes  and  irreducible  characters of irreducible finite complex  reflection groups  are labelled  by certain combinatorial objects; these  labels are shown in  the tables we give.  For the classes, these are partitions or partition tuples for the infinite series, or, for exceptional Coxeter  groups,  Carter&#39;s  admissible  diagrams  (<a href="../references/#car72">Carter, 1972</a>); for other primitive  complex reflection groups we just use words in the generators to specify  representatives of the  classes. For the  characters, these labels are  again partitions or partition tuples  for the infinite series, and for the  exceptional groups they are pairs of two integers <code>(d,b)</code> where <code>d</code> is the  degree of the character and <code>b</code> is the smallest symmetric power of the reflection  representation containing  the character  as a constituent (the valuation of the <a href="#Chevie.Symbols.fakedegree-Tuple{Any, Any, Any}">fakedegree</a>); further a <code>&#39;</code> or <code>&#39;&#39;</code> may be added to disambiguate  pairs with  the same  <code>(d,b)</code>. These  labels are shown by the functions   <a href="#Chevie.Chars.classinfo"><code>classinfo</code></a>  and   <a href="#Chevie.Chars.charinfo"><code>charinfo</code></a>.  Displaying  the character table also shows the labelings for classes and characters.</p><p>A  typical example is <code>coxgroup(:A,n)</code>,  the symmetric group <span>$ğ”–â‚™â‚Šâ‚$</span> where classes  and characters are parameterized by  partitions of <code>n+1</code> (the same table is shown for <code>coxsym(n+1)</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; CharTable(coxgroup(:A,3))
CharTable(Aâ‚ƒ)
â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    â”‚1111 211 22 31  4â”‚
â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚1111â”‚   1  -1  1  1 -1â”‚
â”‚211 â”‚   3  -1 -1  .  1â”‚
â”‚22  â”‚   2   .  2 -1  .â”‚
â”‚31  â”‚   3   1 -1  . -1â”‚
â”‚4   â”‚   1   1  1  1  1â”‚
â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

julia&gt; ct=CharTable(coxgroup(:G,2))
CharTable(Gâ‚‚)
â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     â”‚Aâ‚€ AÌƒâ‚ Aâ‚ Gâ‚‚ Aâ‚‚ Aâ‚+AÌƒâ‚â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚Ï†â‚â€šâ‚€ â”‚ 1  1  1  1  1     1â”‚
â”‚Ï†â‚â€šâ‚† â”‚ 1 -1 -1  1  1     1â”‚
â”‚Ï†â€²â‚â€šâ‚ƒâ”‚ 1  1 -1 -1  1    -1â”‚
â”‚Ï†â€³â‚â€šâ‚ƒâ”‚ 1 -1  1 -1  1    -1â”‚
â”‚Ï†â‚‚â€šâ‚ â”‚ 2  .  .  1 -1    -2â”‚
â”‚Ï†â‚‚â€šâ‚‚ â”‚ 2  .  . -1 -1     2â”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

julia&gt; charnames(ct,TeX=true)
6-element Vector{String}:
 &quot;\phi_{1,0}&quot;
 &quot;\phi_{1,6}&quot;
 &quot;\phi_{1,3}&#39;&quot;
 &quot;\phi_{1,3}&#39;&#39;&quot;
 &quot;\phi_{2,1}&quot;
 &quot;\phi_{2,2}&quot;

julia&gt; classnames(ct,TeX=true)
6-element Vector{String}:
 &quot;A_0&quot;
 &quot;\tilde A_1&quot;
 &quot;A_1&quot;
 &quot;G_2&quot;
 &quot;A_2&quot;
 &quot;A_1+\tilde A_1&quot;</code></pre><p>Reflection  groups  have  <code>fakedegrees</code>](@ref),  whose valuation and degree give  two  invariants  <code>b,B</code>  for  each  irreducible  character of <code>W</code>. For spetsial  groups (which include  finite Coxeter groups),  the valuation and degree  of the generic degrees of the  spetsial Hecke algebra give two more invariants  <code>a,A</code>; for Coxeter groups  see (<a href="../references/#car85">Carter, 1985</a>; chap.11) for more details.  These integers are used in the operations of truncated induction, see <a href="#Chevie.Chars.j_induction_table"><code>j_induction_table</code></a> and <a href="#Chevie.Chars.J_induction_table"><code>J_induction_table</code></a>.</p><p>Iwahori-Hecke  algebras and  cyclotomic Hecke  algebras also have character tables, see <a href="../hecke/#Chevie.HeckeAlgebras"><code>HeckeAlgebras</code></a>.</p><p>We  now describe for each type our conventions for labeling the classes and characters.</p><ul><li>Type <code>Aâ‚™</code> (<code>nâ‰¥0</code>). </li></ul><p>We  have  <span>$W(Aâ‚™)â‰…ğ”–â‚™â‚Šâ‚$</span>;  its  classes  and  characters  are  labelled  by partitions  of <code>n+1</code>. The partition labelling a  class is the cycle type of the  elements in that  class; the representative  word in the generators in <code>.classtext</code>  is the concatenation of the words corresponding to each part, where  the  word  for  a  part  <code>i</code>  is  the  product  of <code>i-1</code> consecutive generators  (starting  one  higher  than  the  last  generator used for the previous  parts). The partition labelling a character describes the type of the  Young  subgroup  such  that  the  trivial  character induced from this subgroup  contains that character with multiplicity <code>1</code> and such that every other character occurring in this induced character has a higher <code>a</code>-value. Thus,  the sign  character is  labelled by  the partition  <code>(1â¿âºÂ¹)</code> and the trivial character by the partition <code>(n+1)</code>. The character of the reflection representation of <code>W</code> is labelled by <code>(n,1)</code>.</p><ul><li>Type  <code>Bâ‚™</code>  (<code>nâ‰¥2</code>).  </li></ul><p>The group <code>W=W(Bâ‚™)</code> is isomorphic to the wreath product of the cyclic group of  order  <code>2</code>  with  the  symmetric  group <span>$ğ”–â‚™$</span>. Hence  the  classes and characters are parameterized by pairs of partitions such that the total sum of  their parts equals <code>n</code>. The pair corresponding to a class describes the signed  cycle type for the elements in that class, as in (<a href="../references/#car72">Carter, 1972</a>). We use  the convention that if <code>(Î»,Î¼)</code> is  such a pair then <code>Î»</code> corresponds to the  positive  and  <code>Î¼</code>  to  the  negative  cycles.  Thus,  <code>((1â¿),-)</code>  and <code>(-,(1â¿))</code>  label  respectively  the  trivial  class  and  the class of the longest element.</p><p>The  pair  corresponding  to  an  irreducible  character  is determined via Clifford  theory using the  semidirect product decomposition <span>$W(Bâ‚™)=Nâ‹Šğ”–â‚™$</span> where <code>N</code> is the standard <code>n</code>-dimensional <code>ğ”½â‚‚â¿</code>-vector space. For <code>a,b â‰¥ 0</code> such that <code>n=a+b</code> let <span>$Î·_{a,b}$</span> be the irreducible character of <code>N</code> which takes  value <code>1</code> on the first <code>a</code>  standard basis vectors and value <code>-1</code> on the  last <code>b</code> standard basis  vectors of <code>N</code>. Then  the inertia subgroup of <span>$Î·_{a,b}$</span>   has  the  form  <span>$T_{a,b}=Nâ‹Š(ğ”–_aÃ—ğ”–_b)$</span>  and  we  can  extend <span>$Î·_{a,b}$</span>   trivially  to   an  irreducible   character  <span>$Î·Ìƒ_{a,b}$</span>  of <span>$T_{a,b}$</span>. Let <code>Î±</code> and <code>Î²</code> be partitions of <code>a</code> and <code>b</code>, respectively. We take  the  tensor  product  of  the corresponding irreducible characters of <span>$ğ”–_a$</span>  and  <span>$ğ”–_b$</span>  and  regard  this  as  an  irreducible  character of <span>$T_{a,b}$</span>.  Multiplying this character with  <span>$Î·Ìƒ_{a,b}$</span> and inducing to <code>W(Bâ‚™)</code>  yields an irreducible character  <span>$Ï‡= Ï‡_{(Î±,Î²)}$</span> of <code>W(Bâ‚™)</code>. This defines  the  correspondence  between  irreducible  characters and pairs of partitions as above.</p><p>For example, the pair <code>((n),-)</code> labels the trivial character and <code>(-,(1â¿))</code> labels  the  sign  character.  The  character  of  the  natural  reflection representation is labeled by <code>((n-1),(1))</code>.</p><ul><li>Type  <code>Dâ‚™</code> (<code>nâ‰¥4</code>). </li></ul><p>The  group <code>W(Dâ‚™)</code>  can be  embedded as  a subgroup  of index  <code>2</code> into the Coxeter  group <code>W(Bâ‚™)</code>. The intersection of a class of <code>W(Bâ‚™)</code> with <code>W(Dâ‚™)</code> is  either empty or a single class in <code>W(Dâ‚™)</code> or splits up into two classes in <code>W(Dâ‚™)</code>. This also leads to a parameterization of the classes of <code>W(Dâ‚™)</code> by  pairs of partitions <code>(Î»,Î¼)</code> as before  but where the number of parts of <code>Î¼</code>  is even and where there  are two classes of this  type if <code>Î¼</code> is empty and all parts of <code>Î»</code> are even. In the latter case we denote the two classes in  <code>W(Dâ‚™)</code> by <code>(Î»,+)</code>  and <code>(Î»,-)</code>, where  we use the  convention that the class  labeled by <code>(Î»,+)</code> contains a representative which can be written as a word in <code>{sâ‚,sâ‚ƒ,â€¦,sâ‚™}</code> and <code>(Î»,-)</code> contains a representative which can be written as a word in <code>{sâ‚‚,sâ‚ƒ, â€¦,sâ‚™}</code>.</p><p>By  Clifford theory the restriction of  an irreducible character of <code>W(Bâ‚™)</code> to  <code>W(Dâ‚™)</code>  is  either  irreducible  or  splits  up  into  two irreducible components.  Let <code>(Î±,Î²)</code> be  a pair of  partitions with total  sum of parts equal to <code>n</code>. If <code>Î±!=Î²</code> then the restrictions of the irreducible characters of  <code>W(Bâ‚™)</code> labeled  by <code>(Î±,Î²)</code>  and <code>(Î²,Î±)</code>  are irreducible and equal. If <code>Î±=Î²</code>  then the restriction of the character labeled by <code>(Î±,Î±)</code> splits into two  irreducible components  which we  denote by  <code>(Î±,+)</code> and <code>(Î±,-)</code>. Note that  this can only happen if <code>n</code> is  even. In order to fix the notation we use  a result of (<a href="../references/#ste89">Stembridge, 1989</a>) which describes the value of the difference of  these two  characters on  a class  of the  form <code>(Î»,+)</code> in terms of the character  values of  the symmetric  group <span>$ğ”–_{n/2}$</span>.  Recall that  it is implicit  in the notation <code>(Î»,+)</code> that all  parts of <code>Î»</code> are even. Let <code>Î»&#39;</code> be  the partition of <code>n/2</code> obtained by  dividing each part by <code>2</code>. Then the value  of <span>$Ï‡_{(Î±,-)}-Ï‡_{(Î±,+)}$</span>  on an  element in  the class  <code>(Î»,+)</code> is given  by  <code>2^{k(Î»)}</code>  times  the  value  of  the  irreducible character of <span>$ğ”–_{n/2}$</span>  labeled by <code>Î±</code> on the class  of cycle type <code>Î»&#39;</code>. (Here, <code>k(Î»)</code> denotes the number of non-zero parts of <code>Î»</code>.)</p><p>The  labels for the trivial, the  sign and the natural reflection character are the same as for <code>W(Bâ‚™)</code>, since these characters are restrictions of the corresponding characters of <code>W(Bâ‚™)</code>.</p><ul><li>The groups <code>G(d,1,n)</code>.</li></ul><p>They are isomorphic to the wreath product <span>$Î¼_dâ‰€ğ”–â‚™$</span> of the cyclic group of order  <code>d</code> with the  symmetric group. Hence  the classes and characters are parameterized  by <code>d</code>-tuples of partitions such that the total sum of their parts  equals <code>n</code>. The words chosen  as representatives of the classes are, when <code>d&gt;2</code>, computed in a slightly different way than for <code>Bâ‚™</code>, in order to agree  with the words on which Ram  and Halverson compute the characters of the  Hecke algebra. First the parts of the <code>d</code> partitions are merged in one big  partition and sorted in  increasing order. Then, to  a part <code>i</code> coming from  the <code>j</code>-th partition is  associated the word <code>(l+1â€¦1â€¦ l+1)Ê²â»Â¹l+2â€¦l+i</code> where <code>l</code> is the highest generator used to express the previous part.</p><p>The  <code>d</code>-tuple corresponding to an  irreducible character is determined via Clifford  theory in  a similar  way than  for the  <code>Bâ‚™</code> case.  The identity character  has the first  partition with one  part equal <code>n</code>  and the other ones  empty. The character of the  reflection representations has the first two  partitions with one part  equal respectively to <code>n-1</code>  and to <code>1</code>, and the other partitions empty.</p><ul><li>The groups <code>G(de,e,n)</code>.</li></ul><p>They  are normal  subgroups of  index <code>e</code>  in <code>G(de,1,n)</code>.  The quotient is cyclic,  generated by the image <code>g</code>  of the first generator of <code>G(de,1,n)</code>. The  classes are parameterized as the  classes of <code>G(de,e,n)</code> with an extra information for a component of a class which splits.</p><p>According  to (<a href="../references/#hu85">Hugues, 1985</a>), a class <code>C</code>  of <code>G(de,1,n)</code> parameterized by a <code>de</code>-partition  <span>$(Sâ‚€,â€¦,S_{de-1})$</span> is in <code>G(de,e,n)</code> if <code>e</code> divides <span>$âˆ‘áµ¢ i âˆ‘_{pâˆˆ Sáµ¢}p$</span>. It splits in <code>d</code> classes for the largest <code>d</code> dividing <code>e</code> and all  parts of all <code>Sáµ¢</code> and  such that <code>Sáµ¢</code> is empty  if <code>d</code> does not divide <code>i</code>.  If <code>wâˆˆC</code> then <code>[gâ± w gâ»â± for i in 0:d-1]</code> are representatives of the classes  of <code>G(de,e,n)</code> which meet <code>C</code>.  They are labelled by appending the integer <code>i</code> to the label for <code>C</code>.</p><p>The  characters are described by Clifford theory. We make <code>g</code> act on labels for  characters of <code>G(de,1,n)</code>  . The action  of <code>g</code> permutes circularly by <code>d</code>  the partitions in the <code>de</code>-tuple.  A character has same restriction to <code>G(de,e,n)</code>  as its transform by <code>g</code>.  The number of irreducible components of its restriction is equal to the order <code>k</code> of its stabilizer under powers of  <code>g</code>.  We  encode  a  character  of  <code>G(de,e,n)</code>  by first, choosing the smallest  for lexicographical order label  of a character whose restriction contains  it; then this label is periodic with a motive repeated <code>k</code> times; we  represent the  character by  one of  these motives,  to which we append <code>E(k)â±</code> for <code>i in 0:k-1</code> to describe which component of the restriction we choose.</p><ul><li>Types <code>Gâ‚‚</code> and <code>Fâ‚„</code>. </li></ul><p>A character is labeled by a pair <code>(d,b)</code> where <code>d</code> denotes the degree and <code>b</code> the  corresponding <code>b</code>-invariant. If there  are several characters with the same pair <code>(d,b)</code> we attach a prime to them, as in (<a href="../references/#car85">Carter, 1985</a>).</p><p>The  matrices of  character values  and the  orderings and labelings of the irreducible characters are exactly the same as in (<a href="../references/#car85">Carter, 1985</a>; p.412â€“413):  in type <code>Gâ‚‚</code> the character  <code>Ï†â‚,â‚ƒ&#39;</code> takes the value -1 on  the reflection associated  to the long  simple root; in  type <code>Fâ‚„</code>, the characters  <code>Ï†â‚,â‚â‚‚&#39;</code>, <code>Ï†â‚‚,â‚„&#39;</code>,  <code>Ï†â‚„,â‚‡&#39;</code>, <code>Ï†â‚ˆ,â‚‰&#39;</code>  and <code>Ï†â‚‰,â‚†&#39;</code>  occur in the induced  of the  identity from  the <code>Aâ‚‚</code>  corresponding to the short simple roots;  the pairs (<code>Ï†â‚‚,â‚â‚†&#39;</code>, <code>Ï†â‚‚,â‚„â€³</code>) and (<code>Ï†â‚ˆ,â‚ƒ&#39;</code>, <code>Ï†â‚ˆ,â‚‰â€³</code>) are related by tensoring  by  sign;  and  finally  <code>Ï†â‚†,â‚†â€³</code>  is  the exterior square of the reflection  representation. Note, however, that we put the long root at the left  of the Dynkin  diagrams to be  in accordance with  the conventions in (<a href="../references/#lus85">Lusztig, 1985</a>; (4.8) and (4.10)).</p><p>The  classes are labeled by  Carter&#39;s admissible diagrams (<a href="../references/#car72">Carter, 1972</a>).</p><ul><li>Types  <code>Eâ‚†,Eâ‚‡,Eâ‚ˆ</code>. </li></ul><p>The  character tables are obtained by  specialization of those of the Hecke algebra.   The  classes   are  labeled   by  Carter&#39;s  admissible  diagrams (<a href="../references/#car72">Carter, 1972</a>).  A  character  is  labeled  by  the  pair <code>(d,b)</code> where <code>d</code> denotes  the degree and  <code>b</code> is the  corresponding <code>b</code>-invariant. For these types, this gives a unique labeling of the characters.</p><ul><li>Non-crystallographic  types <code>Iâ‚‚(m)</code>, <code>Hâ‚ƒ</code>, <code>Hâ‚„</code>. </li></ul><p>In these cases we do not have canonical labelings for the classes. We label them by reduced expressions.</p><p>Each  character for  type <code>Hâ‚ƒ</code>  is uniquely  determined by the pair <code>(d,b)</code> where  <code>d</code> is the degree and  <code>b</code> the corresponding <code>b</code>-invariant. For type <code>Hâ‚„</code>  there are just  two characters (those  of degree <code>30</code>)  for which the corresponding  pairs are  the same.  These two  characters are nevertheless distinguished  by  their  fake  degrees:  the  character <code>Ï†â‚ƒâ‚€,â‚â‚€&#39;</code> has fake degree  <code>qÂ¹â°+qÂ¹Â²+</code> higher terms, while <code>Ï†â‚ƒâ‚€,â‚â‚€â€³</code> has fake degree <code>qÂ¹â°+qÂ¹â´+</code> higher  terms. The characters in the table for type <code>Hâ‚„</code> are ordered in the same way as in (<a href="../references/#al82">Alvis and Lusztig, 1982</a>).</p><p>Finally,  the characters  of degree <code>2</code>  for type  <code>Iâ‚‚(m)</code> are  ordered as follows.  The matrix representations affording the characters of degree <code>2</code> are given by: <span>$Ï_j : sâ‚sâ‚‚ â†¦ \begin{pmatrix}\zeta_m^j&amp;0\\0&amp;\zeta_m^{-j}\end{pmatrix},  sâ‚â†¦\begin{pmatrix}0&amp;1\\1&amp;0\end{pmatrix},$</span> where  <span>$1 â‰¤ j â‰¤  âŒŠ(m-1)/2âŒ‹$</span>. The reflection representation is  <code>Ïâ‚</code>. The  characters in  the table  are ordered by listing first the characters of degree 1 and then <code>Ïâ‚,Ïâ‚‚,â€¦</code>.</p><p><strong>Primitive complex reflection groups <code>Gâ‚„</code> to <code>Gâ‚ƒâ‚„</code>.</strong></p><p>The  groups <code>Gâ‚‚â‚ƒ=Hâ‚ƒ</code>, <code>Gâ‚‚â‚ˆ=Fâ‚„</code>, <code>Gâ‚ƒâ‚€=Hâ‚„</code> are exceptional Coxeter groups and have  been  explained  above.  Similarly  for  the  other groups labels for characters  consist primarily  of the  pair <code>(d,b)</code>  where <code>d</code>  denotes the degree  and <code>b</code> is the corresponding  <code>b</code>-invariant. This is sufficient for <code>Gâ‚„</code>,  <code>Gâ‚â‚‚</code>, <code>Gâ‚‚â‚‚</code> and <code>Gâ‚‚â‚„</code>. For other  groups there are pairs or triples of  characters which  have the  same <code>(d,b)</code>  value. We  disambiguate these according to the conventions of (<a href="../references/#mal00">Malle, 2000</a>) for <code>Gâ‚‚â‚‡, Gâ‚‚â‚‰, Gâ‚ƒâ‚, Gâ‚ƒâ‚ƒ</code> and <code>Gâ‚ƒâ‚„</code>:</p><ul><li>For <code>Gâ‚‚â‚‡</code>:</li></ul><p>The  fake degree  of <code>Ï†â‚ƒ,â‚…&#39;</code>  (resp. <code>Ï†â‚ƒ,â‚‚â‚€&#39;</code>,  <code>Ï†â‚ˆ,â‚‰â€³</code>) has smaller degree that  of  <code>Ï†â‚ƒ,â‚…â€³</code>  (resp.  <code>Ï†â‚ƒ,â‚‚â‚€â€³</code>,  <code>Ï†â‚ˆ,â‚‰&#39;</code>). The characters <code>Ï†â‚…,â‚â‚…&#39;</code> and <code>Ï†â‚…,â‚†&#39;</code> occur with multiplicity 1 in the induced from the trivial character of  the parabolic subgroup  of type <code>Aâ‚‚</code>  generated by the  first and third generator  (it is asserted  mistakenly in (<a href="../references/#mal00">Malle, 2000</a>)  that <code>Ï†â‚…,â‚†â€³</code> does not occur in this induced; it occurs with multiplicity 2).</p><ul><li>For <code>Gâ‚‚â‚‰</code>:</li></ul><p>The  character  <code>Ï†â‚†,â‚â‚€â€´</code>  is  the  exterior  square  of <code>Ï†â‚„,â‚</code>; its complex conjugate  is <code>Ï†â‚†,â‚â‚€â—</code>. The  character <code>Ï†â‚â‚…,â‚„â€³</code> occurs  in <code>Ï†â‚„,â‚âŠ—Ï†â‚„,â‚ƒ</code>; the character  <code>Ï†â‚â‚…,â‚â‚‚â€³</code>  is  tensored  by  the  sign  character from <code>Ï†â‚â‚…,â‚„â€³</code>. Finally  <code>Ï†â‚†,â‚â‚€&#39;</code> occurs in  the induced from  the trivial character of the standard parabolic subgroup of type <code>Aâ‚ƒ</code> generated by the first, second and fourth generators.</p><ul><li>For <code>Gâ‚ƒâ‚</code>:</li></ul><p>The  characters <code>Ï†â‚â‚…,â‚ˆ&#39;</code>, <code>Ï†â‚â‚…,â‚‚â‚€&#39;</code> and <code>Ï†â‚„â‚…,â‚ˆâ€³</code> occur in <code>Ï†â‚„,â‚âŠ—Ï†â‚‚â‚€,â‚‡</code>; the character   <code>Ï†â‚‚â‚€,â‚â‚ƒ&#39;</code>  is  complex  conjugate  of  <code>Ï†â‚‚â‚€,â‚‡</code>;  the  character <code>Ï†â‚„â‚…,â‚â‚‚&#39;</code>  is tensored by sign of <code>Ï†â‚„â‚…,â‚ˆ&#39;</code>. The two terms of maximal degree of  the fakedegree of <code>Ï†â‚ƒâ‚€,â‚â‚€&#39;</code> are  <code>qâµâ°+qâ´â¶</code> while for <code>Ï†â‚ƒâ‚€,â‚â‚€â€³</code> they are <code>qâµâ°+2qâ´â¶</code>.</p><ul><li>For <code>Gâ‚ƒâ‚ƒ</code>:</li></ul><p>The two terms of maximal degree of the fakedegree of <code>Ï†â‚â‚€,â‚ˆ&#39;</code> are <code>qÂ²â¸+qÂ²â¶</code> while  for <code>Ï†â‚â‚€,â‚ˆâ€³</code> they are <code>qÂ²â¸+qÂ²â´</code>. The  terms of maximal degree of the fakedegree   of  <code>Ï†â‚„â‚€,â‚…&#39;</code>  are  <code>qÂ³Â¹+qÂ²â¹</code>   while  for  <code>Ï†â‚„â‚€,â‚…â€³</code>  they  are <code>qÂ³Â¹+2qÂ²â¹</code>.  The character  <code>Ï†â‚â‚€,â‚â‚‡&#39;</code> is  tensored by  sign of <code>Ï†â‚â‚€,â‚ˆ&#39;</code> and <code>Ï†â‚„â‚€,â‚â‚„&#39;</code> is tensored by sign of <code>Ï†â‚„â‚€,â‚…&#39;</code>.</p><ul><li>For <code>Gâ‚ƒâ‚„</code>:</li></ul><p>The  character <code>Ï†â‚‚â‚€,â‚ƒâ‚ƒ&#39;</code> occurs in <code>Ï†â‚†,â‚âŠ—Ï†â‚â‚…,â‚â‚„</code>. The character <code>Ï†â‚‡â‚€,â‚‰&#39;</code> is rational.  The character  <code>Ï†â‚‡â‚€,â‚‰â€³</code> occurs  in <code>Ï†â‚†,â‚âŠ—Ï†â‚â‚…,â‚â‚„</code>.  The character <code>Ï†â‚‡â‚€,â‚„â‚…&#39;</code>   is  rational.The   character  <code>Ï†â‚‡â‚€,â‚„â‚…â€³</code>   is  tensored  by  the determinant  character of  <code>Ï†â‚‡â‚€,â‚‰â€³</code>. The  character <code>Ï†â‚…â‚†â‚€,â‚â‚ˆ&#39;</code> is rational. The character <code>Ï†â‚…â‚†â‚€,â‚â‚ˆâ€´</code> occurs in <code>Ï†â‚†,â‚âŠ—Ï†â‚ƒâ‚ƒâ‚†,â‚â‚‡</code>. The character <code>Ï†â‚‚â‚ˆâ‚€,â‚â‚‚&#39;</code> occurs    in   <code>Ï†â‚†,â‚âŠ—Ï†â‚ƒâ‚ƒâ‚†,â‚â‚‡</code>.   The   character   <code>Ï†â‚‚â‚ˆâ‚€,â‚ƒâ‚€â€³</code>   occurs   in <code>Ï†â‚†,â‚âŠ—Ï†â‚ƒâ‚ƒâ‚†,â‚â‚‡</code>.  The  character  <code>Ï†â‚…â‚„â‚€,â‚‚â‚&#39;</code>  occurs  in <code>Ï†â‚†,â‚âŠ—Ï†â‚â‚€â‚…,â‚‚â‚€</code>. The character  <code>Ï†â‚â‚€â‚…,â‚ˆ&#39;</code> is  complex conjugate  of <code>Ï†â‚â‚€â‚…,â‚„</code>,  and <code>Ï†â‚ˆâ‚„â‚€,â‚â‚ƒ&#39;</code> is complex  conjugate  of  <code>Ï†â‚ˆâ‚„â‚€,â‚â‚</code>.  The  character  <code>Ï†â‚ˆâ‚„â‚€,â‚‚â‚ƒ&#39;</code>  is  complex conjugate  of  <code>Ï†â‚ˆâ‚„â‚€,â‚â‚‰</code>.  Finally  <code>Ï†â‚â‚‚â‚€,â‚‚â‚&#39;</code>  occurs  in induced from the trivial character of the standard parabolic subgroup of type <code>Aâ‚…</code> generated by the generators of <code>Gâ‚ƒâ‚„</code> with the third one omitted.</p><p>For  the groups <code>Gâ‚…</code> and <code>Gâ‚‡</code> we  adopt the following conventions. For <code>Gâ‚…</code> they are compatible with those of (<a href="../references/#mr03">Malle and Rouquier, 2003</a>) and (<a href="../references/#bmm14">BrouÃ© <em>et al.</em>, 2014</a>).</p><ul><li>For <code>Gâ‚…</code>:</li></ul><p>We  let <code>W=complex_reflection_group(5)</code>,  so the  generators are  <code>W(1)</code> and <code>W(2)</code>.</p><p>The  character <code>Ï†â‚,â‚„&#39;</code> (resp. <code>Ï†â‚,â‚â‚‚&#39;</code>, <code>Ï†â‚‚,â‚ƒ&#39;</code>) takes the value <code>1</code> (resp. <code>Î¶â‚ƒ</code>,  <code>-Î¶â‚ƒ</code>)  on  <code>W(1)</code>.  The  character  <code>Ï†â‚,â‚ˆâ€³</code> is complex conjugate to <code>Ï†â‚,â‚â‚†</code>,  and the character  <code>Ï†â‚,â‚ˆ&#39;</code> is complex  conjugate to <code>Ï†â‚,â‚„&#39;</code> . The character  <code>Ï†â‚‚,â‚…â€³</code> is complex conjugate to  <code>Ï†â‚‚,â‚</code>; <code>Ï†â‚‚,â‚…&#39;</code> takes the value <code>-1</code> on <code>W(1)</code>. The character <code>Ï†â‚‚,â‚‡&#39;</code> is complex conjugate to <code>Ï†â‚‚,â‚…&#39;</code>.</p><ul><li>For <code>Gâ‚‡</code>:</li></ul><p>We  let <code>W=complex_reflection_group(7)</code>,  so the  generators are <code>W(1)</code>, <code>W(2)</code> and <code>W(3)</code>.</p><p>The  characters  <code>Ï†â‚,â‚„&#39;</code>  and  <code>Ï†â‚,â‚â‚€&#39;</code>  take  the value <code>1</code> on <code>W(2)</code>. The character  <code>Ï†â‚,â‚ˆâ€³</code> is complex  conjugate to <code>Ï†â‚,â‚â‚†</code>  and <code>Ï†â‚,â‚ˆ&#39;</code> is complex conjugate  to <code>Ï†â‚,â‚„&#39;</code>. The characters <code>Ï†â‚,â‚â‚‚&#39;</code>  and <code>Ï†â‚,â‚â‚ˆ&#39;</code> take the value <code>Î¶â‚ƒ</code>  on <code>W(2)</code>. The character <code>Ï†â‚,â‚â‚„â€³</code> is complex conjugate to <code>Ï†â‚,â‚‚â‚‚</code> and <code>Ï†â‚,â‚â‚„&#39;</code>  is complex conjugate to <code>Ï†â‚,â‚â‚€&#39;</code>. The character <code>Ï†â‚‚,â‚ƒ&#39;</code> takes the value  <code>-Î¶â‚ƒ</code> on  <code>W(2)</code> and  <code>Ï†â‚‚,â‚â‚ƒ&#39;</code> takes  the value  <code>-1</code> on <code>W(2)</code>. The characters  <code>Ï†â‚‚,â‚â‚â€³</code>, <code>Ï†â‚‚,â‚…â€³</code>, <code>Ï†â‚‚,â‚‡â€´</code> and  <code>Ï†â‚‚,â‚</code> are Galois conjugate, as well  as  the  characters  <code>Ï†â‚‚,â‚‡&#39;</code>,  <code>Ï†â‚‚,â‚â‚ƒ&#39;</code>,  <code>Ï†â‚‚,â‚â‚&#39;</code>  and  <code>Ï†â‚‚,â‚…&#39;</code>. The character  <code>Ï†â‚‚,â‚‰&#39;</code> is complex  conjugate to <code>Ï†â‚‚,â‚â‚…</code>  and <code>Ï†â‚‚,â‚‰â€´</code> is complex conjugate to <code>Ï†â‚‚,â‚ƒ&#39;</code>.</p><p>Finally,  for the remaining groups <code>Gâ‚†, Gâ‚ˆ</code>  to <code>Gâ‚â‚, Gâ‚â‚ƒ</code> to <code>Gâ‚‚â‚</code>, <code>Gâ‚‚â‚…</code>, <code>Gâ‚‚â‚†</code>,  <code>Gâ‚ƒâ‚‚</code> and <code>Gâ‚ƒâ‚ƒ</code> there are only  pairs of characters with same value <code>(d,b)</code>.  We give labels uniformly to these characters by applying in order the following rules :</p><ul><li><p>If the two characters have  different fake degrees, label <code>Ï†_{d,b}&#39;</code> the  one  whose  fake  degree  is  minimal  for  the  lexicographic  order of  polynomials (starting with the highest term).</p></li><li><p>For the not yet labeled pairs, if only one of the two characters has the  property   that  in  its   Galois  orbit  at   least  one  character  is  distinguished by its <code>(d,b)</code>-invariant, label it <code>Ï†_{d,b}&#39;</code>.</p></li><li><p>For the not yet labeled pairs,  if the minimum of the <code>(d,b)</code>-value (for  the  lexicographic  order  <code>(d,b)</code>)  in  the  Galois  orbits  of the two  character  is different, label <code>Ï†_{d,b}&#39;</code> the character with the minimal  minimum.</p></li><li><p>We define now a new invariant <code>t</code> for a character <code>Ï†</code>: consider all the  pairs of irreducible characters <code>Ï‡</code> and <code>Ïˆ</code> uniquely determined by their  <code>(d,b)</code>-invariant such that <code>Ï†</code> occurs with non-zero multiplicity <code>m</code> in  <code>Ï‡âŠ—Ïˆ</code>.  We define  <code>t(Ï†)</code> to  be the  minimal (for  lexicographic order)  possible list <code>(d(Ï‡),b(Ï‡),d(Ïˆ),b(Ïˆ),m)</code>.</p></li></ul><p>For  the not  yet labeled  pairs, if  the t-invariants are different, label <code>Ï†_{d,b}&#39;</code> the character with the minimal <code>t</code>-invariant.</p><p>After  applying  the  last  rule  all  the  pairs  will be labelled for the considered  groups. The labelling obtained  is compatible for <code>Gâ‚‚â‚…</code>, <code>Gâ‚‚â‚†</code>, <code>Gâ‚ƒâ‚‚</code>  and  <code>Gâ‚ƒâ‚ƒ</code>  with  that  of  (<a href="../references/#mal00">Malle, 2000</a>)  and  for  <code>Gâ‚ˆ</code> with that described in (<a href="../references/#mr03">Malle and Rouquier, 2003</a>).</p><p>We  should  emphasize  that  for  all  groups  with  a  few exceptions, the parameters  for characters do  not depend on  any non-canonical choice. The exceptions  are <code>G(de,e,n)</code> with <code>e&gt;1</code>, and <code>Gâ‚…</code>, <code>Gâ‚‡</code>, <code>Gâ‚‚â‚‡</code>, <code>Gâ‚‚â‚ˆ</code>, <code>Gâ‚‚â‚‰</code> and  <code>Gâ‚ƒâ‚„</code>, groups  which admit  outer automorphisms  preserving the set of reflections,  so choices  of a  particular value  on a particular generator must be made for characters which are not invariant by these automorphisms.</p><ul><li>Labels  for the classes. </li></ul><p>For  the exceptional complex reflection groups,  the labels for the classes represent  the decomposition of a representative  of the class as a product of  generators,  with  the  additional  conventions that <code>z</code> represents the generator  of the  center and  for well-generated  groups <code>c</code>  represents a Coxeter element (a product of the generators which is a regular element for the highest reflection degree).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/91d5d058448089756f0709d051bcaa8750b4620e/src/Chars.jl#L1-L393">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Chars.CharTable"><a class="docstring-binding" href="#Chevie.Chars.CharTable"><code>Chevie.Chars.CharTable</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><p>CharTable is a structure to hold character tables of groups and Hecke  algebras</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/91d5d058448089756f0709d051bcaa8750b4620e/src/Chars.jl#L1119-L1122">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Chars.decompose-Tuple{CharTable, AbstractVector}"><a class="docstring-binding" href="#Chevie.Chars.decompose-Tuple{CharTable, AbstractVector}"><code>Chevie.Chars.decompose</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><p><code>decompose(ct::CharTable,c::Vector;exact=true)</code></p><p>decompose  class function <code>c</code> (given by its values on conjugacy classes) on irreducible  characters as  given by  <code>CharTable</code> <code>ct</code>.  By default  <code>c</code> is expected to be a virtual character so the result will be an integer vector. If  <code>c</code> is not a virtual character  give the keyword <code>exact=false</code> to get a correct result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/91d5d058448089756f0709d051bcaa8750b4620e/src/Chars.jl#L1226-L1234">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Chars.on_chars"><a class="docstring-binding" href="#Chevie.Chars.on_chars"><code>Chevie.Chars.on_chars</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><p><code>on_chars(G,aut)</code></p><p><code>aut</code>  is an automorphism of  the group <code>G</code> (for  a permutation group, this could  be  given  as  a  permutation  normalizing  <code>G</code>).  The result is the permutation of the indices of the irreducible characters induced by <code>aut</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; WF=rootdatum(&quot;3D4&quot;)
Â³Dâ‚„

julia&gt; on_chars(Group(WF),WF.phi)
(1,2,7)(8,9,12)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/91d5d058448089756f0709d051bcaa8750b4620e/src/Chars.jl#L1346-L1359">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Chars.charinfo"><a class="docstring-binding" href="#Chevie.Chars.charinfo"><code>Chevie.Chars.charinfo</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><p><code>charinfo(W)</code></p><p>returns   information  about  the  irreducible  characters  of  the  finite reflection group or Spets <code>W</code>. The result is an object with various entries describing  properties of  the irreducible  characters of  <code>W</code>. This object prints  at the  Repl or  in Pluto  or Jupyter  as a table synthesizing most information.</p><p>A  field  not  printed  is  <code>.charparams</code>:  it  contains parameters for the irreducible  characters.  A  parameter  is  a  list  with one item for each irreducible  component of <code>W</code> (as given  by <code>refltype</code>). For an irreducible <code>W</code> see the explanation in <a href="#Chevie.Chars"><code>Chars</code></a> for what are the parameters.</p><pre><code class="language-julia-repl hljs">julia&gt; charinfo(coxgroup(:G,2)).charparams
6-element Vector{Vector{Vector{Int64}}}:
 [[1, 0]]
 [[1, 6]]
 [[1, 3, 1]]
 [[1, 3, 2]]
 [[2, 1]]
 [[2, 2]]</code></pre><pre><code class="language-julia-repl hljs">julia&gt; charinfo(coxgroup(:G,2))
â”Œâ”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚n0â”‚ name ext b B a A spaltenstein lusztig              symbolâ”‚
â”œâ”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚1 â”‚ Ï†â‚â€šâ‚€  Id 0 0 0 0            1       1       (0,0,0,0,0,2)â”‚
â”‚2 â”‚ Ï†â‚â€šâ‚† det 6 6 6 6            Îµ       Îµ (01,01,01,01,01,12)â”‚
â”‚3 â”‚Ï†â€²â‚â€šâ‚ƒ     3 3 1 5           Îµâ‚—      Îµâ€²            (0,0,1+)â”‚
â”‚4 â”‚Ï†â€³â‚â€šâ‚ƒ     3 3 1 5          Îµ_c      Îµâ€³            (0,0,1-)â”‚
â”‚5 â”‚ Ï†â‚‚â€šâ‚  Î›Â¹ 1 5 1 5           Î¸â€²      Î¸â€²       (0,0,0,0,1,1)â”‚
â”‚6 â”‚ Ï†â‚‚â€šâ‚‚     2 4 1 5           Î¸â€³      Î¸â€³       (0,0,0,1,0,1)â”‚
â””â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre><p>In  the table printed  at the Repl,  the columns reflect  various fields of <code>charinfo</code>.  The  column  <code>name</code>  reflects  the  field <code>.charnames</code>, a name computed  from <code>.charparams</code>. This  is the same  as <code>charnames(io,W)</code> where here <code>io</code> being the Repl has the property <code>:limit</code> true.</p><p>The   column   <code>ext</code>   shows   the   exterior   powers  of  the  reflection representation.  It corresponds  to the  field <code>.extrefl</code>  which is present only  if <code>W</code>  is irreducible.  Otherwise, only  two items  are shown in the column:  <code>Id</code> corresponds to the field  <code>.positionId</code> and shows the trivial character.  <code>det</code>  corresponds  to  the  field <code>.positionDet</code> and shows the determinant  character (for Coxeter groups the sign character). When <code>W</code> is irreducible,  the characters marked  <code>Î›â±</code> are the  <code>i</code>-th exterior power of the  reflection  representation.  They  are  irreducible  by  a  theorem of Steinberg.</p><p>The  column  <code>b</code>  shows  the  field  <code>.b</code>  listing  for  each character the valuation  of the fake degree, and the column <code>B</code> shows the field <code>.B</code>, the degree of the fake degree.</p><p>The  columns <code>a</code> and  <code>A</code> only appear  for Spetsial groups. They correspond then  to the fields  <code>.a</code> and <code>.A</code>,  and contain respectively the valuation and the degree of the generic degree of the character (in the one-parameter Hecke algebra <code>hecke(W,Pol())</code> for <code>W</code>).</p><p>For  irreducible  groups,  the  table  shows  sometimes additional columns, corresponding to a field of the same name.</p><p>for  <code>Fâ‚„</code>,  the  column  <code>kondo</code>  gives  the  labeling of the characters in (<a href="../references/#kon65">Kondo, 1965</a>). The columns <code>spaltenstein</code> and <code>lusztig</code> show variants used in (<a href="../references/#spalt85">Spaltenstein, 1985</a>) and (<a href="../references/#lus85">Lusztig, 1985</a>; (4.10)).</p><p>for <code>Eâ‚†, Eâ‚‡, Eâ‚ˆ</code> the column <code>frame</code> gives the labeling of the characters in (<a href="../references/#frame51">Frame, 1951</a>; <a href="../references/#frame70">Frame, 1970</a>), also used in (<a href="../references/#lus85">Lusztig, 1985</a>; (4.11) to (4.13)).</p><p>for  <code>Gâ‚‚</code> the  column <code>spaltenstein</code>  gives the  labeling of the characters used  by (<a href="../references/#spalt85">Spaltenstein, 1985</a>) and the column  <code>lusztig</code> shows a variant used in (<a href="../references/#lus85">Lusztig, 1985</a>).</p><p>for  <code>Hâ‚ƒ</code> and <code>Hâ‚„</code> the  column <code>gp</code>  gives the  labeling of the characters used  in (<a href="../references/#gp2000">Geck and Pfeiffer, 2000</a>).</p><p>for <code>G(de,e,2)</code> even <code>e</code> and <code>d&gt;1</code>, the column <code>malle</code> gives the parameters for the characters used in (<a href="../references/#mal96">Malle, 1994</a>).</p><p>If  <code>W</code>  is  irreducible  spetsial  and  imprimitive,  the  column <code>symbol</code> (corresponding  to the field  <code>.charSymbols</code>) shows the  symbol attached to the corresponding unipotent caracter.</p><p>If  <code>W  isa  Spets</code>,  the  column  <code>restr.</code>  (corresponding  to  the  field <code>.charRestrictions</code>)  gives  the  index  of  the corresponding character of <code>Group(W)</code>.</p><p>Finally,  the  field  <code>.hgal</code>  contains  the  permutation of the characters resulting  from a Galois  action on the  characters of <code>H=hecke(W,Pol()^e)</code> where  <code>e</code> is the order of  the center of <code>W</code>. <code>H</code>  splits by taking <code>v</code> an <code>e</code>-th root of <code>Pol()</code>, and <code>.hgal</code> records the permutation effected by the Galois action <code>v-&gt;E(e)*v</code> (<code>charinfo</code> does not have the key <code>:hgal</code> if this permutation   is  trivial).  <code>.hgal*conj</code>,  where  <code>conj</code>  is  the  complex conjugaison, is the Opdam involution.</p><pre><code class="language-julia-repl hljs">julia&gt; charinfo(complex_reflection_group(24))
â”Œâ”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚n0â”‚ name ext  b  B  a  Aâ”‚
â”œâ”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚1 â”‚ Ï†â‚â€šâ‚€  Id  0  0  0  0â”‚
â”‚2 â”‚Ï†â‚â€šâ‚‚â‚ det 21 21 21 21â”‚
â”‚3 â”‚ Ï†â‚ƒâ€šâ‚ˆ      8 18  8 20â”‚
â”‚4 â”‚ Ï†â‚ƒâ€šâ‚  Î›Â¹  1 11  1 13â”‚
â”‚5 â”‚Ï†â‚ƒâ€šâ‚â‚€  Î›Â² 10 20  8 20â”‚
â”‚6 â”‚ Ï†â‚ƒâ€šâ‚ƒ      3 13  1 13â”‚
â”‚7 â”‚ Ï†â‚†â€šâ‚‚      2 12  1 13â”‚
â”‚8 â”‚ Ï†â‚†â€šâ‚‰      9 19  8 20â”‚
â”‚9 â”‚ Ï†â‚‡â€šâ‚†      6 18  6 18â”‚
â”‚10â”‚ Ï†â‚‡â€šâ‚ƒ      3 15  3 15â”‚
â”‚11â”‚ Ï†â‚ˆâ€šâ‚„      4 16  4 17â”‚
â”‚12â”‚ Ï†â‚ˆâ€šâ‚…      5 17  4 17â”‚
â””â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
hgal=(11,12)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/91d5d058448089756f0709d051bcaa8750b4620e/src/Chars.jl#L595-L712">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Chars.charnames-Tuple{IO, Union{Coset, Group}}"><a class="docstring-binding" href="#Chevie.Chars.charnames-Tuple{IO, Union{Coset, Group}}"><code>Chevie.Chars.charnames</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><p><code>charnames(W;options...)</code> or <code>charnames(io::IO,W)</code></p><p>returns  the list of character names for  the reflection group or Spets <code>W</code> (<code>W</code>  could also  be a  <code>CharTable</code> or  <code>CharInfo</code>). The  options may imply alternative  names in certain cases, or  a different formatting of names in general.  They are specified by <code>IO</code> attributes  if giving an <code>IO</code> as first argument.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
Gâ‚‚

julia&gt; charnames(W;limit=true)
6-element Vector{String}:
 &quot;Ï†â‚â€šâ‚€&quot;
 &quot;Ï†â‚â€šâ‚†&quot;
 &quot;Ï†â€²â‚â€šâ‚ƒ&quot;
 &quot;Ï†â€³â‚â€šâ‚ƒ&quot;
 &quot;Ï†â‚‚â€šâ‚&quot;
 &quot;Ï†â‚‚â€šâ‚‚&quot;

julia&gt; charnames(W;TeX=true)
6-element Vector{String}:
 &quot;\phi_{1,0}&quot;
 &quot;\phi_{1,6}&quot;
 &quot;\phi_{1,3}&#39;&quot;
 &quot;\phi_{1,3}&#39;&#39;&quot;
 &quot;\phi_{2,1}&quot;
 &quot;\phi_{2,2}&quot;

julia&gt; charnames(W;spaltenstein=true,limit=true)
6-element Vector{String}:
 &quot;1&quot;
 &quot;Îµ&quot;
 &quot;Îµâ‚—&quot;
 &quot;Îµ_c&quot;
 &quot;Î¸â€²&quot;
 &quot;Î¸â€³&quot;

julia&gt; charnames(W;spaltenstein=true,TeX=true)
6-element Vector{String}:
 &quot;1&quot;
 &quot;\varepsilon&quot;
 &quot;\varepsilon_l&quot;
 &quot;\varepsilon_c&quot;
 &quot;\theta&#39;&quot;
 &quot;\theta&#39;&#39;&quot;</code></pre><p>The  last two commands  show the character  names used in (<a href="../references/#spalt85">Spaltenstein, 1985</a>). Other  keywords  available  are  <code>frame,  kondo,  malle,  gp, lusztig</code>, see <a href="#Chevie.Chars.charinfo"><code>charinfo</code></a> for a description.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/91d5d058448089756f0709d051bcaa8750b4620e/src/Chars.jl#L1575-L1627">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Chars.classnames"><a class="docstring-binding" href="#Chevie.Chars.classnames"><code>Chevie.Chars.classnames</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><p><code>classnames(W;options...)</code> or <code>classnames(io::IO,W)</code></p><p>returns  the list of class names for the reflection group <code>W</code> (<code>W</code> may also be  a <code>CharTable</code> or  the result of  <code>classinfo</code>). The optional options are IOContext  attributes which can give alternative names in certain cases, or a different formatting of names in general. They can be specified by giving an IO as argument.</p><pre><code class="language-julia-repl hljs">julia&gt; classnames(coxgroup(:G,2),TeX=true)
6-element Vector{String}:
 &quot;A_0&quot;
 &quot;\tilde A_1&quot;
 &quot;A_1&quot;
 &quot;G_2&quot;
 &quot;A_2&quot;
 &quot;A_1+\tilde A_1&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/91d5d058448089756f0709d051bcaa8750b4620e/src/Chars.jl#L1657-L1675">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Chars.classinfo"><a class="docstring-binding" href="#Chevie.Chars.classinfo"><code>Chevie.Chars.classinfo</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><p><code>classinfo(W)</code></p><p>returns  information about the  conjugacy classes of  the finite reflection group or Spets <code>W</code>. The result is an object with various entries describing properties  of the conjugacy classes of <code>W</code>. This object prints at the Repl or in Pluto or Jupyter as a table synthesizing most information.</p><p>A field not shown in the table is <code>.classparams</code>, containing parameters for the  conjugacy classes. Each parameter  is a vector which  has one item for each  irreducible  component  of  <code>W</code>.  For  what are the parameters for an irreducible <code>W</code>, see the description for each type in <a href="#Chevie.Chars"><code>Chars</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; classinfo(coxgroup(:A,2))
â”Œâ”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚n0â”‚name length order wordâ”‚
â”œâ”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚1 â”‚ 111      1     1    .â”‚
â”‚2 â”‚  21      3     2    1â”‚
â”‚3 â”‚   3      2     3   12â”‚
â””â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre><p>The table contains the columns:</p><ul><li><code>name</code>, corresponding to the field <code>.classnames</code>:  strings describing the conjugacy classes, made out of the information in <code>:classparams</code>.</li><li><code>length</code>, corresponding to the field <code>.classes</code>, is the number of elements in the conjugacy class.</li><li><code>order</code>, corresponding to the field <code>.orders</code>, is the order of elements in the conjugacy class.</li><li><code>word</code>, corresponding to the field <code>.classtext</code>, describes a word in the  generators for the  representatives of each  conjugacy class. Each word is a list of integers where the generator <code>W(i)</code> is represented by the  integer  <code>i</code>.  For  finite  Coxeter  groups,  it  is  the  same as <code>word.(Ref(W),classreps(W))</code>,   and  each  such  representative  is  of minimal  length in its conjugacy class and  is a &quot;very good&quot; element in the sense of (<a href="../references/#gm97">Geck and Michel, 1997</a>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/91d5d058448089756f0709d051bcaa8750b4620e/src/Chars.jl#L880-L917">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Symbols.fakedegree-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#Chevie.Symbols.fakedegree-Tuple{Any, Any, Any}"><code>Chevie.Symbols.fakedegree</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><p><code>fakedegree(W, Ï†, q=Pol())</code></p><p>returns the fake degree (see <a href="#Chevie.Chars.fakedegrees"><code>fakedegrees</code></a> for a definition) of the character  of parameter  Ï† (see  <a href="#Chevie.Chars.charinfo"><code>charinfo</code></a><code>(W).charparams</code>) of the reflection group <code>W</code>, evaluated at <code>q</code> .</p><pre><code class="language-julia-repl hljs">julia&gt; fakedegree(coxgroup(:A,2),[[2,1]],Pol(:q))
Pol{Int64}: qÂ²+q</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/91d5d058448089756f0709d051bcaa8750b4620e/src/Chars.jl#L466-L477">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Chars.fakedegrees"><a class="docstring-binding" href="#Chevie.Chars.fakedegrees"><code>Chevie.Chars.fakedegrees</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><p><code>fakedegrees(W, q=Pol())</code></p><p>returns  a list holding the fake degrees of the reflection group <code>W</code> on the vector  space <code>V</code>, evaluated at <code>q</code>. These are the graded multiplicities of the  irreducible characters of <code>W</code> in the quotient <code>SV/I</code> where <code>SV</code> is the symmetric  algebra of <code>V</code> and <code>I</code> is the ideal generated by the homogeneous invariants  of  positive  degree  in  <code>SV</code>.  The  ordering  of  the  result corresponds to the ordering of the characters in <code>charinfo(W)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; fakedegrees(coxgroup(:A,2),Pol(:q))
3-element Vector{Pol{Int64}}:
 qÂ³
 qÂ²+q
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/91d5d058448089756f0709d051bcaa8750b4620e/src/Chars.jl#L492-L509">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Chars.representation-Tuple{Union{Spets, FiniteCoxeterGroup, PermRootGroup}, Integer}"><a class="docstring-binding" href="#Chevie.Chars.representation-Tuple{Union{Spets, FiniteCoxeterGroup, PermRootGroup}, Integer}"><code>Chevie.Chars.representation</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><p><code>representation(W,i)</code></p><p>returns,   for  the  <code>i</code>-th  irreducible   representation  of  the  complex reflection  group or Spets <code>W</code>, a list of matrices images of the generating reflections  of <code>W</code> in a model of the representation (for Spets, the result is  a <code>NamedTuple</code> with fields <code>gens</code>,  a representation of <code>Group(W)</code>, and <code>F</code>,  the matrix for <code>W.phi</code> in the representation). This function is based on  the  classification,  and  is  not  yet fully implemented for <code>Gâ‚ƒâ‚„</code>; 60 representations   are  missing  out   of  169,  that   is,  about  half  of representations  of  dimension  â‰¥140.  <code>nothing</code>  is returned for a missing representation.</p><pre><code class="language-julia-repl hljs">julia&gt; representation(complex_reflection_group(24),3)
3-element Vector{Matrix{Cyc{Int64}}}:
 [1 0 0; -1 -1 0; -1 0 -1]
 [-1 0 -1; 0 -1 (1-âˆš-7)/2; 0 0 1]
 [-1 -1 0; 0 1 0; 0 (1+âˆš-7)/2 -1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/91d5d058448089756f0709d051bcaa8750b4620e/src/Chars.jl#L1365-L1385">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Chars.representations-Tuple{Union{Spets, FiniteCoxeterGroup, PermRootGroup}}"><a class="docstring-binding" href="#Chevie.Chars.representations-Tuple{Union{Spets, FiniteCoxeterGroup, PermRootGroup}}"><code>Chevie.Chars.representations</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><p><code>representations(W)</code></p><p>returns  the list  of representations  of the  complex reflection  group or Spets <code>W</code> (see <code>representation</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; representations(coxgroup(:B,2))
5-element Vector{Vector{Matrix{Int64}}}:
 [[1;;], [-1;;]]
 [[1 0; -1 -1], [1 2; 0 -1]]
 [[-1;;], [-1;;]]
 [[1;;], [1;;]]
 [[-1;;], [1;;]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/91d5d058448089756f0709d051bcaa8750b4620e/src/Chars.jl#L1409-L1424">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Chars.induction_table"><a class="docstring-binding" href="#Chevie.Chars.induction_table"><code>Chevie.Chars.induction_table</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><p><code>induction_table(u,g)</code></p><p>returns   an  object  describing  the   decomposition  of  the  irreducible characters  of the subgroup  <code>u</code> induced to  the group <code>g</code>.  At the repl or IJulia  or Pluto,  a table  is displayed  where the  rows correspond to the characters  of the parent group, and the  columns to those of the subgroup. The  returned  object  has  a  field  <code>scalar</code>  which  is  a  <code>Matrix{Int}</code> containing  the  induction  table,  and  the  other fields contain labeling information taken from the character tables of <code>u</code> and <code>g</code> when it exists.</p><pre><code class="language-julia-rep1 hljs">julia&gt; g=Group([Perm(1,2),Perm(2,3),Perm(3,4)])
Group([(1,2),(2,3),(3,4)])

julia&gt; u=Group( [ Perm(1,2), Perm(3,4) ])
Group([(1,2),(3,4)])

julia&gt; induction_table(u,g)  #     needs &quot;using GAP&quot;
Induction table from Group((1,2),(3,4)) to Group((1,2),(2,3),(3,4))
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   â”‚X.1 X.2 X.3 X.4â”‚
â”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚X.1â”‚  .   1   .   .â”‚
â”‚X.2â”‚  .   1   1   1â”‚
â”‚X.3â”‚  1   1   .   .â”‚
â”‚X.4â”‚  1   .   1   1â”‚
â”‚X.5â”‚  1   .   .   .â”‚
â””â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre><pre><code class="language-julia-repl hljs">julia&gt; g=coxgroup(:G,2)
Gâ‚‚

julia&gt; u=reflection_subgroup(g,[1,6])
Gâ‚‚â‚â‚â‚…â‚=Aâ‚‚

julia&gt; t=induction_table(u,g)
Induction table from Gâ‚‚â‚â‚â‚…â‚=Aâ‚‚ to Gâ‚‚
â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     â”‚111 21 3â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚Ï†â‚â€šâ‚€ â”‚  .  . 1â”‚
â”‚Ï†â‚â€šâ‚† â”‚  1  . .â”‚
â”‚Ï†â€²â‚â€šâ‚ƒâ”‚  1  . .â”‚
â”‚Ï†â€³â‚â€šâ‚ƒâ”‚  .  . 1â”‚
â”‚Ï†â‚‚â€šâ‚ â”‚  .  1 .â”‚
â”‚Ï†â‚‚â€šâ‚‚ â”‚  .  1 .â”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre><p><code>IO</code> attributes can be transmitted to the table format method</p><pre><code class="language-julia-rep1 hljs">julia&gt; xdisplay(t;rows=[5],cols=[3,2])
Induction table from Gâ‚‚â‚â‚â‚…â‚=Aâ‚‚ to Gâ‚‚
â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
â”‚     â”‚3 21â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤
â”‚Ï†â‚‚â€šâ‚ â”‚.  1â”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜</code></pre><p>It is also possible to TeX induction tables with <code>xdisplay(t;TeX=true)</code>.</p><p><code>induction_table</code> also works for spets (reflection cosets).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/91d5d058448089756f0709d051bcaa8750b4620e/src/Chars.jl#L1707-L1774">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Chars.j_induction_table"><a class="docstring-binding" href="#Chevie.Chars.j_induction_table"><code>Chevie.Chars.j_induction_table</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><p><code>j_induction_table(H, W)</code></p><p>computes  the decomposition  into irreducible  characters of the reflection group  <code>W</code>  of  the  <code>j</code>-induced  of  the  irreducible  characters  of  the reflection  subgroup  <code>H</code>.  The  <code>j</code>-induced  of  <code>Ï†</code>  is  the  sum  of the irreducible  components of the induced of  <code>Ï†</code> which have same <code>b</code>-function (see <code>charinfo</code>) as <code>Ï†</code>. What is returned is an <code>InductionTable</code> struct.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:D,4)
Dâ‚„

julia&gt; H=reflection_subgroup(W,[1,3])
Dâ‚„â‚â‚â‚ƒâ‚=Aâ‚‚Î¦â‚Â²

julia&gt; j_induction_table(H,W)
j-induction table from Dâ‚„â‚â‚â‚ƒâ‚=Aâ‚‚Î¦â‚Â² to Dâ‚„
â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     â”‚111 21 3â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚11+  â”‚  .  . .â”‚
â”‚11-  â”‚  .  . .â”‚
â”‚1.111â”‚  .  . .â”‚
â”‚.1111â”‚  .  . .â”‚
â”‚11.2 â”‚  .  . .â”‚
â”‚1.21 â”‚  1  . .â”‚
â”‚.211 â”‚  .  . .â”‚
â”‚2+   â”‚  .  . .â”‚
â”‚2-   â”‚  .  . .â”‚
â”‚.22  â”‚  .  . .â”‚
â”‚1.3  â”‚  .  1 .â”‚
â”‚.31  â”‚  .  . .â”‚
â”‚.4   â”‚  .  . 1â”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/91d5d058448089756f0709d051bcaa8750b4620e/src/Chars.jl#L1811-L1847">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Chars.J_induction_table"><a class="docstring-binding" href="#Chevie.Chars.J_induction_table"><code>Chevie.Chars.J_induction_table</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><p><code>J_induction_table(H, W)</code></p><p>computes  the decomposition  into irreducible  characters of the reflection group  <code>W</code>  of  the  <code>J</code>-induced  of  the  irreducible  characters  of  the reflection  subgroup  <code>H</code>.  The  <code>J</code>-induced  of  <code>Ï†</code>  is  the  sum  of the irreducible  components of the induced of  <code>Ï†</code> which have same <code>a</code>-function (see <code>charinfo</code>) as <code>Ï†</code>. What is returned is an <code>InductionTable</code> struct.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:D,4)
Dâ‚„

julia&gt; H=reflection_subgroup(W,[1,3])
Dâ‚„â‚â‚â‚ƒâ‚=Aâ‚‚Î¦â‚Â²

julia&gt; J_induction_table(H,W)
J-induction table from Dâ‚„â‚â‚â‚ƒâ‚=Aâ‚‚Î¦â‚Â² to Dâ‚„
â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     â”‚111 21 3â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚11+  â”‚  .  . .â”‚
â”‚11-  â”‚  .  . .â”‚
â”‚1.111â”‚  .  . .â”‚
â”‚.1111â”‚  .  . .â”‚
â”‚11.2 â”‚  1  . .â”‚
â”‚1.21 â”‚  1  . .â”‚
â”‚.211 â”‚  .  . .â”‚
â”‚2+   â”‚  .  . .â”‚
â”‚2-   â”‚  .  . .â”‚
â”‚.22  â”‚  .  . .â”‚
â”‚1.3  â”‚  .  1 .â”‚
â”‚.31  â”‚  .  . .â”‚
â”‚.4   â”‚  .  . 1â”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/91d5d058448089756f0709d051bcaa8750b4620e/src/Chars.jl#L1861-L1897">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Chars.schur_functor"><a class="docstring-binding" href="#Chevie.Chars.schur_functor"><code>Chevie.Chars.schur_functor</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><p><code>schur_functor(mat,Î»)</code></p><p><code>mat</code>  should be  a square  matrix and  <code>Î»</code> a  partition. The result is the Schur  functor  of  the  matrix  <code>mat</code>  corresponding to partition <code>Î»</code>; for example,   if  <code>Î»==[n]</code>  it  returns  the   n-th  symmetric  power  and  if <code>Î»==[1,1,1]</code> it returns the 3rd exterior power. The current algorithm (from Littlewood)  is rather inefficient so it is  quite slow for partitions of n where <code>n&gt;6</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; m=cartan(:A,3)
3Ã—3 Matrix{Int64}:
  2  -1   0
 -1   2  -1
  0  -1   2

julia&gt; schur_functor(m,[2,2])
6Ã—6 Matrix{Rational{Int64}}:
   9   -6    4  3//2   -2    1
 -12   16  -16  -4      8   -4
   4   -8   16   2     -8    4
  12  -16   16  10    -16   12
  -4    8  -16  -4     16  -12
   1   -2    4  3//2   -6    9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/91d5d058448089756f0709d051bcaa8750b4620e/src/Chars.jl#L404-L430">source</a></section><section><div><p><code>schur_functor(ct::CharTable,Ï†::AbstractVector,Î»)</code></p><p><code>schur_functor(ct::CharTable,i::Integer,Î»)</code></p><p><code>ct</code>  should be a character table for some group <code>G</code>. In the first form <code>Ï†</code> should  be a vector representing a character of <code>G</code>, and in the second form <code>i</code>  denotes the <code>i</code>-th  character <code>Ï†</code> of  <code>G</code>. <code>Î»</code> is  a partition of some integer  <code>n</code>, representing an irreducible character  of <span>$ğ”– â‚™$</span>. The function returns  the Schur functor <code>Ï†[Î»]</code> of Ï† defined by Î» . This is the character defined by the formula</p><p><span>$Ï†[Î»](g)=âˆ‘_Î¼ Î»(Î¼)âˆ_{kâˆˆ1:n}Ï†(gáµ)^{nâ‚–(Î¼)}$</span></p><p>where  <code>Î¼</code> runs over the partitions of  <code>n</code>, representing the classes of <span>$ğ”– â‚™$</span>,  where <code>Î»(Î¼)</code> is the  value of the character  <code>Î»</code> at the class <code>Î¼</code>, and <code>nâ‚–(Î¼)</code> is the number of parts of <code>Î¼</code> equal to <code>k</code>.</p><p>Particular  examples are the exterior  powers, corresponding to <code>Î»=1â¿</code>, and the symmetric powers, corresponding <code>Î»=n</code>.</p><p><code>ct</code>  should  have  <code>.powermaps</code>  containing  powermaps  for  at  least the prime divisors of the order of <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/91d5d058448089756f0709d051bcaa8750b4620e/src/Chars.jl#L1272-L1295">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Chars.detPerm"><a class="docstring-binding" href="#Chevie.Chars.detPerm"><code>Chevie.Chars.detPerm</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><p><code>detPerm(W)</code></p><p>return  the permutation of the characters of the reflection group <code>W</code> which is effected when tensoring by the determinant character (for Coxeter groups this is the sign character).</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:D,4)
Dâ‚„

julia&gt; detPerm(W)
(1,8)(2,9)(3,11)(4,13)(7,12)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/91d5d058448089756f0709d051bcaa8750b4620e/src/Chars.jl#L814-L828">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Chars.conjPerm"><a class="docstring-binding" href="#Chevie.Chars.conjPerm"><code>Chevie.Chars.conjPerm</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><p><code>conjPerm(W)</code></p><p>return  the permutation of the characters of the group <code>W</code> which is effected when taking the complex conjugate of the character table.</p><pre><code class="language-julia-repl hljs">julia&gt; W=complex_reflection_group(4)
Gâ‚„

julia&gt; conjPerm(W)
(2,3)(5,6)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/91d5d058448089756f0709d051bcaa8750b4620e/src/Chars.jl#L836-L849">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../weyl/">Â« Finite Coxeter groups, Weyl groups, crystallographic root systems</a><a class="docs-footer-nextpage" href="../hecke/">Hecke algebras Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 18 December 2025 23:04">Thursday 18 December 2025</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
