<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Hecke algebras Â· Chevie.jl documentation</title><meta name="title" content="Hecke algebras Â· Chevie.jl documentation"/><meta property="og:title" content="Hecke algebras Â· Chevie.jl documentation"/><meta property="twitter:title" content="Hecke algebras Â· Chevie.jl documentation"/><meta name="description" content="Documentation for Chevie.jl documentation."/><meta property="og:description" content="Documentation for Chevie.jl documentation."/><meta property="twitter:description" content="Documentation for Chevie.jl documentation."/><meta property="og:url" content="https://juliadocs.github.io/Chevie.jl/hecke/"/><meta property="twitter:url" content="https://juliadocs.github.io/Chevie.jl/hecke/"/><link rel="canonical" href="https://juliadocs.github.io/Chevie.jl/hecke/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Chevie.jl documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Chevie</a></li><li><span class="tocitem">Infrastructure</span><ul><li><a class="tocitem" href="../format/">formatting facilities</a></li><li><a class="tocitem" href="../symbols/">Symbols</a></li><li><a class="tocitem" href="../symfuncs/">Symmetric functions</a></li><li><a class="tocitem" href="../nf/">Number fields</a></li><li><a class="tocitem" href="../truncs/">Truncated Laurent series</a></li></ul></li><li><span class="tocitem">Reflection groups</span><ul><li><a class="tocitem" href="../permroot/">Finite reflection groups</a></li><li><a class="tocitem" href="../coxgroups/">Coxeter groups</a></li><li><a class="tocitem" href="../weyl/">Finite Coxeter groups, Weyl groups, crystallographic root systems</a></li><li><a class="tocitem" href="../chars/">Classes/characters of reflection groups</a></li></ul></li><li><span class="tocitem">Hecke algebras</span><ul><li class="is-active"><a class="tocitem" href>Hecke algebras</a></li><li><a class="tocitem" href="../kl/">Kazhdan-Lusztig polynomials and bases</a></li><li><a class="tocitem" href="../algebras/">Algebras</a></li></ul></li><li><a class="tocitem" href="../garside/">Garside monoids and groups, braids.</a></li><li><span class="tocitem">Reductive groups</span><ul><li><a class="tocitem" href="../rootdata/">Reductive algebraic groups and root data</a></li><li><a class="tocitem" href="../semisimple/">Semisimple elements</a></li><li><a class="tocitem" href="../cosets/">Reflection cosets and Spets</a></li><li><a class="tocitem" href="../sscoset/">Non-connected reductive groups</a></li><li><a class="tocitem" href="../uch/">Unipotent characters</a></li><li><a class="tocitem" href="../ct/">Classtypes</a></li></ul></li><li><span class="tocitem">Eigenspaces</span><ul><li><a class="tocitem" href="../eigen/">Eigenspaces</a></li><li><a class="tocitem" href="../dseries/">d-Harish-Chandra series</a></li></ul></li><li><span class="tocitem">Unipotent elements</span><ul><li><a class="tocitem" href="../ucl/">Unipotent classes of reductive groups</a></li><li><a class="tocitem" href="../urad/">Unipotent Elements</a></li></ul></li><li><a class="tocitem" href="../gendec/">Decomposition Matrices</a></li><li><a class="tocitem" href="../references/">References</a></li><li><a class="tocitem" href="../dict/">Dictionary from GAP3/Chevie</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Hecke algebras</a></li><li class="is-active"><a href>Hecke algebras</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Hecke algebras</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jmichel7/Chevie.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ï‚›</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jmichel7/Chevie.jl/blob/main/docs/src/hecke.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ï„</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Hecke-algebras"><a class="docs-heading-anchor" href="#Hecke-algebras">Hecke algebras</a><a id="Hecke-algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Hecke-algebras" title="Permalink"></a></h1><ul><li><a href="#Chevie.HeckeAlgebras"><code>Chevie.HeckeAlgebras</code></a></li><li><a href="#Chevie.Chars.CharTable-Tuple{HeckeAlgebra}"><code>Chevie.Chars.CharTable</code></a></li><li><a href="#Chevie.HeckeAlgebras.FactSchur"><code>Chevie.HeckeAlgebras.FactSchur</code></a></li><li><a href="#Chevie.HeckeAlgebras.HeckeCoset"><code>Chevie.HeckeAlgebras.HeckeCoset</code></a></li><li><a href="#Chevie.Chars.representation-Tuple{HeckeAlgebra, Integer}"><code>Chevie.Chars.representation</code></a></li><li><a href="#Chevie.Chars.representation-Tuple{HeckeElt, Any}"><code>Chevie.Chars.representation</code></a></li><li><a href="#Chevie.Chars.representations-Tuple{Union{HeckeAlgebra, HeckeCoset}}"><code>Chevie.Chars.representations</code></a></li><li><a href="#Chevie.Garside.Î±-Tuple{HeckeTElt}"><code>Chevie.Garside.Î±</code></a></li><li><a href="#Chevie.HeckeAlgebras.Tbasis-Tuple{HeckeAlgebra}"><code>Chevie.HeckeAlgebras.Tbasis</code></a></li><li><a href="#Chevie.HeckeAlgebras.alt"><code>Chevie.HeckeAlgebras.alt</code></a></li><li><a href="#Chevie.HeckeAlgebras.central_monomials"><code>Chevie.HeckeAlgebras.central_monomials</code></a></li><li><a href="#Chevie.HeckeAlgebras.char_values"><code>Chevie.HeckeAlgebras.char_values</code></a></li><li><a href="#Chevie.HeckeAlgebras.class_polynomials"><code>Chevie.HeckeAlgebras.class_polynomials</code></a></li><li><a href="#Chevie.HeckeAlgebras.factorized_schur_element"><code>Chevie.HeckeAlgebras.factorized_schur_element</code></a></li><li><a href="#Chevie.HeckeAlgebras.factorized_schur_elements"><code>Chevie.HeckeAlgebras.factorized_schur_elements</code></a></li><li><a href="#Chevie.HeckeAlgebras.hecke-Tuple{Spets, HeckeAlgebra}"><code>Chevie.HeckeAlgebras.hecke</code></a></li><li><a href="#Chevie.HeckeAlgebras.hecke-Union{Tuple{C}, Tuple{Group, Vector{&lt;:Vector{C}}}} where C"><code>Chevie.HeckeAlgebras.hecke</code></a></li><li><a href="#Chevie.HeckeAlgebras.hecke-Tuple{HeckeCoset}"><code>Chevie.HeckeAlgebras.hecke</code></a></li><li><a href="#Chevie.HeckeAlgebras.isrepresentation"><code>Chevie.HeckeAlgebras.isrepresentation</code></a></li><li><a href="#Chevie.HeckeAlgebras.schur_elements"><code>Chevie.HeckeAlgebras.schur_elements</code></a></li><li><a href="#Chevie.PermRoot.reflection_representation-Tuple{HeckeAlgebra}"><code>Chevie.PermRoot.reflection_representation</code></a></li></ul><article><details class="docstring" open="true"><summary id="Chevie.HeckeAlgebras"><a class="docstring-binding" href="#Chevie.HeckeAlgebras"><code>Chevie.HeckeAlgebras</code></a> â€” <span class="docstring-category">Module</span></summary><section><div><p>This  module  implements  Hecke  algebras associated to finite complex reflection  groups and arbitrary Coxeter  groups (these algebras are called Iwahori-Hecke  algebras  in  this  last  case),  and  also  implements  the character  tables, Schur elements and representations of Hecke algebras for finite  groups. For Iwahori-Hecke  algebras and for  <code>G(d,1,1)</code> this module also  implements the  standard <code>T</code>  basis; see  the module <a href="../kl/#Chevie.KL"><code>KL</code></a> for Kazhdan-Lusztig bases.</p><p>Let  <code>(W,S)</code> be  a Coxeter  system and  let <code>mâ‚›â‚œ</code>  be the order of <code>st</code> for <code>s,tâˆˆ S</code>. Let <code>R</code> be a commutative ring with 1 and for <code>sâˆˆ S</code> let <code>uâ‚›â‚€,uâ‚›â‚âˆˆ R</code> be elements which depend only on the conjugacy class of <code>s</code> in <code>W</code> (this is  the  same  as  requiring  that  <code>uâ‚›áµ¢=uâ‚œáµ¢</code>  whenever  <code>mâ‚›â‚œ</code> is odd). The Iwahori-Hecke   algebra  of  <code>W</code>  over  <code>R</code>  with  parameters  <code>uâ‚›áµ¢</code>  is  a deformation  of the group algebra of <code>W</code> over <code>R</code> defined as follows: it is the  unitary  associative  <code>R</code>-algebra  generated  by  elements  <code>Tâ‚›, sâˆˆ S</code> subject to the relations:</p><p><span>$(Tâ‚›-uâ‚›â‚€)(Tâ‚›-uâ‚›â‚)=0$</span> for all <code>sâˆˆ S</code> (the quadratic relations)</p><p><span>$Tâ‚›Tâ‚œTâ‚›â€¦= Tâ‚œTâ‚›Tâ‚œâ€¦$</span> with <code>mâ‚›â‚œ</code> factors on each side (the braid relations)</p><p>If  <code>uâ‚›â‚€=1</code> and  <code>uâ‚›â‚=-1</code> for  all <code>s</code>  then the quadratic relations become <code>Tâ‚›Â²=1</code> and the deformation of the group algebra is trivial.</p><p>Since  the generators <code>Tâ‚›</code>  satisfy the braid  relations, <code>H</code> is  in fact a quotient  of the group algebra of the  braid group associated with <code>W</code>. The braid relations also imply that for any reduced expression <code>s_1â‹¯ s_m</code> of <code>w âˆˆ  W</code> the product <code>Tâ‚›_â‚â‹¯ Tâ‚›_â‚˜</code> has the same value, that we denote <code>T_w</code>. We have  <code>Tâ‚=1</code>; if one of the <code>uâ‚›áµ¢</code> is invertible, the <code>{T_w}_{wâˆˆ W}</code> form an <code>R</code>-basis  of the Iwahori-Hecke algebra  which specializes to the canonical basis of the group algebra <code>R[W]</code> for <code>uâ‚›â‚€â†¦1</code> and <code>uâ‚›â‚â†¦-1</code>.</p><p>The  structure constants (the  decomposition of a  product <code>T_vT_w</code> in the <code>T_w</code>)  basis are obtained as follows.  Choose a reduced expression for <code>v</code>, say <code>v=s_1 â‹¯ s_k</code> and apply inductively the formula:</p><p><span>$T_sT_w=T_{sw}$</span>               if <code>l(sw)=l(w)+1</code></p><p><span>$T_sT_w=-uâ‚›â‚€uâ‚›â‚T_{sw}+(uâ‚›â‚€+uâ‚›â‚)T_w$</span> if <code>l(sw)=l(w)-1</code>.</p><p>If  one of <code>uâ‚›â‚€</code> or <code>uâ‚›â‚</code> is invertible  in <code>R</code>, for example <code>uâ‚›â‚</code>, then by changing  the generators  to <code>Tâ€²â‚›=-Tâ‚›/uâ‚›â‚</code>,  and setting <code>qâ‚›=-uâ‚›â‚€/uâ‚›â‚</code>, the braid  relations do no change  (since when <code>mâ‚›â‚œ</code> is  odd we have <code>uâ‚›áµ¢=uâ‚œáµ¢</code>) but  the quadratic relations become <code>(Tâ€²â‚›-qâ‚›)(Tâ€²â‚›+1)=0</code>. This normalisation is  the most common form considered  in the literature. Another common form in  the context of  Kazhdan-Lusztig theory, is  <code>uâ‚›â‚€=âˆšqâ‚›</code> and <code>uâ‚›â‚=-âˆšqâ‚›â»Â¹</code>. The  form provided, with two parameters per generator, is often useful, for instance  when constructing  the Jones  polynomial. If  for all <code>s</code> we have <code>uâ‚›â‚€=q</code>,   <code>uâ‚›â‚=-1</code>   then   we   call   the   corresponding   algebra  the &quot;one-parameter&quot; or &quot;Spetsial&quot; Iwahori-Hecke algebra associated with <code>W</code>.</p><p>For  some  Iwahori-Hecke  algebras  the  character  table,  and  in general Kazhdan-Lusztig  bases, require  a square  root of  <code>-uâ‚›â‚€uâ‚›â‚</code>. These square roots  can  be  specified  with  the  keyword  <code>rootpara</code>  of  the function <a href="#Chevie.HeckeAlgebras.hecke-Union{Tuple{C}, Tuple{Group, Vector{&lt;:Vector{C}}}} where C"><code>hecke</code></a>  constructing  the  algebra;  after  this <code>H.rootpara</code> will return  the  chosen  roots.  If  not  specified,  we  try  to extract roots automatically  when needed; <code>rootpara(H)</code> informs on the choices made. Note that some mathematical results require an explicit choice of one of the two possible  roots which cannot  be automatically made  thus require a keyword initialisation.</p><p>There  is a universal choice  for <code>R</code> and <code>uâ‚›áµ¢</code>:  Let <code>uâ‚›áµ¢:sâˆˆ S,iâˆˆ[0,1]</code> be indeterminates   such  that  <code>uâ‚›áµ¢=uâ‚œáµ¢</code>  whenever  <code>mâ‚›â‚œ</code>  is  odd,  and  let <code>A=â„¤[uâ‚›áµ¢]</code> be the corresponding polynomial ring. Then the Hecke algebra <code>H</code> of  <code>W</code> over <code>A</code> with parameters <code>uâ‚›áµ¢</code> is called the <em>generic Iwahori-Hecke algebra</em>  of <code>W</code> (we work  often with the ring  <code>â„¤[uâ‚›áµ¢^{Â±1}]</code> so that basis elements have an inverse). Any Hecke algebra <code>Hâ‚</code> with parameters <code>vâ‚›áµ¢</code> can be  obtained  by  specialization  from  <code>H</code>,  since  there is a unique ring homomorphism  <code>f:A â†’ R</code> such that <code>f(uâ‚›áµ¢)=vâ‚›áµ¢</code> for all <code>i</code>. Then via <code>f</code> we can identify <code>Hâ‚</code> to <span>$RâŠ— _A H$</span>.</p><p>Certain invariants of the irreducible characters of the one-parameter Hecke algebra  play a special role in the representation theory of the underlying finite  Coxeter  groups,  namely  the  <code>a</code>-  and  <code>A</code>-invariants. For basic properties   of  Iwahori-Hecke   algebras  and   their  relevance   to  the representation  theory of finite groups of Lie type, see for example (<a href="../references/#cr87">Curtis and Reiner, 1987</a>; Sections 67 and 68).</p><p>In  the  following  example,  we  compute  the multiplication table for the <code>0</code>-Iwahoriâ€“Hecke algebra associated with the Coxeter group of type <code>A_2</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,2)
Aâ‚‚

julia&gt; H=hecke(W,0)            # One-parameter algebra with `q=0`
hecke(Aâ‚‚,0)

julia&gt; T=Tbasis(H);            # Create the `T` basis

julia&gt; b=T.(elements(W))       # the basis
6-element Vector{HeckeTElt{HeckeAlgebra{Int64, Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}, Int64, Perm{Int16}}}:
 T.
 Tâ‚
 Tâ‚‚
 Tâ‚â‚‚
 Tâ‚‚â‚
 Tâ‚â‚‚â‚

julia&gt; b*permutedims(b)       # multiplication table
6Ã—6 Matrix{HeckeTElt{HeckeAlgebra{Int64, Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}, Int64, Perm{Int16}}}:
 T.    Tâ‚     Tâ‚‚     Tâ‚â‚‚    Tâ‚‚â‚    Tâ‚â‚‚â‚
 Tâ‚    -Tâ‚    Tâ‚â‚‚    -Tâ‚â‚‚   Tâ‚â‚‚â‚   -Tâ‚â‚‚â‚
 Tâ‚‚    Tâ‚‚â‚    -Tâ‚‚    Tâ‚â‚‚â‚   -Tâ‚‚â‚   -Tâ‚â‚‚â‚
 Tâ‚â‚‚   Tâ‚â‚‚â‚   -Tâ‚â‚‚   -Tâ‚â‚‚â‚  -Tâ‚â‚‚â‚  Tâ‚â‚‚â‚
 Tâ‚‚â‚   -Tâ‚‚â‚   Tâ‚â‚‚â‚   -Tâ‚â‚‚â‚  -Tâ‚â‚‚â‚  Tâ‚â‚‚â‚
 Tâ‚â‚‚â‚  -Tâ‚â‚‚â‚  -Tâ‚â‚‚â‚  Tâ‚â‚‚â‚   Tâ‚â‚‚â‚   -Tâ‚â‚‚â‚</code></pre><p>Thus,  we work  with algebras  with arbitrary  parameters. We will see that this also works on the level of characters and representations.</p><p>For  general complex reflection  groups, the picture  is similar. The Hecke algebras  are deformations  of the  group algebras,  generalizing those for real reflection groups.</p><p>The  definition is  as a  quotient of  the algebra  of the  braid group. We assume  now that <code>W</code> is  a <em>finite</em> reflection group  in the complex vector space  <code>V</code>. The <em>braid group</em> associated  is the fundamental group <code>Î â‚</code> of the  space Â <span>$(V-\bigcup_{H\in\mathcal H}  H)/W$</span>, where <span>$\mathcal H$</span> is  the set of  reflecting hyperplanes of  <code>W</code>. This group  is generated by <em>braid reflections</em>, elements which by the natural map from the braid group to  the reflection  group project  to distinguished  reflections. The braid reflections   which  project  to  a  given  <code>W</code>-orbit  of  reflections  are conjugate.  Let <code>ğ¬</code> be a representative of  such a conjugacy class of braid reflections,  let <code>e</code>  be the  order of  the image  of <code>ğ¬</code>  in <code>W</code>, and let <span>$u_{ğ¬,0},â€¦,u_{ğ¬,e-1}$</span> be indeterminates. The generic Hecke algebra of <code>W</code> is  the  <span>$â„¤[u_{ğ¬,i}^{Â±  1}]_{ğ¬,i}$</span>-algebra  quotient  of  the braid group algebra  by the relations <span>$(ğ¬-u_{ğ¬,0})â€¦(ğ¬-u_{ğ¬,e-1})=0$</span>, and an arbitrary Hecke  algebra for <code>W</code> is an algebra  obtained from this generic algebra by specializing some of the parameters.</p><p>The  generic Hecke algebras are explicitely  described by a presentation of the  braid group. The braid group can be presented by homogeneous relations in   the  braid   reflections,  called   <em>braid  relations</em>,  described  in (<a href="../references/#bmr98">BrouÃ© <em>et al.</em>, 1998</a>)  and (<a href="../references/#bm03">Bessis and Michel, 2004</a>)  (some of  which were  obtained using the VKCURVE   GAP3-package,   also   ported   to   Julia).  Furthermore,  these presentations  are such that the reflection  group is presented by the same relations,   plus  relations   describing  the   order  of  the  generating reflections,  called the  <em>order relations</em>.  Thus the  Hecke algebra has a presentation  similar to that of <code>W</code>, with the same braid relations but the order relations replaced by a deformed version.</p><p>If  <code>SâŠ‚ W</code>  is the  set of  distinguished reflections  of <code>W</code> which lift to generating  braid reflections in the braid  group, for each conjugacy class of  an  <code>s</code>  of  order  <code>e</code>  we take indeterminates <code>uâ‚›â‚€,â€¦,uâ‚›â‚‘â‚‹â‚</code>. Then the generic  Hecke algebra is the <span>$â„¤[uâ‚›áµ¢^{Â±1}]â‚›áµ¢$</span>-algebra <code>H</code> with generators <code>T_s</code>  for each <code>sâˆˆ  S</code> presented by  the braid relations  and the deformed order relations <span>$(T_s-u_{s,0})â€¦(T_s-u_{s,e-1})=0$</span>.</p><p>Ariki and Koike have described models of representations for these algebras corresponding  to imprimitive complex  reflection groups, and Halverson-Ram and  some other  authors have  computed the  character tables in this case. Malle has given representation models and the character table for the other 2-dimensional  reflection groups, see (<a href="../references/#bm93">BrouÃ© and Malle, 1993</a>) and (<a href="../references/#mal96">Malle, 1994</a>); our data  has models  of all  representations, and  character tables,  for real reflection  groups; it  contains the  same for  imprimitive groups  and for primitive groups of dimension 2 and 3 (these last representations have been computed  in  (<a href="../references/#mm10">Malle and Michel, 2010</a>))  and  the  situation  is  as follows for other primitive complex groups:</p><ul><li><code>Gâ‚‚â‚‰</code> and <code>Gâ‚ƒâ‚ƒ</code> character table and representations computed by Michel.</li><li><code>Gâ‚ƒâ‚</code> character table and partial list of representations computed by Michel.</li><li><code>Gâ‚ƒâ‚‚</code> character table and partial list of representations computed by Malle and Michel.</li><li><code>Gâ‚ƒâ‚„</code> partial character table and partial list of representations computed by  Michel.</li></ul><p>The quotient of the Hecke algebra obtained by the specialisation <span>$u_{ğ¬,i}â†¦ Î¶â‚‘â±$</span>  is isomorphic to the group algebra of <code>W</code>. It was conjectured for 25 years  that over a splitting ring the Hecke algebra is itself isomorphic to the  group algebra of <code>W</code> over the  same ring. This was called the freeness conjecture since the main problem is to show that the Hecke algebra is free of dimension <code>|W|</code>. This has finally been proved in 2020 thanks to the work of  many people including (<a href="../references/#mp17">Marin and Pfeiffer, 2017</a>; <a href="../references/#ch18">Chavli, 2018</a>; <a href="../references/#ts20">Tsuchioka, 2020</a>) for exceptional groups. Along  the way it has been proven that there exists a set <code>{b_w}_{wâˆˆ W}</code> of elements  of the Braid group such that <code>b_1=1</code> and <code>b_w</code> maps to <code>w</code> by the natural  quotient map,  such that  their images  <code>T_w</code> form  a basis of the Hecke algebra.</p><p>It  is  conjectured  that  such  a  basis  <code>T_w</code>  can  be  chosen such that additionnaly  the  linear  form  <code>t</code>  defined  by  <code>t(T_w)=0</code> if <code>wâ‰  1</code> and <code>t(1)=1</code> is a symmetrizing form for the symmetric algebra <code>H</code>. This is well known  for all real reflection groups  and has been proved in (<a href="../references/#mm98">Malle and Mathas, 1998</a>) for  imprimitive reflection groups and  in (<a href="../references/#mm10">Malle and Michel, 2010</a>) for some primitive groups  of dimension 2 and 3. (<a href="../references/#bcck20">Boura <em>et al.</em>, 2020</a>; <a href="../references/#bcc20">Boura <em>et al.</em>, 2020</a>) have handled some other 2-dimensional  cases. For each  irreducible character <code>Ï†</code>  of <code>H</code> we define the  <em>Schur element</em> <code>Sáµ©</code> associated  to <code>Ï†</code> by the  condition that for any element  <code>T</code> of  <code>H</code> we  have <code>t(T)=âˆ‘áµ©  Ï†(T)/Sáµ©</code>. It  can be shown that the Schur  elements  are  Laurent  polynomials,  and  they do not depend on the choice of a basis having the above property. Malle has computed these Schur elements, assuming the above conjecture; they are in the Chevie data.</p><p>See <a href="#Chevie.HeckeAlgebras.hecke-Union{Tuple{C}, Tuple{Group, Vector{&lt;:Vector{C}}}} where C"><code>hecke</code></a> for various ways of specifying the parameters of a Hecke   algebra.  Look  also  at <a href="#Chevie.HeckeAlgebras.central_monomials"><code>central_monomials</code></a>, <a href="#Chevie.HeckeAlgebras.char_values"><code>char_values</code></a>, <a href="#Chevie.HeckeAlgebras.class_polynomials"><code>class_polynomials</code></a>, <a href="#Chevie.HeckeAlgebras.schur_elements"><code>schur_elements</code></a>, <a href="#Chevie.HeckeAlgebras.isrepresentation"><code>isrepresentation</code></a>, <a href="#Chevie.HeckeAlgebras.factorized_schur_elements"><code>factorized_schur_elements</code></a> and  at  the  methods  for  Hecke  algebras of <code>CharTable, representations, reflrep</code>.</p><p>Taking  apart  Hecke  elements  is  done  with  the  functions  <code>getindex</code>, <code>setindex!</code>, <code>keys</code>, <code>values</code>, <code>iterate</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; H=hecke(W,Pol(:q))
hecke(Aâ‚‚,q)

julia&gt; T=Tbasis(H);

julia&gt; h=T(1,2)^2
qTâ‚‚â‚+(q-1)Tâ‚â‚‚â‚

julia&gt; length(h) # h has 2 terms
2

julia&gt; h[W(2,1)] # coefficient of W(2,1)
Pol{Int64}: q

julia&gt; collect(h) # pairs perm=&gt;coeff
2-element Vector{Any}:
  (1,2,6)(3,4,5) =&gt; q
 (1,5)(2,4)(3,6) =&gt; q-1

julia&gt; collect(values(h)) # the coefficients
2-element Vector{Pol{Int64}}:
 q
 q-1

julia&gt; collect(keys(h)) # the corresponding Perms
2-element Vector{Perm{Int16}}:
 (1,2,6)(3,4,5)
 (1,5)(2,4)(3,6)

julia&gt; h[W(2,1)]=Pol(3)
Pol{Int64}: 3

julia&gt; h
3Tâ‚‚â‚+(q-1)Tâ‚â‚‚â‚</code></pre><p>Finally,  Hecke &quot;algebras&quot; can also be  attached to reflection cosets; they are  not algebras  but modules  for the  Hecke algebra of the corresponding group.   But  they  also  have  character  tables,  class  polynomials  and representations.</p><p>finally, benchmarks on julia 1.8</p><pre><code class="language-benchmark hljs">julia&gt; function test_w0(n)
         W=coxgroup(:A,n)
         Tbasis(hecke(W,Pol(:q)))(longest(W))^2
       end
test_w0 (generic function with 1 method)

julia&gt; @btime test_w0(7);
   97.210 ms (1776476 allocations: 127.52 MiB)</code></pre><p>in GAP3 the analogous function takes 920ms</p><pre><code class="language-julia hljs">test_w0:=function(n)local W,T,H;
  W:=CoxeterGroup(&quot;A&quot;,n);H:=Hecke(W,X(Rationals));T:=Basis(H,&quot;T&quot;);
  return T(LongestCoxeterWord(W))^2;
end;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/672ace5cc6250cb344a26a435cd2b757cb16fc90/src/HeckeAlgebras.jl#L1-L265">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.HeckeAlgebras.hecke-Union{Tuple{C}, Tuple{Group, Vector{&lt;:Vector{C}}}} where C"><a class="docstring-binding" href="#Chevie.HeckeAlgebras.hecke-Union{Tuple{C}, Tuple{Group, Vector{&lt;:Vector{C}}}} where C"><code>Chevie.HeckeAlgebras.hecke</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><p><code>hecke(W,parameter=1;rootpara=missing)</code></p><p>Hecke  algebra for the complex reflection group or Coxeter group <code>W</code>. If no <code>parameter</code> is given, <code>1</code> is assumed which gives the group algebra of <code>W</code>.</p><p>The  following forms are accepted for  <code>parameter</code>: if <code>parameter</code> is not a vector or a tuple, it is replaced by the vector <code>fill(parameter,ngens(W))</code>. If it is a vector with one entry, it is replaced with <code>fill(parameter[1],ngens(W))</code>.  If <code>parameter</code>  is a  vector with more than one  entry, it should  have length <code>ngens(W)</code>,  each entry representing the parameters   for   the   corresponding   generator   of  <code>W</code>,  and  entries corresponding  to  the  same  <code>W</code>-orbit  of generators should be identical. Finally, if <code>parameter</code> is a <code>Tuple</code>, the tuple should have as many entries as  there are hyperplane  orbits in <code>W</code>  and each entry  will represent the parameters for the corresponding conjugacy class of braid reflections.</p><p>An  entry in  <code>parameter</code> for  a reflection  of order  <code>e</code> can  be either a single scalar value or a <code>Vector</code> of length &#39;e&#39;. If it is a <code>Vector</code>, it is interpreted as the list <code>[uâ‚€,â€¦,uâ‚‘â‚‹â‚]</code> of parameters for that reflection. If it  is  not  a  vector,  let  <code>q</code>  be  its value; it is then interpreted as specifying  the  list  of  parameters  for  the Spetsial algebra, which are <code>[q,Î¶â‚‘,â€¦,Î¶â‚‘áµ‰â»Â¹]</code>  (thus the list <code>[q,-1]</code>  of the one-parameter algebra for Coxeter groups).</p><p>When  printing an Hecke algebra the parameter list is abbreviated using the same conventions.</p><p>Computing characters or representations of Hecke algebra needs sometimes to extract  roots of the  parameters. These roots  are extracted automatically (when  possible). To control the roots, which is needed for example to have composable  specializations  or  make  sure  the  same  root  is  used  for subgroups,  for Coxeter  groups it  is possible  to give  explicit roots by giving  a keyword argument <code>rootpara</code>: if it  is a vector it should contain at  the <code>i</code>-th position a square root of <code>-parameter[i][1]*parameter[i][2]</code> (that  is, a square root of <code>q</code>  if <code>parameter[i]==[q,-1]</code>); if a scalar it is  replaced by <code>fill(rootpara,ngens(W))</code>. If  not specified the entries in <code>rootpara</code>  start  as  missing.  The  function  <code>rootpara(H)</code> tries to fill automatically  missing entries in <code>H.rootpara</code>  and returns the result. The same  mechanism  has  been  extended  to  some  complex  reflection  groups generated  by 2-reflections and needing only square roots of the parameters to split the Hecke algebra, that is to <code>Gâ‚‚â‚„, Gâ‚‚â‚‰, Gâ‚ƒâ‚, Gâ‚ƒâ‚ƒ</code> and <code>Gâ‚„,â‚‚,áµ£</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:B,2)
Bâ‚‚

julia&gt; @Pol q
Pol{Int64}: q

julia&gt; H=hecke(W,q)
hecke(Bâ‚‚,q)

julia&gt; H.para
2-element Vector{Vector{Pol{Int64}}}:
 [q, -1]
 [q, -1]

julia&gt; H=hecke(W,q^2,rootpara=-q)
hecke(Bâ‚‚,qÂ²,rootpara=-q)

julia&gt; H=hecke(W,q^2)
hecke(Bâ‚‚,qÂ²)

julia&gt; rootpara(H) # automatically computed
2-element Vector{Pol{Int64}}:
 q
 q

julia&gt; H
hecke(Bâ‚‚,qÂ²,rootpara=q)

julia&gt; H=hecke(W,[q^2,q^4],rootpara=[q,q^2])
hecke(Bâ‚‚,Pol{Int64}[qÂ², qâ´],rootpara=Pol{Int64}[q, qÂ²])

julia&gt; H.para,H.rootpara
(Vector{Pol{Int64}}[[qÂ², -1], [qâ´, -1]], Pol{Int64}[q, qÂ²])

julia&gt; H=hecke(W,9,rootpara=3)
hecke(Bâ‚‚,9,rootpara=3)

julia&gt; H.para,H.rootpara
([[9, -1], [9, -1]], [3, 3])

julia&gt; @Mvp x,y,z,t

julia&gt; H=hecke(W,[[x,y]])
hecke(Bâ‚‚,Vector{Mvp{Int64, Int64}}[[x, y]])

julia&gt; rootpara(H);H
hecke(Bâ‚‚,Vector{Mvp{Int64, Int64}}[[x, y]],rootpara=Î¶â‚„xÂ½yÂ½)

julia&gt; H=hecke(W,[[x,y],[z,t]])
hecke(Bâ‚‚,Vector{Mvp{Int64, Int64}}[[x, y], [z, t]])

julia&gt; rootpara(H);H
hecke(Bâ‚‚,Vector{Mvp{Int64, Int64}}[[x, y], [z, t]],rootpara=Mvp{Cyc{Int64}, Rational{Int64}}[Î¶â‚„xÂ½yÂ½, Î¶â‚„tÂ½zÂ½])

julia&gt; hecke(coxgroup(:F,4),(q,q^2)).para
4-element Vector{Vector{Pol{Int64}}}:
 [q, -1]
 [q, -1]
 [qÂ², -1]
 [qÂ², -1]

julia&gt; hecke(complex_reflection_group(3,1,2),q).para # spetsial parameters
2-element Vector{Vector{Pol{Cyc{Int64}}}}:
 [q, Î¶â‚ƒ, Î¶â‚ƒÂ²]
 [q, -1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/672ace5cc6250cb344a26a435cd2b757cb16fc90/src/HeckeAlgebras.jl#L281-L392">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.HeckeAlgebras.Tbasis-Tuple{HeckeAlgebra}"><a class="docstring-binding" href="#Chevie.HeckeAlgebras.Tbasis-Tuple{HeckeAlgebra}"><code>Chevie.HeckeAlgebras.Tbasis</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><p><code>Tbasis(H::HeckeAlgebra)</code> The  <code>T</code> basis of  <code>H</code>. It is  defined currently for Iwahori-Hecke algebras and  for Hecke algebras of cyclic  complex reflection groups <code>G(d,1,1)</code>. It returns  a function, say <code>T</code>,  which can take an  argument of the following forms</p><ul><li><code>T(i::Integer)</code>: the generator <code>T_s</code> where <code>s=H.W(i)</code>.</li><li><code>T(iâ‚,â€¦,iáµ£)</code>: the product <code>T(iâ‚)â€¦T(iáµ£)</code></li><li><code>T([iâ‚,â€¦,iáµ£])</code>: same as <code>T(iâ‚,â€¦,iáµ£)</code></li><li><code>T(w)</code> where <code>wâˆˆ H.W</code>: returns <code>T_w</code></li></ul><pre><code class="language-julia-repl hljs">julia&gt; H=hecke(coxgroup(:A,2),Pol(:q))
hecke(Aâ‚‚,q)

julia&gt; T=Tbasis(H);T(longest(H.W))^2
qÂ³T.+(qÂ³-2qÂ²+q)Tâ‚‚â‚+(qÂ³-qÂ²)Tâ‚‚+(qÂ³-qÂ²)Tâ‚+(qÂ³-2qÂ²+2q-1)Tâ‚â‚‚â‚+(qÂ³-2qÂ²+q)Tâ‚â‚‚

julia&gt; W=crg(3,1,1)
Gâ‚ƒâ€šâ‚â€šâ‚

julia&gt; H=hecke(crg(3,1,1),Pol(:q))
hecke(Gâ‚ƒâ€šâ‚â€šâ‚,q)

julia&gt; T=Tbasis(H);T(1)^3
(q-1)T.+(q-1)Tâ‚+qTâ‚â‚</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/672ace5cc6250cb344a26a435cd2b757cb16fc90/src/HeckeAlgebras.jl#L896-L924">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.HeckeAlgebras.alt"><a class="docstring-binding" href="#Chevie.HeckeAlgebras.alt"><code>Chevie.HeckeAlgebras.alt</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><p><code>alt(a::HeckeTElt)</code></p><p><code>a</code> should be an element of an Iwahori-Hecke algebra <code>H</code>. the involution on <code>H</code>   defined  by  <code>xâ†¦  bar(x)</code>   on  coefficients  and  <code>Tâ‚›â†¦  uâ‚›,â‚€uâ‚›,â‚Tâ‚›</code>. Essentially it corresponds to tensoring with the sign representation.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2);H=hecke(W,Pol(:q))
hecke(Gâ‚‚,q)

julia&gt; T=Tbasis(H);h=T(1,2)*T(2,1)
qÂ²T.+(qÂ²-q)Tâ‚+(q-1)Tâ‚â‚‚â‚

julia&gt; alt(h)
qâ»Â²T.+(qâ»Â²-qâ»Â³)Tâ‚+(qâ»Â³-qâ»â´)Tâ‚â‚‚â‚</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/672ace5cc6250cb344a26a435cd2b757cb16fc90/src/HeckeAlgebras.jl#L1018-L1035">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Garside.Î±-Tuple{HeckeTElt}"><a class="docstring-binding" href="#Chevie.Garside.Î±-Tuple{HeckeTElt}"><code>Chevie.Garside.Î±</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><p><code>Î±(a::HeckeTElt)</code></p><p>the anti-involution on the Hecke algebra defined by <span>$T_wâ†¦ T_{inv(w)}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/672ace5cc6250cb344a26a435cd2b757cb16fc90/src/HeckeAlgebras.jl#L1041-L1045">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Chars.CharTable-Tuple{HeckeAlgebra}"><a class="docstring-binding" href="#Chevie.Chars.CharTable-Tuple{HeckeAlgebra}"><code>Chevie.Chars.CharTable</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><p><code>CharTable(H::HeckeAlgebra or HeckeCoset)</code></p><p>returns the <code>CharTable</code> of the Hecke algebra <code>H</code>. For the primitive complex reflection group <code>Gâ‚ƒâ‚„</code> there are <code>missing</code> entries. If <code>W=H.W</code>, the columns of  the  <code>CharTable</code>  are  labelled  by  <code>classnames(W)</code>; the <code>i</code>-th column contains   the  character  values   for  the  lift   to  <code>H</code>  of  the  word <code>classinfo(W).classreps[i]</code>   for   the   element   <code>classreps(W)[i]</code>  (see <a href="#Chevie.HeckeAlgebras.char_values"><code>char_values</code></a> for more information).</p><pre><code class="language-julia-repl hljs">julia&gt; H=hecke(crg(4),Pol())
hecke(Gâ‚„,q)

julia&gt; CharTable(H)
CharTable(hecke(Gâ‚„,q))
â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    â”‚.    z 2c    c     zc     1        1zâ”‚
â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚Ï†â‚â€šâ‚€â”‚1   qâ¶ qÂ³   qÂ²     qâ¸     q        qâ·â”‚
â”‚Ï†â‚â€šâ‚„â”‚1    1  1  Î¶â‚ƒÂ²    Î¶â‚ƒÂ²    Î¶â‚ƒ        Î¶â‚ƒâ”‚
â”‚Ï†â‚â€šâ‚ˆâ”‚1    1  1   Î¶â‚ƒ     Î¶â‚ƒ   Î¶â‚ƒÂ²       Î¶â‚ƒÂ²â”‚
â”‚Ï†â‚‚â€šâ‚…â”‚2   -2  .    1     -1    -1         1â”‚
â”‚Ï†â‚‚â€šâ‚ƒâ”‚2 -2qÂ³  . Î¶â‚ƒÂ²q -Î¶â‚ƒÂ²qâ´ q+Î¶â‚ƒÂ² -qâ´-Î¶â‚ƒÂ²qÂ³â”‚
â”‚Ï†â‚‚â€šâ‚â”‚2 -2qÂ³  .  Î¶â‚ƒq  -Î¶â‚ƒqâ´  q+Î¶â‚ƒ  -qâ´-Î¶â‚ƒqÂ³â”‚
â”‚Ï†â‚ƒâ€šâ‚‚â”‚3  3qÂ² -q    .      .   q-1     qÂ³-qÂ²â”‚
â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/672ace5cc6250cb344a26a435cd2b757cb16fc90/src/HeckeAlgebras.jl#L485-L513">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.HeckeAlgebras.central_monomials"><a class="docstring-binding" href="#Chevie.HeckeAlgebras.central_monomials"><code>Chevie.HeckeAlgebras.central_monomials</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><p><code>central_monomials(H)</code></p><p>Let  <code>H</code>  be  an  Hecke  algebra  for  the finite reflection group <code>W</code>. The function  returns the scalars by which the image  in <code>H</code> of <code>Ï€</code> acts on the irreducible representations of <code>H</code>.</p><p>When  <code>W</code> is irreducible,  <code>Ï€</code> is the  generator of the  center of the pure braid  group.  In  general,  it  is  the  product of such elements for each irreducible  component. When  <code>W</code> is  a Coxeter  group, the  image of  Ï€ in <code>H</code> is <span>$T_{w_0}^2$</span>.</p><pre><code class="language-julia-repl hljs">julia&gt; H=hecke(coxgroup(:H,3),Pol(:q))
hecke(Hâ‚ƒ,q)

julia&gt; central_monomials(H)
10-element Vector{Pol{Cyc{Int64}}}:
 1
 qÂ³â°
 qÂ¹Â²
 qÂ¹â¸
 qÂ¹â°
 qÂ¹â°
 qÂ²â°
 qÂ²â°
 qÂ¹âµ
 qÂ¹âµ</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/672ace5cc6250cb344a26a435cd2b757cb16fc90/src/HeckeAlgebras.jl#L743-L772">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.HeckeAlgebras.class_polynomials"><a class="docstring-binding" href="#Chevie.HeckeAlgebras.class_polynomials"><code>Chevie.HeckeAlgebras.class_polynomials</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><p><code>class_polynomials(h::HeckeElt)</code></p><p>returns  the  class  polynomials  of  the  element <code>h</code> of the Iwahori-Hecke algebra or coset given by <code>h.H</code> with respect to the <code>T</code> basis for a set <code>R</code> of  representatives  of  minimal  length  in  the  conjugacy classes of the Coxeter group or coset <code>H.W</code>. Such minimal length representatives are given by  <code>classreps(H.W)</code>. The vector <code>p</code> of  these polynomials has the property that  if <code>X</code> is the  matrix of the values  of the irreducible characters of <code>H</code>  on <code>T_w</code> (for <code>wâˆˆ R</code>), then the product <code>X*p</code> is the list of values of the irreducible characters on <code>h</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxsym(4)
ğ”– â‚„

julia&gt; H=hecke(W,Pol(:q))
hecke(ğ”– â‚„,q)

julia&gt; h=Tbasis(H,longest(W))
Tâ‚â‚‚â‚â‚ƒâ‚‚â‚

julia&gt; p=class_polynomials(h)
5-element Vector{Pol{Int64}}:
 0
 0
 qÂ²
 qÂ³-2qÂ²+q
 qÂ³-qÂ²+q-1</code></pre><p>The class polynomials were introduced in (<a href="../references/#gp93">Geck and Pfeiffer, 1993</a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/672ace5cc6250cb344a26a435cd2b757cb16fc90/src/HeckeAlgebras.jl#L1048-L1079">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.HeckeAlgebras.char_values"><a class="docstring-binding" href="#Chevie.HeckeAlgebras.char_values"><code>Chevie.HeckeAlgebras.char_values</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><p><code>char_values(h::HeckeTElt)</code></p><p><code>h</code> is an element of an Iwahori-Hecke algebra <code>H</code>. The function returns the values  of the irreducible characters of <code>H</code>  on <code>h</code> (the method used is to convert to the <code>T</code> basis, and then use <code>class_polynomials</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:B,2)
Bâ‚‚

julia&gt; H=hecke(W,q^2;rootpara=q)
hecke(Bâ‚‚,qÂ²,rootpara=q)

julia&gt; char_values(Cpbasis(H)(1,2,1))
5-element Vector{Pol{Int64}}:
 -q-qâ»Â¹
 q+qâ»Â¹
 0
 qÂ³+2q+2qâ»Â¹+qâ»Â³
 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/672ace5cc6250cb344a26a435cd2b757cb16fc90/src/HeckeAlgebras.jl#L1134-L1156">source</a></section><section><div><p><code>char_values(H::HeckeAlgebra,v::Vector{&lt;:Integer})</code></p><p>For an Iwahori-Hecke algebra this computes the character values of <code>H</code> on <code>Tbasis(H)(v)</code>.</p><p>For  <code>H</code> the Hecke algebra  of a complex reflection  group <code>W</code> this routine computes  character values on a  lift of the element  of <code>W</code> defined by the word <code>v</code> in <code>gens(W)</code>.</p><p>For  complex reflection  groups the  character table  of the  generic Hecke algebra of <code>W</code> has been computed (excepted for <code>Gâ‚ƒâ‚„</code>) in the sense that, if <code>sâ‚,â€¦,sâ‚™</code> are generators of the braid group lifting the BrouÃ©-Malle-Rouquier-Bessis-Michel generators of <code>W</code>, there is at least one element  <code>v</code>  in  each  conjugacy  class  of  <code>W</code> and one expression in the generators  for it such that the character  values of the image <code>Táµ¥</code> in the Hecke  algebra of the lift to the braid group are known. Such an expression in the generators will be called a <em>known</em> word (the list of known words is obtained  by <code>word.(conjugacy_classes(W))</code>  or <code>classinfo(W).classtext</code>. If the  word <code>v</code> is known, the computation is quick using the character table. If  not,  the  function  computes  the  trace  of  <code>Táµ¥</code> in each irreducible representation.   The   values   returned   are   <code>missing</code>   for   missing representations    (see   <a href="../chars/#Chevie.Chars.representation-Tuple{Union{Spets, FiniteCoxeterGroup, PermRootGroup}, Integer}"><code>representation</code></a>;   there   are   missing representations for <code>Gâ‚ƒâ‚, Gâ‚ƒâ‚‚</code> and <code>Gâ‚ƒâ‚„</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; W=crg(4)
Gâ‚„

julia&gt; H=hecke(W,Pol(:q))
hecke(Gâ‚„,q)

julia&gt; char_values(H,[2,1,2])
7-element Vector{Pol{Cyc{Int64}}}:
 qÂ³
 1
 1
 0
 0
 0
 -q</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/672ace5cc6250cb344a26a435cd2b757cb16fc90/src/HeckeAlgebras.jl#L1159-L1200">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.HeckeAlgebras.schur_elements"><a class="docstring-binding" href="#Chevie.HeckeAlgebras.schur_elements"><code>Chevie.HeckeAlgebras.schur_elements</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><p><code>schur_elements(H)</code></p><p>returns the list of Schur elements for the Hecke algebra <code>H</code></p><pre><code class="language-julia-repl hljs">julia&gt; H=hecke(complex_reflection_group(4),Pol(:q))
hecke(Gâ‚„,q)

julia&gt; s=schur_elements(H)
7-element Vector{Pol{Cyc{Int64}}}:
 qâ¸+2qâ·+3qâ¶+4qâµ+4qâ´+4qÂ³+3qÂ²+2q+1
 2âˆš-3+(6+4âˆš-3)qâ»Â¹+12qâ»Â²+(6-4âˆš-3)qâ»Â³-2âˆš-3qâ»â´
 -2âˆš-3+(6-4âˆš-3)qâ»Â¹+12qâ»Â²+(6+4âˆš-3)qâ»Â³+2âˆš-3qâ»â´
 2+2qâ»Â¹+4qâ»Â²+2qâ»Â³+2qâ»â´
 Î¶â‚ƒÂ²âˆš-3qÂ³+(3-âˆš-3)qÂ²+3q+3+âˆš-3-Î¶â‚ƒâˆš-3qâ»Â¹
 -Î¶â‚ƒâˆš-3qÂ³+(3+âˆš-3)qÂ²+3q+3-âˆš-3+Î¶â‚ƒÂ²âˆš-3qâ»Â¹
 qÂ²+2q+2+2qâ»Â¹+qâ»Â²

julia&gt; CycPol.(s)
7-element Vector{CycPol{Cyc{Int64}}}:
 Î¦â‚‚Â²Î¦â‚ƒÎ¦â‚„Î¦â‚†
 2âˆš-3qâ»â´Î¦â‚‚Â²Î¦â€²â‚ƒÎ¦â€²â‚†
 -2âˆš-3qâ»â´Î¦â‚‚Â²Î¦â€³â‚ƒÎ¦â€³â‚†
 2qâ»â´Î¦â‚ƒÎ¦â‚„
 Î¶â‚ƒÂ²âˆš-3qâ»Â¹Î¦â‚‚Â²Î¦â€²â‚ƒÎ¦â€³â‚†
 -Î¶â‚ƒâˆš-3qâ»Â¹Î¦â‚‚Â²Î¦â€³â‚ƒÎ¦â€²â‚†
 qâ»Â²Î¦â‚‚Â²Î¦â‚„</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/672ace5cc6250cb344a26a435cd2b757cb16fc90/src/HeckeAlgebras.jl#L1219-L1248">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.HeckeAlgebras.factorized_schur_element"><a class="docstring-binding" href="#Chevie.HeckeAlgebras.factorized_schur_element"><code>Chevie.HeckeAlgebras.factorized_schur_element</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><p><code>factorized_schur_element(H,phi)</code></p><p>returns the factorized <code>schur_element</code> (see <a href="#Chevie.HeckeAlgebras.factorized_schur_elements"><code>factorized_schur_elements</code></a>)  of  the  Hecke  algebra  <code>H</code>  for the irreducible character of <code>H</code> of parameter <code>phi</code> (see <a href="../chars/#Chevie.Chars.charinfo"><code>charinfo</code></a><code>(W).charparams</code>)</p><pre><code class="language-julia-repl hljs">julia&gt; W=complex_reflection_group(4)
Gâ‚„

julia&gt; @Mvp x,y; H=hecke(W,[[1,x,y]])
hecke(Gâ‚„,Vector{Mvp{Int64, Int64}}[[1, x, y]])

julia&gt; factorized_schur_element(H,[[2,5]])
-xâ»Â¹y(xy+1)(x-1)Î¦â‚†(xyâ»Â¹)(y-1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/672ace5cc6250cb344a26a435cd2b757cb16fc90/src/HeckeAlgebras.jl#L1448-L1466">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.HeckeAlgebras.factorized_schur_elements"><a class="docstring-binding" href="#Chevie.HeckeAlgebras.factorized_schur_elements"><code>Chevie.HeckeAlgebras.factorized_schur_elements</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><p><code>factorized_schur_elements(H)</code></p><p>Let  <code>H</code> be  a Hecke  algebra for  the complex  reflection group <code>W</code>, whose parameters are all (Laurent) monomials in some variables <code>xâ‚,â€¦,xâ‚™</code>, and let K  be the field of definition of  <code>W</code>. Then (<a href="../references/#chlou09">Chlouveraki, 2009</a>) has shown that the  Schur elements of <code>H</code> take the  particular form <code>M âˆáµ© Ï†(Máµ©)</code> where <code>Ï†</code> runs  over  a  list  of  K-cyclotomic  polynomials,  and  <code>M</code>  and <code>Máµ©</code> are (Laurent)  monomials (in possibly some  fractional powers) of the variables <code>xáµ¢</code>.  The  function  <code>factorized_schur_elements</code>  returns a data structure (see <a href="#Chevie.HeckeAlgebras.FactSchur"><code>HeckeAlgebras.FactSchur</code></a>) which shows this factorization.</p><pre><code class="language-julia-repl hljs">julia&gt; W=complex_reflection_group(4)
Gâ‚„

julia&gt; @Mvp x,y; H=hecke(W,[[1,x,y]])
hecke(Gâ‚„,Vector{Mvp{Int64, Int64}}[[1, x, y]])

julia&gt; factorized_schur_elements(H)
7-element Vector{Chevie.HeckeAlgebras.FactSchur}:
 xâ»â´yâ»â´(xy+1)Î¦â‚Î¦â‚†(x)Î¦â‚Î¦â‚†(y)
 (xÂ²yâ»Â¹+1)Î¦â‚Î¦â‚†(x)Î¦â‚Î¦â‚†(xyâ»Â¹)
 -xâ»â´yâµÎ¦â‚Î¦â‚†(xyâ»Â¹)(xyâ»Â²+1)Î¦â‚Î¦â‚†(y)
 -xâ»Â¹y(xy+1)(x-1)Î¦â‚†(xyâ»Â¹)(y-1)
 -xâ»â´y(xÂ²yâ»Â¹+1)(x-1)(xyâ»Â¹-1)Î¦â‚†(y)
 xâ»Â¹yâ»Â¹Î¦â‚†(x)(xyâ»Â¹-1)(xyâ»Â²+1)(y-1)
 xâ»Â²y(xÂ²yâ»Â¹+1)(xy+1)(xyâ»Â²+1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/672ace5cc6250cb344a26a435cd2b757cb16fc90/src/HeckeAlgebras.jl#L1477-L1506">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.HeckeAlgebras.FactSchur"><a class="docstring-binding" href="#Chevie.HeckeAlgebras.FactSchur"><code>Chevie.HeckeAlgebras.FactSchur</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><p>A  <code>FactSchur</code> representing  a Schur  element of  the form  <code>Mâˆáµ©Ï†(Máµ©)</code> (see <a href="#Chevie.HeckeAlgebras.factorized_schur_element"><code>factorized_schur_element</code></a>)  is  a  <code>struct</code>  with a field <code>factor</code> which  holds the  monomial <code>M</code>,  and a  field <code>vcyc</code>  which holds a list of <code>NamedTuples</code>  describing each  factor <code>Máµ©</code>  in the  product. An element of <code>vcyc</code>  representing a  term <code>Ï†(Máµ©)</code>  is itself  a <code>NamedTuple</code> with fields <code>monomial</code> holding <code>Máµ©</code> (as an <code>Mvp</code> with a single term), and a field <code>pol</code> holding a <code>CycPol</code> (see <code>CycPol</code>) representing <code>Ï†</code>.</p><p>A  few operations are implemented for  <code>FactSchur</code>, like <code>*, lcm</code>. They can be  evaluated  partially  or  completely  keeping  as  much as possible the factored form.</p><pre><code class="language-julia-repl hljs">julia&gt; @Mvp x,y; W=crg(4); H=hecke(W,[[1,x,y]])
hecke(Gâ‚„,Vector{Mvp{Int64, Int64}}[[1, x, y]])

julia&gt; p=factorized_schur_element(H,[[2,5]])
-xâ»Â¹y(xy+1)(x-1)Î¦â‚†(xyâ»Â¹)(y-1)

julia&gt; q=p(;x=E(3)) # partial evaluation
Î¶â‚ƒÂ²âˆš-3yâ»Â¹Î¦â‚Î¦â‚‚Î¦â€²â‚†Â²(y)

julia&gt; q(;y=2//1)
-9âˆš-3/2</code></pre><p>In contrast, the next operation expands <code>p</code> to an <code>Mvp</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; HeckeAlgebras.expand(p)
Mvp{Cyc{Rational{Int64}},Rational{Int64}}: -xÂ³y+xÂ³+xÂ²yÂ²-2xÂ²+xÂ²yâ»Â¹-xyÂ³+2xy-xyâ»Â¹+yÂ³-2yÂ²+1+xâ»Â¹yÂ²-xâ»Â¹y</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/672ace5cc6250cb344a26a435cd2b757cb16fc90/src/HeckeAlgebras.jl#L1255-L1288">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Chars.representation-Tuple{HeckeAlgebra, Integer}"><a class="docstring-binding" href="#Chevie.Chars.representation-Tuple{HeckeAlgebra, Integer}"><code>Chevie.Chars.representation</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><p><code>representation(H::HeckeAlgebra or HeckeCoset,i)</code></p><p>returns,  for the <code>i</code>-th irreducible representation of the Hecke algebra or Hecke  coset <code>H</code>, a list  of matrices images of  the generators of <code>H</code> in a model of the representation (for Hecke cosets, the result is a <code>NamedTuple</code> with fields <code>gens</code>, a representation of <code>hecke(H)</code>, and <code>F</code>, the matrix for the automorphism of <code>H</code> in the representation).</p><p>This  function  is  based  on  the  classification,  and  is  not yet fully implemented for the Hecke algebras of the groups <code>Gâ‚ƒâ‚</code>, <code>Gâ‚ƒâ‚‚</code> and <code>Gâ‚ƒâ‚„</code>: we have 50 representations out of 59 for type <code>Gâ‚ƒâ‚</code>, 30 representations out of 102  for  type  <code>Gâ‚ƒâ‚‚</code>  and  38  representations  out of 169 for type <code>Gâ‚ƒâ‚„</code>; <code>nothing</code> is returned for a missing representation.</p><pre><code class="language-julia-repl hljs">julia&gt; W=crg(24)
Gâ‚‚â‚„

julia&gt; H=hecke(W,Pol(:q))
hecke(Gâ‚‚â‚„,q)

julia&gt; representation(H,3)
3-element Vector{Matrix{Pol{Cyc{Int64}}}}:
 [q 0 0; -q -1 0; -q 0 -1]
 [-1 0 -1; 0 -1 ((1-âˆš-7)/2)q; 0 0 q]
 [-1 -1 0; 0 q 0; 0 (1+âˆš-7)/2 -1]</code></pre><p>The  models  implemented  for  imprimitive  types <code>G(de,e,n)</code> for <code>n&gt;2</code> and <code>de&gt;1</code> (this includes Coxeter type <code>Dâ‚™</code>), excepted for <code>G(2,2,4), G(3,3,3), G(3,3,4), G(3,3,5)</code> and <code>G(4,4,3)</code>, involve rational fractions.</p><pre><code class="language-julia-repl hljs">julia&gt; H=hecke(coxgroup(:D,5),Pol(:q))
hecke(Dâ‚…,q)

julia&gt; representation(H,7)
5-element Vector{Matrix{Frac{Pol{Int64}}}}:
 [q 0 0 0; 0 -1 0 0; 0 0 -1 0; 0 0 0 -1]
 [q 0 0 0; 0 -1 0 0; 0 0 -1 0; 0 0 0 -1]
 [1/(-q-1) q/(q+1) 0 0; (qÂ²+q+1)/(q+1) qÂ²/(q+1) 0 0; 0 0 -1 0; 0 0 0 -1]
 [-1 0 0 0; 0 1/(-qÂ²-q-1) (-qÂ²-q)/(-qÂ²-q-1) 0; 0 (qÂ³+qÂ²+q+1)/(qÂ²+q+1) qÂ³/(qÂ²+q+1) 0; 0 0 0 -1]
 [-1 0 0 0; 0 -1 0 0; 0 0 1/(-qÂ³-qÂ²-q-1) (-qÂ³-qÂ²-q)/(-qÂ³-qÂ²-q-1); 0 0 (qâ´+qÂ³+qÂ²+q+1)/(qÂ³+qÂ²+q+1) qâ´/(qÂ³+qÂ²+q+1)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/672ace5cc6250cb344a26a435cd2b757cb16fc90/src/HeckeAlgebras.jl#L536-L581">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Chars.representation-Tuple{HeckeElt, Any}"><a class="docstring-binding" href="#Chevie.Chars.representation-Tuple{HeckeElt, Any}"><code>Chevie.Chars.representation</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><p><code>representation(h::HeckeElt,r)</code></p><p><code>r</code>  should be a representation  of <code>h.H</code>, or an  integer, in which case it means  <code>representation(h.H,r)</code>. The value of that representation applied to <code>h</code> is returned. Here <code>h.H</code> can be an Hecke algebra or an Hecke coset.</p><pre><code class="language-julia-repl hljs">julia&gt; H=hecke(coxsym(4),Pol(:q));T=Tbasis(H);

julia&gt; representation(T(1,2)^2,2)
3Ã—3 Matrix{Pol{Rational{Int64}}}:
 -qÂ²  -qÂ²   0
 qÂ²   0     0
 -q   -q+1  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/672ace5cc6250cb344a26a435cd2b757cb16fc90/src/HeckeAlgebras.jl#L835-L850">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Chars.representations-Tuple{Union{HeckeAlgebra, HeckeCoset}}"><a class="docstring-binding" href="#Chevie.Chars.representations-Tuple{Union{HeckeAlgebra, HeckeCoset}}"><code>Chevie.Chars.representations</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><p><code>representations(H)</code></p><p>returns  the list  of representations  of the  Hecke algebra or Hecke coset <code>H</code> (see <a href="../chars/#Chevie.Chars.representation-Tuple{Union{Spets, FiniteCoxeterGroup, PermRootGroup}, Integer}"><code>representation</code></a>).</p><pre><code class="language-julia-repl hljs">julia&gt; WF=rootdatum(&quot;2B2&quot;)
Â²Bâ‚‚

julia&gt; H=hecke(WF,Pol(:x)^2;rootpara=Pol())
hecke(Â²Bâ‚‚,xÂ²,rootpara=x)

julia&gt; representations(H)
3-element Vector{NamedTuple{(:gens, :F)}}:
 (gens = Matrix{Pol{Int64}}[[xÂ²;;], [xÂ²;;]], F = [1;;])
 (gens = Matrix{Pol{Int64}}[[-1;;], [-1;;]], F = [1;;])
 (gens = Matrix{Pol{Cyc{Int64}}}[[-1 0; âˆš2x xÂ²], [xÂ² âˆš2x; 0 -1]], F = [0 -1; -1 0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/672ace5cc6250cb344a26a435cd2b757cb16fc90/src/HeckeAlgebras.jl#L1624-L1643">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.HeckeAlgebras.isrepresentation"><a class="docstring-binding" href="#Chevie.HeckeAlgebras.isrepresentation"><code>Chevie.HeckeAlgebras.isrepresentation</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><p><code>isrepresentation(H::HeckeAlgebra,r;details=false)</code> or</p><p><code>isrepresentation(W::ComplexReflectionGroup,r;details=false)</code></p><p>returns <code>true</code> or <code>false</code>, according to whether a given set <code>r</code> of elements in bijection with <code>gens(H.W)</code> defines a representation of the Hecke algebra <code>H</code> or not; <code>isrepresentation(W,r)</code> is equivalent to <code>isrepresentation(hecke(W)),r)</code>.   If  <code>details=true</code>  the  function  gives details of the cause of a failure.</p><pre><code class="language-julia-repl hljs">julia&gt; H=hecke(coxgroup(:F,4))
hecke(Fâ‚„,1)

julia&gt; isrepresentation(H,reflrep(H))
true

julia&gt; isrepresentation(H,Tbasis(H).(1:4))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/672ace5cc6250cb344a26a435cd2b757cb16fc90/src/HeckeAlgebras.jl#L599-L620">source</a></section><section><div><p><code>isrepresentation(H::HeckeCoset,r;details=false)</code> or</p><p><code>isrepresentation(W::Spets,r;details=false)</code></p><p>returns <code>true</code> or <code>false</code>, according to whether <code>NamedTuple</code> <code>r</code> defines a representation of <code>H</code> or not. If details=true the function gives details of the cause of a failure. ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/672ace5cc6250cb344a26a435cd2b757cb16fc90/src/HeckeAlgebras.jl#L1646-L1655">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.PermRoot.reflection_representation-Tuple{HeckeAlgebra}"><a class="docstring-binding" href="#Chevie.PermRoot.reflection_representation-Tuple{HeckeAlgebra}"><code>Chevie.PermRoot.reflection_representation</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><p><code>reflection_representation(H::HeckeAlgebra)</code> or <code>reflrep(H)</code></p><p>returns  a  list  of  matrices  for  the  generators  of <code>H</code> which give the reflection  representation of the Iwahori-Hecke  algebra <code>H</code>. This is based on a general formula and does not necessarily agree with <code>representation(H,i)</code>   where   <code>i</code>   is   the   index  of  the  reflection representation,   and   does   not   either   necessarily   specialises  to <code>reflrep(H.W)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:B,2);H=hecke(W,Pol(:q))
hecke(Bâ‚‚,q)

julia&gt; reflrep(H)
2-element Vector{Matrix{Pol{Int64}}}:
 [-1 0; -q q]
 [q -2; 0 -1]

julia&gt; H=hecke(coxgroup(:H,3))
hecke(Hâ‚ƒ,1)

julia&gt; reflrep(H)
3-element Vector{Matrix{Cyc{Int64}}}:
 [-1 0 0; -1 1 0; 0 0 1]
 [1 (-3-âˆš5)/2 0; 0 -1 0; 0 -1 1]
 [1 0 0; 0 1 -1; 0 0 -1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/672ace5cc6250cb344a26a435cd2b757cb16fc90/src/HeckeAlgebras.jl#L649-L677">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.HeckeAlgebras.HeckeCoset"><a class="docstring-binding" href="#Chevie.HeckeAlgebras.HeckeCoset"><code>Chevie.HeckeAlgebras.HeckeCoset</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><p><code>HeckeCoset</code>s  are  <code>HÏ•</code>  where  <code>H</code>  is  an  Iwahori-Hecke algebra of some Coxeter  group <code>W</code> on which the automorphism <code>Ï•</code> of some Spets <code>WÏ•</code> acts by <code>Ï•(T_w)=T_{Ï•(w)}</code>.  For Weyl groups, this corresponds  to the action of the Frobenius  automorphism  on  the  commuting  algebra  of the induced of the trivial  representation from the  rational points of  some <code>F</code>-stable Borel subgroup to <code>ğ† ^F</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; WF=rootdatum(:u,3)
uâ‚ƒ

julia&gt; HF=hecke(WF,Pol(:v)^2;rootpara=Pol())
hecke(uâ‚ƒ,vÂ²,rootpara=v)

julia&gt; CharTable(HF)
CharTable(hecke(uâ‚ƒ,vÂ²,rootpara=v))
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   â”‚ 111 21  3â”‚
â”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚111â”‚  -1  1 -1â”‚
â”‚21 â”‚-2vÂ³  .  vâ”‚
â”‚3  â”‚  vâ¶  1 vÂ²â”‚
â””â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre><p>Thanks  to the work  of (<a href="../references/#hn12">He and Nie, 2012</a>), &#39;class_polynomials&#39;  also make sense for these cosets. This is used to compute such character tables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/672ace5cc6250cb344a26a435cd2b757cb16fc90/src/HeckeAlgebras.jl#L1518-L1545">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.HeckeAlgebras.hecke-Tuple{HeckeCoset}"><a class="docstring-binding" href="#Chevie.HeckeAlgebras.hecke-Tuple{HeckeCoset}"><code>Chevie.HeckeAlgebras.hecke</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><p><code>hecke(HF::HeckeCoset)</code> returns the underlying Hecke algebra</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/672ace5cc6250cb344a26a435cd2b757cb16fc90/src/HeckeAlgebras.jl#L1551">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.HeckeAlgebras.hecke-Tuple{Spets, HeckeAlgebra}"><a class="docstring-binding" href="#Chevie.HeckeAlgebras.hecke-Tuple{Spets, HeckeAlgebra}"><code>Chevie.HeckeAlgebras.hecke</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><p><code>hecke(WF::Spets, H)</code></p><p><code>hecke(WF::Spets, params)</code></p><p>Construct  a <code>HeckeCoset</code>  from a  Coxeter coset  <code>WF</code> and an Hecke algebra associated to <code>Group(WF)</code>. The second form is equivalent to <code>Hecke(WF,Hecke(Group(WF),params))</code>. See the doc for <code>HeckeCoset</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/672ace5cc6250cb344a26a435cd2b757cb16fc90/src/HeckeAlgebras.jl#L1554-L1562">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../chars/">Â« Classes/characters of reflection groups</a><a class="docs-footer-nextpage" href="../kl/">Kazhdan-Lusztig polynomials and bases Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 29 January 2026 13:38">Thursday 29 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
