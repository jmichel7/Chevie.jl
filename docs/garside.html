<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Garside monoids and groups, braids. ¬∑ Chevie.jl documentation</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Chevie.jl documentation</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Chevie</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Infrastructure</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="format.html">formatting facilities</a></li><li><a class="tocitem" href="symbols.html">Symbols</a></li><li><a class="tocitem" href="nf.html">Number fields</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Reflection groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="permroot.html">Finite reflection groups</a></li><li><a class="tocitem" href="coxgroups.html">Coxeter groups</a></li><li><a class="tocitem" href="weyl.html">Finite Coxeter groups, Weyl groups, crystallographic root systems</a></li><li><a class="tocitem" href="chars.html">Classes/characters of reflection groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Hecke algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="hecke.html">Hecke algebras</a></li><li><a class="tocitem" href="kl.html">Kazhdan-Lusztig polynomials and bases</a></li><li><a class="tocitem" href="algebras.html">Algebras</a></li></ul></li><li class="is-active"><a class="tocitem" href="garside.html">Garside monoids and groups, braids.</a></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Reductive groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="semisimple.html">Reductive groups, semisimple elements</a></li><li><a class="tocitem" href="cosets.html">Reflection cosets and Spets</a></li><li><a class="tocitem" href="sscoset.html">Non-connected reductive groups</a></li><li><a class="tocitem" href="uch.html">Unipotent characters</a></li><li><a class="tocitem" href="ct.html">Classtypes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Eigenspaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="eigen.html">Eigenspaces</a></li><li><a class="tocitem" href="dseries.html">d-Harish-Chandra series</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Unipotent elements</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="ucl.html">Unipotent classes of reductive groups</a></li><li><a class="tocitem" href="urad.html">Unipotent Elements</a></li></ul></li><li><a class="tocitem" href="gendec.html">Decomposition Matrices</a></li><li><a class="tocitem" href="dict.html">Dictionary from GAP3/Chevie</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="garside.html">Garside monoids and groups, braids.</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="garside.html">Garside monoids and groups, braids.</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jmichel7/Chevie.jl/blob/master/docs/src/garside.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Garside-monoids-and-groups,-braids."><a class="docs-heading-anchor" href="#Garside-monoids-and-groups,-braids.">Garside monoids and groups, braids.</a><a id="Garside-monoids-and-groups,-braids.-1"></a><a class="docs-heading-anchor-permalink" href="#Garside-monoids-and-groups,-braids." title="Permalink"></a></h1><ul><li><a href="garside.html#Chevie.Garside"><code>Chevie.Garside</code></a></li><li><a href="garside.html#Chevie.Garside.BraidMonoid"><code>Chevie.Garside.BraidMonoid</code></a></li><li><a href="garside.html#Chevie.Garside.Category"><code>Chevie.Garside.Category</code></a></li><li><a href="garside.html#Chevie.Garside.Category-Tuple{Function, Any}"><code>Chevie.Garside.Category</code></a></li><li><a href="garside.html#Chevie.Garside.DualBraidMonoid"><code>Chevie.Garside.DualBraidMonoid</code></a></li><li><a href="garside.html#Chevie.Garside.GarsideMonoid"><code>Chevie.Garside.GarsideMonoid</code></a></li><li><a href="garside.html#Chevie.Garside.LocallyGarsideMonoid"><code>Chevie.Garside.LocallyGarsideMonoid</code></a></li><li><a href="garside.html#GroupPresentations.Presentation-Tuple{GarsideMonoid}"><code>GroupPresentations.Presentation</code></a></li><li><a href="garside.html#Chevie.CoxGroups.isleftdescent-Tuple{BraidMonoid, Any, Int64}"><code>Chevie.CoxGroups.isleftdescent</code></a></li><li><a href="garside.html#Chevie.CoxGroups.leftdescents-Tuple{Chevie.Garside.LocallyGarsideElt}"><code>Chevie.CoxGroups.leftdescents</code></a></li><li><a href="garside.html#Chevie.Garside.Brieskorn_normal_form"><code>Chevie.Garside.Brieskorn_normal_form</code></a></li><li><a href="garside.html#Chevie.Garside.CorranPicantinMonoid"><code>Chevie.Garside.CorranPicantinMonoid</code></a></li><li><a href="garside.html#Chevie.Garside.centralizer_gens"><code>Chevie.Garside.centralizer_gens</code></a></li><li><a href="garside.html#Chevie.Garside.conjcat"><code>Chevie.Garside.conjcat</code></a></li><li><a href="garside.html#Chevie.Garside.conjugating_elt"><code>Chevie.Garside.conjugating_elt</code></a></li><li><a href="garside.html#Chevie.Garside.endomorphisms"><code>Chevie.Garside.endomorphisms</code></a></li><li><a href="garside.html#Chevie.Garside.fraction"><code>Chevie.Garside.fraction</code></a></li><li><a href="garside.html#Chevie.Garside.hurwitz"><code>Chevie.Garside.hurwitz</code></a></li><li><a href="garside.html#Chevie.Garside.image"><code>Chevie.Garside.image</code></a></li><li><a href="garside.html#Chevie.Garside.left_divisors"><code>Chevie.Garside.left_divisors</code></a></li><li><a href="garside.html#Chevie.Garside.leftgcd"><code>Chevie.Garside.leftgcd</code></a></li><li><a href="garside.html#Chevie.Garside.leftlcm"><code>Chevie.Garside.leftlcm</code></a></li><li><a href="garside.html#Chevie.Garside.rightascents"><code>Chevie.Garside.rightascents</code></a></li><li><a href="garside.html#Chevie.Garside.rightgcd"><code>Chevie.Garside.rightgcd</code></a></li><li><a href="garside.html#Chevie.Garside.rightlcm"><code>Chevie.Garside.rightlcm</code></a></li><li><a href="garside.html#Chevie.Garside.shrink"><code>Chevie.Garside.shrink</code></a></li><li><a href="garside.html#Chevie.Garside.Œ±-Tuple{Chevie.Garside.LocallyGarsideElt}"><code>Chevie.Garside.Œ±</code></a></li><li><a href="garside.html#Chevie.Garside.Œ±-Tuple{Chevie.Garside.LocallyGarsideElt, AbstractVector}"><code>Chevie.Garside.Œ±</code></a></li><li><a href="garside.html#Chevie.Garside.Œ¥ad"><code>Chevie.Garside.Œ¥ad</code></a></li><li><a href="garside.html#PermGroups.Groups.elements-Tuple{LocallyGarsideMonoid, Integer}"><code>PermGroups.Groups.elements</code></a></li><li><a href="garside.html#PermGroups.Groups.word-Tuple{GarsideElt}"><code>PermGroups.Groups.word</code></a></li><li><a href="garside.html#PermGroups.Groups.word-Tuple{LocallyGarsideMonoid, Any}"><code>PermGroups.Groups.word</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Chevie.Garside" href="#Chevie.Garside"><code>Chevie.Garside</code></a> ‚Äî <span class="docstring-category">Module</span></header><section><div><p>Garside  monoids are a general class  of monoids whose most famous examples are  the braid and dual braid monoids. They have groups of fractions, which in  both above examples is the braid  group. We implement braid groups as a special case of a general implementation of Garside monoids and groups.</p><p>We  first  introduce  some  vocabulary  about  divisibility  in  monoids. A <em>left-divisor</em>  of <code>x</code> is a <code>d</code> such that there exists <code>y</code> with <code>x=dy</code> (and then  we say that <code>x</code> is  a <em>right multiple</em> of <code>d</code>,  and write <code>d‚âº x</code>). We say  that a monoid <code>M</code>  is left cancellable if  an equality <code>dx=dy</code> implies <code>x=y</code>.  We  define  symmetrically  right-divisors,  left  multiples,  right cancellability  and the symbol <code>‚âΩ</code>. We say that <code>x</code> is an <em>atom</em> if <code>1</code> and <code>x</code>  are its only left or right divisors. A  <em>left gcd</em> of <code>x</code> and <code>y</code> is a common  left  divisor  <code>d</code>  of  <code>x</code>  and  <code>y</code>  such  that  any other common left-divisor  is a left-divisor of <code>d</code>. Similarly  a <em>right lcm</em> of <code>x</code> and <code>y</code>  is  a  common  multiple  which  is  a left-divisor of any other common multiple.</p><p>We  call <em>Garside</em> a monoid <code>M</code> which:</p><ul><li>is left and right cancellable.</li><li>is generated by its atoms.</li><li>admits left and  right  gcds  and  lcms.</li><li>is such that any element has only finitely many left (or right) divisors.</li><li>admits a <em>Garside element</em>, which is an element <code>Œî</code> whose set of left and right-divisors coincide and generate <code>M</code>.</li></ul><p>Garside  elements are not  unique, but there  is a unique  minimal one (for divisibility);  we assume that  a Garside element  <code>Œî</code> has been chosen. The divisors  of <code>Œî</code> are called  the <em>simples</em> of <code>M</code>.  A Garside monoid embeds into  its group of fractions, which is called a <em>Garside group</em>; the monoid defines  a <em>Garside structure</em> for the group of fractions. A group can have several  different Garside structures, for  instance braid groups of finite Coxeter groups have an ordinary and a dual braid monoid.</p><p>We  also implement more generally <em>locally Garside</em> monoids, which have the same  axioms, excepted lcms  do not always  exist, but exist  if any common multiple exists; they also do not have Garside elements. The set of simples is  then not defined by  a Garside element, but  by the condition that they contain  the  atoms  and  are  closed  under  lcms and taking divisors (see <a href="biblio.htm#BDM01">BDM01</a>);  each  element  is  still divisible by finitely many  simples,  but  the  set  simples  can be infinite. The most important example  is the Artin monoid of an  infinite Coxeter group. It is not known whether locally Garside monoids embed in their group of fractions (although this  has  been  proved  for  Artin  monoids  of  Coxeter  groups  by Paris <a href="biblio.htm#Paris01">Paris01</a>),  and thus computing in  the monoid does not help  for computing in the  group; only the monoid  is implemented here for these cases.</p><p>There  is another  generalization, <em>quasi-Garside  monoids</em>, where we relax the  axiom  that  an  element  has  finititely  many divisors (there may me infinitely  atoms).  We  do  not  implement  this but the package <code>AffineA</code> implements,  following the work of Fran√ßois Digne, the dual braid monoid of the affine Coxeter group <code>W(AÃÉ‚Çô)</code> which is of this type.</p><p>What allows computing with Garside and locally Garside monoids, and Garside groups,  is the fact  that they admit  normal forms ‚Äì-  these normal forms were   exhibited   for   braid   monoids   of  Coxeter  groups  by  Deligne <a href="biblio.htm#Del72">Del72</a>,  who extended  earlier work  of Brieskorn, Saito <a href="biblio.htm#BS72">BS72</a> and Garside <a href="biblio.htm#Gar69">Gar69</a>:</p><ol><li><p>Let <code>M</code> be a locally Garside monoid. Then for any <code>b‚àà M</code> there is a unique  maximal (for divisibility) simple left-divisor <code>Œ±(b)</code> of <code>b</code>. In a Garside monoid it is the <code>leftgcd(b,Œî)</code>.</p></li><li><p>Let <code>M</code> be a Garside monoid with Garside element <code>Œî</code> and group of fractions <code>G</code>. Then for any <code>x‚àà  G</code>, for large enough <code>i</code> we have <code>Œî‚Å±x‚àà M</code>.</p></li></ol><p>A  consequence  of  1.  is  that  every  element  of  <code>M</code>  has  a canonical decomposition as a product of simples, its <em>left-greedy</em> normal form. If we define   <code>œâ(x)</code>  by   <code>x=Œ±(x)œâ(x)</code>,  then   the  normal   form  of  <code>x</code>  is <code>Œ±(x)Œ±(œâ(x))Œ±(œâ^2(x))‚Ä¶</code>  For locally Garside monoids we use the normal form to  represent elements of <code>M</code>.  When <code>M</code> is Garside  we use 2. to represent any  element of <code>G</code>:  given <code>x‚àà G</code>  we compute the  smallest power <code>i</code> such that  <code>Œî‚Å± x‚àà M</code>, and  we represent <code>x</code> by  the pair <code>(-i,Œî‚Å±x)</code>. We are thus reduced  to the case where <code>x‚àà M</code>, not divisible by <code>Œî</code>, where we represent <code>x</code>  by the sequence of simples that make up its normal form (this sequence thus  does  not  contain  the  identity  or  <code>Delta</code>).  We  see that in our implementation  the  simples  is  another  type  that  the  type of Garside elements.  Thus a Garside monoid is  a parametrized type whose most general instance is the type <code>LocallyGarsideMonoid{T}</code> where <code>T</code> is the type of the simples.</p><p>We  now describe Artin-Tits braid monoids. Let <code>(W,S)</code> be a Coxeter system, that is <code>W</code> has presentation</p><p><code>‚ü®s‚àà S‚à£s¬≤=1, sts‚ãØ =tst‚ãØ   (m‚Çõ‚Çú factors on each side) for s,t‚àà S‚ü©</code></p><p>for some Coxeter matrix <code>m‚Çõ‚Çú</code>. The braid group <code>B</code> associated to <code>(W,S)</code> is the group defined by the presentation</p><p><code>‚ü®ùê¨‚àà ùêí‚à£ ùê¨ùê≠ùê¨‚ãØ =ùê≠ùê¨ùê≠‚ãØ  (m‚Çõ‚Çú factors on each side) for ùê¨,ùê≠‚àà ùêí‚ü©</code></p><p>The  associated <em>positive</em> braid monoid <code>B‚Å∫</code> is the monoid defined by  the  presentation  above  ‚Äì-  it  identifies with the submonoid of <code>B</code> generated  by <code>ùêí</code> by <a href="biblio.htm#Paris01">Paris01</a>.  This monoid is locally Garside,  with the set of simples in bijection with the elements of <code>W</code> and with  <code>ùêí</code> as atoms; we will denote by <code>ùêñ</code> the set of simples, and by <code>ùê∞ ‚Üî w</code>  the bijection between simples and elements  of <code>W</code>. The group <code>W</code> has a length  defined  in  terms  of  reduced expressions. Similarly, having only homogeneous relations, <code>B‚Å∫</code> has a natural length function. Then <code>ùêñ</code> can be characterised  as the subset  of elements of  <code>B‚Å∫</code> with the  same length as their image in <code>W</code>.</p><p>If  <code>W</code> is finite, then <code>B‚Å∫</code> is Garside with Garside element the element of <code>ùêñ</code> whose image is the longest element  of <code>W</code>. A finite Coxeter group is also  a reflection group in  a real vector space,  thus in its complexified <code>V</code>,  and <code>B</code> also has a topological definition as the fundamental group of the  space <code>V ≥·µâ·µç/W</code>, where <code>V ≥·µâ·µç</code>  is the set of  elements of <code>V</code> which are not fixed by any non-identity element of <code>S</code>; however, we will not use this here.</p><p>Given a Coxeter group <code>W</code>,</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,4)
A‚ÇÑ

julia&gt; B=BraidMonoid(W)
BraidMonoid(A‚ÇÑ)</code></pre><p>constructs  the associated braid monoid, and  then, used as a function, <code>B</code> constructs  elements of the braid monoid (or group when <code>W</code> is finite) from a list of generators indices given as arguments:</p><pre><code class="language-julia-repl hljs">julia&gt; w=B(1,2,3,4) # represents ùê¨‚ÇÅùê¨‚ÇÇùê¨‚ÇÉùê¨‚ÇÑ
1234</code></pre><p>The  operations <code>*</code>  and <code>^</code>  (exponentiation) are  implemented for locally Garside  elements (and also multiplication of a Garside element by a simple) and  in addition  the operations  <code>\</code> and  &#39;/&#39; (left and right  division),  <code>inv</code>  and  <code>^</code>  (inverse  and  conjugation) for Garside elements (and conjugation of a Garside element by a simple).</p><pre><code class="language-julia-repl hljs">julia&gt; w*w
1213243.4

julia&gt; w*W(1) # multiplication by a simple
12134

julia&gt; W(1)*w
1.1234

julia&gt; w^3  # the terms of the normal form are printed separated by a .
121321432.343

julia&gt; B(1,2)\w
34

julia&gt; w/B(3,4)
12

julia&gt; w^B(1) # conjugation
2134

julia&gt; w^W(1) # conjugation by a simple
2134

julia&gt; word(Œ±(w^3))
9-element Vector{Int64}:
 1
 2
 1
 3
 2
 1
 4
 3
 2

julia&gt; w^4
Œî.232432

julia&gt; inv(w)
(1234)‚Åª¬π

julia&gt; B(-4,-3,-2,-1) # another way of entering the same element
(1234)‚Åª¬π</code></pre><p>How  an  element  of  a  Garside  group  is  printed  is  controlled by the <code>IOcontext</code>  attribute  &#39;:greedy&#39;.  By  default,  elements  are  printed as fractions <code>a‚Åª¬πb</code> where <code>a</code> and <code>b</code> have no left common divisor. Each of <code>a</code> and  <code>b</code> is printed  using its left-greedy  normal form, that  is a maximal power of the Garside element followed by the rest. One can print the entire element   in  the  left-greedy  normal  from  by  setting  the  <code>IOContext</code> <code>:greedy=&gt;true</code>; with the same <code>w</code> as above we have:</p><pre><code class="language-julia-repl hljs">julia&gt; xrepr(w^-1,greedy=true,limit=true)
&quot;Œî‚Åª¬π.232432&quot;</code></pre><p>By default,  <code>repr</code> gives   <code>w</code>  back   in  a   form  which   after  assigning <code>B=BraidMonoid(W)</code> can be input back into Julia:</p><pre><code class="language-julia-repl hljs">julia&gt; repr(w)
&quot;B(1,2,3,4)&quot;

julia&gt; repr(w^3)
&quot;B(1,2,1,3,2,1,4,3,2,3,4,3)&quot;

julia&gt; repr(w^-1)
&quot;B(-4,-3,-2,-1)&quot;</code></pre><p>In  general elements  of a  Garside monoid  are displayed  as a list of the indices of their constituting atoms.</p><p>We  will  now  describe  the  dual  braid  monoid. First we define interval monoids.  Given a group <code>W</code> and a set <code>S</code> of generators of <code>W</code> as a monoid, we  define the  length <code>l_S(w)</code>  as the  minimum number  of elements of <code>S</code> needed  to write <code>w</code>.  We then define  left-divisors of <code>x</code>  as those <code>d‚ààW</code> such  that there exists <code>y</code> with  <code>x=dy</code> and <code>l_S(d)+l_S(y)=l_S(x)</code>. We say that  <code>w‚àà W</code> is balanced if its set of left and right divisors coincide; in this  case we denote  this set by  <code>[1,w]</code>, an <em>interval</em>  for the poset of <code>S</code>-divisibility.  We say that <code>w</code>  is Garside for <code>l_S</code>  if it is balanced and  <code>[1,w]</code> is a lattice (where upper and lower bounds are lcms and gcds), which generates <code>W</code>. Then we have the theorem:</p><p>Suppose  <code>w</code> is Garside for the <code>l_S</code>.  Then the monoid <code>M</code> with generators <code>[1,w]</code>   and   relations   <code>xy=z</code>   whenever   <code>xy=z</code>  holds  in  <code>W</code>  and <code>l_S(x)+l_S(y)=l_S(z)</code>, is a Garside monoid, with simples <code>[1,w]</code> and atoms <code>S</code>.  It is called  the interval monoid  defined by <code>l_S</code>  and the interval <code>[1,w]</code>.</p><p>The  Artin-Tits braid monoid  is an interval  monoid by taking  for <code>S</code> the Coxeter  generators, in which case <code>l_S</code>  is the Coxeter length, and taking for <code>w</code> the longest element of <code>W</code>. The dual monoid, constructed by Birman, Ko  and  Lee  for  type  <code>A</code>  and  by Bessis for all well-generated complex reflection  groups, is obtained in  a similar way, by  taking this time for <code>w</code> a Coxeter element, for <code>l_S</code> the reflection length (see <a href="@ref   PermGroups.Perms.reflength"><code>reflength</code></a>)   and   for   <code>S_S</code>   the reflections  which divide <code>w</code> for the reflection length (for Coxeter groups all  reflections divide  a Coxeter  element but  this is  not the  case for well-generated  complex reflection groups); the  simples of the dual monoid are of cardinality the generalized Catalan numbers (see <a href="permroot.html#Combinat.catalan-Tuple{Group, Any}"><code>catalan</code></a>). An  interval  monoid  has  naturally  an  inverse morphism from <code>M</code> to <code>W</code>, called  &#39;image&#39; which is the  quotient map from the  interval monoid to <code>W</code> which sends back simple braids to <code>[1,w]</code>.</p><p>A last pertinent notion is <em>reversible</em> monoids. Since we store left normal forms,  it is easy to compute left lcms and gcds, but hard to compute right lcms  and gcds. But this becomes easy to  do if the monoid has an operation &#39;reverse&#39;,  which has the property that &#39;a&#39; is a left-divisor of &#39;b&#39; if and only  if &#39;reverse(a)&#39;  is a  right-divisor  of &#39;reverse(b)&#39;. This holds for Artin-Tits  and dual braid monoids of groups generated by true reflections; Artin-Tits monoids have a <code>reverse</code> operation which consists of reversing a word,  written as  a list  of atoms.  The dual  monoid also has a <code>reverse</code> operation  defined in the  same way, but  this operation changes monoid: it goes  from the dual monoid  for the Coxeter element  <code>w</code> to the dual monoid for  the Coxeter element  <code>w‚Åª¬π</code>. The operations  &#39;rightlcm&#39; and &#39;rightgcd&#39;, and  some other algorithms, have faster implementations if the monoid has a <code>reverse</code> operation.</p><p>This  module implements also  functions to solve  the conjugacy problem and compute  centralizers  in  Garside  groups,  following  the work of Franco, Gebhardt and Gonzalez-Meneses.</p><p>Two  elements <code>w</code> and <code>w&#39;</code> of a monoid  <code>M</code> are <em>conjugate</em> in <code>M</code> if there exists  <code>x‚àà M</code> such that <code>wx=xw&#39;</code>; if  <code>M</code> satisfies the √ñre conditions, it has  a  group  of  fractions  where  this  becomes  <code>x‚Åª¬πwx=w&#39;</code>,  the  usual definition  of conjugacy. A special case  which is even closer to conjugacy in  the group is if there exists <code>y‚àà  M</code> such that <code>w=xy</code> and <code>w&#39;=yx</code>. This relation  is not transitive in general,  but we call <em>cyclic conjugacy</em> the transitive closure of this relation, a restricted form of conjugacy.</p><p>The next observation is that if <code>w,w&#39;‚ààM</code> where <code>M</code> is Garside are conjugate in  the group  of fractions  <code>G</code> then  they are  conjugate in <code>M</code>, since if <code>wx=xw&#39;</code>  then there is a  power <code>Œî‚Å±</code> which is  central and such that <code>xŒî‚Å±‚àà M</code>. Then <code>wxŒî‚Å±=xŒî‚Å± w&#39;</code> is a conjugation in <code>M</code>.</p><p>The crucial observation for solving the conjugacy problem in Garside groups is  to introduce <code>inf(w):=sup{i such that Œî‚Åª‚Å±w‚àà M}</code> and <code>sup(w):=inf{i such that  w‚Åª¬πŒî‚Å±‚àà M}</code>, and to  notice that the number  of conjugates of <code>w</code> with same  <code>inf</code> and  <code>sup</code> as  <code>w</code> is  finite (since  our monoids have a finite number  of simples).  Further, a  theorem of  Birman shows that the maximum <code>inf</code>   and  minimum   <code>sup</code>  in   a  conjugacy   class  can   be  achieved simultaneously; the elements achieving this are called the super summit set of  <code>w</code>,  denoted  <code>SS(w)</code>.  Thus  a  way  to determine if <code>w</code> and <code>w&#39;</code> are conjugate  is to find  representatives <code>w‚ÇÅ‚ààSS(w)</code>, <code>w&#39;‚ÇÅ‚ààSS(w&#39;)</code>  of them in their  super summit set, and then enumerate  <code>SS(w)</code> and see if it contains <code>w&#39;‚ÇÅ</code>.  This can also be used to  compute the centralizer of an element: if we  consider  the  super  summit  set  as  a category whose objects are its elements  and  morphisms  are  the  conjugations  by  simple  elements, the centralizer  of <code>w‚ÇÅ</code> is given by the  endomorphisms of that object. For the implementation   of  finite  categories  we  use,  see  the  docstrings  of <code>Category</code> and <code>endomorphisms</code>.</p><p>We illustrate this on an example:</p><pre><code class="language-julia-repl hljs">julia&gt; b=B(2,1,4,1,4)
214.14

julia&gt; c=B(1,4,1,4,3)
14.143

julia&gt; d=conjugating_elt(b,c) # would return nothing if b, c are not conjugate
(1)‚Åª¬π21321432

julia&gt; b^d
14.143

julia&gt; centralizer_gens(b)
3-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 321432.213243
 21.1
 4

julia&gt; C=conjcat(b;ss=Val(:ss)) # SS(b) as a category
category with 10 objects and 32 generating maps

julia&gt; C.obj # the elements of SS(b). Notice it contains c
10-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 1214.4
 214.14
 124.24
 1343.1
 14.124
 143.13
 24.214
 134.14
 13.134
 14.143</code></pre><p>There   is  a   faster  solution   to  the   conjugacy  problem   given  in <a href="biblio.htm#gebgon10">gebgon10</a>:  for each <code>b‚ààM</code>, they define a particular simple  left-divisor of <code>b</code>, its <em>preferred prefix</em> such that the operation <em>slide</em>  which  cyclically  conjugates  <code>b</code>  by  its  preferred  prefix, is eventually periodic, and the period is contained in the super summit set of <code>x</code>.  We say that <code>x</code>  is in its sliding  circuit if some iterated slide of <code>x</code> is equal to <code>x</code>. The set of sliding circuits in a given conjugacy class is  smaller than the super  summit set, thus allows  to solve the conjugacy problem faster. Continuing from the above example,</p><pre><code class="language-julia-repl hljs">julia&gt; word(W,preferred_prefix(b))
2-element Vector{Int64}:
 2
 1

julia&gt; b^B(preferred_prefix(b))
1214.4

julia&gt; C=conjcat(b) # with no Val argument computes the sliding circuits
category with 2 objects and 6 generating maps

julia&gt; C.obj # the elements of the sliding circuits
2-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 1214.4
 1343.1</code></pre><p>Finally,  we have implemented  Hao Zheng&#39;s algorithm  to extract roots in a Garside monoid:</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A‚ÇÉ

julia&gt; B=BraidMonoid(W)
BraidMonoid(A‚ÇÉ)

julia&gt; Pi=B(B.Œ¥)^2
Œî¬≤

julia&gt; root(Pi,2)
Œî

julia&gt; root(Pi,3)
1232

julia&gt; root(Pi,4)
132</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L1-L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Garside.LocallyGarsideMonoid" href="#Chevie.Garside.LocallyGarsideMonoid"><code>Chevie.Garside.LocallyGarsideMonoid</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p><code>LocallyGarsideMonoid{T}</code>  is the abstract type of locally Garside monoids, where  <code>T</code>  is  the  type  of  simples.  Such a monoid <code>M</code> needs, for <code>a,b</code> simples, to implement the functions</p><ul><li><code>one(M)</code></li><li><code>isleftdescent(M,a,i::Int)</code>  whether <code>M.atoms[i]‚âº a</code></li><li><code>isrightdescent(M,a,i::Int)</code> whether <code>a‚âΩ M.atoms[i]</code></li><li><code>isrightascent(M,a,i::Int)</code>  whether <code>a*M.atoms[i]</code> is simple</li><li><code>*(M,a,b)</code>  when <code>a*b</code> is simple returns the simple <code>a*b</code></li><li><code>\(M,a,b)</code> when <code>a‚âº b</code> returns the simple <code>a</code></li><li><code>/(M,a,b)</code>  when <code>a‚âΩ b</code> returns the simple <code>a/b</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L380-L391">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Garside.GarsideMonoid" href="#Chevie.Garside.GarsideMonoid"><code>Chevie.Garside.GarsideMonoid</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p><code>GarsideMonoid{T}</code>  is the abstract  type of Garside  monoids, where <code>T</code> is the type of simples. Such a monoid <code>M</code> should implement the same methods as <code>LocallyGarsideMonoid</code>  except  that  <code>isrightascent(M,a)</code> is automatically defined as <code>isleftdescent(M,\(M,a,M.Œ¥),i)</code>.</p><p>An implementation should have fields <code>M.Œ¥</code>, <code>M.stringŒ¥</code></p><p>An interval monoid should have a field <code>M.orderŒ¥</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L396-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.CoxGroups.isleftdescent-Tuple{BraidMonoid, Any, Int64}" href="#Chevie.CoxGroups.isleftdescent-Tuple{BraidMonoid, Any, Int64}"><code>Chevie.CoxGroups.isleftdescent</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>isleftdescent(M,w,i)</code></p><p>returns <code>true</code> if and only if the <code>i</code>-th atom of the locally Garside monoid <code>M</code> left-divides the simple <code>w</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L759-L764">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.CoxGroups.leftdescents-Tuple{Chevie.Garside.LocallyGarsideElt}" href="#Chevie.CoxGroups.leftdescents-Tuple{Chevie.Garside.LocallyGarsideElt}"><code>Chevie.CoxGroups.leftdescents</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>leftdescents(b::LocallyGarsideElt)</code> the list of indices of the atoms which left-divide <code>b</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L876-L879">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Garside.rightascents" href="#Chevie.Garside.rightascents"><code>Chevie.Garside.rightascents</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p><code>rightascents(M,s)</code> where <code>s</code> is a simple return the right ascents of <code>s</code>, that is the list of <code>i</code> such that <code>s*M.atoms[i]</code> is still simple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L623-L626">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Garside.left_divisors" href="#Chevie.Garside.left_divisors"><code>Chevie.Garside.left_divisors</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>left_divisors(M::LocallyGarsideMonoid, s)</p><p>left_divisors(M::LocallyGarsideMonoid, s,i)</p><p>all  the left-divisors  of the  simple element  <code>s</code> of  <code>M</code>, as a vector of vectors   of  simples,  where  the  i+1-th  vector  of  simples  holds  the left-divisors  of length i in the atoms.  If a third argument <code>i</code> is given, returns the list of divisors of length <code>i</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A‚ÇÉ

julia&gt; B=BraidMonoid(W)
BraidMonoid(A‚ÇÉ)

julia&gt; map(x-&gt;B.(x),left_divisors(B,W(1,3,2)))
4-element Vector{Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}}:
 [.]
 [1, 3]
 [13]
 [132]

julia&gt; B=DualBraidMonoid(W)
DualBraidMonoid(A‚ÇÉ,c=[1, 3, 2])

julia&gt; map(x-&gt;B.(x),left_divisors(B,W(1,3,2)))
4-element Vector{Vector{GarsideElt{Perm{Int16}, DualBraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}}:
 [.]
 [1, 2, 3, 4, 5, 6]
 [12, 13, 15, 25, 34, 45]
 [Œ¥]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L570-L604">source</a></section><section><div><p><code>left_divisors(b::LocallyGarsideElt[, i])</code></p><p>returns all left-divisors of <code>b</code> (left-divisors of length <code>i</code> if specified)</p><pre><code class="language-julia-repl hljs">julia&gt; B=DualBraidMonoid(coxsym(4))
DualBraidMonoid(ùîñ ‚ÇÑ,c=[1, 3, 2])

julia&gt; left_divisors(B(1,5,4,3))
10-element Vector{GarsideElt{Perm{Int16}, DualBraidMonoid{Perm{Int16}, CoxSym{Int16}}}}:
 .
 1
 1.4
 1.4.2
 1.4.3
 5
 6
 15
 15.4
 15.4.3

julia&gt; left_divisors(B(1,5,4,3),1)
3-element Vector{GarsideElt{Perm{Int16}, DualBraidMonoid{Perm{Int16}, CoxSym{Int16}}}}:
 1
 5
 6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L911-L939">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Garside.leftgcd" href="#Chevie.Garside.leftgcd"><code>Chevie.Garside.leftgcd</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p><code>leftgcd(M::LocallyGarsideMonoid,s‚ÇÅ,‚Ä¶,s‚Çô)</code> <code>leftgcdc(M::LocallyGarsideMonoid,s‚ÇÅ,‚Ä¶,s‚Çô)</code></p><p><code>s‚ÇÅ,‚Ä¶,s‚Çô</code> should be simples of <code>M</code>. The  function returns the left gcd <code>d</code> of the <code>s·µ¢</code>.</p><p><code>leftgcdc</code> returns <code>(d,(d‚Åª¬πs‚ÇÅ,‚Ä¶,d‚Åª¬πs‚Çô))</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L423-L431">source</a></section><section><div><p><code>leftgcd(a‚ÇÅ,‚Ä¶,a‚Çô)</code> <code>leftgcdc(a‚ÇÅ,‚Ä¶,a‚Çô)</code></p><p><code>a‚ÇÅ,‚Ä¶,a‚Çô</code>  should be  elements of  the same  (locally) Garside  monoid. The function returns the left gcd <code>d</code> of <code>a‚ÇÅ,‚Ä¶,a‚Çô</code>.</p><p><code>leftgcdc</code> returns <code>(d,(d‚Åª¬πa‚ÇÅ,‚Ä¶,d‚Åª¬πa‚Çô))</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A‚ÇÉ

julia&gt; B=BraidMonoid(W)
BraidMonoid(A‚ÇÉ)

julia&gt; leftgcdc(B(2,1,2)^2,B(3,2)^2)
(2, (121.21, 32.2))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L1339-L1358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Garside.rightgcd" href="#Chevie.Garside.rightgcd"><code>Chevie.Garside.rightgcd</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p><code>rightgcd(M::LocallyGarsideMonoid,s‚ÇÅ,‚Ä¶,s‚Çô)</code> <code>rightgcdc(M::LocallyGarsideMonoid,s‚ÇÅ,‚Ä¶,s‚Çô)</code></p><p><code>s‚ÇÅ,‚Ä¶,s‚Çô</code> should be simples of <code>M</code>. The  function returns the right gcd <code>d</code> of the <code>s·µ¢</code>.</p><p><code>rightgcdc</code> returns <code>(d,(s‚ÇÅd‚Åª¬π,‚Ä¶,s‚Çôd‚Åª¬π))</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L450-L458">source</a></section><section><div><p><code>rightgcd(a‚ÇÅ,‚Ä¶,a‚Çô)</code> <code>rightgcdc(a‚ÇÅ,‚Ä¶,a‚Çô)</code></p><p><code>a‚ÇÅ,‚Ä¶,a‚Çô</code>  should be  elements of  the same  (locally) Garside  monoid. The function returns the right gcd <code>d</code> of <code>a‚ÇÅ,‚Ä¶,a‚Çô</code></p><p><code>rightgcdc</code> returns <code>(d,(a‚ÇÅ/d,‚Ä¶,a‚Çô/d))</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A‚ÇÉ

julia&gt; B=BraidMonoid(W)
BraidMonoid(A‚ÇÉ)

julia&gt; rightgcdc(B(2,1,2)^2,B(3,2)^2)
(2.2, (12.21, 23))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L1366-L1385">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Garside.leftlcm" href="#Chevie.Garside.leftlcm"><code>Chevie.Garside.leftlcm</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p><code>leftlcm(M::GarsideMonoid,s‚ÇÅ,‚Ä¶,s‚Çô)</code> <code>leftlcmc(M::GarsideMonoid,s‚ÇÅ,‚Ä¶,s‚Çô)</code></p><p><code>s‚ÇÅ,‚Ä¶,s‚Çô</code> should be simples of <code>M</code>. The  function returns the left lcm <code>m</code> of the <code>s·µ¢</code>.</p><p><code>leftlcmc</code> returns <code>(m,(ms‚ÇÅ‚Åª¬π,‚Ä¶,ms‚Çô‚Åª¬π))</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L504-L512">source</a></section><section><div><p><code>leftlcm(a‚ÇÅ,‚Ä¶,a‚Çô)</code> <code>leftlcmc(a‚ÇÅ,‚Ä¶,a‚Çô)</code></p><p><code>a‚ÇÅ,‚Ä¶,a‚Çô</code>  should  be  elements  of  the  same Garside monoid. The function returns  the least common left multiple  <code>m</code> of <code>a‚ÇÅ,‚Ä¶,a‚Çô</code>.</p><p><code>leftlcmc</code> returns &#39;(m,(m/a‚ÇÅ,‚Ä¶,m/a‚Çô))`.</p><pre><code class="language-julia-repl hljs">julia&gt; B=BraidMonoid(coxgroup(:A,3))
BraidMonoid(A‚ÇÉ)

julia&gt; leftlcmc(B(2,1,2)^2,B(3,2)^2)
(Œî.121, (123, 23.321))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L1399-L1415">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Garside.rightlcm" href="#Chevie.Garside.rightlcm"><code>Chevie.Garside.rightlcm</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p><code>rightlcm(M::GarsideMonoid,s‚ÇÅ,‚Ä¶,s‚Çô)</code> <code>rightlcmc(M::GarsideMonoid,s‚ÇÅ,‚Ä¶,s‚Çô)</code></p><p><code>s‚ÇÅ,‚Ä¶,s‚Çô</code> should be simples of <code>M</code>. The  function returns the right lcm <code>m</code> of the <code>s·µ¢</code>.</p><p><code>rightlcmc</code> returns <code>(m,(s‚ÇÅ‚Åª¬πm,‚Ä¶,s‚Çô‚Åª¬πm))</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L487-L495">source</a></section><section><div><p><code>rightlcm(a‚ÇÅ,‚Ä¶,a‚Çô)</code> <code>rightlcmc(a‚ÇÅ,‚Ä¶,a‚Çô)</code></p><p><code>a‚ÇÅ,‚Ä¶,a‚Çô</code>  should  be  elements  of  the  same Garside monoid. The function returns  the least common right multiple  <code>m</code> of <code>a‚ÇÅ,‚Ä¶,a‚Çô</code>.</p><p><code>rightlcmc</code> returns &#39;(m,(a‚ÇÅ‚Åª¬π<em>m,‚Ä¶,a‚Çô‚Åª¬π</em>m))`.</p><pre><code class="language-julia-repl hljs">julia&gt; B=BraidMonoid(coxgroup(:A,3))
BraidMonoid(A‚ÇÉ)

julia&gt; rightlcmc(B(2,1,2)^2,B(3,2)^2)
(Œî¬≤, (321.123, 12321.321))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L1423-L1439">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Garside.Œ±-Tuple{Chevie.Garside.LocallyGarsideElt}" href="#Chevie.Garside.Œ±-Tuple{Chevie.Garside.LocallyGarsideElt}"><code>Chevie.Garside.Œ±</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>Œ±(b::LocallyGarsideElt)</code></p><p>returns as a Garside element  the first term in  the normal form of  <code>b</code> (the expression <code>b[1]</code> returns this term as a simple).</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A‚ÇÉ

julia&gt; b=BraidMonoid(W)(2,1,2,1,1)
121.1.1

julia&gt; Œ±(b)
121</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L1051-L1067">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Garside.Œ±-Tuple{Chevie.Garside.LocallyGarsideElt, AbstractVector}" href="#Chevie.Garside.Œ±-Tuple{Chevie.Garside.LocallyGarsideElt, AbstractVector}"><code>Chevie.Garside.Œ±</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>Œ±(b::LocallyGarsideElt,I)</code></p><p>returns the longest prefix of b using only <code>b.M.atoms[I]</code></p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,4);B=BraidMonoid(W)
BraidMonoid(A‚ÇÑ)

julia&gt; w0=B(longest(W))
Œî

julia&gt; Œ±(w0,[1,2,3])
121321</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L1070-L1084">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Garside.Œ¥ad" href="#Chevie.Garside.Œ¥ad"><code>Chevie.Garside.Œ¥ad</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p><code>Œ¥ad(M::GarsideMonoid,x,i=1)</code></p><p>returns the image of the simple <code>x</code> by the <code>i</code>-th power of the automorphism induced by conjugation by <code>M.Œ¥</code> (that is <code>x^(M.Œ¥^i)</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L635-L640">source</a></section><section><div><p><code>Œ¥ad(b::GarsideElt,i=1)</code></p><p>returns the image of <code>b</code> by the <code>i</code>-th power of the automorphism induced by conjugation by <code>b.M.Œ¥</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L867-L872">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Garside.Brieskorn_normal_form" href="#Chevie.Garside.Brieskorn_normal_form"><code>Chevie.Garside.Brieskorn_normal_form</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p><code>Brieskorn_normal_form(b::LocallyGarsideElt)</code></p><p>Brieskorn  citeBri71 has noticed that if <code>L(b)</code>  is the left descent set of <code>b</code>  (see <a href="coxgroups.html#Chevie.CoxGroups.leftdescents-Tuple{CoxeterGroup, Any}"><code>leftdescents</code></a>),  and if  <code>b_(L(b))</code> is  the right lcm of <code>L(b)</code>,  then  <code>b_(L(b))</code>  left-divides  <code>b</code>.  We  can  now  divide  <code>b</code> by <code>b_(L(b))</code>  and continue  this process  with the  quotient. In this way, we obtain  an expression  <code>b=b_(L‚ÇÅ)‚ãØ b_(L·µ£)</code>  where <code>L·µ¢=L(b_(L·µ¢)‚ãØ b_(L·µ£))</code> for all  <code>i</code>, which we  call the <em>Brieskorn  normal form</em> of  <code>b</code>. The function <code>Brieskorn_normal_form</code>  returns a  description of  this form, by returning the   list  of  sets   <code>L(b)</code>  which  describe   the  above  decomposition.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:E,8);B=BraidMonoid(W)
BraidMonoid(E‚Çà)

julia&gt; w=B(2,3,4,2,3,4,5,4,2,3,4,5,6,5,4,2,3,4,5,6,7,6,5,4,2,3,4,5,6,7,8)
2342345423456542345676542345678

julia&gt; Brieskorn_normal_form(w)
2-element Vector{Vector{Int64}}:
 [2, 3, 4, 5, 6, 7]
 [8]

julia&gt; Brieskorn_normal_form(w^2)
2-element Vector{Vector{Int64}}:
 [2, 3, 4, 5, 6, 7, 8]
 [2, 3, 4, 5, 6]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L944-L972">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Garside.BraidMonoid" href="#Chevie.Garside.BraidMonoid"><code>Chevie.Garside.BraidMonoid</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p><code>BraidMonoid(W::CoxeterGroup)</code></p><p>The ordinary monoid of the Artin group associated to <code>W</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L748-L752">source</a></section><section><div><p><code>(B::BraidMonoid)(M::DualBraidMonoid,i::Integer)</code></p><p>convert to an element of <code>B</code> the <code>i</code>-th atom of <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L1631-L1635">source</a></section><section><div><p><code>(B::BraidMonoid)(M::DualBraidMonoid,s)</code></p><p>convert to an element of <code>B</code> the simple <code>s</code> of <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L1637-L1641">source</a></section><section><div><p><code>(B::BraidMonoid)(b::GarsideElt)</code></p><p><code>b</code> should be a dual braid. Convert <code>b</code> to an element of <code>B</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L1643-L1647">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Garside.DualBraidMonoid" href="#Chevie.Garside.DualBraidMonoid"><code>Chevie.Garside.DualBraidMonoid</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p><code>DualBraidMonoid(W;c=xxx)</code></p><p><code>W</code>  should be a well generated complex  reflection group and <code>c</code> a Coxeter element  of <code>W</code>, given as a  word (a <code>Vector{Int}</code>) specifiying the element <code>W(c...)</code>. </p><p>If  no <code>c</code>  is given  a particular  one is  chosen (what the notation <code>xxx</code> above tries to convey).</p><p>For  <code>·∫Ä</code> a Coxeter  groups the Coxeter  diagram is partitioned  in two sets where  in each set reflections commute pairwise;  <code>c</code> is the product of the product of the reflections in each set.</p><p>For  a complex  reflection group  the representative  stored in the Coxeter class is used for <code>c</code>.</p><p>The function returns the dual braid monoid determined by <code>W</code> and <code>c</code></p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A‚ÇÉ

julia&gt; B=DualBraidMonoid(W)
DualBraidMonoid(A‚ÇÉ,c=[1, 3, 2])

julia&gt; B(2,1,2,1,1)
12.1.1.1

julia&gt; B(-1,-2,-3,1,1)
(25.1)‚Åª¬π1.1

julia&gt; W=crg(4)
G‚ÇÑ

julia&gt; B=DualBraidMonoid(W)
DualBraidMonoid(G‚ÇÑ,c=[1, 2])

julia&gt; left_divisors(B(B.Œ¥))
5-element Vector{GarsideElt{Perm{Int16}, DualBraidMonoid{Perm{Int16}, PRG{Cyc{Rational{Int64}}, Int16}}}}:
 .
 1
 2
 3
 Œ¥</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L1530-L1576">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Garside.hurwitz" href="#Chevie.Garside.hurwitz"><code>Chevie.Garside.hurwitz</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p><code>hurwitz(l,i::Integer)</code> the  Hurwitz action of  the generator <code>œÉ·µ¢</code>  of the braid  group <code>B‚Çô</code> on the list  <code>l</code>  of  length  <code>n</code>  of  group elements, which replaces <code>l·µ¢,l·µ¢‚Çä‚ÇÅ</code> by <code>l·µ¢‚Çä‚ÇÅ,l·µ¢^l·µ¢‚Çä‚ÇÅ</code>.  If <code>i&lt;0</code>, does the action of <code>inv(œÉ‚±º)</code> where <code>j=-i</code>, which replaces <code>l‚±º,l‚±º‚Çä‚ÇÅ</code> by <code>l‚±º‚Çä‚ÇÅ^inv(l‚±º),l‚±º</code>.</p><p>The  following  expression  computes  the  orbit  of the list <code>l</code> under the various Huwitz actions: <code>orbit(1:length(l)-1,l,hurwitz)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L2446-L2455">source</a></section><section><div><p><code>hurwitz(l,v::AbstractVector{&lt;:Integer})</code></p><p>does successively <code>hurwitz(l,i)</code> for each <code>i</code> in <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L2464-L2468">source</a></section><section><div><p><code>hurwitz(l,b)</code> the  Hurwitz action of the braid  <code>b‚àà B‚Çô</code> on the list  <code>l</code> of length <code>n</code> of group elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L2474-L2478">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Garside.fraction" href="#Chevie.Garside.fraction"><code>Chevie.Garside.fraction</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><ul><li><code>fraction(b::GarsideElt)</code></li><li><code>denominator(b::GarsideElt)</code></li><li><code>numerator(b::GarsideElt)</code></li></ul><p><code>fraction(b)</code>  returns a  tuple <code>(x,y)</code>  of positive  Garside elements with trivial  <code>leftgcd</code>  and  such  that  <code>b=x\y</code>.  For  such  a decomposition, <code>denominator(b)</code> returns <code>x</code> and <code>numerator(b)</code> returns <code>y</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; B=BraidMonoid(coxgroup(:A,3))
BraidMonoid(A‚ÇÉ)

julia&gt; b=B( 2, 1, -3, 1, 1)
(23)‚Åª¬π321.1.1

julia&gt; fraction(b)
(23, 321.1.1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L1009-L1027">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PermGroups.Groups.word-Tuple{LocallyGarsideMonoid, Any}" href="#PermGroups.Groups.word-Tuple{LocallyGarsideMonoid, Any}"><code>PermGroups.Groups.word</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>word(M::GarsideMonoid,w)</code></p><p>returns a word in the atoms of <code>M</code> representing the simple <code>w</code></p><pre><code class="language-julia-repl hljs">julia&gt; B=BraidMonoid(coxgroup(:A,3))
BraidMonoid(A‚ÇÉ)

julia&gt; word(B,B.Œ¥)
6-element Vector{Int64}:
 1
 2
 1
 3
 2
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L539-L557">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PermGroups.Groups.word-Tuple{GarsideElt}" href="#PermGroups.Groups.word-Tuple{GarsideElt}"><code>PermGroups.Groups.word</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>word(b::GarsideElt)</code></p><p>returns  a description  of <code>b</code>  as a  list of  the atoms  of which  it is a product.  If <code>b</code> is in the Garside group  but not the Garside monoid, it is represented  in  fraction  normal  form  where  as a special convention the inverses  of  the  atoms  are  represented  by  negating  the corresponding integer.</p><pre><code class="language-julia-repl hljs">julia&gt; B=BraidMonoid(coxgroup(:A,3))
BraidMonoid(A‚ÇÉ)

julia&gt; b=B(2,1,2,1,1)*inv(B(2,2))
(21)‚Åª¬π1.12.21

julia&gt; word(b)
7-element Vector{Int64}:
 -1
 -2
  1
  1
  2
  2
  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L1114-L1140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PermGroups.Groups.elements-Tuple{LocallyGarsideMonoid, Integer}" href="#PermGroups.Groups.elements-Tuple{LocallyGarsideMonoid, Integer}"><code>PermGroups.Groups.elements</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>elements(M::LocallyGarsideMonoid,l::Integer)</code> <code>elements(M::LocallyGarsideMonoid,v::AbstractVector{&lt;:Integer})</code></p><p><code>M</code>  should have  an additive  length function  (that is,  a product of <code>l</code> atoms  is not equal to any product of less than <code>l</code> atoms). <code>elements(M,l)</code> returns the list of elements of length <code>l</code> in <code>M</code>.</p><p>In the second form <code>elements</code> returns all elements of length <code>i</code> for <code>i‚àà v</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; M=BraidMonoid(coxgroup(:A,2))
BraidMonoid(A‚ÇÇ)

julia&gt; elements(M,4)
12-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 Œî.1
 Œî.2
 12.21
 12.2.2
 1.12.2
 1.1.12
 1.1.1.1
 21.12
 21.1.1
 2.21.1
 2.2.21
 2.2.2.2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L650-L679">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Garside.image" href="#Chevie.Garside.image"><code>Chevie.Garside.image</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p><code>image(b::GarsideElt)</code></p><p>This  function is defined only if <code>b</code>  is an element of an interval monoid, for instance a braid. It returns the image of <code>b</code> in the group of which the monoid  is an interval  monoid. For instance  it gives the  projection of a braid in an Artin monoid back to the Coxeter group.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxsym(4)
ùîñ ‚ÇÑ

julia&gt; b=BraidMonoid(W)(2,1,2,1,1)
121.1.1

julia&gt; p=image(b)
(1,3)

julia&gt; word(W,p)
3-element Vector{Int64}:
 1
 2
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L1444-L1468">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Garside.conjugating_elt" href="#Chevie.Garside.conjugating_elt"><code>Chevie.Garside.conjugating_elt</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>conjugating_elt(b,b‚ÇÅ[,F];ss=Val(:sc))</p><p><code>b</code>  and <code>b‚ÇÅ</code> should  be elements of  the same Garside  group. The function returns  <code>a</code> such that <code>b^a=b‚ÇÅ</code> if such exists, and <code>nothing</code> otherwise. If an  argument <code>ss</code>  is given,  the computation  is done in the corresponding category  ‚Äì- see <a href="garside.html#Chevie.Garside.conjcat"><code>conjcat</code></a>. If an  argument <code>F</code> is given it should be  an automorphism of the braid monoid, like the Frobenius of a reflection coset   attached  to  <code>b.M.W</code>;   the  computation  is   then  done  in  the corresponding <code>F</code>-conjugacy category.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:D,4)
D‚ÇÑ

julia&gt; B=BraidMonoid(W)
BraidMonoid(D‚ÇÑ)

julia&gt; b=B(2,3,1,2,4,3)
231243

julia&gt; b1=B(1,4,3,2,2,2)
1432.2.2

julia&gt; conjugating_elt(b,b1)
(134312.23)‚Åª¬π

julia&gt; c=conjugating_elt(b,b1;ss=Val(:cyc))
232.2

julia&gt; b^c
1432.2.2

julia&gt; WF=spets(W,Perm(1,2,4))
¬≥D‚ÇÑ

julia&gt; F=Frobenius(WF);

julia&gt; c=B(3,4,3,1,2,3)
343123

julia&gt; conjugating_elt(b,c,F)
124312

julia&gt; ^(b,B(1,2,4,3,1,2),F)
343123</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L2068-L2115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Garside.centralizer_gens" href="#Chevie.Garside.centralizer_gens"><code>Chevie.Garside.centralizer_gens</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p><code>centralizer_gens(b[,F];ss=Val(:sc))</code></p><p>a  list of generators of the centralizer of <code>b</code>. The computation is done by computing  the  endomorphisms  of  the  object  <code>b</code>  in the category of its sliding  circuits. If an argument <code>ss</code> is given, the computation is done in the corresponding category ‚Äì- see <a href="garside.html#Chevie.Garside.conjcat"><code>conjcat</code></a>.</p><p>If  an argument  <code>F</code> is  given it  should be  an automorphism  of the braid monoid,  like the Frobenius of a reflection coset attached to <code>b.M.W</code>; then the <code>F</code>-centralizer is computed.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:D,4)
D‚ÇÑ

julia&gt; B=BraidMonoid(W)
BraidMonoid(D‚ÇÑ)

julia&gt; w=B(4,4,4)
4.4.4

julia&gt; cc=centralizer_gens(w)
8-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 1
 (31432)‚Åª¬π231432
 (1)‚Åª¬π34.431
 (2)‚Åª¬π34.432
 (32431)‚Åª¬π132431
 4
 34.43
 2

julia&gt; shrink(cc)
5-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 4
 2
 1
 34.43
 (3243)‚Åª¬π13243

julia&gt; centralizer_gens(w;ss=Val(:cyc))
1-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 4

julia&gt; F=Frobenius(spets(W,Perm(1,2,4)));

julia&gt; centralizer_gens(w,F)
2-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 124
 312343123</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L2146-L2198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Garside.Category" href="#Chevie.Garside.Category"><code>Chevie.Garside.Category</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>The <code>struct Category{TO,TM}</code> represents a finite category whose objects are of type <code>TO</code> and maps of type <code>TM</code>. It has two fields:</p><ul><li><code>.obj::Vector{TO}</code> the objects</li><li><code>.atoms::Vector{Vector{Pair{TM,Int}}}</code> a vector of same length as <code>.obj</code> representing  the atoms (generators)  of the category;  <code>atoms[i]</code> is a <code>Vector</code> of pairs <code>m=&gt;j</code> holding a map <code>m</code> from <code>obj[i]</code> to <code>obj[j]</code>.</li></ul><pre><code class="language-julia-rep1 hljs">julia&gt; W=coxsym(4);B=BraidMonoid(W);b=B(1,1,2,2,3)
1.12.23

julia&gt; print(conjcat(b))
Category([B(1,2,2,1,3),B(2,1,3,1,2),B(2,1,3,3,2),B(3,2,2,1,3)],[
[B(1,2)=&gt;2, B(2,1,3)=&gt;3],
[B(2,1,3)=&gt;1, B(1,3,2,1)=&gt;4],
[B(2,1,3)=&gt;4, B(1,2,3,2)=&gt;1],
[B(2,1,3)=&gt;2, B(3,2)=&gt;3]])

julia&gt; xprint(conjcat(b);graph=true) # show graphically the category
category with 4 objects and 8 generating maps
      1232       12       213       213       213       32 
213.32‚Äï‚Äï‚Äï‚ûî 12.213‚Äï‚ûî 213.12‚Äï‚Äï‚ûî 12.213‚Äï‚Äï‚ûî 213.32‚Äï‚Äï‚ûî 32.213‚Äï‚ûî 213.32
      1321       213 
213.12‚Äï‚Äï‚Äï‚ûî 32.213‚Äï‚Äï‚ûî 213.12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L1653-L1678">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Garside.Category-Tuple{Function, Any}" href="#Chevie.Garside.Category-Tuple{Function, Any}"><code>Chevie.Garside.Category</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>Category(atomsfrom::Function,o;action::Function=^)</code></p><p>constructs a category from an initial object <code>o</code> and two functions:</p><ul><li><code>atomsfrom(o)</code> given an object <code>o</code> returns  the list of atoms from <code>o</code>. - <code>action(o,m)</code> returns the resulting object obtained by applying the map <code>m</code>  to the object  <code>o</code>. If <code>action</code>  is not given,  it is assumed that <code>o^m</code> does the job.</li></ul><p>The  result is  a <code>Category{TO,TM}</code>  where <code>TO=typeof(o)</code>  and <code>TM</code>  is the <code>eltype</code>  of the result of  <code>atomsfrom</code>. </p><p>As an example we construct a Garside category associated to the braid group of  <code>G‚ÇÉ‚ÇÅ</code>, realized as the  centralizer of a 4th  root of <code>Œ¥¬≥‚Å∞</code> in the dual braid  monoid of <code>E‚Çà</code>; that is the fixed points of <code>Œ¥ad¬π‚Åµ</code> in the 2-divided category.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:E,8);M=DualBraidMonoid(W)
DualBraidMonoid(E‚Çà,c=[1, 4, 6, 8, 3, 2, 5, 7])

julia&gt; s4=left_divisors(M,M.Œ¥,4); # simples of length 4

julia&gt; s=M(s4[findfirst(x-&gt;x*Œ¥ad(M,x,8)==M.Œ¥,s4)])#an object of 2-divided cat
(1 8 17 35)

julia&gt; &quot;the right-lcms of the `Œ¥‚Å±`-orbits on `leftdescents(b)`&quot;
       function satoms(b,i)
         M=b.M
         ld=M.atoms[leftdescents(b)]
         di=Perm(ld,Œ¥ad.(Ref(M),ld,i))
         if isnothing(di) error(b,&quot; is not Œ¥^$i-stable&quot;) end
         map(o-&gt;M(rightlcm(M,ld[o]...)),orbits(di,eachindex(ld)))
       end
satoms

julia&gt; Category(x-&gt;satoms(x,15),s;action=(o,m)-&gt;inv(m)*o*Œ¥ad(m,8))
category with 88 objects and 660 generating maps</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L1704-L1740">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Garside.conjcat" href="#Chevie.Garside.conjcat"><code>Chevie.Garside.conjcat</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p><code>conjcat(b[,F];ss=Val(:sc))</code></p><p>returns  the conjugacy category  of the summit  set of <code>b</code>  of the required type.</p><ul><li>By default,  computes the  category of  sliding circuits  of <code>b</code>.</li><li>If <code>ss==Val(:ss)</code>,  computes  the  super  summit  set.</li><li>If <code>ss==Val(:cyc)</code>, computes the cyclic  conjugacy category.</li><li>If <code>ss==Val(:inf)</code> computes the category of all conjugate elements with same <code>Inf</code> as <code>b</code>.</li></ul><p>If  an argument  <code>F</code> is  given it  should be  the Frobenius of a Reflection coset attached to <code>b.M.W</code>. Then the <code>F</code>-conjugacy category is returned.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,4)
A‚ÇÑ

julia&gt; w=BraidMonoid(W)(4,3,3,2,1)
43.321

julia&gt; C=conjcat(w)
category with 2 objects and 4 generating maps

julia&gt; C.obj # the (sliding circuits) summit set
2-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 32143
 21324</code></pre><pre><code class="language-julia-rep1 hljs">julia&gt; xprint(C;graph=true)   # show the conjugations among the summit set
category with 2 objects and 4 generating maps
     32143      21343      21324      13214
32143‚îÄ‚îÄ‚îÄ‚îÄ‚Üí 32143‚îÄ‚îÄ‚îÄ‚îÄ‚Üí 21324‚îÄ‚îÄ‚îÄ‚îÄ‚Üí 21324‚îÄ‚îÄ‚îÄ‚îÄ‚Üí 32143</code></pre><pre><code class="language-julia-repl hljs">julia&gt; conjcat(w;ss=Val(:ss)).obj # the super summit set
4-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 32143
 13243
 21432
 21324</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L2018-L2062">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Garside.endomorphisms" href="#Chevie.Garside.endomorphisms"><code>Chevie.Garside.endomorphisms</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p><code>endomorphisms(C::Category,o::Integer)</code> Assuming  the atoms of <code>C</code>  are invertible by <code>inv</code>  and maps multiply with <code>*</code>, returns generators of the endomorphisms of <code>C.obj[o]</code></p><pre><code class="language-julia-repl hljs">julia&gt; W=coxsym(4);M=BraidMonoid(W)
BraidMonoid(ùîñ ‚ÇÑ)

julia&gt; endomorphisms(conjcat(M(1,1,2,2,3)),1) # generators of centralizer
2-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, CoxSym{Int16}}}}:
 213.1232
 12.213</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L1809-L1822">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GroupPresentations.Presentation-Tuple{GarsideMonoid}" href="#GroupPresentations.Presentation-Tuple{GarsideMonoid}"><code>GroupPresentations.Presentation</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>Presentation(M::GarsideMonoid)</code></p><p>returns  a presentation of  the Garside group  defined by <code>M</code>  (as given in theorem 4.1 of <a href="biblio.htm#DePa99">Dehornoy-Paris 1999</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; M=DualBraidMonoid(coxgroup(:A,3))
DualBraidMonoid(A‚ÇÉ,c=[1, 3, 2])

julia&gt; p=Presentation(M)
Presentation: 6 generators, 15 relators, total length 62</code></pre><pre><code class="language-julia-rep1 hljs">julia&gt; simplify(p)
&lt;&lt; presentation with 3 generators, 4 relators of total length 26&gt;&gt;
&lt;&lt; presentation with 3 generators, 3 relators of total length 16&gt;&gt;

julia&gt; display_balanced(p)
1: ab=ba
2: cac=aca
3: cbc=bcb</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L2210-L2234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Garside.shrink" href="#Chevie.Garside.shrink"><code>Chevie.Garside.shrink</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>shrink(l::Vector{&lt;:GarsideElt})</p><p>The  list <code>l</code>  is a  list of  elements of  the same Garside group <code>G</code>. This function  tries to find  another set of  generators of the  subgroup of <code>G</code> generated by the elements of <code>l</code>, of smaller total length (the length being counted  as returned by the  function <code>word</code>). This can  be use to simplify the result of <code>centralizer_gens</code>, or other braid subgroups.</p><pre><code class="language-julia-repl hljs">julia&gt; B=BraidMonoid(coxsym(3))
BraidMonoid(ùîñ ‚ÇÉ)

julia&gt; b=[B(1)^3,B(2)^3,B(-2,-1,-1,2,2,2,2,1,1,2),B(1,1,1,2)]
4-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, CoxSym{Int16}}}}:
 1.1.1
 2.2.2
 (1.12)‚Åª¬π2.2.2.21.12
 1.1.12

julia&gt; shrink(b)
2-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, CoxSym{Int16}}}}:
 2
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/Garside.jl#L2363-L2388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Garside.CorranPicantinMonoid" href="#Chevie.Garside.CorranPicantinMonoid"><code>Chevie.Garside.CorranPicantinMonoid</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p><code>CorranPicantinMonoid(e,n,k=1)</code></p><p>returns the interval monoid defined by G. Neaime, http://arxiv.org/abs/1707.06864,   which  generalizes  the  Corran-Picantin monoid for <code>G(e,e,n)</code>.</p><p>In  this monoid <code>Œ¥</code> has <code>image</code>  the element of <code>G(e,e,n)</code> corresponding to the  diagonal matrix whose  diagonal entries except  the first are equal to <code>E(e)^k</code>;  this  monoid  is  isomorphic  to  the Corran-Picantin monoid for <code>G(e,e,n)</code> when <code>gcd(k,e)=1</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; C=CorranPicantinMonoid(3,3)
CorranPicantinMonoid(3,3,3)

julia&gt; word(C(C.Œ¥))
6-element Vector{Int64}:
 1
 3
 4
 1
 3
 4

julia&gt; Matrix(C,C.Œ¥)
3√ó3 Matrix{Cyc{Int64}}:
 Œ∂‚ÇÉ   0   0
  0  Œ∂‚ÇÉ   0
  0   0  Œ∂‚ÇÉ

julia&gt; b=C(1,2,3,4)^3
1.2.341.2.341.2.34

julia&gt; Matrix(C,b[3])
3√ó3 Matrix{Cyc{Int64}}:
 0    0  Œ∂‚ÇÉ
 0  Œ∂‚ÇÉ¬≤   0
 1    0   0</code></pre><p>¬© July 2017 ‚Äì- Jean Michel and Georges Neaime</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/fbddb048572eb9b42fb2c8f80113717339b328da/src/cp.jl#L46-L87">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="algebras.html">¬´ Algebras</a><a class="docs-footer-nextpage" href="semisimple.html">Reductive groups, semisimple elements ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 12 September 2025 19:28">Friday 12 September 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
