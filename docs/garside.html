<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Garside monoids and groups, braids. ¬∑ Gapjm.jl documentation</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Gapjm.jl documentation</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Gapjm</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Infrastructure</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="cycpol.html">Cyclotomic polynomials</a></li><li><a class="tocitem" href="posets.html">Posets</a></li><li><a class="tocitem" href="sperm.html">Signed permutations</a></li><li><a class="tocitem" href="symbols.html">Symbols</a></li><li><a class="tocitem" href="glinearalgebra.html">Linear algebra on any field/ring</a></li><li><a class="tocitem" href="matint.html">Integral matrices and lattices</a></li><li><a class="tocitem" href="ffe.html">Finite fields</a></li><li><a class="tocitem" href="presentations.html">Presentations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Reflection groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="permroot.html">Finite reflection groups</a></li><li><a class="tocitem" href="coxgroups.html">Coxeter groups</a></li><li><a class="tocitem" href="weyl.html">Finite Coxeter groups and Weyl groups</a></li><li><a class="tocitem" href="chars.html">Classes/characters of reflection groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Hecke algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="hecke.html">Hecke algebras</a></li><li><a class="tocitem" href="kl.html">Kazhdan-Lusztig polynomials and bases</a></li></ul></li><li class="is-active"><a class="tocitem" href="garside.html">Garside monoids and groups, braids.</a></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Reductive groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="semisimple.html">Reductive groups, semisimple elements</a></li><li><a class="tocitem" href="cosets.html">Reflection cosets</a></li><li><a class="tocitem" href="sscoset.html">Non-connected reductive groups</a></li><li><a class="tocitem" href="uch.html">Unipotent characters</a></li><li><a class="tocitem" href="ct.html">Classtypes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Eigenspaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="eigen.html">Eigenspaces</a></li><li><a class="tocitem" href="dseries.html">d-Harish-Chandra series</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Unipotent elements</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="ucl.html">Unipotent classes of reductive groups</a></li><li><a class="tocitem" href="urad.html">Unipotent Elements</a></li></ul></li><li><a class="tocitem" href="gendec.html">Decomposition Matrices</a></li><li><a class="tocitem" href="dict.html">Dictionary from GAP3/Chevie</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="garside.html">Garside monoids and groups, braids.</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="garside.html">Garside monoids and groups, braids.</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jmichel7/Gapjm.jl/blob/master/docs/src/garside.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Garside-monoids-and-groups,-braids."><a class="docs-heading-anchor" href="#Garside-monoids-and-groups,-braids.">Garside monoids and groups, braids.</a><a id="Garside-monoids-and-groups,-braids.-1"></a><a class="docs-heading-anchor-permalink" href="#Garside-monoids-and-groups,-braids." title="Permalink"></a></h1><ul><li><a href="garside.html#Gapjm.Garside"><code>Gapjm.Garside</code></a></li><li><a href="garside.html#Gapjm.Garside.BraidMonoid"><code>Gapjm.Garside.BraidMonoid</code></a></li><li><a href="garside.html#Gapjm.Garside.DualBraidMonoid"><code>Gapjm.Garside.DualBraidMonoid</code></a></li><li><a href="garside.html#Gapjm.Garside.GarsideMonoid"><code>Gapjm.Garside.GarsideMonoid</code></a></li><li><a href="garside.html#Gapjm.Garside.LocallyGarsideMonoid"><code>Gapjm.Garside.LocallyGarsideMonoid</code></a></li><li><a href="garside.html#Gapjm.Presentations.Presentation-Tuple{GarsideMonoid}"><code>Gapjm.Presentations.Presentation</code></a></li><li><a href="garside.html#Gapjm.CoxGroups.isleftdescent-Tuple{BraidMonoid, Any, Int64}"><code>Gapjm.CoxGroups.isleftdescent</code></a></li><li><a href="garside.html#Gapjm.CoxGroups.leftdescents-Tuple{Gapjm.Garside.LocallyGarsideElt}"><code>Gapjm.CoxGroups.leftdescents</code></a></li><li><a href="garside.html#Gapjm.Garside.Brieskorn_normal_form"><code>Gapjm.Garside.Brieskorn_normal_form</code></a></li><li><a href="garside.html#Gapjm.Garside.centralizer_gens"><code>Gapjm.Garside.centralizer_gens</code></a></li><li><a href="garside.html#Gapjm.Garside.conjcat"><code>Gapjm.Garside.conjcat</code></a></li><li><a href="garside.html#Gapjm.Garside.conjugating_elt"><code>Gapjm.Garside.conjugating_elt</code></a></li><li><a href="garside.html#Gapjm.Garside.endomorphisms"><code>Gapjm.Garside.endomorphisms</code></a></li><li><a href="garside.html#Gapjm.Garside.fraction"><code>Gapjm.Garside.fraction</code></a></li><li><a href="garside.html#Gapjm.Garside.hurwitz"><code>Gapjm.Garside.hurwitz</code></a></li><li><a href="garside.html#Gapjm.Garside.image"><code>Gapjm.Garside.image</code></a></li><li><a href="garside.html#Gapjm.Garside.left_divisors"><code>Gapjm.Garside.left_divisors</code></a></li><li><a href="garside.html#Gapjm.Garside.leftgcd"><code>Gapjm.Garside.leftgcd</code></a></li><li><a href="garside.html#Gapjm.Garside.leftlcm"><code>Gapjm.Garside.leftlcm</code></a></li><li><a href="garside.html#Gapjm.Garside.rightgcd"><code>Gapjm.Garside.rightgcd</code></a></li><li><a href="garside.html#Gapjm.Garside.rightlcm"><code>Gapjm.Garside.rightlcm</code></a></li><li><a href="garside.html#Gapjm.Garside.shrink"><code>Gapjm.Garside.shrink</code></a></li><li><a href="garside.html#Gapjm.Garside.Œ±-Tuple{Gapjm.Garside.LocallyGarsideElt}"><code>Gapjm.Garside.Œ±</code></a></li><li><a href="garside.html#Gapjm.Garside.Œ±-Tuple{Gapjm.Garside.LocallyGarsideElt, AbstractVector}"><code>Gapjm.Garside.Œ±</code></a></li><li><a href="garside.html#PermGroups.Groups.elements-Tuple{LocallyGarsideMonoid, Any}"><code>PermGroups.Groups.elements</code></a></li><li><a href="garside.html#PermGroups.Groups.word-Tuple{GarsideElt}"><code>PermGroups.Groups.word</code></a></li><li><a href="garside.html#PermGroups.Groups.word-Tuple{GarsideMonoid, Any}"><code>PermGroups.Groups.word</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside" href="#Gapjm.Garside"><code>Gapjm.Garside</code></a> ‚Äî <span class="docstring-category">Module</span></header><section><div><p>Garside  monoids are a general class  of monoids whose most famous examples are  the braid and dual braid monoids.  They have groups of fractions which in  both cases are the  braid group. Here we  implement braid groups in the framework of a general implementation of Garside monoids and groups.</p><p>To  define Garside monoids we  introduce some vocabulary about divisibility in  monoids. A <em>left  divisor</em> of <code>x</code>  is a <code>d</code>  such that there exists <code>y</code> with  <code>x=dy</code> (and then  we say that  <code>x</code> is a  <em>right multiple</em> of <code>d</code>, and write  <code>d‚âº x</code>). We say that a monoid <code>M</code> is left cancellable if an equality <code>dx=dy</code>  implies  <code>x=y</code>.  We  define  symmetrically  right  divisors,  left multiples and right cancellability. We say that <code>x</code> is an <em>atom</em> if <code>1</code> and <code>x</code>  are its only  divisors. A <em>left  gcd</em> of <code>x</code>  and <code>y</code> is a common left divisor  <code>d</code> of <code>x</code>  and <code>y</code> such  that any other  common left divisor is a left  divisor of <code>d</code>.  Similarly a <em>right  lcm</em> of <code>x</code>  and <code>y</code> is a common multiple which is a left divisor of any other common multiple.</p><p>We  call <em>Garside</em> a monoid <code>M</code> which:</p><ul><li>is left and right cancellable.</li><li>is generated by its atoms,  which are finite in number.</li><li>admits left and  right  gcds  and  lcms.</li><li>is such that any element has only finitely many left (or right) divisors.</li><li>admits a <em>Garside element</em>, which is an element <code>Œî</code> whose set of left and right divisors coincide and generate <code>M</code>.</li></ul><p>Garside  elements are not  unique, but there  is a unique  minimal one (for divisibility);  we assume a  Garside element <code>Œî</code>  has been chosen. Then the divisors  of <code>Œî</code> are called  the <em>simples</em> of <code>M</code>.  A Garside monoid embeds into  its group of fractions, which is  called a <em>Garside group</em> (a Garside group  may have  several distinct  Garside structures,  as we  will see for Braid groups of finite Coxeter groups).</p><p>We  also implement <em>locally Garside</em> monoids,  which are monoids where lcms do  not always exist, but exist when any common multiple exists; the set of simples  is then not defined using a  Garside element, but by the condition that  they contain the atoms and are  closed under lcms and taking divisors (see  <a href="biblio.htm#BDM01">BDM01</a>); since it is  not ensured by the existence of  <code>Œî</code>, one  has to  add the  condition that  any element  is divisible by finitely many simples (but the number of simples can be infinite). The main example  is the braid monoid of an  infinite Coxeter group. It is not known if  these monoids embed in  their group of fractions  (though that has been proved for braid monoids of Coxeter groups by Paris <a href="biblio.htm#Paris01">Paris01</a>)  and thus  computing in  the monoid does not help  for computing in the group (only  the monoid is implemented for these cases).</p><p>What allows computing with Garside and locally Garside monoids, and Garside groups,  is the fact  that they admit  normal forms ‚Äì-  these normal forms where   exhibited  for   braid  monoids   of  Coxeter   groups  by  Deligne <a href="biblio.htm#Del72">Del72</a>,  who extended previous  work of Brieskorn, Saito <a href="biblio.htm#BS72">BS72</a> and Garside <a href="biblio.htm#Gar69">Gar69</a>:</p><ul><li><p>(1) Let <code>M</code> be a locally Garside monoid and let <code>b‚àà M</code>. Then there is a unique  maximal left simple divisor <code>Œ±(b)</code>  of <code>b</code> ‚Äì- any other simple dividing <code>b</code> on the left divides <code>Œ±(b)</code> on the left.</p></li><li><p>(2) Assume <code>M</code> is a Garside monoid, <code>Œî</code> is its Garside element and <code>G</code> is  its group of  fractions. Then, given  any element <code>x‚àà  G</code>, there is some power <code>i</code> such that <code>Œî‚Å± x‚àà M</code>.</p></li></ul><p>A consequence of (1) is that any element has a canonical decomposition as a product of simples, called its left-greedy normal form. If we define <code>œâ(x)</code> by  <code>x=Œ±(x)œâ(x)</code>, then the normal form of <code>x</code> is <code>Œ±(x)Œ±(œâ(x))Œ±(œâ^2(x))‚Ä¶</code> We use  the normal form to represent elements  of <code>M</code>, and when <code>M</code> is Garside (2)  to represent  elements of  <code>G</code>: given  <code>x‚àà G</code>  we compute the smallest power  <code>i</code>  such  that  <code>Œî‚Å±  x‚àà  M</code>,  and  we  represent  <code>x</code> by the couple <code>(i,Œî‚Åª‚Å±x)</code>.  We are thus reduced to the case where <code>x‚àà M</code>, not divisible by <code>Œî</code>,  where we represent  <code>x</code> by the  sequence of simples which constitutes its normal form.</p><p>We  now describe Artin-Tits braid monoids. Let <code>(W,S)</code> be a Coxeter system, that is <code>W</code> has presentation</p><p><code>‚ü®s‚àà S‚à£s^2=1, sts‚ãØ =tst‚ãØ   (m‚Çõ‚Çú factors on each side) for s,t‚àà S‚ü©</code></p><p>for  some Coxeter matrix <code>m‚Çõ‚Çú</code> for <code>s,t‚àà S</code>. The braid group <code>B</code> associated to <code>(W,S)</code> is the group defined by the presentation</p><p><code>‚ü®ùê¨‚àà ùêí‚à£ ùê¨ùê≠ùê¨‚ãØ =ùê≠ùê¨ùê≠‚ãØ  (m‚Çõ‚Çú factors on each side) for ùê¨,ùê≠‚àà ùêí‚ü©</code></p><p>The <em>positive</em> braid monoid <code>B‚Å∫</code> associated to <code>W</code> is the monoid defined by the  presentation above ‚Äì- it identifies to the submonoid of <code>B</code> generated by  <code>ùêí</code> by  the result  of Paris  mentioned above.  This monoid  is locally Garside,  with set of simples  in bijection with elements  of <code>W</code> and atoms the elements of <code>ùêí</code>; we will denote by <code>ùêñ</code> the set of simples, and by <code>ùê∞ ‚Ü¶ w</code>  the bijection between simples and elements  of <code>W</code>. The group <code>W</code> has a length  defined  in  terms  of  reduced expressions. Similarly, having only homogeneous relations, <code>B‚Å∫</code> has a natural length function. Then <code>ùêñ</code> can be characterized  as the subset of the elements  of <code>B‚Å∫</code> of the same length as their image in <code>W</code>.</p><p>If  <code>W</code> is finite, then <code>B‚Å∫</code> is Garside with Garside element the element of <code>ùêñ</code> whose image is the longest element  of <code>W</code>. A finite Coxeter group is also  a reflection group in  a real vector space,  thus in its complexified <code>V</code>,  and <code>B</code> has also a topological definition as the fundamental group of the  space <code>V ≥·µâ·µç/W</code>, where <code>V ≥·µâ·µç</code>  is the set of  elements of <code>V</code> which are fixed  by no  non-identity element  of <code>S</code>;  however, we  will not use this here.</p><p>Given a Coxeter group <code>W</code>,</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,4)
A‚ÇÑ

julia&gt; B=BraidMonoid(W)
BraidMonoid(A‚ÇÑ)</code></pre><p>constructs  the  associated  braid  monoid,  and  then  as  a  function <code>B</code> constructs  elements of the braid monoid (or group when <code>W</code> is finite) from a list of generators (below <code>B(1,2,3,4)</code> represents <code>ùê¨‚ÇÅùê¨‚ÇÇùê¨‚ÇÉùê¨‚ÇÑ</code>):</p><pre><code class="language-julia-repl hljs">julia&gt; w=B(1,2,3,4)
1234

julia&gt; w^3  # the terms of the normal form are separated by a `.`
121321432.343

julia&gt; word(Œ±(w^3))
9-element Vector{Int64}:
 1
 2
 1
 3
 2
 1
 4
 3
 2

julia&gt; w^4
Œî.232432

julia&gt; inv(w)
(1234)‚Åª¬π</code></pre><p>How  an  element  of  a  Garside  group  is  printed  is  controlled by the <code>IOcontext</code>  attribute  &#39;:greedy&#39;.  By  default,  elements  are  printed as fractions <code>a‚Åª¬πb</code> where <code>a</code> and <code>b</code> have no left common divisor. Each of <code>a</code> and  <code>b</code> is printed  using its left-greedy  normal form, that  is a maximal power of the Garside element followed by the rest. One can print the entire element   in  the  left-greedy  normal  from  by  setting  the  <code>IOContext</code> <code>:greedy=&gt;true</code>; with the same <code>w</code> as above we have:</p><pre><code class="language-julia-repl hljs">julia&gt; repr(w^-1,context=IOContext(stdout,:greedy=&gt;true,:limit=&gt;true))
&quot;Œî‚Åª¬π.232432&quot;</code></pre><p>Finally,  <code>repr</code> gives   <code>w</code>  back   in  a   form  which   after  assigning <code>B=BraidMonoid(W)</code> can be input back into Julia:</p><pre><code class="language-julia-repl hljs">julia&gt; repr(w)
&quot;B(1,2,3,4)&quot;

julia&gt; repr(w^3)
&quot;B(1,2,1,3,2,1,4,3,2,3,4,3)&quot;

julia&gt; repr(w^-1)
&quot;B(-4,-3,-2,-1)&quot;</code></pre><p>In  general elements of a Garside monoid  are displayed similarly as a list of their constituting atoms.</p><p>We  now describe the dual braid monoid.  For that, we first give a possible approach  to construct Garside monoids. Given a  group <code>W</code> and a set <code>S</code> of generators  of <code>W</code> as  a monoid, we  define the <code>S</code>-length  <code>l_S(w)</code> as the minimum  number of elements of <code>S</code> needed to write <code>w</code>. We then define left divisors  of <code>x</code>  as the  <code>d</code> such  that there  exists <code>y</code>  with <code>x=dy</code> and <code>l_S(d)+l_S(y)=l_S(x)</code>.  We say that <code>w‚àà W</code> is  balanced if its set of left and  right divisors coincide, and we say that <code>w</code> is Garside if that set is a  lattice (where upper and  lower bounds are lcms  and gcds) and generates <code>W</code>. Then we have:</p><p>suppose  <code>w</code> is Garside and let <code>[1,w]</code> be its set of divisors (an interval for  the partial order  defined by divisibility).  Then the monoid <code>M</code> with generators  <code>[1,w]</code> and relations  <code>xy=z</code> whenever <code>xy=z</code>  holds in <code>W</code> and <code>l_S(x)+l_S(y)=l_S(z)</code>  is Garside, with simples  <code>[1,w]</code> and atoms <code>S</code>. It is called the interval monoid defined by the interval <code>[1,w]</code>.</p><p>The  Artin-Tits braid monoid  is an interval  monoid by taking  for <code>S</code> the Coxeter  generators, in which case <code>l_S</code>  is the Coxeter length, and taking for <code>w</code> the longest element of <code>W</code>. The dual monoid, constructed by Birman, Ko  and  Lee  for  type  <code>A</code>  and  by Bessis for all well-generated complex reflection  groups, is obtained in  a similar way, by  taking this time for <code>w</code>  a Coxeter element, for <code>l_S</code> the reflection length &#39;reflength&#39; and for <code>S_S</code>  the  reflections  which  divide  <code>w</code>  for the reflection length (for Coxeter  groups all reflections  divide <code>w</code> but  for well-generated complex reflection  groups not  all reflections  divide); for  the dual  monoid the simples  are of cardinality  the generalized Catalan  numbers <code>catalan</code>. An interval  monoid has naturally an inverse  morphism from <code>M</code> to <code>W</code>, called &#39;image&#39;  which is the  quotient map from  the interval monoid  to <code>W</code> which sends back simple braids to <code>[1,w]</code>.</p><p>A last pertinent notion is <em>reversible</em> monoids. Since we store left normal forms,  it is easy to compute left lcms and gcds, but hard to compute right lcms  and gcds. But this becomes easy to  do if the monoid has an operation &#39;reverse&#39;,  which has the property that &#39;a&#39; is a left divisor of &#39;b&#39; if and only  if &#39;reverse(a)&#39;  is a  right divisor  of &#39;reverse(b)&#39;. This holds for Artin-Tits  and dual braid monoids of groups generated by true reflections; Artin-Tits monoids have a <code>reverse</code> operation which consists of reversing a word,  written as  a list  of atoms.  The dual  monoid also has a <code>reverse</code> operation  defined in the  same way, but  this operation changes monoid: it goes  from the dual monoid  for the Coxeter element  <code>w</code> to the dual monoid for  the Coxeter element  <code>w‚Åª¬π</code>. The operations  &#39;rightlcm&#39; and &#39;rightgcd&#39;, and  some other algorithms, have faster implementations if the monoid has a <code>reverse</code> operation.</p><p>This  module implements also  functions to solve  the conjugacy problem and compute  centralizers  in  Garside  groups,  following  the work of Franco, Gebhardt and Gonzalez-Meneses.</p><p>Two  elements <code>w</code> and <code>w&#39;</code> of a monoid  <code>M</code> are <em>conjugate</em> in <code>M</code> if there exists  <code>x‚àà M</code> such that <code>wx=xw&#39;</code>; if  <code>M</code> satisfies the √ñre conditions, it has  a  group  of  fractions  where  this  becomes  <code>x‚Åª¬πwx=w&#39;</code>,  the  usual definition  of conjugacy. A special case  which is even closer to conjugacy in  the group is if there exists <code>y‚àà  M</code> such that <code>w=xy</code> and <code>w&#39;=yx</code>. This relation  is not transitive in general,  but we call <em>cyclic conjugacy</em> the transitive closure of this relation, a restricted form of conjugacy.</p><p>The  next  observation  is  that  if  <code>w,w&#39;</code>  are conjugate in the group of fractions  of the Garside monoid <code>M</code> then  they are conjugate in <code>M</code>, since if  <code>wx=xw&#39;</code> then  there is  a power  <code>Œî‚Å±</code> which  is central and such that <code>xŒî‚Å±‚àà M</code>. Then <code>wxŒî‚Å±=xŒî‚Å± w&#39;</code> is a conjugation in <code>M</code>.</p><p>The  crucial observation for solving the  conjugacy problem is to introduce <code>inf(w):=sup{i such  that  Œî‚Å±   divides  w}</code>  and <code>sup(w):=inf{i such  that  w  divides Œî‚Å±}</code>, and to notice  that the number of  conjugates of <code>w</code> with  same <code>inf</code> and <code>sup</code> as <code>w</code>  is finite. Further, a  theorem of Birman shows  that the maximum <code>inf</code> and  minimum <code>sup</code> in a conjugacy class can be achieved simultaneously; the elements  achieving this are called the super summit set of <code>w</code>. Thus a way to  determine if two elements are conjugate  is to find a representative of both  of them in  their super summit  set, and then  solve conjugacy within that  set. This can also be used  to compute the centralizer of an element: if  we consider  the super  summit set  as the  objects of a category whose morphisms are the conjugations by simple elements, the centralizer is given by the endomorphisms of the given object.</p><p>We illustrate this on an example:</p><pre><code class="language-julia-repl hljs">julia&gt; b=B(2,1,4,1,4)
214.14

julia&gt; c=B(1,4,1,4,3)
14.143

julia&gt; d=conjugating_elt(b,c)
(1)‚Åª¬π21321432

julia&gt; b^d
14.143

julia&gt; centralizer_gens(b)
3-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 321432.213243
 21.1
 4

julia&gt; C=conjcat(b;ss=:ss)
category with 10 objects and 32 generating maps

julia&gt; C.obj
10-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 1214.4
 214.14
 124.24
 1343.1
 14.124
 143.13
 24.214
 134.14
 13.134
 14.143</code></pre><p>There   is  a   faster  solution   to  the   conjugacy  problem   given  in <a href="biblio.htm#gebgon10">gebgon10</a>:  for each <code>b‚àà M</code>, they define a particular simple  left divisor of <code>b</code>, its <em>preferred prefix</em> such that the operation <em>sliding</em>  which  cyclically  conjugates  <code>b</code>  by  its preferred prefix, is eventually periodic, and the period is contained in the super summit set of <code>x</code>.  We say that <code>x</code> is in its sliding circuit if some iterated sliding of <code>x</code> is equal to <code>x</code>. The set of sliding circuits in a given conjugacy class is  smaller than the super  summit set, thus allows  to solve the conjugacy problem faster. Continuing from the above example,</p><pre><code class="language-julia-repl hljs">julia&gt; word(W,preferred_prefix(b))
2-element Vector{Int64}:
 2
 1

julia&gt; b^B(preferred_prefix(b))
1214.4

julia&gt; b1=b^B(preferred_prefix(b))
1214.4

julia&gt; C=conjcat(b)
category with 2 objects and 6 generating maps

julia&gt; C.obj
2-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 1214.4
 1343.1</code></pre><p>Finally,  we have implemented  Hao Zheng&#39;s algorithm  to extract roots in a Garside monoid:</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A‚ÇÉ

julia&gt; B=BraidMonoid(W)
BraidMonoid(A‚ÇÉ)

julia&gt; Pi=B(B.Œ¥)^2
Œî¬≤

julia&gt; root(Pi,2)
Œî

julia&gt; root(Pi,3)
1232

julia&gt; root(Pi,4)
132</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/65a2d935877e2b271770956f575a43ba9e71f517/src/Garside.jl#L1-L332">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.LocallyGarsideMonoid" href="#Gapjm.Garside.LocallyGarsideMonoid"><code>Gapjm.Garside.LocallyGarsideMonoid</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p><code>LocallyGarsideMonoid{T}</code>  is the abstract type of locally Garside monoids, where  <code>T</code>  is  the  type  of  simples.  Such a monoid <code>M</code> needs, for <code>a,b</code> simples, to implement the functions</p><ul><li><code>one(M)</code></li><li><code>isleftdescent(M,a,::Int)</code>  whether <code>M.atoms[i]‚âº a</code></li><li><code>isrightdescent(M,a,::Int)</code> whether <code>a‚âΩ M.atoms[i]</code></li><li><code>isrightascent(M,a,::Int)</code>  whether <code>a*M.atoms[i]</code> is simple</li><li><code>*(M,a,b)</code>    when <code>a*b</code> is simple</li><li><code>\(M,a,b)</code>   when <code>a‚âº b</code></li><li><code>/(M,a,b)</code>    when <code>a‚âΩ b</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/65a2d935877e2b271770956f575a43ba9e71f517/src/Garside.jl#L341-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.GarsideMonoid" href="#Gapjm.Garside.GarsideMonoid"><code>Gapjm.Garside.GarsideMonoid</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p><code>GarsideMonoid{T}</code>  is the abstract  type of Garside  monoids, where <code>T</code> is the type of simples. Such a monoid <code>M</code> should implement the same methods as <code>LocallyGarsideMonoid</code>   except   that   <code>isrightascent</code>  is  automatically defined. It should have fields <code>M.Œ¥</code>,<code>M.stringŒ¥</code>,<code>M.orderŒ¥</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/65a2d935877e2b271770956f575a43ba9e71f517/src/Garside.jl#L354-L359">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.left_divisors" href="#Gapjm.Garside.left_divisors"><code>Gapjm.Garside.left_divisors</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>left_divisors(M::LocallyGarsideMonoid, s)</p><p>all  the left  divisors of  the simple  element <code>s</code>  of <code>M</code>, as a vector of vectors,  where the  i+1-th vector  holds the  divisors of  length i in the atoms.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A‚ÇÉ

julia&gt; B=BraidMonoid(W)
BraidMonoid(A‚ÇÉ)

julia&gt; map(x-&gt;B.(x),left_divisors(B,W(1,3,2)))
4-element Vector{Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}}:
 [.]   
 [1, 3]
 [13]
 [132] 

julia&gt; B=DualBraidMonoid(W)
DualBraidMonoid(A‚ÇÉ,c=[1, 3, 2])

julia&gt; map(x-&gt;B.(x),left_divisors(B,W(1,3,2)))
4-element Vector{Vector{GarsideElt{Perm{Int16}, DualBraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}}:
 [.]                     
 [1, 2, 3, 4, 5, 6]      
 [12, 13, 15, 25, 34, 45]
 [Œ¥]                     </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/65a2d935877e2b271770956f575a43ba9e71f517/src/Garside.jl#L515-L546">source</a></section><section><div><p><code>left_divisors(b::LocallyGarsideElt[, i])</code></p><p>returns all left divisors of <code>b</code> (divisors of length <code>i</code> if specified)</p><pre><code class="language-julia-repl hljs">julia&gt; B=DualBraidMonoid(CoxSym(4))
DualBraidMonoid(ùîñ ‚ÇÑ,c=[1, 3, 2])

julia&gt; left_divisors(B(1,5,4,3))
10-element Vector{GarsideElt{Perm{Int16}, DualBraidMonoid{Perm{Int16}, CoxSym{Int16}}}}:
 .
 1
 1.4
 1.4.2
 1.4.3
 5
 6
 15
 15.4
 15.4.3

julia&gt; left_divisors(B(1,5,4,3),1)
3-element Vector{GarsideElt{Perm{Int16}, DualBraidMonoid{Perm{Int16}, CoxSym{Int16}}}}:
 1
 5
 6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/65a2d935877e2b271770956f575a43ba9e71f517/src/Garside.jl#L829-L857">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.leftgcd" href="#Gapjm.Garside.leftgcd"><code>Gapjm.Garside.leftgcd</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p><code>leftgcd(M::LocallyGarsideMonoid,elts...;complements=false)</code></p><p><code>elts</code>  should be simples of <code>M</code>. The  function returns the left gcd <code>d</code> of the  <code>elts</code>; if <code>complements=true</code>, followed by  a tuple of the complements <code>d^-1*elts[1],‚Ä¶</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/65a2d935877e2b271770956f575a43ba9e71f517/src/Garside.jl#L362-L368">source</a></section><section><div><p><code>leftgcd(a‚ÇÅ,‚Ä¶,a‚Çô;complements=false)</code> </p><p><code>a‚ÇÅ,‚Ä¶,a‚Çô</code>  should be  elements of  the same  (locally) Garside  monoid. The function returns the left gcd <code>d</code> of <code>a‚ÇÅ,‚Ä¶,a‚Çô</code>. If <code>complements</code> is true it returns <code>(d,(d‚Åª¬πa‚ÇÅ,‚Ä¶,d‚Åª¬πa‚Çô))</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A‚ÇÉ

julia&gt; B=BraidMonoid(W)
BraidMonoid(A‚ÇÉ)

julia&gt; leftgcd(B(2,1,2)^2,B(3,2)^2;complements=true)
(2, (121.21, 32.2))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/65a2d935877e2b271770956f575a43ba9e71f517/src/Garside.jl#L1220-L1237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.rightgcd" href="#Gapjm.Garside.rightgcd"><code>Gapjm.Garside.rightgcd</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p><code>rightgcd(M::LocallyGarsideMonoid,elts...)</code></p><p><code>elts</code>  should be simples of <code>M</code>. The function returns the right gcd <code>d</code> of the  <code>elts</code>; if <code>complements=true</code>, followed by  a tuple of the complements <code>elts[1]*d^-1,‚Ä¶</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/65a2d935877e2b271770956f575a43ba9e71f517/src/Garside.jl#L386-L392">source</a></section><section><div><p><code>rightgcd(a‚ÇÅ,‚Ä¶,a‚Çô;complements=false)</code> </p><p><code>a‚ÇÅ,‚Ä¶,a‚Çô</code>  should be  elements of  the same  (locally) Garside  monoid. The function returns the right gcd <code>d</code> of <code>a‚ÇÅ,‚Ä¶,a‚Çô</code>. If <code>complements</code> is true it returns <code>(d,(a‚ÇÅ/d,‚Ä¶,a‚Çô/d))</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A‚ÇÉ

julia&gt; B=BraidMonoid(W)
BraidMonoid(A‚ÇÉ)

julia&gt; rightgcd(B(2,1,2)^2,B(3,2)^2;complements=true)
(2.2, (12.21, 23))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/65a2d935877e2b271770956f575a43ba9e71f517/src/Garside.jl#L1265-L1282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.leftlcm" href="#Gapjm.Garside.leftlcm"><code>Gapjm.Garside.leftlcm</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p><code>leftlcm(M::GarsideMonoid,elts...;complements=false)</code></p><p><code>elts</code>  should be simples of <code>M</code>. The  function returns the left lcm <code>m</code> of the  <code>elts</code>; if <code>complements=true</code>, followed by  a tuple of the complements <code>m/elts[1],‚Ä¶</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/65a2d935877e2b271770956f575a43ba9e71f517/src/Garside.jl#L445-L451">source</a></section><section><div><p><code>leftlcm(a‚ÇÅ,‚Ä¶,a‚Çô;complements=false)</code></p><p><code>a‚ÇÅ,‚Ä¶,a‚Çô</code>  should  be  elements  of  the  same Garside monoid. The function returns  the least common left multiple  <code>m</code> of <code>a‚ÇÅ,‚Ä¶,a‚Çô</code>; if <code>complements</code> is true it returns &#39;(m,(m/a‚ÇÅ,‚Ä¶,m/a‚Çô))`.</p><pre><code class="language-julia-repl hljs">julia&gt; B=BraidMonoid(coxgroup(:A,3))
BraidMonoid(A‚ÇÉ)

julia&gt; leftlcm(B(2,1,2)^2,B(3,2)^2;complements=true)
(Œî.121, (123, 23.321))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/65a2d935877e2b271770956f575a43ba9e71f517/src/Garside.jl#L1291-L1305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.rightlcm" href="#Gapjm.Garside.rightlcm"><code>Gapjm.Garside.rightlcm</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p><code>rightlcm(M::GarsideMonoid,elts...;complements=false)</code></p><p><code>elts</code>  should be simples of <code>M</code>. The function returns the right lcm <code>m</code> of the  <code>elts</code>; if <code>complements=true</code>, followed by  a tuple of the complements <code>elts[1]^-1*m,‚Ä¶</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/65a2d935877e2b271770956f575a43ba9e71f517/src/Garside.jl#L433-L439">source</a></section><section><div><p><code>rightlcm(a‚ÇÅ,‚Ä¶,a‚Çô;complements=false)</code></p><p><code>a‚ÇÅ,‚Ä¶,a‚Çô</code>  should  be  elements  of  the  same Garside monoid. The function returns  the least common right multiple  <code>m</code> of <code>a‚ÇÅ,‚Ä¶,a‚Çô</code>; if <code>complements</code> is true it returns &#39;(m,(a‚ÇÅ‚Åª¬π<em>m,‚Ä¶,a‚Çô‚Åª¬π</em>m))`.</p><pre><code class="language-julia-repl hljs">julia&gt; B=BraidMonoid(coxgroup(:A,3))
BraidMonoid(A‚ÇÉ)

julia&gt; rightlcm(B(2,1,2)^2,B(3,2)^2;complements=true)
(Œî¬≤, (321.123, 12321.321))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/65a2d935877e2b271770956f575a43ba9e71f517/src/Garside.jl#L1316-L1330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.Œ±-Tuple{Gapjm.Garside.LocallyGarsideElt}" href="#Gapjm.Garside.Œ±-Tuple{Gapjm.Garside.LocallyGarsideElt}"><code>Gapjm.Garside.Œ±</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>Œ±(b::LocallyGarsideElt)</code></p><p>returns as a Garside element  the first term in  the normal form of  <code>b</code> (this term is <code>b[1]</code> as a simple).</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A‚ÇÉ

julia&gt; b=BraidMonoid(W)(2,1,2,1,1)
121.1.1

julia&gt; Œ±(b)
121</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/65a2d935877e2b271770956f575a43ba9e71f517/src/Garside.jl#L953-L969">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.Œ±-Tuple{Gapjm.Garside.LocallyGarsideElt, AbstractVector}" href="#Gapjm.Garside.Œ±-Tuple{Gapjm.Garside.LocallyGarsideElt, AbstractVector}"><code>Gapjm.Garside.Œ±</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>Œ±(b::LocallyGarsideElt,I)</code> returns the longest prefix of b which uses only  <code>b.M.atoms[I]</code></p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,4);B=BraidMonoid(W)
BraidMonoid(A‚ÇÑ)

julia&gt; w0=B(longest(W))
Œî

julia&gt; Œ±(w0,[1,2,3])
121321</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/65a2d935877e2b271770956f575a43ba9e71f517/src/Garside.jl#L972-L985">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.isleftdescent-Tuple{BraidMonoid, Any, Int64}" href="#Gapjm.CoxGroups.isleftdescent-Tuple{BraidMonoid, Any, Int64}"><code>Gapjm.CoxGroups.isleftdescent</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>isleftdescent(M,w,i)</code></p><p>returns <code>true</code> if and only if the <code>i</code>-th atom of the locally Garside monoid <code>M</code> left-divides the simple <code>w</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/65a2d935877e2b271770956f575a43ba9e71f517/src/Garside.jl#L682-L687">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.leftdescents-Tuple{Gapjm.Garside.LocallyGarsideElt}" href="#Gapjm.CoxGroups.leftdescents-Tuple{Gapjm.Garside.LocallyGarsideElt}"><code>Gapjm.CoxGroups.leftdescents</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>leftdescents(b::LocallyGarsideElt)</code> the list of indices of the atoms which left-divide <code>b</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/65a2d935877e2b271770956f575a43ba9e71f517/src/Garside.jl#L792-L795">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.Brieskorn_normal_form" href="#Gapjm.Garside.Brieskorn_normal_form"><code>Gapjm.Garside.Brieskorn_normal_form</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p><code>Brieskorn_normal_form(b::LocallyGarsideElt)</code></p><p>Brieskorn  citeBri71 has noticed that if <code>L(b)</code>  is the left descent set of <code>b</code>  (see <a href="coxgroups.html#Gapjm.CoxGroups.leftdescents-Tuple{CoxeterGroup, Any}"><code>leftdescents</code></a>),  and if  <code>b_(L(b))</code> is  the right lcm of <code>L(b)</code>,  then  <code>b_(L(b))</code>  left-divides  <code>b</code>.  We  can  now  divide  <code>b</code> by <code>b_(L(b))</code>  and continue  this process  with the  quotient. In this way, we obtain  an expression  <code>b=b_(L‚ÇÅ)‚ãØ b_(L·µ£)</code>  where <code>L·µ¢=L(b_(L·µ¢)‚ãØ b_(L·µ£))</code> for all  <code>i</code>, which we  call the <em>Brieskorn  normal form</em> of  <code>b</code>. The function <code>Brieskorn_normal_form</code>  returns a  description of  this form, by returning the   list  of  sets   <code>L(b)</code>  which  describe   the  above  decomposition.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:E,8);B=BraidMonoid(W)
BraidMonoid(E‚Çà)

julia&gt; w=B(2,3,4,2,3,4,5,4,2,3,4,5,6,5,4,2,3,4,5,6,7,6,5,4,2,3,4,5,6,7,8)
2342345423456542345676542345678

julia&gt; Brieskorn_normal_form(w)
2-element Vector{Vector{Int64}}:
 [2, 3, 4, 5, 6, 7]
 [8]

julia&gt; Brieskorn_normal_form(w^2)
2-element Vector{Vector{Int64}}:
 [2, 3, 4, 5, 6, 7, 8]
 [2, 3, 4, 5, 6]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/65a2d935877e2b271770956f575a43ba9e71f517/src/Garside.jl#L863-L891">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.BraidMonoid" href="#Gapjm.Garside.BraidMonoid"><code>Gapjm.Garside.BraidMonoid</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p><code>BraidMonoid(W::CoxeterGroup)</code></p><p>The ordinary monoid of the Artin group associated to <code>W</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/65a2d935877e2b271770956f575a43ba9e71f517/src/Garside.jl#L671-L675">source</a></section><section><div><p>(B::BraidMonoid)(M::DualBraidMonoid,i::Integer)</p><p>give an expression as an element of <code>B</code> of the <code>i</code>-th atom of <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/65a2d935877e2b271770956f575a43ba9e71f517/src/Garside.jl#L1468-L1472">source</a></section><section><div><p>(B::BraidMonoid)(M::DualBraidMonoid,s)</p><p>give an expression as an element of <code>B</code> of the dual simple <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/65a2d935877e2b271770956f575a43ba9e71f517/src/Garside.jl#L1474-L1478">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.DualBraidMonoid" href="#Gapjm.Garside.DualBraidMonoid"><code>Gapjm.Garside.DualBraidMonoid</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p><code>DualBraidMonoid(W;c=...)</code></p><p>Let  <code>W</code> be a well generated complex  reflection group and <code>c</code> be a Coxeter element  of <code>W</code> (if no <code>c</code> is given  a particular one is chosen for Coxeter groups  by making  the product  of elements  in a  partition of the Coxeter diagram  in two  sets where  in each  set elements  commute pairwise; for a complex  reflection group the representative stored in the Coxeter class is used). The function returns the dual braid monoid determined by <code>W</code> and <code>c</code> (which  should  be  a  <code>Vector{Int}</code>  specifying  a  sequence of indices of reflections of <code>W</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A‚ÇÉ

julia&gt; B=DualBraidMonoid(W)
DualBraidMonoid(A‚ÇÉ,c=[1, 3, 2])

julia&gt; B(2,1,2,1,1)
12.1.1.1

julia&gt; B(-1,-2,-3,1,1)
(25.1)‚Åª¬π1.1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/65a2d935877e2b271770956f575a43ba9e71f517/src/Garside.jl#L1388-L1413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.hurwitz" href="#Gapjm.Garside.hurwitz"><code>Gapjm.Garside.hurwitz</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p><code>hurwitz(l,i::Integer)</code> the  Hurwitz action of the  generator œÉ·µ¢ of the  braid group B‚Çô on the list <code>l</code>   of  length  <code>n</code>  of  group  elements,  which  replaces  <code>l·µ¢,l·µ¢‚Çä‚ÇÅ</code>  by <code>l·µ¢‚Çä‚ÇÅ,l·µ¢^l·µ¢‚Çä‚ÇÅ</code>. If <code>i&lt;0</code> does the action of <code>inv(œÉ‚Çã·µ¢)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/65a2d935877e2b271770956f575a43ba9e71f517/src/Garside.jl#L2147-L2152">source</a></section><section><div><p><code>hurwitz(l,v::AbstractVector{&lt;:Integer})</code></p><p>does successively <code>hurwitz(l,i)</code> for each <code>i</code> in <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/65a2d935877e2b271770956f575a43ba9e71f517/src/Garside.jl#L2161-L2165">source</a></section><section><div><p><code>hurwitz(l,b)</code> the  Hurwitz action of the braid  <code>b‚àà B‚Çô</code> on the list  <code>l</code> of length <code>n</code> of group elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/65a2d935877e2b271770956f575a43ba9e71f517/src/Garside.jl#L2171-L2175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.fraction" href="#Gapjm.Garside.fraction"><code>Gapjm.Garside.fraction</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>fraction(b::GarsideElt) returns  a tuple <code>(x,y)</code> of two Garside elements with no non-trivial common left divisor and such that <code>b=inv(x)*y</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; B=BraidMonoid(coxgroup(:A,3))
BraidMonoid(A‚ÇÉ)

julia&gt; b=B( 2, 1, -3, 1, 1)
(23)‚Åª¬π321.1.1

julia&gt; fraction(b)
(23, 321.1.1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/65a2d935877e2b271770956f575a43ba9e71f517/src/Garside.jl#L911-L926">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PermGroups.Groups.word-Tuple{GarsideMonoid, Any}" href="#PermGroups.Groups.word-Tuple{GarsideMonoid, Any}"><code>PermGroups.Groups.word</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>word(M::GarsideMonoid,w)</code></p><p>returns a word in the atoms of <code>M</code> representing the simple <code>w</code></p><pre><code class="language-julia-repl hljs">julia&gt; B=BraidMonoid(coxgroup(:A,3))
BraidMonoid(A‚ÇÉ)

julia&gt; word(B,B.Œ¥)
6-element Vector{Int64}:
 1
 2
 1
 3
 2
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/65a2d935877e2b271770956f575a43ba9e71f517/src/Garside.jl#L484-L502">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PermGroups.Groups.word-Tuple{GarsideElt}" href="#PermGroups.Groups.word-Tuple{GarsideElt}"><code>PermGroups.Groups.word</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>word(b::GarsideElt)</code></p><p>returns  a description  of <code>b</code>  as a  list of  the atoms  of which  it is a product.  If <code>b</code> is in the Garside group  but not the Garside monoid, it is represented  in  fraction  normal  form  where  as a special convention the inverses  of  the  atoms  are  represented  by  negating  the corresponding integer.</p><pre><code class="language-julia-repl hljs">julia&gt; B=BraidMonoid(coxgroup(:A,3))
BraidMonoid(A‚ÇÉ)

julia&gt; b=B(2,1,2,1,1)*inv(B(2,2))
(21)‚Åª¬π1.12.21

julia&gt; word(b)
7-element Vector{Int64}:
 -1
 -2
  1
  1
  2
  2
  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/65a2d935877e2b271770956f575a43ba9e71f517/src/Garside.jl#L1008-L1034">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PermGroups.Groups.elements-Tuple{LocallyGarsideMonoid, Any}" href="#PermGroups.Groups.elements-Tuple{LocallyGarsideMonoid, Any}"><code>PermGroups.Groups.elements</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>elements(M::LocallyGarsideMonoid,l)</code></p><p><code>M</code>  should have  an additive  length function  (that is,  a product of <code>l</code> atoms  is not equal to any product of less than <code>l</code> atoms). <code>elements(M,l)</code> returns the list of elements of length <code>l</code> in <code>M</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; M=BraidMonoid(coxgroup(:A,2))
BraidMonoid(A‚ÇÇ)

julia&gt; elements(M,4)
12-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 12.21
 21.12
 1.1.1.1
 2.2.2.2
 1.1.12
 1.12.2
 12.2.2
 2.2.21
 21.1.1
 2.21.1
 Œî.1
 Œî.2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/65a2d935877e2b271770956f575a43ba9e71f517/src/Garside.jl#L582-L608">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.image" href="#Gapjm.Garside.image"><code>Gapjm.Garside.image</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p><code>image(b::GarsideElt)</code></p><p>This  function is defined only if <code>b</code>  is an element of an interval monoid, for instance a braid. It returns the image of <code>b</code> in the group of which the monoid  is an interval  monoid. For instance  it gives the  projection of a braid in an Artin monoid back to the Coxeter group.</p><pre><code class="language-julia-repl hljs">julia&gt; W=CoxSym(4)
ùîñ ‚ÇÑ

julia&gt; b=BraidMonoid(W)(2,1,2,1,1)
121.1.1

julia&gt; p=image(b)
(1,3)

julia&gt; word(W,p)
3-element Vector{Int64}:
 1
 2
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/65a2d935877e2b271770956f575a43ba9e71f517/src/Garside.jl#L1345-L1369">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.conjugating_elt" href="#Gapjm.Garside.conjugating_elt"><code>Gapjm.Garside.conjugating_elt</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>conjugating_elt(b,b1[,F];ss=:sc)</p><p><code>b</code>  and <code>b1</code> should  be elements of  the same Garside  group. The function returns  <code>a</code> such that <code>b^a=b1</code> if such exists, and <code>nothing</code> otherwise. If an  argument <code>ss</code>  is given,  the computation  is done in the corresponding category  ‚Äì- see <a href="garside.html#Gapjm.Garside.conjcat"><code>conjcat</code></a>. If an  argument <code>F</code> is given it should be  an automorphism of the braid monoid, like the Frobenius of a reflection coset   attached  to  <code>b.M.W</code>;   the  computation  is   then  done  in  the corresponding <code>F</code>-conjugacy category.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:D,4)
D‚ÇÑ

julia&gt; B=BraidMonoid(W)
BraidMonoid(D‚ÇÑ)

julia&gt; b=B(2,3,1,2,4,3);b1=B(1,4,3,2,2,2)
1432.2.2

julia&gt; conjugating_elt(b,b1)
(134312.23)‚Åª¬π

julia&gt; c=conjugating_elt(b,b1;ss=:cyc)
232.2

julia&gt; b^c
1432.2.2

julia&gt; WF=spets(W,Perm(1,2,4))
¬≥D‚ÇÑ

julia&gt; F=Frobenius(WF);

julia&gt; c=B(3,4,3,1,2,3)
343123

julia&gt; conjugating_elt(b,c,F)
124312

julia&gt; ^(b,B(1,2,4,3,1,2),F)
343123</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/65a2d935877e2b271770956f575a43ba9e71f517/src/Garside.jl#L1774-L1818">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.centralizer_gens" href="#Gapjm.Garside.centralizer_gens"><code>Gapjm.Garside.centralizer_gens</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p><code>centralizer_gens(b[,F];ss=:sc)</code></p><p>a  list of generators of the centralizer of <code>b</code>. The computation is done by computing  the  endomorphisms  of  the  object  <code>b</code>  in the category of its sliding  circuits. If an argument <code>ss</code> is given, the computation is done in the corresponding category ‚Äì- see <code>conjcat</code>.</p><p>If  an argument  <code>F</code> is  given it  should be  an automorphism  of the braid monoid,  like the Frobenius of a reflection coset attached to <code>b.M.W</code>; then the <code>F</code>-centralizer is computed.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:D,4)
D‚ÇÑ

julia&gt; B=BraidMonoid(W)
BraidMonoid(D‚ÇÑ)

julia&gt; w=B(4,4,4)
4.4.4

julia&gt; cc=centralizer_gens(w)
8-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 1
 (31432)‚Åª¬π231432
 (1)‚Åª¬π34.431
 (2)‚Åª¬π34.432
 (32431)‚Åª¬π132431
 4
 34.43
 2

julia&gt; shrink(cc)
5-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 4            
 2            
 1            
 34.43        
 (3243)‚Åª¬π13243

julia&gt; centralizer_gens(w;ss=:cyc)
Set{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}} with 1 element:
  4

julia&gt; F=Frobenius(spets(W,Perm(1,2,4)));

julia&gt; centralizer_gens(w,F)
2-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 124      
 312343123</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/65a2d935877e2b271770956f575a43ba9e71f517/src/Garside.jl#L1849-L1901">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.conjcat" href="#Gapjm.Garside.conjcat"><code>Gapjm.Garside.conjcat</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p><code>conjcat(b[,F];ss=:sc)</code></p><p>returns  the conjugacy category  of the summit  set of <code>b</code>  of the required type.  By default,  computes the  category of  sliding circuits  of <code>b</code>. If <code>ss==:ss</code>,  computes  the  super  summit  set.  If <code>ss==:cyc</code>, computes the cyclic  conjugacy category. Finally, if <code>ss==:inf</code> computes the category of all conjugate elements with same <code>Inf</code> as <code>b</code>.</p><p>If  an argument  <code>F</code> is  given it  should be  the Frobenius of a Reflection coset attached to <code>b.M.W</code>. Then the <code>F</code>-conjugacy category is returned.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,4)
A‚ÇÑ

julia&gt; w=BraidMonoid(W)(4,3,3,2,1)
43.321

julia&gt; C=conjcat(w)
category with 2 objects and 4 generating maps

julia&gt; C.obj
2-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 32143
 21324</code></pre><pre><code class="language-julia-rep1 hljs">julia&gt; xprint(C;graph=true)
category with 2 objects and 4 generating maps
     32143      21343      21324      13214 
32143‚îÄ‚îÄ‚îÄ‚îÄ‚Üí 32143‚îÄ‚îÄ‚îÄ‚îÄ‚Üí 21324‚îÄ‚îÄ‚îÄ‚îÄ‚Üí 21324‚îÄ‚îÄ‚îÄ‚îÄ‚Üí 32143</code></pre><pre><code class="language-julia-repl hljs">julia&gt; conjcat(w;ss=:ss).obj
4-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 32143
 13243
 21432
 21324</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/65a2d935877e2b271770956f575a43ba9e71f517/src/Garside.jl#L1725-L1768">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.endomorphisms" href="#Gapjm.Garside.endomorphisms"><code>Gapjm.Garside.endomorphisms</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p><code>endomorphisms(C::Category,o)</code> returns generators of the endomorphisms of <code>C.obj[o]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/65a2d935877e2b271770956f575a43ba9e71f517/src/Garside.jl#L1570-L1573">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Presentations.Presentation-Tuple{GarsideMonoid}" href="#Gapjm.Presentations.Presentation-Tuple{GarsideMonoid}"><code>Gapjm.Presentations.Presentation</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>Presentation(M::GarsideMonoid)</code></p><p>returns   a  presentation  of  the  Garside   group  defined  by  <code>M</code>  (the presentation is as given in theorem 4.1 of <a href="biblio.htm#DePa99">Dehornoy-Paris 1999</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; M=DualBraidMonoid(coxgroup(:A,3))
DualBraidMonoid(A‚ÇÉ,c=[1, 3, 2])

julia&gt; p=Presentation(M)
Presentation: 6 generators, 15 relators, total length 62</code></pre><pre><code class="language-julia-rep1 hljs">julia&gt; simplify(p)
&lt;&lt; presentation with 3 generators, 4 relators of total length 26&gt;&gt;
&lt;&lt; presentation with 3 generators, 3 relators of total length 16&gt;&gt;

julia&gt; display_balanced(p)
1: ab=ba
2: cac=aca
3: cbc=bcb</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/65a2d935877e2b271770956f575a43ba9e71f517/src/Garside.jl#L1913-L1937">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.shrink" href="#Gapjm.Garside.shrink"><code>Gapjm.Garside.shrink</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>shrink(l::Vector{&lt;:GarsideElt})</p><p>The  list <code>l</code> is a  list of  elements of  the same Garside group <code>G</code>. This function  tries to find  another set of  generators of the  subgroup of <code>G</code> generated by the elements of <code>l</code>, of smaller total length (the length being counted  as returned by the function  <code>word</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; B=BraidMonoid(CoxSym(3))
BraidMonoid(ùîñ ‚ÇÉ)

julia&gt; b=[B(1)^3,B(2)^3,B(-2,-1,-1,2,2,2,2,1,1,2),B(1,1,1,2)]
4-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, CoxSym{Int16}}}}:
 1.1.1              
 2.2.2              
 (1.12)‚Åª¬π2.2.2.21.12
 1.1.12             

julia&gt; shrink(b)
2-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, CoxSym{Int16}}}}:
 2  
 1  </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/65a2d935877e2b271770956f575a43ba9e71f517/src/Garside.jl#L2065-L2089">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="kl.html">¬´ Kazhdan-Lusztig polynomials and bases</a><a class="docs-footer-nextpage" href="semisimple.html">Reductive groups, semisimple elements ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Wednesday 19 October 2022 18:46">Wednesday 19 October 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
