<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Kazhdan-Lusztig polynomials and bases · Chevie.jl documentation</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Chevie.jl documentation</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Chevie</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Infrastructure</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="symbols.html">Symbols</a></li><li><a class="tocitem" href="nf.html">Number fields</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Reflection groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="permroot.html">Finite reflection groups</a></li><li><a class="tocitem" href="coxgroups.html">Coxeter groups</a></li><li><a class="tocitem" href="weyl.html">Finite Coxeter groups, Weyl groups, crystallographic root systems</a></li><li><a class="tocitem" href="chars.html">Classes/characters of reflection groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Hecke algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="hecke.html">Hecke algebras</a></li><li class="is-active"><a class="tocitem" href="kl.html">Kazhdan-Lusztig polynomials and bases</a></li><li><a class="tocitem" href="algebras.html">Algebras</a></li></ul></li><li><a class="tocitem" href="garside.html">Garside monoids and groups, braids.</a></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Reductive groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="semisimple.html">Reductive groups, semisimple elements</a></li><li><a class="tocitem" href="cosets.html">Reflection cosets and Spets</a></li><li><a class="tocitem" href="sscoset.html">Non-connected reductive groups</a></li><li><a class="tocitem" href="uch.html">Unipotent characters</a></li><li><a class="tocitem" href="ct.html">Classtypes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Eigenspaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="eigen.html">Eigenspaces</a></li><li><a class="tocitem" href="dseries.html">d-Harish-Chandra series</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Unipotent elements</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="ucl.html">Unipotent classes of reductive groups</a></li><li><a class="tocitem" href="urad.html">Unipotent Elements</a></li></ul></li><li><a class="tocitem" href="gendec.html">Decomposition Matrices</a></li><li><a class="tocitem" href="dict.html">Dictionary from GAP3/Chevie</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Hecke algebras</a></li><li class="is-active"><a href="kl.html">Kazhdan-Lusztig polynomials and bases</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="kl.html">Kazhdan-Lusztig polynomials and bases</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jmichel7/Chevie.jl/blob/master/docs/src/kl.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Kazhdan-Lusztig-polynomials-and-bases"><a class="docs-heading-anchor" href="#Kazhdan-Lusztig-polynomials-and-bases">Kazhdan-Lusztig polynomials and bases</a><a id="Kazhdan-Lusztig-polynomials-and-bases-1"></a><a class="docs-heading-anchor-permalink" href="#Kazhdan-Lusztig-polynomials-and-bases" title="Permalink"></a></h1><ul><li><a href="kl.html#Chevie.KL"><code>Chevie.KL</code></a></li><li><a href="kl.html#Chevie.KL.AsymptoticAlgebra"><code>Chevie.KL.AsymptoticAlgebra</code></a></li><li><a href="kl.html#Chevie.KL.LeftCell"><code>Chevie.KL.LeftCell</code></a></li><li><a href="kl.html#Chevie.Chars.WGraphToRepresentation"><code>Chevie.Chars.WGraphToRepresentation</code></a></li><li><a href="kl.html#Chevie.Chars.representation-Tuple{LeftCell, Any}"><code>Chevie.Chars.representation</code></a></li><li><a href="kl.html#Chevie.HeckeAlgebras.Tbasis-Tuple{Chevie.KL.HeckeCpElt}"><code>Chevie.HeckeAlgebras.Tbasis</code></a></li><li><a href="kl.html#Chevie.KL.Cbasis"><code>Chevie.KL.Cbasis</code></a></li><li><a href="kl.html#Chevie.KL.Cpbasis"><code>Chevie.KL.Cpbasis</code></a></li><li><a href="kl.html#Chevie.KL.KLPol"><code>Chevie.KL.KLPol</code></a></li><li><a href="kl.html#Chevie.KL.LusztigAw"><code>Chevie.KL.LusztigAw</code></a></li><li><a href="kl.html#Chevie.KL.Lusztigaw"><code>Chevie.KL.Lusztigaw</code></a></li><li><a href="kl.html#Chevie.KL.Wgraph"><code>Chevie.KL.Wgraph</code></a></li><li><a href="kl.html#Chevie.KL.character"><code>Chevie.KL.character</code></a></li><li><a href="kl.html#Chevie.KL.critical_pair"><code>Chevie.KL.critical_pair</code></a></li><li><a href="kl.html#Chevie.KL.left_cells"><code>Chevie.KL.left_cells</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Chevie.KL" href="#Chevie.KL"><code>Chevie.KL</code></a> — <span class="docstring-category">Module</span></header><section><div><p>This  module defines Kazhdan-Lusztig polynomials and bases, and computes W-graphs and asymptotic algebras.</p><p>Let  <code>ℋ</code> be  the Iwahori-Hecke algebra  of a Coxeter  system <code>(W,S)</code>, with quadratic  relations <code>(Tₛ-uₛ₀)(Tₛ-uₛ₁)=0</code>  for <code>s∈  S</code>. If  <code>-uₛ₀uₛ₁</code> has a square  root  <code>wₛ</code>,  we  can  scale  the  basis  <code>Tₛ</code>  to  get  a new basis <code>tₛ=-Tₛ/wₛ</code>    with   quadratic    relations   <code>(tₛ-vₛ)(tₛ+vₛ⁻¹)=0</code>   where <code>vₛ=wₛ/uₛ₁</code>.   The  most  general  case   when  Kazhdan-Lusztig  bases  and polynomials  can be defined is when the parameters <code>vₛ</code> belong to a totally ordered abelian group <code>Γ</code> for multiplication, see <a href="biblio.htm#Lus83">Lusztig1983</a>.  We set  <code>Γ⁺= {γ∈  Γ∣γ&gt;0}</code> and <code>Γ⁻={γ⁻¹∣γ∈ Γ⁺}={γ∈ Γ∣γ&lt;0}</code>.</p><p>Thus  we assume <code>ℋ</code> defined over the ring <code>ℤ[Γ]</code>, the group algebra of <code>Γ</code> over  <code>ℤ</code>, and the quadratic  relations of <code>ℋ</code>  associate to each <code>s∈ S</code> a <code>vₛ∈  Γ⁺</code> such that  <code>(tₛ-vₛ)(tₛ+vₛ⁻¹)=0</code>. We also  set <code>qₛ=vₛ²</code> and define the  basis <code>Tₛ=vₛtₛ</code> with quadratic relations <code>(Tₛ-qₛ)(Tₛ+1)=0</code>; for <code>w∈ W</code> with reduced expression <code>w=s₁…sₙ</code> we define <span>$q_w∈ Γ⁺$</span> by <span>$q_w^½=v_{s₁}…v_{sₙ}$</span> and let <span>$q_w=(q_w^½)²$</span>; we have <span>$T_w=q_w^½t_w$</span>.</p><p>We  define the bar involution on <code>ℋ</code>  by linearity: on <code>ℤ[Γ]</code> we define it by  <span>$\overline{∑_{γ∈ Γ}a_γγ}= ∑_{γ∈ Γ} a_γ γ⁻¹$</span> and we extend it to <code>ℋ</code> by  <span>$\overline T_s=T_s^{-1}$</span>  (equivalently <code>\overline t_s=t_s^{-1}</code><code>). Then the Kazhdan-Lusztig basis</code><code>C^′_w</code><code>is defined as the only basis of</code>ℋ <code>stable by  the bar  involution and  congruent to</code><code>t_w</code><code>modulo</code><code>∑_{w∈ W}Γ⁻.t_w</code>`.</p><p>The  basis  <span>$C^′_w$</span>  can  be  computed  as  follows.  We  define  elements <span>$R_{x,y}$</span>  of <code>ℤ[Γ]</code> by  <span>$T_y⁻¹=∑_x \overline{R_{x,y⁻¹}} q_x⁻¹T_x$</span>. We then  define inductively  the Kazhdan-Lusztig  polynomials (in this general context  we should say the Kazhdan-Lusztig elements of <code>ℤ[Γ]</code>, which belong to the subalgebra of <code>ℤ[Γ]</code> generated by the <code>qₛ</code>) by <span>$P_{x,w}=τ_{≤(q_w/q_x)^½}  (∑_{x&lt;y≤w}R_{x,y}P_{y,w})$</span>  where  <code>τ</code>  is the truncation:  <span>$τ_≤\nu ∑_{γ∈  Γ} a_γγ=  ∑_{γ≤\nu}a_γγ$</span>; the  induction is thus on decreasing <code>x</code> for the Bruhat order and starts at <span>$P_{w,w}=1$</span>. We have then <span>$C^′_w=∑_y q_w^{-1/2} P_{y,w}T_y$</span>.</p><p>The  Chevie code  for the  Kazhdan-Lusztig bases  <code>C</code>, <code>D</code> and their primed versions,  was originally  written by  Andrew Mathas  around 1994, who also contributed  to  the  design  of  the programs dealing with Kazhdan-Lusztig bases. He also implemented some other bases, such as the Murphy basis which we  also implement. The code for the case of unequal parameters was written around  1999 by F.Digne  and J.Michel. The  other Kazhdan-Lusztig bases are computed in terms of the <code>C′</code> basis.</p><p>When  the <code>ℤ[Γ]</code> is a  Laurent polynomial ring the  bar operation is taking the  inverse of  the variables,  and truncation  is keeping terms of degree smaller or equal to that of <code>ν</code>. It is possible to use arbitrary groups <code>Γ</code> as   long   as   methods   <code>bar</code>:<span>$∑_{γ∈   Γ}   a_γγ↦  ∑_{γ∈  Γ}  a_γγ⁻¹$</span>, <code>positive_part</code>  : <span>$∑_{γ∈  Γ} a_γγ↦  ∑_{γ≥ 1}  a_γγ$</span> and <code>negative_part</code>: <span>$∑_{γ∈  Γ}  a_γγ  ↦  ∑_{γ≤  1}  a_γγ$</span>  have been defined on <code>ℤ[Γ]</code>. These operations   will   be   used   internally   by  the  programs  to  compute Kazhdan-Lusztig bases.</p><p>We provide also functionality to study the Kazhdan-Lusztig left cells (for the equal-parameter Hecke algebra).</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:H,3)
H₃

julia&gt; c=left_cells(W)
22-element Vector{LeftCell{FiniteCoxeterGroup{Perm{Int16},Cyc{Int64}}}}:
 LeftCell&lt;H₃: duflo= character=φ₁‚₀&gt;
 LeftCell&lt;H₃: duflo=123 character=φ₁‚₁₅&gt;
 LeftCell&lt;H₃: duflo=(15) character=φ₅‚₅&gt;
 LeftCell&lt;H₃: duflo=(10) character=φ₅‚₅&gt;
 LeftCell&lt;H₃: duflo=(14) character=φ₅‚₅&gt;
 LeftCell&lt;H₃: duflo=7 character=φ₅‚₅&gt;
 LeftCell&lt;H₃: duflo=(12) character=φ₅‚₅&gt;
 LeftCell&lt;H₃: duflo=(9,12) character=φ₅‚₂&gt;
 LeftCell&lt;H₃: duflo=(5,11) character=φ₅‚₂&gt;
 LeftCell&lt;H₃: duflo=13 character=φ₅‚₂&gt;
 ⋮
 LeftCell&lt;H₃: duflo=(8,13) character=φ₃‚₆+φ₃‚₈&gt;
 LeftCell&lt;H₃: duflo=(1,15) character=φ₃‚₆+φ₃‚₈&gt;
 LeftCell&lt;H₃: duflo=3 character=φ₃‚₁+φ₃‚₃&gt;
 LeftCell&lt;H₃: duflo=2 character=φ₃‚₁+φ₃‚₃&gt;
 LeftCell&lt;H₃: duflo=1 character=φ₃‚₁+φ₃‚₃&gt;
 LeftCell&lt;H₃: duflo=6 character=φ₄‚₃+φ₄‚₄&gt;
 LeftCell&lt;H₃: duflo=(13) character=φ₄‚₃+φ₄‚₄&gt;
 LeftCell&lt;H₃: duflo=(11) character=φ₄‚₃+φ₄‚₄&gt;
 LeftCell&lt;H₃: duflo=9 character=φ₄‚₃+φ₄‚₄&gt;</code></pre><p>see  also the  functions <code>elements</code>,  <a href="kl.html#Chevie.KL.character"><code>character</code></a>, <code>representation</code> and  <a href="kl.html#Chevie.KL.Wgraph"><code>Wgraph</code></a> for left cells.  The operations <code>length</code>, <code>in</code> (which refer  to <code>elements</code>) and <code>==</code> (which  compares Duflo involutions) are also defined  for left cells. When <code>character(c)</code>  has been computed, then <code>c.a</code> also  has been bound which holds the common value of Lusztig&#39;s <code>a</code>-function for the elements of <code>c</code> and the irreducible constituents of <code>character(c)</code>.</p><p>finally, benchmarks</p><pre><code class="language-benchmark hljs">julia&gt; function test_kl(W)
         q=Pol(); H=hecke(W,q^2,rootpara=q)
         C=Cpbasis(H); T=Tbasis(H)
         [T(C(w)) for w in elements(W)]
       end
test_kl (generic function with 1 method)

julia&gt; @btime test_kl(coxgroup(:F,4));  #julia 1.8
1.332 s (13934392 allocations: 2.27 GiB)</code></pre><p>in GAP3 the following function takes 11s for W=F4</p><pre><code class="nohighlight hljs">test_kl:=function(W)local q,H,T,C;
  q:=X(Rationals);H:=Hecke(W,q^2,q);
  T:=Basis(H,&quot;T&quot;);C:=Basis(H,&quot;C&#39;&quot;);
  List(Elements(W),e-&gt;T(C(e)));
end;</code></pre><p>Another benchmark:</p><pre><code class="language-benchmark hljs">function test_kl2(W)
  el=elements(W)
  [KLPol(W,x,y) for x in el, y in el]
end

test_kl2 (generic function with 1 method)

julia&gt;@btime test_kl2(coxgroup(:F,4)); # julia 1.9
4.307 s (42294917 allocations: 5.24 GiB)</code></pre><p>in GAP3 the following function takes 42s for F4</p><pre><code class="nohighlight hljs">test_kl2:=function(W)local el;
  el:=Elements(W);
  List(el,x-&gt;List(el,y-&gt;KazhdanLusztigPolynomial(W,x,y)));
end;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/4249294d12fd53e00306818ee02f28461246acf4/src/KL.jl#L21-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.KL.KLPol" href="#Chevie.KL.KLPol"><code>Chevie.KL.KLPol</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>KLPol(W,y,w)</code> returns the Kazhdan-Lusztig polynomial <code>P_{y,w}</code> of <code>W</code>.</p><p>To  compute Kazhdan-Lusztig polynomials in  the one-parameter case it still seems   best  to   use  the   recursion  formula   in  the  original  paper <a href="biblio.htm#KL79">KL79</a>.  We first perform  a series of  checks on the pair <code>(y,w)</code>  to see if  the computation of  the corresponding polynomial can be reduced  to  a  similar  calculation  for  elements  of  smaller length. In particular, we reduce to the case of critical pairs (see <a href="kl.html#Chevie.KL.critical_pair"><code>KL.critical_pair</code></a>),  and whenever the  polynomial corresponding to such  a pair is computed, the value is  stored in a <code>Dict</code> <code>W.klpol</code> in the underlying Coxeter group.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:B,3)
B₃

julia&gt; map(i-&gt;map(x-&gt;KLPol(W,one(W),x),elements(W,i)),1:nref(W))
9-element Vector{Vector{Pol{Int64}}}:
 [1, 1, 1]
 [1, 1, 1, 1, 1]
 [1, 1, 1, 1, 1, 1, 1]
 [1, 1, 1, 1, 1, x+1, 1, 1]
 [x+1, 1, x+1, x+1, 1, 1, x+1, 1]
 [x²+1, 1, x+1, x+1, x+1, 1, 1]
 [1, 1, x²+x+1, x+1, x+1]
 [1, x+1, x²+1]
 [1]</code></pre><p>Our code is based on Meinolf Geck&#39;s code for GAP3/Chevie.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/4249294d12fd53e00306818ee02f28461246acf4/src/KL.jl#L229-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.KL.critical_pair" href="#Chevie.KL.critical_pair"><code>Chevie.KL.critical_pair</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>critical_pair(W, y, w)</code> returns the critical pair z≤w associated to y≤w (see <a href="biblio.htm#Alv87">Alvis1987</a>).</p><p>Let  <code>ℒ</code> (resp.  <code>ℛ</code>)  be the  left (resp.  right) descent  set. A pair of elements y≤w of W is called critical if <code>ℒ(y)⊃ ℒ(w)</code> and <code>ℛ (y)⊃ ℛ (w)</code>. If y≤w is not critical, y can be multiplied from the left (resp. the right) by an  element of  <code>ℒ(w)</code> (resp.  <code>ℛ (w)</code>)  which is  not in <code>ℒ (y)</code> (resp. <code>ℛ (y)</code>) until we get a critical pair z≤w. The function returns z. If y≤w then y≤z≤w.</p><p>The significance of this construction is that <code>KLPol(W,y,w)==KLPol(W,z,w)</code></p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:F,4)
F₄

julia&gt; w=longest(W)*gens(W)[1];length(W,w)
23

julia&gt; y=W(1:4...);length(W,y)
4

julia&gt; cr=KL.critical_pair(W,y,w);length(W,cr)
16

julia&gt; Pol(:x);KLPol(W,y,w)
Pol{Int64}: x³+1

julia&gt; KLPol(W,cr,w)
Pol{Int64}: x³+1</code></pre><p>julia-repl</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/4249294d12fd53e00306818ee02f28461246acf4/src/KL.jl#L158-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.HeckeAlgebras.Tbasis-Tuple{Chevie.KL.HeckeCpElt}" href="#Chevie.HeckeAlgebras.Tbasis-Tuple{Chevie.KL.HeckeCpElt}"><code>Chevie.HeckeAlgebras.Tbasis</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Tbasis(h::HeckeCpElt)</code> </p><p>converts the element <code>h</code> of the <code>C&#39;</code> basis to the <code>T</code> basis.</p><p>For one-parameter Hecke algebras, we use the formulae: <span>$C&#39;_w=Σ_{y≤w}P_{y,w}(q)q^{-l(w)/2}T_y$</span> and if <span>$sw&lt;w$</span> then</p><p><span>$C&#39;ₛ C&#39;_{sw}=C&#39;_w+Σ_{y&lt;sw}μ(y,sw)C&#39;_y=Σ_{v≤w}μᵥ Tᵥ$</span></p><p>where</p><p><span>$μᵥ=P_{v,w}(q)q^{-l(w)/2}+Σ_{v≤y≤sw}μ(y,sw)P_{v,y}(q)q^{-l(y)/2}$</span></p><p>It  follows that if <span>$deg(μᵥ)&gt;=-l(v)$</span>  then <span>$deg(μᵥ)=-l(v)$</span> with leading coefficient  <span>$μ(v,sw)$</span> (this happens exactly for <span>$y=v$</span> in the sum which occurs in the formula for <span>$μᵥ$</span>).</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:B,3)
B₃

julia&gt; @Pol v;H=hecke(W,v^2,rootpara=v)
hecke(B₃,v²,rootpara=v)

julia&gt; C=Cpbasis(H); Tbasis(C(1,2))
v⁻²T.+v⁻²T₂+v⁻²T₁+v⁻²T₁₂</code></pre><p>For general Hecke algebras, we follow formula 2.2 in  <a href="biblio.htm#Lus83">Lusztig1983</a></p><p><span>$\overline{P_{x,w}}-P_{x,w}=∑_{x&lt;y≤w} R_{x,y} P_{y,w}$</span></p><p>where  <span>$R_{x,y}=\overline{(t_{y^{-1}}^{-1}|t_x)}$</span> where <code>t</code> is the basis with  parameters  <span>$q_s,-q_s^{-1}$</span>.  It  follows  that  <span>$P_{x,w}$</span> is the negative  part of <span>$∑_{x&lt;y≤w} R_{x,y} P_{y,w}$</span>  which allows to compute it by  induction on <code>l(w)-l(x)</code>. The code is based on GAP3/Chevie code of Jean Michel and François Digne (1999).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/4249294d12fd53e00306818ee02f28461246acf4/src/KL.jl#L456-L496">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.KL.Cbasis" href="#Chevie.KL.Cbasis"><code>Chevie.KL.Cbasis</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>Cbasis(H::HeckeAlgebra)</code></p><p>returns  a function which gives the  <code>C</code>-basis of the Iwahori-Hecke algebra <code>H</code>. The algebra <code>H</code> should have the functon <code>rootpara</code> defined. This basis is  defined as follows (see e.g. <a href="biblio.htm#Lus85">(5.1)Lusztig1985</a>). Let <code>W</code>  be the underlying Coxeter group. For  <code>x,y ∈ W</code> let <span>$P_{x,y}$</span> be the corresponding  Kazhdan–Lusztig polynomial. If <span>$\{T_w ∣ w∈ W\}$</span> denotes the usual T-basis, then <span>$C_x=\sum_{y\le x}(-1)^{l(x)-l(y)}P_{y,x}(q^{-1})q_x^{1/2}q_y^{-1}  T_y$</span> for <code>x  ∈ W</code>. For example,  we have <code>Cₛ=qₛ⁻½Tₛ-qₛ½T₁</code>  for <code>s ∈  S</code>. Thus, the transformation matrix between the <code>T</code>-basis and the <code>C</code>-basis is lower unitriangular, with monomials  in <code>qₛ</code> along the diagonal.  In the one-parameter case (all <code>qₛ</code> are equal to <code>v²</code>) the multiplication rules for the <code>C</code> basis are given by:</p><p><code>Cₛ⋅Cₓ =-(v+v⁻¹)Cₓ</code>, if <code>sx&lt;x</code>, and <code>Cₛₓ+∑ₜ μ(t,x)Cₜ</code> if <code>sx&gt;x</code>.</p><p>where  the sum  is over  all <code>t</code>  such that  <code>t&lt;x</code>, <code>l(t)</code>  and <code>l(x)</code> have different parity and <code>st&lt;t</code>. The coefficient <code>μ(t,x)</code> is the coefficient of degree <code>(l(x)-l(t)-1)/2</code> in the Kazhdan–Lusztig polynomial <span>$P_{x,t}$</span>.</p><p>The  returned function can take as argument a list of integers (as a vector or  as a list of arguments), representing a Coxeter word, an element of the Coxeter group, or a Hecke element (converted then to the <code>C&#39;</code> basis).</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:B,3);H=hecke(W,Pol(:v)^2)
hecke(B₃,v²)

julia&gt; T=Tbasis(H);C=Cbasis(H);T(C(1))
-vT.+v⁻¹T₁

julia&gt; C(T(1))
v²C.+vC₁</code></pre><p>We  can  also  compute  character  values  on  elements in the <code>C</code>-basis as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; ref=reflrep(H)
3-element Vector{Matrix{Pol{Int64}}}:
 [-1 0 0; -v² v² 0; 0 0 v²]
 [v² -2 0; 0 -1 0; 0 -v² v²]
 [v² 0 0; 0 v² -1; 0 0 -1]</code></pre><pre><code class="language-julia-rep1 hljs">julia&gt; c=CharTable(H).irr[charinfo(W).extRefl[[2]],:]
1×10 Matrix{Pol{Int64}}:
 3  2v²-1  v⁸-2v⁴  -3v¹²  2v²-1  v⁴  v⁴-2v²  -v⁶  v⁴-v²  0

julia&gt; hcat(char_values.(C.(classreps(W)),Ref(c))...)
1×10 Matrix{Pol{Int64}}:
 3  -v-v⁻¹  0  0  -v-v⁻¹  2  0  0  1  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/4249294d12fd53e00306818ee02f28461246acf4/src/KL.jl#L334-L389">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.KL.Cpbasis" href="#Chevie.KL.Cpbasis"><code>Chevie.KL.Cpbasis</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>Cpbasis(H)</code></p><p>returns  a function which gives the <code>C&#39;</code>-basis of the Iwahori-Hecke algebra <code>H</code>  (see <a href="biblio.htm#Lus85">(5.1)Lusztig1985</a>).  This basis  is defined by <span>$C&#39;_x= ∑_{y≤x}P_{y,x}q_x^{-1/2} T_y$</span> for <code>x ∈ W</code>. We have <span>$C&#39;_x=(-1)^{l(x)}alt(C_x)$</span> for all <code>x ∈ W</code> (see <code>alt</code>).  The  returned function can take as argument a list of integers (as a vector or  as a list of arguments), representing a Coxeter word, an element of the Coxeter group, or a Hecke element (converted then to the <code>C&#39;</code> basis).</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:B,2);@Pol v;H=hecke(W,[v^4,v^2])
hecke(B₂,Pol{Int64}[v⁴, v²])

julia&gt; Cp=Cpbasis(H);h=Cp(1)^2
(v²+v⁻²)C′₁

julia&gt; k=Tbasis(h)
(1+v⁻⁴)T.+(1+v⁻⁴)T₁

julia&gt; Cp(k)
(v²+v⁻²)C′₁</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/4249294d12fd53e00306818ee02f28461246acf4/src/KL.jl#L303-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.KL.character" href="#Chevie.KL.character"><code>Chevie.KL.character</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>character(c)</code></p><p>Returns  a list <code>l</code>  such that the  character of <code>c.group</code>  afforded by the left cell <code>c</code> is <code>sum(CharTable(c.group).irr[l])</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; c=left_cells(coxgroup(:G,2))[3]
LeftCell&lt;G₂: duflo=2 character=φ₂‚₁+φ′₁‚₃+φ₂‚₂&gt;

julia&gt; character(c)
3-element Vector{Int64}:
 3
 5
 6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/4249294d12fd53e00306818ee02f28461246acf4/src/KL.jl#L531-L547">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Chars.representation-Tuple{LeftCell, Any}" href="#Chevie.Chars.representation-Tuple{LeftCell, Any}"><code>Chevie.Chars.representation</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>representation(c::LeftCell,H)</code></p><p>returns matrices giving the representation of the Iwahori-Hecke algebra <code>H</code> on the left cell <code>c</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:H,3)
H₃

julia&gt; c=left_cells(W)[3]
LeftCell&lt;H₃: duflo=(15) character=φ₅‚₅&gt;

julia&gt; @Mvp q;H=hecke(W,q)
hecke(H₃,q)

julia&gt; representation(c,H)
3-element Vector{Matrix{Mvp{Int64, Rational{Int64}}}}:
 [-1 0 … 0 0; 0 -1 … 0 -q½; … ; 0 0 … q 0; 0 0 … 0 q]
 [-1 -q½ … 0 0; 0 q … 0 0; … ; 0 0 … -1 0; 0 -q½ … 0 -1]
 [q 0 … 0 0; -q½ -1 … 0 0; … ; 0 0 … q 0; 0 0 … 0 -1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/4249294d12fd53e00306818ee02f28461246acf4/src/KL.jl#L651-L673">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Chars.WGraphToRepresentation" href="#Chevie.Chars.WGraphToRepresentation"><code>Chevie.Chars.WGraphToRepresentation</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>WGraphToRepresentation(coxrank::Integer,graph,v)</code></p><p>We  store some  representations of  one-parameter Iwahori-Hecke algebras as <code>W</code>-graphs.  For  a  Coxeter  system  <code>(W,S)</code>  where <code>coxrank=length(S)</code>, a <code>W</code>-graph  is defined by  a set of  vertices <code>C</code> with  a function <code>I</code> which attaches  to <code>x∈ C</code> a subset <code>I(x)⊂  S</code>, and <em>edge labels</em> which to <code>(x,y)∈ C^2</code>  attach <code>μ(x,y)∈ K</code> where <code>K</code> is  the field of definition of <code>W</code>; this defines  a  representation  of  the  Hecke  algebra with parameters <code>v</code> and <code>-v⁻¹</code> on a space with basis <span>${e_y}_{y∈ C}$</span> by:</p><p><span>$T_s(e_y)=-e_y$</span> if <code>s∈ I(y)</code> and otherwise <span>$T_s(e_y)=v^2 e_y+∑_{x∣s∈ I(x)} vμ(x,y)eₓ$</span>.</p><p>The  <code>W</code>-graphs are  stored in  a compact  format to  save space.  They are represented as a pair.</p><ul><li><p>The  first element is a list describing <code>C</code>. Its  elements are either a set <code>I(x)</code>,  or an integer <code>n</code> specifying to repeat the previous element <code>n</code> more times.</p></li><li><p>The  second element is a list which  specifies <code>μ</code>. </p></li></ul><p>We   first   describe   the   <code>μ</code>-list   for   symmetric  <code>W</code>-graphs  (when <code>μ(x,y)=μ(y,x)</code>).  There is one  element of the  <code>μ</code>-list for each non-zero value <code>m</code> taken by <code>μ</code>, which consists of a pair whose first element is <code>m</code> and  whose second element is a list of  lists; if <code>l</code> is one of these lists each  pair <code>[l[1],l[i]]</code>  represents an  edge (<code>x=l[1]</code>,<code>y=l[i]</code>) such that <code>μ(x,y)=μ(y,x)=m</code>.  For non-symmetric <code>W</code>-graphs, the first element of each pair  in the <code>μ</code>-list  is a pair  <code>[m1,m2]</code> and each  edge <code>[x,y]</code> obtained from  the lists in the second element  has to be interpreted as <code>μ(x,y)=m1</code> and <code>μ(y,x)=m2</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:H,3)
H₃

julia&gt; g=Wgraph(W,3)
2-element Vector{Vector{Vector{Any}}}:
 [[2], [1, 2], [1, 3], [1, 3], [2, 3]]
 [[-1, [[1, 3], [2, 4], [3, 5], [4, 5]]]]

julia&gt; toM.(WGraphToRepresentation(3,g,Pol(:x)))
3-element Vector{Matrix{Pol{Int64}}}:
 [x² 0 … 0 0; 0 -1 … 0 0; … ; 0 0 … -1 -x; 0 0 … 0 x²]
 [-1 0 … 0 0; 0 -1 … -x 0; … ; 0 0 … x² 0; 0 0 … -x -1]
 [x² 0 … 0 0; 0 x² … 0 0; … ; 0 -x … -1 0; 0 0 … 0 -1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/4249294d12fd53e00306818ee02f28461246acf4/src/Chars.jl#L1243-L1290">source</a></section><section><div><p><code>WGraphToRepresentation(H::HeckeAlgebra,gr::Vector)</code></p><p><code>H</code>  should be  a one-parameter  Hecke algebra  for a  finite Coxeter group where  <code>rootpara</code>  is  defined.  The  function  returns the matrices of the representation  of <code>H</code> defined by the W-graph <code>gr</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:H,3)
H₃

julia&gt; H=hecke(W,Pol(:q)^2)
hecke(H₃,q²)

julia&gt; g=Wgraph(W,3)
2-element Vector{Vector{Vector{Any}}}:
 [[2], [1, 2], [1, 3], [1, 3], [2, 3]]
 [[-1, [[1, 3], [2, 4], [3, 5], [4, 5]]]]

julia&gt; WGraphToRepresentation(H,g)
3-element Vector{Matrix{Pol{Int64}}}:
 [q² 0 … 0 0; 0 -1 … 0 0; … ; 0 0 … -1 q; 0 0 … 0 q²]
 [-1 0 … 0 0; 0 -1 … q 0; … ; 0 0 … q² 0; 0 0 … q -1]
 [q² 0 … 0 0; 0 q² … 0 0; … ; 0 q … -1 0; 0 0 … 0 -1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/4249294d12fd53e00306818ee02f28461246acf4/src/HeckeAlgebras.jl#L640-L665">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.KL.Wgraph" href="#Chevie.KL.Wgraph"><code>Chevie.KL.Wgraph</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>Wgraph(c::LeftCell)</code></p><p>return the W-graph for a left cell for the one-parameter Hecke algebra of a finite Coxeter group. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/4249294d12fd53e00306818ee02f28461246acf4/src/KL.jl#L911-L916">source</a></section><section><div><p><code>Wgraph(W::CoxeterGroup,i)</code></p><p>return the W-graph for the <code>i</code>-th irreducible representation of <code>W</code> (or of the 1-parameter Hecke algebra of <code>W</code>).</p><p>Only implemented for irreducible groups of type <code>E</code>, <code>F</code> or <code>H</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/4249294d12fd53e00306818ee02f28461246acf4/src/KL.jl#L946-L953">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.KL.left_cells" href="#Chevie.KL.left_cells"><code>Chevie.KL.left_cells</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>left_cells(W[,i])</code> left cells of <code>W</code> [in <code>i</code>-th 2-sided cell] for the 1-parameter Hecke algebra <code>hecke(W,q)</code></p><p>The  program uses precomputed  data(see <a href="biblio.htm#GH14">Geck-Halls 2014</a>) for  exceptional types and for type <code>:A</code>,  so is quite fast for these types (it  takes 13 seconds to compute the  101796 left cells for type <code>E₈</code>). For other  types, left cells are computed from first principles, thus computing many  Kazhdan-Lusztig polynomials. It takes 30  seconds to compute the left cells of <code>D₆</code>, for example.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; left_cells(W)
4-element Vector{LeftCell{FiniteCoxeterGroup{Perm{Int16},Int64}}}:
 LeftCell&lt;G₂: duflo= character=φ₁‚₀&gt;
 LeftCell&lt;G₂: duflo=12 character=φ₁‚₆&gt;
 LeftCell&lt;G₂: duflo=2 character=φ₂‚₁+φ′₁‚₃+φ₂‚₂&gt;
 LeftCell&lt;G₂: duflo=1 character=φ₂‚₁+φ″₁‚₃+φ₂‚₂&gt;</code></pre><p>Printing such a record displays the character afforded by the left cell and its  Duflo involution; the Duflo involution <code>r</code>  is printed as a subset <code>I</code> of   <code>1:nref(W)</code>   such   that  <code>r=longest(reflection_subgroup(W,I))</code>,  see <code>describe_involution</code>.</p><p>If  a second argument <code>i</code> is given, the program returns only the left cells which  are in the <code>i</code>-th two-sided cell,  that is whose character is in the <code>i</code>-th family of <code>W</code> (see <a href="uch.html#Chevie.Families"><code>Families</code></a>).</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2);
julia&gt; left_cells(W,1)
2-element Vector{LeftCell{FiniteCoxeterGroup{Perm{Int16},Int64}}}:
 LeftCell&lt;G₂: duflo=2 character=φ₂‚₁+φ′₁‚₃+φ₂‚₂&gt;
 LeftCell&lt;G₂: duflo=1 character=φ₂‚₁+φ″₁‚₃+φ₂‚₂&gt;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/4249294d12fd53e00306818ee02f28461246acf4/src/KL.jl#L794-L833">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.KL.LeftCell" href="#Chevie.KL.LeftCell"><code>Chevie.KL.LeftCell</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>LeftCell(W,w)</code></p><p>returns  a  record  describing  the  left  cell  of  <code>W</code>  for  <code>hecke(W,q)</code> containing element <code>w</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:E,8)
E₈

julia&gt; LeftCell(W,W((1:8)...))
LeftCell&lt;E₈: duflo=(42,43) character=φ₃₅‚₂&gt;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/4249294d12fd53e00306818ee02f28461246acf4/src/KL.jl#L885-L898">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.KL.Lusztigaw" href="#Chevie.KL.Lusztigaw"><code>Chevie.KL.Lusztigaw</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>Lusztigaw(W,w)</code></p><p>For  <code>w</code> an element  of the Coxeter  groups <code>W</code>, this  function returns the coefficients  on the irreducible characters of the virtual Character <code>ca_w</code> defined  in <a href="biblio.htm#Lus85">5.10.2 Lusztig1985</a>.  This character has the property that the corresponding almost character is integral and positive.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; l=Lusztigaw(W,W(1))
6-element Vector{Int64}:
 0
 0
 1
 0
 1
 1

julia&gt; sum(l.*map(i-&gt;almostChar(W,i),eachindex(l)))
[G₂]:&lt;φ′₁‚₃&gt;+&lt;φ₂‚₁&gt;+&lt;φ₂‚₂&gt;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/4249294d12fd53e00306818ee02f28461246acf4/src/KL.jl#L962-L986">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.KL.LusztigAw" href="#Chevie.KL.LusztigAw"><code>Chevie.KL.LusztigAw</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>LusztigAw( &lt;W&gt;, &lt;w&gt;)</code></p><p>For  &lt;w&gt; an element  of the Coxeter  groups &lt;W&gt;, this  function returns the coefficients  on the irreducible  characters of the  virtual Character cA_w defined  in <a href="biblio.htm#Lus85">5.11.6 Lusztig1985</a>.  This character has the property that the corresponding almost character is integral and positive.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; l=LusztigAw(W,W(1))
6-element Vector{Int64}:
 0
 0
 0
 1
 1
 1

julia&gt; sum(l.*map(i-&gt;almostChar(W,i),eachindex(l)))
[G₂]:&lt;φ″₁‚₃&gt;+&lt;φ₂‚₁&gt;+&lt;φ₂‚₂&gt;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/4249294d12fd53e00306818ee02f28461246acf4/src/KL.jl#L993-L1017">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.KL.AsymptoticAlgebra" href="#Chevie.KL.AsymptoticAlgebra"><code>Chevie.KL.AsymptoticAlgebra</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>AsymptoticAlgebra(W,i)</code></p><p>The  asymptotic algebra <code>A</code> associated to  the algebra <code>H=Hecke(W,q)</code> is an algebra   with   basis   <span>$\{tₓ\}_{x∈   W}$</span>   and   structure  constants <span>$t_xt_y=\sum_z  γ_{x,y,z}  t_z$</span>  given  by:  let  <span>$h_{x,y,z}$</span>  be  the coefficient  of  <span>$C_x  C_y$</span>  on  <span>$C_z$</span>. Then <span>$h_{x,y,z}=γ_{x,y,z^{-1}} q^{a(z)/2}+$</span>lower terms, where <span>$q^{a(z)/2}$</span> is the maximum over <code>x,y</code> of the degree of <span>$h_{x,y,z}$</span>.</p><p>The  algebra <code>A</code>  is the  direct product  of the subalgebras <span>$A_{\mathcal C}$</span>  generated  by  the  elements  <span>$\{t_x\}_{x∈{\mathcal  C}}$</span>, where <span>$\mathcal C$</span> runs over the two-sided cells of <code>W</code>. If <span>$\mathcal C$</span> is the  <code>i</code>-th  two-sided  cell  of  <code>W</code>, the command <code>AsymptoticAlgebra(W,i)</code> returns  the algebra <span>$A_{\mathcal C}$</span>. Note  that the function <code>a(z)</code> is constant  over  a  two-sided  cell,  equal  to  the  common value of the <code>a</code>-function   attached  to  the  characters   of  the  two-sided  cell  (see <code>Character</code> for left cells).</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; A=AsymptoticAlgebra(W,1)
AsymptoticAlgebra(G₂,1) dim.10

julia&gt; b=basis(A)
10-element Vector{AlgebraElt{AsymptoticAlgebra, Int64}}:
 t₂
 t₁₂
 t₂₁₂
 t₁₂₁₂
 t₂₁₂₁₂
 t₁
 t₂₁
 t₁₂₁
 t₂₁₂₁
 t₁₂₁₂₁

julia&gt; b*permutedims(b)
10×10 Matrix{AlgebraElt{AsymptoticAlgebra, Int64}}:
 t₂      0            t₂₁₂            …  0               t₂₁₂₁        0
 t₁₂     0            t₁₂+t₁₂₁₂          0               t₁₂₁+t₁₂₁₂₁  0
 t₂₁₂    0            t₂+t₂₁₂+t₂₁₂₁₂     0               t₂₁+t₂₁₂₁    0
 t₁₂₁₂   0            t₁₂+t₁₂₁₂          0               t₁+t₁₂₁      0
 t₂₁₂₁₂  0            t₂₁₂               0               t₂₁          0
 0       t₁₂          0               …  t₁₂₁            0            t₁₂₁₂₁
 0       t₂+t₂₁₂      0                  t₂₁+t₂₁₂₁       0            t₂₁₂₁
 0       t₁₂+t₁₂₁₂    0                  t₁+t₁₂₁+t₁₂₁₂₁  0            t₁₂₁
 0       t₂₁₂+t₂₁₂₁₂  0                  t₂₁+t₂₁₂₁       0            t₂₁
 0       t₁₂₁₂        0                  t₁₂₁            0            t₁

julia&gt; CharTable(A)
CharTable(AsymptoticAlgebra(G₂,1) dim.10)
     │2 12 212 1212 21212 1 21 121 2121 12121
─────┼────────────────────────────────────────
φ′₁‚₃│.  .   .    .     . 1  .  -1    .     1
φ₂‚₁ │1  .   2    .     1 1  .   2    .     1
φ₂‚₂ │1  .   .    .    -1 1  .   .    .    -1
φ″₁‚₃│1  .  -1    .     1 .  .   .    .     .</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/4249294d12fd53e00306818ee02f28461246acf4/src/KL.jl#L1032-L1093">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="hecke.html">« Hecke algebras</a><a class="docs-footer-nextpage" href="algebras.html">Algebras »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 12 December 2023 17:46">Tuesday 12 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
