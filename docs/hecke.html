<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Hecke algebras · Chevie.jl documentation</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Chevie.jl documentation</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Chevie</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Infrastructure</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="format.html">formatting facilities</a></li><li><a class="tocitem" href="symbols.html">Symbols</a></li><li><a class="tocitem" href="nf.html">Number fields</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Reflection groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="permroot.html">Finite reflection groups</a></li><li><a class="tocitem" href="coxgroups.html">Coxeter groups</a></li><li><a class="tocitem" href="weyl.html">Finite Coxeter groups, Weyl groups, crystallographic root systems</a></li><li><a class="tocitem" href="chars.html">Classes/characters of reflection groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Hecke algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href="hecke.html">Hecke algebras</a></li><li><a class="tocitem" href="kl.html">Kazhdan-Lusztig polynomials and bases</a></li><li><a class="tocitem" href="algebras.html">Algebras</a></li></ul></li><li><a class="tocitem" href="garside.html">Garside monoids and groups, braids.</a></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Reductive groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="semisimple.html">Reductive groups, semisimple elements</a></li><li><a class="tocitem" href="cosets.html">Reflection cosets and Spets</a></li><li><a class="tocitem" href="sscoset.html">Non-connected reductive groups</a></li><li><a class="tocitem" href="uch.html">Unipotent characters</a></li><li><a class="tocitem" href="ct.html">Classtypes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Eigenspaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="eigen.html">Eigenspaces</a></li><li><a class="tocitem" href="dseries.html">d-Harish-Chandra series</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Unipotent elements</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="ucl.html">Unipotent classes of reductive groups</a></li><li><a class="tocitem" href="urad.html">Unipotent Elements</a></li></ul></li><li><a class="tocitem" href="gendec.html">Decomposition Matrices</a></li><li><a class="tocitem" href="dict.html">Dictionary from GAP3/Chevie</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Hecke algebras</a></li><li class="is-active"><a href="hecke.html">Hecke algebras</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="hecke.html">Hecke algebras</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jmichel7/Chevie.jl/blob/master/docs/src/hecke.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Hecke-algebras"><a class="docs-heading-anchor" href="#Hecke-algebras">Hecke algebras</a><a id="Hecke-algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Hecke-algebras" title="Permalink"></a></h1><ul><li><a href="hecke.html#Chevie.HeckeAlgebras"><code>Chevie.HeckeAlgebras</code></a></li><li><a href="hecke.html#Chevie.Chars.CharTable-Tuple{HeckeAlgebra}"><code>Chevie.Chars.CharTable</code></a></li><li><a href="hecke.html#Chevie.HeckeAlgebras.FactSchur"><code>Chevie.HeckeAlgebras.FactSchur</code></a></li><li><a href="hecke.html#Chevie.HeckeAlgebras.HeckeCoset"><code>Chevie.HeckeAlgebras.HeckeCoset</code></a></li><li><a href="hecke.html#Chevie.Chars.representation-Tuple{HeckeAlgebra, Integer}"><code>Chevie.Chars.representation</code></a></li><li><a href="hecke.html#Chevie.Chars.representations-Tuple{Union{HeckeAlgebra, HeckeCoset}}"><code>Chevie.Chars.representations</code></a></li><li><a href="hecke.html#Chevie.Garside.α-Tuple{HeckeTElt}"><code>Chevie.Garside.α</code></a></li><li><a href="hecke.html#Chevie.HeckeAlgebras.Tbasis-Tuple{HeckeAlgebra}"><code>Chevie.HeckeAlgebras.Tbasis</code></a></li><li><a href="hecke.html#Chevie.HeckeAlgebras.alt"><code>Chevie.HeckeAlgebras.alt</code></a></li><li><a href="hecke.html#Chevie.HeckeAlgebras.central_monomials"><code>Chevie.HeckeAlgebras.central_monomials</code></a></li><li><a href="hecke.html#Chevie.HeckeAlgebras.char_values"><code>Chevie.HeckeAlgebras.char_values</code></a></li><li><a href="hecke.html#Chevie.HeckeAlgebras.class_polynomials"><code>Chevie.HeckeAlgebras.class_polynomials</code></a></li><li><a href="hecke.html#Chevie.HeckeAlgebras.factorized_schur_element"><code>Chevie.HeckeAlgebras.factorized_schur_element</code></a></li><li><a href="hecke.html#Chevie.HeckeAlgebras.factorized_schur_elements"><code>Chevie.HeckeAlgebras.factorized_schur_elements</code></a></li><li><a href="hecke.html#Chevie.HeckeAlgebras.hecke-Tuple{Spets, HeckeAlgebra}"><code>Chevie.HeckeAlgebras.hecke</code></a></li><li><a href="hecke.html#Chevie.HeckeAlgebras.hecke-Union{Tuple{C}, Tuple{Group, Vector{&lt;:Vector{C}}}} where C"><code>Chevie.HeckeAlgebras.hecke</code></a></li><li><a href="hecke.html#Chevie.HeckeAlgebras.hecke-Tuple{HeckeCoset}"><code>Chevie.HeckeAlgebras.hecke</code></a></li><li><a href="hecke.html#Chevie.HeckeAlgebras.isrepresentation"><code>Chevie.HeckeAlgebras.isrepresentation</code></a></li><li><a href="hecke.html#Chevie.HeckeAlgebras.schur_elements"><code>Chevie.HeckeAlgebras.schur_elements</code></a></li><li><a href="hecke.html#Chevie.PermRoot.reflection_representation-Tuple{HeckeAlgebra}"><code>Chevie.PermRoot.reflection_representation</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Chevie.HeckeAlgebras" href="#Chevie.HeckeAlgebras"><code>Chevie.HeckeAlgebras</code></a> — <span class="docstring-category">Module</span></header><section><div><p>This   module  implements  Hecke  algebras  associated  to  finite  complex reflection  groups and arbitrary Coxeter  groups (these algebras are called Iwahori-Hecke  algebras  in  this  last  case),  and  also  implements  the character  tables, Schur elements and representations of Hecke algebras for finite  groups. For Iwahori-Hecke algebras  and <code>G(d,1,1)</code> this module also implements  the standard <code>T</code> basis;  see the module <code>KL</code>for Kazhdan-Lusztig bases.</p><p>Let  <code>(W,S)</code> be  a Coxeter  system and  let <code>mₛₜ</code>  be the order of <code>st</code> for <code>s,t∈ S</code>. Let <code>R</code> be a commutative ring with 1 and for <code>s∈ S</code> let <code>uₛ₀,uₛ₁∈ R</code> be elements which depend only on the conjugacy class of <code>s</code> in <code>W</code> (this is  the  same  as  requiring  that  <code>uₛᵢ=uₜᵢ</code>  whenever  <code>mₛₜ</code> is odd). The Iwahori-Hecke   algebra  of  <code>W</code>  over  <code>R</code>  with  parameters  <code>uₛᵢ</code>  is  a deformation  of the group algebra of <code>W</code> over <code>R</code> defined as follows: it is the  unitary  associative  <code>R</code>-algebra  generated  by  elements  <code>Tₛ, s∈ S</code> subject to the relations:</p><p><span>$(Tₛ-uₛ₀)(Tₛ-uₛ₁)=0$</span> for all <code>s∈ S</code> (the quadratic relations)</p><p><span>$TₛTₜTₛ…= TₜTₛTₜ…$</span> with <code>mₛₜ</code> factors on each side (the braid relations)</p><p>If  <code>uₛ₀=1</code> and  <code>uₛ₁=-1</code> for  all <code>s</code>  then the quadratic relations become <code>Tₛ²=1</code> and the deformation of the group algebra is trivial.</p><p>Since  the generators <code>Tₛ</code>  satisfy the braid  relations, <code>H</code> is  in fact a quotient  of the group algebra of the  braid group associated with <code>W</code>. The braid relations also imply that for any reduced expression <code>s_1⋯ s_m</code> of <code>w ∈  W</code> the product <code>Tₛ_1⋯ Tₛ_m</code> has the same value, that we denote <code>T_w</code>. We have <code>T_1=1</code>; if one of the <code>uₛᵢ</code> is invertible, the <code>{T_w}_{w∈ W}</code> form an <code>R</code>-basis  of the Iwahori-Hecke algebra  which specializes to the canonical basis of the group algebra <code>R[W]</code> for <code>uₛ₀↦1</code> and <code>uₛ₁↦-1</code>.</p><p>When  one  of  the  <code>uₛᵢ</code>  is  invertible,  the  structure  constants  (the decomposion  of  a  product  <code>T_vT_w</code>)  in  the <code>T_w</code> basis are obtained as follows.  Choose a reduced expression for <code>v</code>,  say <code>v=s_1 ⋯ s_k</code> and apply inductively the formula:</p><p><span>$T_sT_w=T_{sw}$</span>               if <code>l(sw)=l(w)+1</code></p><p><span>$T_sT_w=-uₛ₀uₛ₁T_{sw}+(uₛ₀+uₛ₁)T_w$</span> if <code>l(sw)=l(w)-1</code>.</p><p>If  one of <code>uₛ₀</code> or <code>uₛ₁</code> is invertible  in <code>R</code>, for example <code>uₛ₁</code>, then by changing  the generators  to <code>T′ₛ=-Tₛ/uₛ₁</code>,  and setting <code>qₛ=-uₛ₀/uₛ₁</code>, the braid  relations do no change  (since when <code>mₛₜ</code> is  odd we have <code>uₛᵢ=uₜᵢ</code>) but  the quadratic relations become <code>(T′ₛ-qₛ)(T′ₛ+1)=0</code>. This normalisation is  the most common form considered  in the literature. Another common form in  the context of  Kazhdan-Lusztig theory, is  <code>uₛ₀=√qₛ</code> and <code>uₛ₁=-√qₛ⁻¹</code>. The  form provided, with two parameters per generator, is often useful, for instance  when constructing  the Jones  polynomial. If  for all <code>s</code> we have <code>uₛ₀=q</code>,   <code>uₛ₁=-1</code>   then   we   call   the   corresponding   algebra  the &quot;one-parameter&quot; or &quot;Spetsial&quot; Iwahori-Hecke algebra associated with <code>W</code>.</p><p>For  some  Iwahori-Hecke  algebras  the  character  table,  and  in general Kazhdan-Lusztig  bases, require  a square  root of  <code>-uₛ₀uₛ₁</code>. These square roots  can be specified  with the keyword  <code>rootpara</code> when constructing the algebra;  after  this  the  function  <code>rootpara(H)</code>  will return the chosen roots. If not specified, we try to extract roots automatically when needed; <code>rootpara(H)</code>  informs  on  the  choices  made. Note that some mathematical results  require an explicit choice of one  of the two possible roots which cannot be automatically made thus require a keyword initialisation.</p><p>There  is a universal choice  for <code>R</code> and <code>uₛᵢ</code>:  Let <code>uₛᵢ:s∈ S,i∈[0,1]</code> be indeterminates   such  that  <code>uₛᵢ=uₜᵢ</code>  whenever  <code>mₛₜ</code>  is  odd,  and  let <code>A=ℤ[uₛᵢ]</code> be the corresponding polynomial ring. Then the Hecke algebra <code>H</code> of  <code>W</code> over <code>A</code> with parameters <code>uₛᵢ</code> is called the <em>generic Iwahori-Hecke algebra</em>  of  <code>W</code>.  Any  Hecke  algebra  <code>H₁</code>  with parameters <code>vₛᵢ</code> can be obtained  by  specialization  from  <code>H</code>,  since  there  is  a  unique  ring homomorphism  <code>f:A → R</code> such that <code>f(uₛᵢ)=vₛᵢ</code> for all <code>i</code>. Then via <code>f</code> we can identify <code>H₁</code> to <span>$R⊗ _A H$</span>.</p><p>Certain invariants of the irreducible characters of the one-parameter Hecke algebra  play a special role in the representation theory of the underlying finite  Coxeter  groups,  namely  the  <code>a</code>-  and  <code>A</code>-invariants. For basic properties   of  Iwahori-Hecke   algebras  and   their  relevance   to  the representation theory of finite groups of Lie type, see for example <a href="biblio.htm#CR87">Curtis and Reiner 1987</a> Sections~67 and 68.</p><p>In  the  following  example,  we  compute  the multiplication table for the <code>0</code>-Iwahori–Hecke algebra associated with the Coxeter group of type <code>A_2</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,2)
A₂

julia&gt; H=hecke(W,0)            # One-parameter algebra with `q=0`
hecke(A₂,0)

julia&gt; T=Tbasis(H);            # Create the `T` basis

julia&gt; b=T.(elements(W))       # the basis
6-element Vector{HeckeTElt{HeckeAlgebra{Int64, Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}, Int64, Perm{Int16}}}:
 T.
 T₁
 T₂
 T₁₂
 T₂₁
 T₁₂₁

julia&gt; b*permutedims(b)       # multiplication table
6×6 Matrix{HeckeTElt{HeckeAlgebra{Int64, Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}, Int64, Perm{Int16}}}:
 T.    T₁     T₂     T₁₂    T₂₁    T₁₂₁
 T₁    -T₁    T₁₂    -T₁₂   T₁₂₁   -T₁₂₁
 T₂    T₂₁    -T₂    T₁₂₁   -T₂₁   -T₁₂₁
 T₁₂   T₁₂₁   -T₁₂   -T₁₂₁  -T₁₂₁  T₁₂₁
 T₂₁   -T₂₁   T₁₂₁   -T₁₂₁  -T₁₂₁  T₁₂₁
 T₁₂₁  -T₁₂₁  -T₁₂₁  T₁₂₁   T₁₂₁   -T₁₂₁</code></pre><p>Thus,  we work  with algebras  with arbitrary  parameters. We will see that this also works on the level of characters and representations.</p><p>For  general complex reflection  groups, the picture  is similar. The Hecke algebras  are deformations  of the  group algebras,  generalizing those for real reflection groups.</p><p>The  definition is  as a  quotient of  the algebra  of the  braid group. We assume  now that <code>W</code> is  a <em>finite</em> reflection group  in the complex vector space  <code>V</code>. The <em>braid group</em> associated  is the fundamental group <code>Π₁</code> of the  space  <span>$(V-\bigcup_{H\in\mathcal H}  H)/W$</span>, where <span>$\mathcal H$</span> is  the set of  reflecting hyperplanes of  <code>W</code>. This group  is generated by <em>braid reflections</em>, elements which by the natural map from the braid group to  the reflection  group project  to distinguished  reflections. The braid reflections   which  project  to  a  given  <code>W</code>-orbit  of  reflections  are conjugate.  Let <code>𝐬</code> be a representative of  such a conjugacy class of braid reflections,  let <code>e</code>  be the  order of  the image  of <code>𝐬</code>  in <code>W</code>, and let <span>$u_{𝐬,0},…,u_{𝐬,e-1}$</span> be indeterminates. The generic Hecke algebra of <code>W</code> is  the  <span>$ℤ[u_{𝐬,i}^{±  1}]_{𝐬,i}$</span>-algebra  quotient  of  the braid group algebra  by the relations <span>$(𝐬-u_{𝐬,0})…(𝐬-u_{𝐬,e-1})=0$</span>, and an arbitrary Hecke  algebra for <code>W</code> is an algebra  obtained from this generic algebra by specializing some of the parameters.</p><p>The  generic Hecke algebras are explicitely  described by a presentation of the  braid group. The braid group can be presented by homogeneous relations in   the  braid   reflections,  called   <em>braid  relations</em>,  described  in <a href="biblio.htm#BMR98">Broué-Malle-Rouquier     1998</a>     and    <a href="biblio.htm#BM03">Bessis-Michel 2003</a>  (some  of  which  were  obtained  using the VKCURVE GAP3-package,  also ported to Julia).  Furthermore, these presentations are such  that the  reflection group  is presented  by the same relations, plus relations  describing the order  of the generating  reflections, called the <em>order  relations</em>. Thus  the Hecke  algebra has  a presentation similar to that of <code>W</code>, with the same braid relations but the order relations replaced by a deformed version.</p><p>If  <code>S⊂ W</code>  is the  set of  distinguished reflections  of <code>W</code> which lift to generating  braid reflections in the braid  group, for each conjugacy class of  an  <code>s</code>  of  order  <code>e</code>  we take indeterminates <code>uₛ₀,…,uₛₑ₋₁</code>. Then the generic  Hecke algebra is the <span>$ℤ[uₛᵢ^{±1}]ₛᵢ$</span>-algebra <code>H</code> with generators <code>T_s</code>  for each <code>s∈  S</code> presented by  the braid relations  and the deformed order relations <span>$(T_s-u_{s,0})…(T_s-u_{s,e-1})=0$</span>.</p><p>Ariki,  Koike and Malle have computed the  character table of some of these algebras,  including  those  for  all  2-dimensional reflection groups, see <a href="biblio.htm#BM93">Broué-Malle 1993</a> and <a href="biblio.htm#Mal96">Malle 1996</a>; our data  has  models  of  all  representation  and  character  tables for real reflection  groups; it  contains the  same for  imprimitive groups  and for primitive groups of dimension 2 and 3 (these last representations have been computed  in <a href="biblio.htm#MM10">Malle-Michel 2010</a>) and contains also models and  character tables computed  by Michel for  <code>G₂₉</code> and <code>G₃₃</code>; it contains also  partial lists of representations and partial character tables for the remaining  groups <code>G₃₁,G₃₂</code>  and <code>G₃₄</code>,  computed by  Malle and  Michel for <code>G₃₂</code> and by Michel for the other two algebras.</p><p>The quotient of the Hecke algebra obtained by the specialisation <span>$u_{𝐬,i}↦ ζₑⁱ$</span>  is isomorphic to the group algebra of <code>W</code>. It was conjectured for 20 years  that over a splitting ring the Hecke algebra is itself isomorphic to the  group algebra of <code>W</code> over the  same ring. This was called the freeness conjecture since the main problem is to show that the Hecke algebra is free of dimension <code>|W|</code>. This has finally been proved in 2019 thanks to the work of  many  people  including  Marin,  Pfeiffer,  Chavli  and  Tsuchioka  for exceptional  groups. Along the way  it has been proven  that there exists a set  <code>{b_w}_{w∈ W}</code> of  elements of the  Braid group such  that <code>b_1=1</code> and <code>b_w</code> maps to <code>w</code> by the natural quotient map, such that their images <code>T_w</code> form a basis of the Hecke algebra.</p><p>It  is  conjectured  that  such  a  basis  <code>T_w</code>  can  be  chosen such that additionnaly  the  linear  form  <code>t</code>  defined  by  <code>t(T_w)=0</code> if <code>w≠ 1</code> and <code>t(1)=1</code> is a symmetrizing form for the symmetric algebra <code>H</code>. This is well known  for all real reflection groups  and has been proved in <a href="biblio.htm#MM98">Malle-Mathas 1998</a>   for   imprimitive   reflection   groups   and   in <a href="biblio.htm#MM10">Malle-Michel 2010</a> for some primitive groups of dimension 2  and  3.  Chlouveraki  and  Chavli  have handled some other 2-dimensional cases.  For  each  irreducible  character  <code>φ</code>  of <code>H</code> we define the <em>Schur element</em>  <code>Sᵩ</code> associated to <code>φ</code> by the  condition that for any element <code>T</code> of  <code>H</code> we have <code>t(T)=∑ᵩ φ(T)/Sᵩ</code>. It  can be shown that the Schur elements are  Laurent polynomials, and they  do not depend on  the choice of a basis having  the  above  property.  Malle  has  computed  these  Schur elements, assuming the above conjecture; they are in the Chevie data.</p><p>See the function <code>hecke</code> for various ways of specifying the parameters of a Hecke   algebra.  Look  also  at   the  docstrings  of  <code>central_monomials, char_values,     class_polynomials,    schur_elements,    isrepresentation, factorized_schur_elements</code>,  and  at  the  methods  for  Hecke  algebras of <code>CharTable, representations, reflrep</code>.</p><p>Taking  apart  Hecke  elements  is  done  with  the  functions  <code>getindex</code>, <code>setindex!</code>, <code>keys</code>, <code>values</code>, <code>iterate</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; H=hecke(W,Pol(:q))
hecke(A₂,q)

julia&gt; T=Tbasis(H);

julia&gt; h=T(1,2)^2
qT₂₁+(q-1)T₁₂₁

julia&gt; length(h) # h has 2 terms
2

julia&gt; h[W(2,1)] # coefficient of W(2,1)
Pol{Int64}: q

julia&gt; collect(h) # pairs perm=&gt;coeff
2-element Vector{Any}:
  (1,2,6)(3,4,5) =&gt; q
 (1,5)(2,4)(3,6) =&gt; q-1

julia&gt; collect(values(h)) # the coefficients
2-element Vector{Pol{Int64}}:
 q
 q-1

julia&gt; collect(keys(h)) # the corresponding Perms
2-element Vector{Perm{Int16}}:
 (1,2,6)(3,4,5)
 (1,5)(2,4)(3,6)

julia&gt; h[W(2,1)]=Pol(3)
Pol{Int64}: 3

julia&gt; h
3T₂₁+(q-1)T₁₂₁</code></pre><p>finally, benchmarks on julia 1.8</p><pre><code class="language-benchmark hljs">julia&gt; function test_w0(n)
         W=coxgroup(:A,n)
         Tbasis(hecke(W,Pol(:q)))(longest(W))^2
       end
test_w0 (generic function with 1 method)

julia&gt; @btime test_w0(7);
   97.210 ms (1776476 allocations: 127.52 MiB)</code></pre><p>in GAP3 the analogous function takes 920ms</p><pre><code class="nohighlight hljs">test_w0:=function(n)local W,T,H;
  W:=CoxeterGroup(&quot;A&quot;,n);H:=Hecke(W,X(Rationals));T:=Basis(H,&quot;T&quot;);
  return T(LongestCoxeterWord(W))^2;
end;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/047461a7252cb8b9c53ae1072e1432a30ed9bf27/src/HeckeAlgebras.jl#L1-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.HeckeAlgebras.hecke-Union{Tuple{C}, Tuple{Group, Vector{&lt;:Vector{C}}}} where C" href="#Chevie.HeckeAlgebras.hecke-Union{Tuple{C}, Tuple{Group, Vector{&lt;:Vector{C}}}} where C"><code>Chevie.HeckeAlgebras.hecke</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>hecke( W [, parameter];rootpara=nothing)</code></p><p>Hecke  algebra for the complex reflection group or Coxeter group <code>W</code>. If no <code>parameter</code> is given, <code>1</code> is assumed which gives the group algebra of <code>W</code>.</p><p>The  following forms are accepted for  <code>parameter</code>: if <code>parameter</code> is not a vector or a tuple, it is replaced by the vector <code>fill(parameter,ngens(W))</code>. If it is a vector with one entry, it is replaced with <code>fill(parameter[1],ngens(W))</code>.  If <code>parameter</code>  is a  vector with more than one  entry, it should  have length <code>ngens(W)</code>,  each entry representing the parameters   for   the   corresponding   generator   of  <code>W</code>,  and  entries corresponding  to  the  same  <code>W</code>-orbit  of generators should be identical. Finally, if <code>parameter</code> is a <code>Tuple</code>, the tuple should have as many entries as  there are hyperplane  orbits in <code>W</code>  and each entry  will represent the parameters for the corresponding conjugacy class of braid reflections.</p><p>An  entry in  <code>parameter</code> for  a reflection  of order  <code>e</code> can  be either a single scalar value or a <code>Vector</code> of length &#39;e&#39;. If it is a <code>Vector</code>, it is interpreted as the list <code>[u₀,…,u_(e-1)]</code> of parameters for that reflection. If  it is not  a vector, let  <code>q</code> be its  value; it is  then interpreted as specifying  the  list  of  parameters  for  the Spetsial algebra, which are <code>[q,ζ_e,…,ζ_{e-1}]</code>  (thus the  list <code>[q,-1]</code>  of the one-parameter algebra for Coxeter groups).</p><p>When  printing an Hecke algebra the parameter list is abbreviated using the same conventions.</p><p>Computing characters or representations of Hecke algebra needs sometimes to extract  roots of the  parameters. These roots  are extracted automatically (when  possible). For Coxeter groups it  is possible to give explicit roots by  giving  a  keyword  argument  <code>rootpara</code>:  if  it is a vector it should contain at the <code>i</code>-th position a square root of <code>-parameter[i][1]*parameter[i][2]</code>;   if  a   scalar  it   is  replaced  by <code>fill(rootpara,ngens(W))</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:B,2)
B₂

julia&gt; @Pol q
Pol{Int64}: q

julia&gt; H=hecke(W,q)
hecke(B₂,q)

julia&gt; H.para
2-element Vector{Vector{Pol{Int64}}}:
 [q, -1]
 [q, -1]

julia&gt; H=hecke(W,q^2,rootpara=-q)
hecke(B₂,q²,rootpara=-q)

julia&gt; H=hecke(W,q^2)
hecke(B₂,q²)

julia&gt; rootpara(H)
2-element Vector{Pol{Int64}}:
 q
 q

julia&gt; H
hecke(B₂,q²,rootpara=q)

julia&gt; H=hecke(W,[q^2,q^4],rootpara=[q,q^2])
hecke(B₂,Pol{Int64}[q², q⁴],rootpara=Pol{Int64}[q, q²])

julia&gt; H.para,rootpara(H)
(Vector{Pol{Int64}}[[q², -1], [q⁴, -1]], Pol{Int64}[q, q²])

julia&gt; H=hecke(W,9,rootpara=3)
hecke(B₂,9,rootpara=3)

julia&gt; H.para,rootpara(H)
([[9, -1], [9, -1]], [3, 3])

julia&gt; @Mvp x,y,z,t

julia&gt; H=hecke(W,[[x,y]])
hecke(B₂,Vector{Mvp{Int64, Int64}}[[x, y]])

julia&gt; rootpara(H);H
hecke(B₂,Vector{Mvp{Int64, Int64}}[[x, y]],rootpara=ζ₄x½y½)

julia&gt; H=hecke(W,[[x,y],[z,t]])
hecke(B₂,Vector{Mvp{Int64, Int64}}[[x, y], [z, t]])

julia&gt; rootpara(H);H
hecke(B₂,Vector{Mvp{Int64, Int64}}[[x, y], [z, t]],rootpara=Mvp{Cyc{Int64}, Rational{Int64}}[ζ₄x½y½, ζ₄t½z½])

julia&gt; hecke(coxgroup(:F,4),(q,q^2)).para
4-element Vector{Vector{Pol{Int64}}}:
 [q, -1]
 [q, -1]
 [q², -1]
 [q², -1]

julia&gt; hecke(complex_reflection_group(3,1,2),q).para # spetsial parameters
2-element Vector{Vector{Pol{Cyc{Int64}}}}:
 [q, ζ₃, ζ₃²]
 [q, -1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/047461a7252cb8b9c53ae1072e1432a30ed9bf27/src/HeckeAlgebras.jl#L269-L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.HeckeAlgebras.Tbasis-Tuple{HeckeAlgebra}" href="#Chevie.HeckeAlgebras.Tbasis-Tuple{HeckeAlgebra}"><code>Chevie.HeckeAlgebras.Tbasis</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Tbasis(H::HeckeAlgebra)</code> The  <code>T</code> basis of  <code>H</code>. It is  defined currently for Iwahori-Hecke algebras and  for Hecke algebras of cyclic  complex reflection groups <code>G(d,1,1)</code>. It returns  a function, say <code>T</code>,  which can take an  argument of the following forms</p><ul><li><code>T(i::Integer)</code>: the generator <code>T_s</code> where <code>s=H.W(i)</code>.</li><li><code>T(i₁,…,iᵣ)</code>: the product <code>T(i₁)…T(iᵣ)</code></li><li><code>T([i₁,…,iᵣ])</code>: same as <code>T(i₁,…,iᵣ)</code></li><li><code>T(w)</code> where <code>w∈ H.W</code>: returns <code>T_w</code></li></ul><pre><code class="language-julia-repl hljs">julia&gt; H=hecke(coxgroup(:A,2),Pol(:q))
hecke(A₂,q)

julia&gt; T=Tbasis(H);T(longest(H.W))^2
q³T.+(q³-2q²+q)T₂₁+(q³-q²)T₂+(q³-q²)T₁+(q³-2q²+2q-1)T₁₂₁+(q³-2q²+q)T₁₂

julia&gt; W=crg(3,1,1)
G₃‚₁‚₁

julia&gt; H=hecke(crg(3,1,1),Pol(:q))
hecke(G₃‚₁‚₁,q)

julia&gt; T=Tbasis(H);T(1)^3
(q-1)T.+(q-1)T₁+qT₁₁</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/047461a7252cb8b9c53ae1072e1432a30ed9bf27/src/HeckeAlgebras.jl#L826-L854">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.HeckeAlgebras.alt" href="#Chevie.HeckeAlgebras.alt"><code>Chevie.HeckeAlgebras.alt</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>alt(a::HeckeTElt)</code></p><p><code>a</code> should be an element of an Iwahori-Hecke algebra <code>H</code>. the involution on <code>H</code>   defined  by  <code>x↦  bar(x)</code>   on  coefficients  and  <code>Tₛ↦  uₛ,₀uₛ,₁Tₛ</code>. Essentially it corresponds to tensoring with the sign representation.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2);H=hecke(W,Pol(:q))
hecke(G₂,q)

julia&gt; T=Tbasis(H);h=T(1,2)*T(2,1)
q²T.+(q²-q)T₁+(q-1)T₁₂₁

julia&gt; alt(h)
q⁻²T.+(q⁻²-q⁻³)T₁+(q⁻³-q⁻⁴)T₁₂₁</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/047461a7252cb8b9c53ae1072e1432a30ed9bf27/src/HeckeAlgebras.jl#L947-L964">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Garside.α-Tuple{HeckeTElt}" href="#Chevie.Garside.α-Tuple{HeckeTElt}"><code>Chevie.Garside.α</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>α(a::HeckeTElt)</code></p><p>the anti-involution on the Hecke algebra defined by <span>$T_w↦ T_{inv(w)}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/047461a7252cb8b9c53ae1072e1432a30ed9bf27/src/HeckeAlgebras.jl#L970-L974">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Chars.CharTable-Tuple{HeckeAlgebra}" href="#Chevie.Chars.CharTable-Tuple{HeckeAlgebra}"><code>Chevie.Chars.CharTable</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>CharTable(H::HeckeAlgebra or HeckeCoset)</code></p><p>returns  the <code>CharTable</code> of the Hecke algebra <code>H</code>. For the primitive groups <code>G₃₁,  G₃₂,  G₃₄</code>  there  are  <code>Unknown()</code> entries corresponding to missing representations   (see  <a href="chars.html#Chevie.Chars.representation-Tuple{Union{Spets, FiniteCoxeterGroup, PermRootGroup}, Integer}"><code>representation</code></a>).   The  columns   of  the <code>CharTable</code>  are labelled  by <code>classnames(H.W)</code>  and contain  the character values for the corresponding element given by <code>classreps(H.W)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; H=hecke(crg(4),Pol())
hecke(G₄,q)

julia&gt; CharTable(H)
CharTable(hecke(G₄,q))
┌────┬──────────────────────────────────────┐
│    │.    z 212   12    z12     1        1z│
├────┼──────────────────────────────────────┤
│φ₁‚₀│1   q⁶  q³   q²     q⁸     q        q⁷│
│φ₁‚₄│1    1   1  ζ₃²    ζ₃²    ζ₃        ζ₃│
│φ₁‚₈│1    1   1   ζ₃     ζ₃   ζ₃²       ζ₃²│
│φ₂‚₅│2   -2   .    1     -1    -1         1│
│φ₂‚₃│2 -2q³   . ζ₃²q -ζ₃²q⁴ q+ζ₃² -q⁴-ζ₃²q³│
│φ₂‚₁│2 -2q³   .  ζ₃q  -ζ₃q⁴  q+ζ₃  -q⁴-ζ₃q³│
│φ₃‚₂│3  3q²  -q    .      .   q-1     q³-q²│
└────┴──────────────────────────────────────┘</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/047461a7252cb8b9c53ae1072e1432a30ed9bf27/src/HeckeAlgebras.jl#L469-L496">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.HeckeAlgebras.central_monomials" href="#Chevie.HeckeAlgebras.central_monomials"><code>Chevie.HeckeAlgebras.central_monomials</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>central_monomials(H)</code></p><p>Let  <code>H</code>  be  an  Hecke  algebra  for  the finite reflection group <code>W</code>. The function  returns the scalars by which the image  in <code>H</code> of <code>π</code> acts on the irreducible representations of <code>H</code>.</p><p>When  <code>W</code> is irreducible,  <code>π</code> is the  generator of the  center of the pure braid  group.  In  general,  it  is  the  product of such elements for each irreducible  component. When  <code>W</code> is  a Coxeter  group, the  image of  π in <code>H</code> is <span>$T_{w_0}^2$</span>.</p><pre><code class="language-julia-repl hljs">julia&gt; H=hecke(coxgroup(:H,3),Pol(:q))
hecke(H₃,q)

julia&gt; central_monomials(H)
10-element Vector{Pol{Cyc{Int64}}}:
 1
 q³⁰
 q¹²
 q¹⁸
 q¹⁰
 q¹⁰
 q²⁰
 q²⁰
 q¹⁵
 q¹⁵</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/047461a7252cb8b9c53ae1072e1432a30ed9bf27/src/HeckeAlgebras.jl#L713-L742">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.HeckeAlgebras.class_polynomials" href="#Chevie.HeckeAlgebras.class_polynomials"><code>Chevie.HeckeAlgebras.class_polynomials</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>class_polynomials(h::HeckeElt)</code></p><p>returns  the  class  polynomials  of  the  element <code>h</code> of the Iwahori-Hecke algebra or coset given by <code>h.H</code> with respect to the <code>T</code> basis for a set <code>R</code> of  representatives  of  minimal  length  in  the  conjugacy classes of the Coxeter group or coset <code>H.W</code>. Such minimal length representatives are given by  <code>classreps(H.W)</code>. The vector <code>p</code> of  these polynomials has the property that  if <code>X</code> is the  matrix of the values  of the irreducible characters of <code>H</code>  on <code>T_w</code> (for <code>w∈ R</code>), then the product <code>X*p</code> is the list of values of the irreducible characters on <code>h</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxsym(4)
𝔖 ₄

julia&gt; H=hecke(W,Pol(:q))
hecke(𝔖 ₄,q)

julia&gt; h=Tbasis(H,longest(W))
T₁₂₁₃₂₁

julia&gt; p=class_polynomials(h)
5-element Vector{Pol{Int64}}:
 0
 0
 q²
 q³-2q²+q
 q³-q²+q-1</code></pre><p>The class polynomials were introduced in <a href="biblio.htm#GP93">Geck-Pfeiffer1993</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/047461a7252cb8b9c53ae1072e1432a30ed9bf27/src/HeckeAlgebras.jl#L977-L1008">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.HeckeAlgebras.char_values" href="#Chevie.HeckeAlgebras.char_values"><code>Chevie.HeckeAlgebras.char_values</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>char_values(h::HeckeTElt)</code></p><p><code>h</code> is an element of an Iwahori-Hecke algebra <code>H</code>. The function returns the values  of the irreducible characters of <code>H</code>  on <code>h</code> (the method used is to convert to the <code>T</code> basis, and then use <code>class_polynomials</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:B,2)
B₂

julia&gt; H=hecke(W,q^2;rootpara=q)
hecke(B₂,q²,rootpara=q)

julia&gt; char_values(Cpbasis(H)(1,2,1))
5-element Vector{Pol{Int64}}:
 -q-q⁻¹
 q+q⁻¹
 0
 q³+2q+2q⁻¹+q⁻³
 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/047461a7252cb8b9c53ae1072e1432a30ed9bf27/src/HeckeAlgebras.jl#L1063-L1085">source</a></section><section><div><p><code>char_values(H::HeckeAlgebra,v::Vector{&lt;:Integer})</code></p><p>For an Iwahori-Hecke algebra this computes the character values of <code>H</code> on the <code>Tbasis(H)(v)</code>.</p><p>For  <code>H</code> the Hecke algebra  of a complex reflection  group <code>W</code> this routine computes  character values on a  lift of the element  of <code>W</code> defined by the word <code>v</code> in <code>gens(W)</code>.</p><p>For  complex reflection  groups the  character table  of the  generic Hecke algebra  of  <code>W</code>  has  been  computed  (not  entirely for 3 exceptions, see <code>representation</code>)  in the  sense that,  if <code>s₁,…,sₙ</code>  are generators of the braid  group lifting  the Broué-Malle-Rouquier-Bessis-Michel  generators of <code>W</code>,  there is at least one element <code>v</code>  in each conjugacy class of <code>W</code> and one  expression in the generators for it  such that the character values of the  image <code>Tᵥ</code>  in the  Hecke algebra  of the  lift to the braid group are known.  Such an expression in the generators  will be called a <em>known</em> word (the  list of known words  is obtained by <code>word.(conjugacy_classes(W))</code>. If the  word <code>v</code> is known, the computation is quick using the character table. If  not,  the  function  computes  the  trace  of  <code>Tᵥ</code> in each irreducible representation.   The   values   returned   are   <code>Unknown()</code>  for  missing representations (see <code>representation</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; W=crg(4)
G₄

julia&gt; H=hecke(W,Pol(:q))
hecke(G₄,q)

julia&gt; char_values(H,[2,1,2])
7-element Vector{Pol{Cyc{Int64}}}:
 q³
 1
 1
 0
 0
 0
 -q</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/047461a7252cb8b9c53ae1072e1432a30ed9bf27/src/HeckeAlgebras.jl#L1088-L1128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.HeckeAlgebras.schur_elements" href="#Chevie.HeckeAlgebras.schur_elements"><code>Chevie.HeckeAlgebras.schur_elements</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>schur_elements(H)</code></p><p>returns the list of Schur elements for the Hecke algebra <code>H</code></p><pre><code class="language-julia-repl hljs">julia&gt; H=hecke(complex_reflection_group(4),Pol(:q))
hecke(G₄,q)

julia&gt; s=schur_elements(H)
7-element Vector{Pol{Cyc{Rational{Int64}}}}:
 q⁸+2q⁷+3q⁶+4q⁵+4q⁴+4q³+3q²+2q+1
 2√-3+(6+4√-3)q⁻¹+12q⁻²+(6-4√-3)q⁻³-2√-3q⁻⁴
 -2√-3+(6-4√-3)q⁻¹+12q⁻²+(6+4√-3)q⁻³+2√-3q⁻⁴
 2+2q⁻¹+4q⁻²+2q⁻³+2q⁻⁴
 ζ₃²√-3q³+(3-√-3)q²+3q+3+√-3-ζ₃√-3q⁻¹
 -ζ₃√-3q³+(3+√-3)q²+3q+3-√-3+ζ₃²√-3q⁻¹
 q²+2q+2+2q⁻¹+q⁻²

julia&gt; CycPol.(s)
7-element Vector{CycPol{Cyc{Rational{Int64}}}}:
 Φ₂²Φ₃Φ₄Φ₆
 2√-3q⁻⁴Φ₂²Φ′₃Φ′₆
 -2√-3q⁻⁴Φ₂²Φ″₃Φ″₆
 2q⁻⁴Φ₃Φ₄
 ζ₃²√-3q⁻¹Φ₂²Φ′₃Φ″₆
 -ζ₃√-3q⁻¹Φ₂²Φ″₃Φ′₆
 q⁻²Φ₂²Φ₄</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/047461a7252cb8b9c53ae1072e1432a30ed9bf27/src/HeckeAlgebras.jl#L1149-L1178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.HeckeAlgebras.factorized_schur_element" href="#Chevie.HeckeAlgebras.factorized_schur_element"><code>Chevie.HeckeAlgebras.factorized_schur_element</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>factorized_schur_element(H,phi)</code></p><p>returns  the factorized <code>schur_element</code>  (see <code>factorized_schur_elements</code>) of the  Hecke algebra  <code>H</code> for  the irreducible  character of <code>H</code> of parameter <code>phi</code> (see <code>charinfo(W).charparams</code>)</p><pre><code class="language-julia-repl hljs">julia&gt; W=complex_reflection_group(4)
G₄

julia&gt; @Mvp x,y; H=hecke(W,[[1,x,y]])
hecke(G₄,Vector{Mvp{Int64, Int64}}[[1, x, y]])

julia&gt; factorized_schur_element(H,[[2,5]])
-x⁻¹y(xy+1)(x-1)Φ₆(xy⁻¹)(y-1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/047461a7252cb8b9c53ae1072e1432a30ed9bf27/src/HeckeAlgebras.jl#L1375-L1392">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.HeckeAlgebras.factorized_schur_elements" href="#Chevie.HeckeAlgebras.factorized_schur_elements"><code>Chevie.HeckeAlgebras.factorized_schur_elements</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>factorized_schur_elements(H)</code></p><p>Let  <code>H</code> be  a Hecke  algebra for  the complex  reflection group <code>W</code>, whose parameters are all (Laurent) monomials in some variables <code>x₁,…,xₙ</code>, and let K  be the field of definition of <code>W</code>. Then Maria Chlouveraki has shown that the  Schur elements of <code>H</code> take the  particular form <code>M ∏ᵩ φ(Mᵩ)</code> where <code>φ</code> runs  over  a  list  of  K-cyclotomic  polynomials,  and  <code>M</code>  and <code>Mᵩ</code> are (Laurent)  monomials (in possibly some  fractional powers) of the variables <code>xᵢ</code>.  The  function  <code>factorized_schur_elements</code>  returns a data structure (see <code>HeckeAlgebras.FactSchur</code>) which shows this factorization.</p><pre><code class="language-julia-repl hljs">julia&gt; W=complex_reflection_group(4)
G₄

julia&gt; @Mvp x,y; H=hecke(W,[[1,x,y]])
hecke(G₄,Vector{Mvp{Int64, Int64}}[[1, x, y]])

julia&gt; factorized_schur_elements(H)
7-element Vector{Chevie.HeckeAlgebras.FactSchur}:
 x⁻⁴y⁻⁴(xy+1)Φ₁Φ₆(x)Φ₁Φ₆(y)
 (x²y⁻¹+1)Φ₁Φ₆(x)Φ₁Φ₆(xy⁻¹)
 -x⁻⁴y⁵Φ₁Φ₆(xy⁻¹)(xy⁻²+1)Φ₁Φ₆(y)
 -x⁻¹y(xy+1)(x-1)Φ₆(xy⁻¹)(y-1)
 -x⁻⁴y(x²y⁻¹+1)(x-1)(xy⁻¹-1)Φ₆(y)
 x⁻¹y⁻¹Φ₆(x)(xy⁻¹-1)(xy⁻²+1)(y-1)
 x⁻²y(x²y⁻¹+1)(xy+1)(xy⁻²+1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/047461a7252cb8b9c53ae1072e1432a30ed9bf27/src/HeckeAlgebras.jl#L1403-L1432">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.HeckeAlgebras.FactSchur" href="#Chevie.HeckeAlgebras.FactSchur"><code>Chevie.HeckeAlgebras.FactSchur</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A  <code>FactSchur</code> representing  a Schur  element of  the form  <code>M∏ᵩφ(Mᵩ)</code> (see <a href="hecke.html#Chevie.HeckeAlgebras.factorized_schur_element"><code>factorized_schur_element</code></a>)  is  a  <code>struct</code>  with a field <code>factor</code> which  holds the  monomial <code>M</code>,  and a  field <code>vcyc</code>  which holds a list of <code>NamedTuples</code>  describing each  factor <code>Mᵩ</code>  in the  product. An element of <code>vcyc</code>  representing a  term <code>φ(Mᵩ)</code>  is itself  a <code>NamedTuple</code> with fields <code>monomial</code> holding <code>Mᵩ</code> (as an <code>Mvp</code> with a single term), and a field <code>pol</code> holding a <code>CycPol</code> (see <code>CycPol</code>) representing <code>φ</code>.</p><p>A  few operations are implemented for  <code>FactSchur</code>, like <code>*, lcm</code>. They can be  evaluated  partially  or  completely  keeping  as  much as possible the factored form.</p><pre><code class="language-julia-repl hljs">julia&gt; @Mvp x,y; W=crg(4); H=hecke(W,[[1,x,y]])
hecke(G₄,Vector{Mvp{Int64, Int64}}[[1, x, y]])

julia&gt; p=factorized_schur_element(H,[[2,5]])
-x⁻¹y(xy+1)(x-1)Φ₆(xy⁻¹)(y-1)

julia&gt; q=p(;x=E(3)) # partial evaluation
ζ₃²√-3y⁻¹Φ₁Φ₂Φ′₆²(y)

julia&gt; q(;y=2//1)
-9√-3/2</code></pre><p>In contrast, the next operation expands <code>p</code> to an <code>Mvp</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; HeckeAlgebras.expand(p)
Mvp{Cyc{Rational{Int64}},Rational{Int64}}: -x³y+x³+x²y²-2x²+x²y⁻¹-xy³+2xy-xy⁻¹+y³-2y²+1+x⁻¹y²-x⁻¹y</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/047461a7252cb8b9c53ae1072e1432a30ed9bf27/src/HeckeAlgebras.jl#L1183-L1216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Chars.representation-Tuple{HeckeAlgebra, Integer}" href="#Chevie.Chars.representation-Tuple{HeckeAlgebra, Integer}"><code>Chevie.Chars.representation</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>representation(H::HeckeAlgebra or HeckeCoset,i)</code></p><p>returns,  for the <code>i</code>-th irreducible representation of the Hecke algebra or Hecke  coset <code>H</code>, a list  of matrices images of  the generators of <code>H</code> in a model of the representation (for Hecke cosets, the result is a <code>NamedTuple</code> with fields <code>gens</code>, a representation of <code>hecke(H)</code>, and <code>F</code>, the matrix for the automorphism of <code>H</code> in the representation).</p><p>This  function  is  based  on  the  classification,  and  is  not yet fully implemented for the Hecke algebras of the groups <code>G₃₁</code>, <code>G₃₂</code> and <code>G₃₄</code>: we have 50 representations out of 59 for type <code>G₃₁</code>, 30 representations out of 102  for  type  <code>G₃₂</code>  and  38  representations  out of 169 for type <code>G₃₄</code>; <code>nothing</code> is returned for a missing representation.</p><pre><code class="language-julia-repl hljs">julia&gt; W=crg(24)
G₂₄

julia&gt; H=hecke(W,Pol(:q))
hecke(G₂₄,q)

julia&gt; representation(H,3)
3-element Vector{Matrix{Pol{Cyc{Int64}}}}:
 [q 0 0; -q -1 0; -q 0 -1]
 [-1 0 -1; 0 -1 ((1-√-7)/2)q; 0 0 q]
 [-1 -1 0; 0 q 0; 0 (1+√-7)/2 -1]</code></pre><p>The  models  implemented  for  imprimitive  types <code>G(de,e,n)</code> for <code>n&gt;2</code> and <code>de&gt;1</code> (this includes Coxeter type <code>Dₙ</code>), excepted for <code>G(2,2,4), G(3,3,3), G(3,3,4), G(3,3,5)</code> and <code>G(4,4,3)</code>, involve rational fractions.</p><pre><code class="language-julia-repl hljs">julia&gt; H=hecke(coxgroup(:D,5),Pol())
hecke(D₅,q)

julia&gt; representation(H,7)
5-element Vector{Matrix{Frac{Pol{Int64}}}}:
 [q 0 0 0; 0 -1 0 0; 0 0 -1 0; 0 0 0 -1]
 [q 0 0 0; 0 -1 0 0; 0 0 -1 0; 0 0 0 -1]
 [1/(-q-1) q/(q+1) 0 0; (q²+q+1)/(q+1) q²/(q+1) 0 0; 0 0 -1 0; 0 0 0 -1]
 [-1 0 0 0; 0 1/(-q²-q-1) (-q²-q)/(-q²-q-1) 0; 0 (q³+q²+q+1)/(q²+q+1) q³/(q²+q+1) 0; 0 0 0 -1]
 [-1 0 0 0; 0 -1 0 0; 0 0 1/(-q³-q²-q-1) (-q³-q²-q)/(-q³-q²-q-1); 0 0 (q⁴+q³+q²+q+1)/(q³+q²+q+1) q⁴/(q³+q²+q+1)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/047461a7252cb8b9c53ae1072e1432a30ed9bf27/src/HeckeAlgebras.jl#L518-L563">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Chars.representations-Tuple{Union{HeckeAlgebra, HeckeCoset}}" href="#Chevie.Chars.representations-Tuple{Union{HeckeAlgebra, HeckeCoset}}"><code>Chevie.Chars.representations</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>representations(H)</code></p><p>returns  the list  of representations  of the  Hecke algebra or Hecke coset <code>H</code> (see <code>representation</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; WF=rootdatum(&quot;2B2&quot;)
²B₂

julia&gt; H=hecke(WF,Pol(:x)^2;rootpara=Pol())
hecke(²B₂,x²,rootpara=x)

julia&gt; representations(H)
3-element Vector{NamedTuple{(:gens, :F)}}:
 (gens = Matrix{Pol{Int64}}[[x²;;], [x²;;]], F = [1;;])
 (gens = [[-1;;], [-1;;]], F = [1;;])
 (gens = Matrix{Pol{Cyc{Int64}}}[[-1 0; √2x x²], [x² √2x; 0 -1]], F = [0 -1; -1 0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/047461a7252cb8b9c53ae1072e1432a30ed9bf27/src/HeckeAlgebras.jl#L1550-L1569">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.HeckeAlgebras.isrepresentation" href="#Chevie.HeckeAlgebras.isrepresentation"><code>Chevie.HeckeAlgebras.isrepresentation</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>isrepresentation(H::HeckeAlgebra,r)</code></p><p>returns <code>true</code> or <code>false</code>, according to whether a given set <code>r</code> of elements corresponding  to  the  standard  generators  of the reflection group <code>H.W</code> defines a representation of the Hecke algebra <code>H</code> or not.</p><pre><code class="language-julia-repl hljs">julia&gt; H=hecke(coxgroup(:F,4))
hecke(F₄,1)

julia&gt; isrepresentation(H,reflrep(H))
true

julia&gt; isrepresentation(H,Tbasis(H).(1:4))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/047461a7252cb8b9c53ae1072e1432a30ed9bf27/src/HeckeAlgebras.jl#L583-L600">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.PermRoot.reflection_representation-Tuple{HeckeAlgebra}" href="#Chevie.PermRoot.reflection_representation-Tuple{HeckeAlgebra}"><code>Chevie.PermRoot.reflection_representation</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>reflection_representation(H::HeckeAlgebra)</code> or <code>reflrep(H)</code></p><p>returns  a  list  of  matrices  for  the  generators  of <code>H</code> which give the reflection representation of the Iwahori-Hecke algebra <code>H</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:B,2);H=hecke(W,Pol(:q))
hecke(B₂,q)

julia&gt; reflrep(H)
2-element Vector{Matrix{Pol{Int64}}}:
 [-1 0; -q q]
 [q -2; 0 -1]

julia&gt; H=hecke(coxgroup(:H,3))
hecke(H₃,1)

julia&gt; reflrep(H)
3-element Vector{Matrix{Cyc{Int64}}}:
 [-1 0 0; -1 1 0; 0 0 1]
 [1 (-3-√5)/2 0; 0 -1 0; 0 -1 1]
 [1 0 0; 0 1 -1; 0 0 -1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/047461a7252cb8b9c53ae1072e1432a30ed9bf27/src/HeckeAlgebras.jl#L623-L647">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.HeckeAlgebras.HeckeCoset" href="#Chevie.HeckeAlgebras.HeckeCoset"><code>Chevie.HeckeAlgebras.HeckeCoset</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>HeckeCoset</code>s  are  <code>Hϕ</code>  where  <code>H</code>  is  an  Iwahori-Hecke algebra of some Coxeter  group <code>W</code> on which the automorphism <code>ϕ</code> of some Spets <code>Wϕ</code> acts by <code>ϕ(T_w)=T_{ϕ(w)}</code>.  For Weyl groups, this corresponds  to the action of the Frobenius  automorphism  on  the  commuting  algebra  of the induced of the trivial  representation from the  rational points of  some <code>F</code>-stable Borel subgroup to <code>𝐆 ^F</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; WF=rootdatum(:u,3)
u₃

julia&gt; HF=hecke(WF,Pol(:v)^2;rootpara=Pol())
hecke(u₃,v²,rootpara=v)

julia&gt; CharTable(HF)
CharTable(hecke(u₃,v²,rootpara=v))
┌───┬──────────┐
│   │ 111 21  3│
├───┼──────────┤
│111│  -1  1 -1│
│21 │-2v³  .  v│
│3  │  v⁶  1 v²│
└───┴──────────┘</code></pre><p>Thanks  to the work of Xuhua He and Sian Nie, &#39;class_polynomials&#39; also make sense for these cosets. This is used to compute such character tables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/047461a7252cb8b9c53ae1072e1432a30ed9bf27/src/HeckeAlgebras.jl#L1438-L1465">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.HeckeAlgebras.hecke-Tuple{HeckeCoset}" href="#Chevie.HeckeAlgebras.hecke-Tuple{HeckeCoset}"><code>Chevie.HeckeAlgebras.hecke</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>hecke(HF::HeckeCoset)</code> returns the underlying Hecke algebra</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/047461a7252cb8b9c53ae1072e1432a30ed9bf27/src/HeckeAlgebras.jl#L1471">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.HeckeAlgebras.hecke-Tuple{Spets, HeckeAlgebra}" href="#Chevie.HeckeAlgebras.hecke-Tuple{Spets, HeckeAlgebra}"><code>Chevie.HeckeAlgebras.hecke</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>hecke(WF::Spets, H)</code></p><p><code>hecke(WF::Spets, params)</code></p><p>Construct  a <code>HeckeCoset</code>  from a  Coxeter coset  <code>WF</code> and an Hecke algebra associated to <code>Group(WF)</code>. The second form is equivalent to <code>Hecke(WF,Hecke(Group(WF),params))</code>. See the doc for <code>HeckeCoset</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/047461a7252cb8b9c53ae1072e1432a30ed9bf27/src/HeckeAlgebras.jl#L1474-L1482">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="chars.html">« Classes/characters of reflection groups</a><a class="docs-footer-nextpage" href="kl.html">Kazhdan-Lusztig polynomials and bases »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 19 November 2024 17:56">Tuesday 19 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
