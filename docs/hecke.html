<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Hecke algebras Â· Gapjm.jl documentation</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Gapjm.jl documentation</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Gapjm</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Infrastructure</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="posets.html">Posets</a></li><li><a class="tocitem" href="sperm.html">Signed permutations</a></li><li><a class="tocitem" href="symbols.html">Symbols</a></li><li><a class="tocitem" href="glinearalgebra.html">Linear algebra on any field/ring</a></li><li><a class="tocitem" href="ffe.html">Finite fields</a></li><li><a class="tocitem" href="presentations.html">Presentations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Reflection groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="permroot.html">Finite reflection groups</a></li><li><a class="tocitem" href="coxgroups.html">Coxeter groups</a></li><li><a class="tocitem" href="weyl.html">Finite Coxeter groups and Weyl groups</a></li><li><a class="tocitem" href="chars.html">Classes/characters of reflection groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Hecke algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href="hecke.html">Hecke algebras</a></li><li><a class="tocitem" href="kl.html">Kazhdan-Lusztig polynomials and bases</a></li></ul></li><li><a class="tocitem" href="garside.html">Garside monoids and groups, braids.</a></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Reductive groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="semisimple.html">Reductive groups, semisimple elements</a></li><li><a class="tocitem" href="cosets.html">Reflection cosets and Spets</a></li><li><a class="tocitem" href="sscoset.html">Non-connected reductive groups</a></li><li><a class="tocitem" href="uch.html">Unipotent characters</a></li><li><a class="tocitem" href="ct.html">Classtypes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Eigenspaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="eigen.html">Eigenspaces</a></li><li><a class="tocitem" href="dseries.html">d-Harish-Chandra series</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Unipotent elements</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="ucl.html">Unipotent classes of reductive groups</a></li><li><a class="tocitem" href="urad.html">Unipotent Elements</a></li></ul></li><li><a class="tocitem" href="gendec.html">Decomposition Matrices</a></li><li><a class="tocitem" href="dict.html">Dictionary from GAP3/Chevie</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Hecke algebras</a></li><li class="is-active"><a href="hecke.html">Hecke algebras</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="hecke.html">Hecke algebras</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jmichel7/Gapjm.jl/blob/master/docs/src/hecke.md" title="Edit on GitHub"><span class="docs-icon fab">ï‚›</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Hecke-algebras"><a class="docs-heading-anchor" href="#Hecke-algebras">Hecke algebras</a><a id="Hecke-algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Hecke-algebras" title="Permalink"></a></h1><ul><li><a href="hecke.html#Gapjm.HeckeAlgebras"><code>Gapjm.HeckeAlgebras</code></a></li><li><a href="hecke.html#Gapjm.Chars.CharTable-Tuple{HeckeAlgebra}"><code>Gapjm.Chars.CharTable</code></a></li><li><a href="hecke.html#Gapjm.HeckeAlgebras.FactSchur"><code>Gapjm.HeckeAlgebras.FactSchur</code></a></li><li><a href="hecke.html#Gapjm.HeckeAlgebras.HeckeCoset"><code>Gapjm.HeckeAlgebras.HeckeCoset</code></a></li><li><a href="hecke.html#Gapjm.Chars.representation-Tuple{HeckeAlgebra, Integer}"><code>Gapjm.Chars.representation</code></a></li><li><a href="hecke.html#Gapjm.Chars.representations-Tuple{Union{HeckeAlgebra, HeckeCoset}}"><code>Gapjm.Chars.representations</code></a></li><li><a href="hecke.html#Gapjm.Garside.Î±-Tuple{HeckeTElt}"><code>Gapjm.Garside.Î±</code></a></li><li><a href="hecke.html#Gapjm.HeckeAlgebras.Tbasis-Tuple{HeckeAlgebra}"><code>Gapjm.HeckeAlgebras.Tbasis</code></a></li><li><a href="hecke.html#Gapjm.HeckeAlgebras.alt"><code>Gapjm.HeckeAlgebras.alt</code></a></li><li><a href="hecke.html#Gapjm.HeckeAlgebras.central_monomials"><code>Gapjm.HeckeAlgebras.central_monomials</code></a></li><li><a href="hecke.html#Gapjm.HeckeAlgebras.char_values"><code>Gapjm.HeckeAlgebras.char_values</code></a></li><li><a href="hecke.html#Gapjm.HeckeAlgebras.class_polynomials"><code>Gapjm.HeckeAlgebras.class_polynomials</code></a></li><li><a href="hecke.html#Gapjm.HeckeAlgebras.factorized_schur_element"><code>Gapjm.HeckeAlgebras.factorized_schur_element</code></a></li><li><a href="hecke.html#Gapjm.HeckeAlgebras.factorized_schur_elements"><code>Gapjm.HeckeAlgebras.factorized_schur_elements</code></a></li><li><a href="hecke.html#Gapjm.HeckeAlgebras.hecke-Tuple{HeckeCoset}"><code>Gapjm.HeckeAlgebras.hecke</code></a></li><li><a href="hecke.html#Gapjm.HeckeAlgebras.hecke-Union{Tuple{C}, Tuple{Group, Vector{&lt;:Vector{C}}}} where C"><code>Gapjm.HeckeAlgebras.hecke</code></a></li><li><a href="hecke.html#Gapjm.HeckeAlgebras.hecke-Tuple{Spets, HeckeAlgebra}"><code>Gapjm.HeckeAlgebras.hecke</code></a></li><li><a href="hecke.html#Gapjm.HeckeAlgebras.isrepresentation"><code>Gapjm.HeckeAlgebras.isrepresentation</code></a></li><li><a href="hecke.html#Gapjm.HeckeAlgebras.schur_elements"><code>Gapjm.HeckeAlgebras.schur_elements</code></a></li><li><a href="hecke.html#Gapjm.PermRoot.reflrep-Tuple{HeckeAlgebra}"><code>Gapjm.PermRoot.reflrep</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Gapjm.HeckeAlgebras" href="#Gapjm.HeckeAlgebras"><code>Gapjm.HeckeAlgebras</code></a> â€” <span class="docstring-category">Module</span></header><section><div><p>This   module  implements  Hecke  algebras  associated  to  finite  complex reflection  groups and arbitrary Coxeter  groups (these algebras are called Iwahori-Hecke  algebras  in  this  last  case),  and  also  implements  the character  tables, Schur elements and representations of Hecke algebras for finite  groups. For Iwahori-Hecke algebras  and <code>G(d,1,1)</code> this module also implements  the standard basis (look  at the module <code>KL</code>for Kazhdan-Lusztig bases).</p><p>Let  <code>(W,S)</code> be a Coxeter system where <code>mâ‚›â‚œ</code> is the order of <code>st</code> for <code>s,tâˆˆ S</code>. Let <code>R</code> be a commutative ring with 1 and for <code>sâˆˆ S</code> let <code>uâ‚›â‚€,uâ‚›â‚âˆˆ R</code> be elements which depend ony on the conjugacy class of <code>s</code> in <code>W</code> (this is the same  as requiring that <code>uâ‚›áµ¢=uâ‚œáµ¢</code> whenever <code>mâ‚›â‚œ</code> is odd). The Iwahori-Hecke algebra of <code>W</code> over <code>R</code> with parameters <code>uâ‚›áµ¢</code> is a deformation of the group algebra  of <code>W</code> over <code>R</code> defined as  follows: it is the unitary associative <code>R</code>-algebra generated by elements <code>Tâ‚›, sâˆˆ S</code> subject to the relations:</p><p><span>$(Tâ‚›-uâ‚›â‚€)(Tâ‚›-uâ‚›â‚)=0$</span> for all <code>sâˆˆ S</code> (the quadratic relations)</p><p><span>$Tâ‚›Tâ‚œTâ‚›â€¦= Tâ‚œTâ‚›Tâ‚œâ€¦$</span> with <code>mâ‚›â‚œ</code> factors on each side (the braid relations)</p><p>If  <code>uâ‚›â‚€=1</code> and  <code>uâ‚›â‚=-1</code> for  all <code>s</code>  then the quadratic relations become <code>Tâ‚›Â²=1</code> and the deformation of the group algebra is trivial.</p><p>Since  the generators <code>Tâ‚›</code> satisfy the  braid relations, the algebra <code>H</code> is in  fact a quotient of the group algebra of the braid group associated with <code>W</code>.  It follows that, if  <code>w=s_1â‹¯ s_m</code> is a  reduced expression of <code>w âˆˆ W</code> then  the product <code>Tâ‚›_1â‹¯ Tâ‚›_m</code>  depends only on <code>w</code>,  thus e will therefore denote  it by <code>T_w</code>. We have <code>T_1=1</code>;  if the <code>uâ‚›áµ¢</code> are indeterminates, the <code>{T_w}_{wâˆˆ  W}</code> form a basis of the  Hecke algebra which specializes to the canonical basis of the group algebra for <code>uâ‚›â‚€â†¦1</code> and <code>uâ‚›â‚â†¦-1</code>.</p><p>If  one of <code>uâ‚›â‚€</code> or <code>uâ‚›â‚</code> is invertible  in <code>R</code>, for example <code>uâ‚›â‚</code>, then by changing  the generators  to <code>Tâ€²â‚›=-Tâ‚›/uâ‚›â‚</code>,  and setting <code>qâ‚›=-uâ‚›â‚€/uâ‚›â‚</code>, the braid  relations do no change  (since when <code>mâ‚›â‚œ</code> is  odd we have <code>uâ‚›áµ¢=uâ‚œáµ¢</code>) but  the quadratic relations become  <code>(Tâ€²â‚›-qâ‚›)(Tâ€²â‚›+1)=0</code>. This last form is the  most common  form considered  in the  literature. Another common form, considered  in  the  context  of  Kazhdan-Lusztig  theory, is <code>uâ‚›â‚€=âˆšqâ‚›</code> and <code>uâ‚›â‚=-âˆšqâ‚›â»Â¹</code>.  The  form  provided,  with  two parameters per generator, be useful in many contexts like constructing the Jones polynomial.</p><p>For  some  algebras  the  character  table,  and in general Kazhdan-Lusztig bases,  require a square root of <code>-uâ‚›â‚€uâ‚›â‚</code>.  We provide a way to specify it with  the  field  <code>.rootpara</code>  which  can  be  provided  as  a keyword when constructing  the algebra. If not given,  a root is automatically extracted when needed by the function <code>RootParameter</code>. Note however that sometimes an explicit  choice of one of the two possible roots is necessary which cannot be automatically determined.</p><p>There  is a universal choice  for <code>R</code> and <code>uâ‚›áµ¢</code>:  Let <code>uâ‚›áµ¢:sâˆˆ S,iâˆˆ[0,1]</code> be indeterminates   such  that  <code>uâ‚›áµ¢=uâ‚œáµ¢</code>  whenever  <code>mâ‚›â‚œ</code>  is  odd,  and  let <code>A=â„¤[uâ‚›áµ¢]</code> be the corresponding polynomial ring. Then the Hecke algebra <code>H</code> of  <code>W</code> over a  with parameters <code>uâ‚›áµ¢</code>  is called the <em>generic Iwahori-Hecke algebra</em>  of  with  <code>W</code>.  Any  other  algebra  with parameters <code>vâ‚›áµ¢</code> can be obtained  by specialization from  <code>H</code>: There is  a unique ring homomorphism <code>f:A  â†’ R</code> such that <code>f(uâ‚›áµ¢)=vâ‚›áµ¢</code>  for all <code>i</code>. Then we  can view <code>R</code> as an <code>A</code>-module via <code>f</code> and we can identify the other algebra to <span>$RâŠ— _A H$</span>.</p><p>The  elements <code>{T_wâˆ£wâˆˆ W}</code> actually form an <code>R</code>-basis of <code>H</code> if for all <code>s</code> one  of the <code>uâ‚›áµ¢</code> is invertible. The  structure constants in that basis are obtained  as follows. To compute <code>T_vT_w</code>,  choose a reduced expression for <code>v</code>, say <code>v=s_1 â‹¯ s_k</code> and apply inductively the formula:</p><p><span>$T_sT_w=T_{sw}$</span>               if <code>l(sw)=l(w)+1</code></p><p><span>$T_sT_w=-uâ‚›â‚€uâ‚›â‚T_{sw}+(uâ‚›â‚€+uâ‚›â‚)T_w$</span> if <code>l(sw)=l(w)-1</code>.</p><p>If  for all <code>s</code>  we have <code>uâ‚›â‚€=q</code>,  <code>uâ‚›â‚=-1</code> then we  call the corresponding algebra the one-parameter or Spetsial Iwahori-Hecke algebra associated with <code>W</code>. Certain invariants  of the  irreducible characters  of this  algebra play a special role  in the representation theory of the underlying finite Coxeter groups, namely  the <code>a</code>- and <code>A</code>-invariants.  For basic properties of Iwahori-Hecke algebras  and their relevance to the representation theory of finite groups of Lie type, see for example Curtis and Reiner 1987, Sections~67 and 68.</p><p>In  the  following  example,  we  compute  the multiplication table for the <code>0</code>-Iwahoriâ€“Hecke algebra associated with the Coxeter group of type <code>A_2</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,2)
Aâ‚‚

julia&gt; H=hecke(W,0)            # One-parameter algebra with `q=0`
hecke(Aâ‚‚,0)

julia&gt; T=Tbasis(H);            # Create the `T` basis

julia&gt; b=T.(elements(W))       # the basis
6-element Vector{HeckeTElt{Perm{Int16}, Int64, HeckeAlgebra{Int64, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 T.
 Tâ‚‚
 Tâ‚
 Tâ‚‚â‚
 Tâ‚â‚‚
 Tâ‚â‚‚â‚

julia&gt; b*permutedims(b)       # multiplication table
6Ã—6 Matrix{HeckeTElt{Perm{Int16}, Int64, HeckeAlgebra{Int64, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 T.    Tâ‚‚     Tâ‚     Tâ‚‚â‚    Tâ‚â‚‚    Tâ‚â‚‚â‚
 Tâ‚‚    -Tâ‚‚    Tâ‚‚â‚    -Tâ‚‚â‚   Tâ‚â‚‚â‚   -Tâ‚â‚‚â‚
 Tâ‚    Tâ‚â‚‚    -Tâ‚    Tâ‚â‚‚â‚   -Tâ‚â‚‚   -Tâ‚â‚‚â‚
 Tâ‚‚â‚   Tâ‚â‚‚â‚   -Tâ‚‚â‚   -Tâ‚â‚‚â‚  -Tâ‚â‚‚â‚  Tâ‚â‚‚â‚
 Tâ‚â‚‚   -Tâ‚â‚‚   Tâ‚â‚‚â‚   -Tâ‚â‚‚â‚  -Tâ‚â‚‚â‚  Tâ‚â‚‚â‚
 Tâ‚â‚‚â‚  -Tâ‚â‚‚â‚  -Tâ‚â‚‚â‚  Tâ‚â‚‚â‚   Tâ‚â‚‚â‚   -Tâ‚â‚‚â‚</code></pre><p>Thus,  we work  with algebras  with arbitrary  parameters. We will see that this also works on the level of characters and representations.</p><p>For  general complex reflection  groups, the picture  is similar. The Hecke algebras  are deformations  of the  group algebras,  generalizing those for real reflection groups.</p><p>The  definition is  as a  quotient of  the algebra  of the  braid group. We assume  now that <code>W</code> is  a <em>finite</em> reflection group  in the complex vector space  <code>V</code>. The <em>braid group</em> associated  is the fundamental group <code>Î â‚</code> of the  space Â <span>$(V-\bigcup_{H\in\mathcal H}  H)/W$</span>, where <span>$\mathcal H$</span> is  the set of  reflecting hyperplanes of  <code>W</code>. This group  is generated by <em>braid reflections</em>, elements which by the natural map from the braid group to  the reflection  group project  to distinguished  reflections. The braid reflections   which  project  to  a  given  <code>W</code>-orbit  of  reflections  are conjugate.  Let <code>ğ¬</code> be a representative of  such a conjugacy class of braid reflections,  let <code>e</code>  be the  order of  the image  of <code>ğ¬</code>  in <code>W</code>, and let <span>$u_{ğ¬,0},â€¦,u_{ğ¬,e-1}$</span> be indeterminates. The generic Hecke algebra is the <span>$â„¤[u_{ğ¬,i}^{Â±  1}]_{ğ¬,i}$</span>-algebra quotient of the  braid group algebra by the  relations  <span>$(ğ¬-u_{ğ¬,0})â€¦(ğ¬-u_{ğ¬,e-1})=0$</span>,  and  in  general an Hecke algebra  is any algebra obtained from  this generic algebra by specializing some of the parameters.</p><p>The  Hecke algebras  can be  explictely described  by a presentation of the braid  group. The braid group can  be presented by homogeneous relations in the   braid   reflections,   called   <em>braid   relations</em>,   described   in <a href="biblio.htm#BMR98">BrouÃ©-Malle-Rouquier     1998</a>     and    <a href="biblio.htm#BM03">Bessis-Michel 2003</a>  (some were  obtained using  the VKCURVE  package of GAP3,  ported also  to Julia).  Further, these  presentations are such that the reflection  group  is  presented  by  the  same  relations,  plus relations describing  the  order  of  the  generating  reflections, called the <em>order relations</em>.  This  allows  to  define  the  Hecke algebra by a presentation similar  to  that  of  <code>W</code>,  with  the  same  braid relations but the order relations  replaced by a deformed version. </p><p>If  <code>SâŠ‚ W</code>  is the  set of  distinguished reflections  of <code>W</code> which lift to generating  braid reflections <code>ğ¬</code> in the braid group, we define the generic Hecke  algebra as follows: for each conjugacy  class of an <code>s</code> of order <code>e</code> we take indeterminates <code>uâ‚›â‚€,â€¦,uâ‚›â‚‘â‚‹â‚</code>, and consider the <span>$â„¤[uâ‚›áµ¢^{Â±1}]â‚›áµ¢$</span>-algebra  <code>H</code>  with  generators  <code>T_s</code>  for  each  <code>sâˆˆ  S</code> presented   by  the  braid  relations  and  the  deformed  order  relations <span>$(T_s-u_{ğ¬,0})â€¦(T_s-u_{ğ¬,e-1})=0$</span>.</p><p>Ariki,  Koike and Malle have computed the  character table of some of these algebras,  including  those  for  all  2-dimensional reflection groups, see <a href="biblio.htm#BM93">BrouÃ©-Malle 1993</a> and <a href="biblio.htm#Mal96">Malle 1996</a>; our data  has models of  all representation and  character tables for real reflection  groups; it  contains the  same for  imprimitive groups  and for primitive groups of dimension 2 and 3 (these last representations have been computed  in <a href="biblio.htm#MM10">Malle-Michel 2010</a>) and contains also models and  character tables computed by Michel  for <code>Gâ‚‚â‚‰</code> and <code>Gâ‚ƒâ‚ƒ</code>; it constains also  partial lists of representations and partial character tables for the remaining groups <code>Gâ‚ƒâ‚,Gâ‚ƒâ‚‚</code> and <code>Gâ‚ƒâ‚„</code>, computed by Michel.</p><p>The quotient of the Hecke algebra obtained by specializing <span>$u_{ğ¬,i}â†¦ Î¶â‚‘â±$</span> is  isomorphic to the group algebra of <code>W</code>. It was conjectured for 20 years that  over a splitting ring  the Hecke algebra is  itself isomorphic to the group  algebra of  <code>W</code> over  the same  ring. This  was called  the freeness conjecture since the main problem is to show that the Hecke algebra is free of dimension <code>|W|</code>. This has finally been proved in 2019 thanks to the work of many people including Marin, Pfeiffer and Chavli for exceptional groups. Along  the way it has been proven that there exists a set <code>{b_w}_{wâˆˆ W}</code> of elements  of the Braid group such that <code>b_1=1</code> and <code>b_w</code> maps to <code>w</code> by the natural  quotient map,  such that  their images  <code>T_w</code> form  a basis of the Hecke algebra.</p><p>It  is  conjectured  that  such  a  basis  <code>T_w</code>  can  be  chosen such that additionnaly  the  linear  form  <code>t</code>  defined  by  <code>t(T_w)=0</code> if <code>wâ‰  1</code> and <code>t(1)=1</code> is a symmetrizing form for the symmetric algebra <code>H</code>. This is well known  for all real reflection groups  and has been proved in <a href="biblio.htm#MM98">Malle-Mathas 1998</a>   for   imprimitive   reflection   groups   and   in <a href="biblio.htm#MM10">Malle-Michel 2010</a> for some primitive groups of dimension 2  and  3.  Chlouveraki  and  Chavli  have handled some other 2-dimensional cases.  For  each  irreducible  character  <code>Ï†</code>  of <code>H</code> we define the <em>Schur element</em>  <code>Sáµ©</code> associated to <code>Ï†</code> by the  condition that for any element <code>T</code> of  <code>H</code> we have <code>t(T)=âˆ‘áµ© Ï†(T)/Sáµ©</code>. It  can be shown that the Schur elements are  Laurent polynomials, and they  do not depend on  the choice of a basis having  the above  property. Malle  has the  computed these Schur elements, assuming the above conjecture; they are in the Chevie data.</p><p>See the function <code>hecke</code> for various ways of specifying the parameters of a Hecke   algebra.  Look  also  at   the  docstrings  of  <code>central_monomials, char_values,    class_polynomials,    schur_elements,    isrepresentations, factorized_schur_elements</code>,  and  at  the  methods  for  Hecke  algebras of <code>CharTable, representations, reflrep</code>.</p><p>finally, benchmarks on julia 1.8</p><pre><code class="language-benchmark hljs">julia&gt; function test_w0(n)
         W=coxgroup(:A,n)
         Tbasis(hecke(W,Pol(:q)))(longest(W))^2
       end
test_w0 (generic function with 1 method)

julia&gt; @btime test_w0(7);
   97.210 ms (1776476 allocations: 127.52 MiB)</code></pre><p>in GAP3 the following function takes 920ms</p><pre><code class="nohighlight hljs">test_w0:=function(n)local W,T,H;
  W:=CoxeterGroup(&quot;A&quot;,n);H:=Hecke(W,X(Rationals));T:=Basis(H,&quot;T&quot;);
  T(LongestCoxeterWord(W))^2;
end;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/3b53d0f4c72f407ebafb3ea0229d9669c036252f/src/HeckeAlgebras.jl#L1-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.HeckeAlgebras.hecke-Union{Tuple{C}, Tuple{Group, Vector{&lt;:Vector{C}}}} where C" href="#Gapjm.HeckeAlgebras.hecke-Union{Tuple{C}, Tuple{Group, Vector{&lt;:Vector{C}}}} where C"><code>Gapjm.HeckeAlgebras.hecke</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p><code>hecke( W [, parameter];rootpara=r)</code></p><p>Hecke  algebra for the complex reflection group or Coxeter group <code>W</code>. If no <code>parameter</code> is given, <code>1</code> is assumed which gives the group algebra of <code>W</code>.</p><p>The  following  forms  are  accepted  for  <code>parameter</code>: if <code>parameter</code> is a scalar,  it is  replaced by  <code>fill(parameter,ngens(W))</code>. If  it is a vector with   one  entry,  it   is  replaced  with  <code>fill(parameter[1],ngens(W))</code>. Otherwise,  <code>parameter</code> should be  a list of  length <code>ngens(W)</code>. Entries of <code>parameter</code>  corresponding to  the same  <code>W</code>-orbit of  generators should be identical.</p><p>Finally,  if <code>parameter</code> is a <code>Tuple</code>, the  tuple should have as many entry as  there are hyperplane  orbits in <code>W</code>  and each entry  will represent the parameter for the corresponding conjugacy class of braid reflections.</p><p>An  entry in  <code>parameter</code> for  a reflection  of order  <code>e</code> can  be either a single scalar value or a <code>Vector</code> of length &#39;e&#39;. If it is a <code>Vector</code>, it is interpreted as the list <code>[uâ‚€,â€¦,u_(e-1)]</code> of parameters for that reflection. If  it is a single  value <code>q</code>, it is  interpreted as the partly specialized list  of  parameters  <code>[q,Î¶_e,â€¦,Î¶_{e-1}]</code>  (thus  as  <code>[q,-1]</code>  for Coxeter groups).</p><p>The printing of a Hecke algebra is abbreviated using the same conventions.</p><p>Computing characters or representations of Hecke algebra needs sometimes to extract  roots of the  parameters. These roots  are extracted automatically (when  possible). For Coxeter groups it  is possible to give explicit roots by  giving a keyword argument <code>rootpara</code>:  it should be a vector containing at the <code>i</code>-th position a square root of <code>-parameter[i][1]*parameter[i][2]</code>; if <code>rootpara</code> is a scalar it is replaced by <code>fill(rootpara,ngens(W))</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:B,2)
Bâ‚‚

julia&gt; @Pol q
Pol{Int64}: q

julia&gt; H=hecke(W,q)
hecke(Bâ‚‚,q)

julia&gt; H.para
2-element Vector{Vector{Pol{Int64}}}:
 [q, -1]
 [q, -1]

julia&gt; H=hecke(W,q^2,rootpara=q)
hecke(Bâ‚‚,qÂ²,rootpara=q)

julia&gt; H.para,rootpara(H)
(Vector{Pol{Int64}}[[qÂ², -1], [qÂ², -1]], Pol{Int64}[q, q])

julia&gt; H=hecke(W,[q^2,q^4],rootpara=[q,q^2])
hecke(Bâ‚‚,Pol{Int64}[qÂ², qâ´],rootpara=Pol{Int64}[q, qÂ²])

julia&gt; H.para,rootpara(H)
(Vector{Pol{Int64}}[[qÂ², -1], [qâ´, -1]], Pol{Int64}[q, qÂ²])

julia&gt; H=hecke(W,9,rootpara=3)
hecke(Bâ‚‚,9,rootpara=3)

julia&gt; H.para,rootpara(H)
([[9, -1], [9, -1]], [3, 3])

julia&gt; @Mvp x,y,z,t

julia&gt; H=hecke(W,[[x,y]])
hecke(Bâ‚‚,Vector{Mvp{Int64, Int64}}[[x, y]])

julia&gt; H.para,rootpara(H)
(Vector{Mvp{Int64, Int64}}[[x, y], [x, y]], Mvp{Cyc{Int64}, Rational{Int64}}[Î¶â‚„xÂ½yÂ½, Î¶â‚„xÂ½yÂ½])

julia&gt; H=hecke(W,[[x,y],[z,t]])
hecke(Bâ‚‚,Vector{Mvp{Int64, Int64}}[[x, y], [z, t]])

julia&gt; H.para,rootpara(H)
(Vector{Mvp{Int64, Int64}}[[x, y], [z, t]], Mvp{Cyc{Int64}, Rational{Int64}}[Î¶â‚„xÂ½yÂ½, Î¶â‚„tÂ½zÂ½])

julia&gt; hecke(coxgroup(:F,4),(q,q^2)).para
4-element Vector{Vector{Pol{Int64}}}:
 [q, -1]
 [q, -1]
 [qÂ², -1]
 [qÂ², -1]

julia&gt; hecke(complex_reflection_group(3,1,2),q).para
2-element Vector{Vector{Pol{Cyc{Int64}}}}:
 [q, Î¶â‚ƒ, Î¶â‚ƒÂ²]
 [q, -1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/3b53d0f4c72f407ebafb3ea0229d9669c036252f/src/HeckeAlgebras.jl#L225-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.HeckeAlgebras.Tbasis-Tuple{HeckeAlgebra}" href="#Gapjm.HeckeAlgebras.Tbasis-Tuple{HeckeAlgebra}"><code>Gapjm.HeckeAlgebras.Tbasis</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p><code>Tbasis(H::HeckeAlgebra)</code> The  <code>T</code> basis of  <code>H</code>. It is  defined currently for Iwahori-Hecke algebras and for Hecke algebras of cyclic complex reflection groups.</p><pre><code class="language-julia-repl hljs">julia&gt; H=hecke(coxgroup(:A,2),Pol(:q))
hecke(Aâ‚‚,q)

julia&gt; T=Tbasis(H);T(longest(H.W))^2
qÂ³T.+(qÂ³-2qÂ²+q)Tâ‚‚â‚+(qÂ³-qÂ²)Tâ‚‚+(qÂ³-qÂ²)Tâ‚+(qÂ³-2qÂ²+2q-1)Tâ‚â‚‚â‚+(qÂ³-2qÂ²+q)Tâ‚â‚‚

julia&gt; W=crg(3,1,1)
Gâ‚ƒâ€šâ‚â€šâ‚

julia&gt; H=hecke(crg(3,1,1),Pol(:q))
hecke(Gâ‚ƒâ€šâ‚â€šâ‚,q)

julia&gt; T=Tbasis(H);T(W(1))^3
(q-1)T.+(q-1)Tâ‚+qTâ‚â‚</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/3b53d0f4c72f407ebafb3ea0229d9669c036252f/src/HeckeAlgebras.jl#L755-L776">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.HeckeAlgebras.alt" href="#Gapjm.HeckeAlgebras.alt"><code>Gapjm.HeckeAlgebras.alt</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p><code>alt(a::HeckeTElt)</code></p><p><code>a</code> should be an element of an Iwahori-Hecke algebra <code>H</code>. the involution on <code>H</code>   defined  by  <code>xâ†¦  bar(x)</code>   on  coefficients  and  <code>Tâ‚›â†¦  uâ‚›,â‚€uâ‚›,â‚Tâ‚›</code>. Essentially it corresponds to tensoring with the sign representation.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2);H=hecke(W,Pol(:q))
hecke(Gâ‚‚,q)

julia&gt; T=Tbasis(H);h=T(1,2)*T(2,1)
qÂ²T.+(qÂ²-q)Tâ‚+(q-1)Tâ‚â‚‚â‚

julia&gt; alt(h)
qâ»Â²T.+(qâ»Â²-qâ»Â³)Tâ‚+(qâ»Â³-qâ»â´)Tâ‚â‚‚â‚</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/3b53d0f4c72f407ebafb3ea0229d9669c036252f/src/HeckeAlgebras.jl#L862-L879">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Garside.Î±-Tuple{HeckeTElt}" href="#Gapjm.Garside.Î±-Tuple{HeckeTElt}"><code>Gapjm.Garside.Î±</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p><code>Î±(a::HeckeTElt)</code></p><p>the anti-involution on the Hecke algebra defined by <code>T_wâ†¦T_inv(w)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/3b53d0f4c72f407ebafb3ea0229d9669c036252f/src/HeckeAlgebras.jl#L885-L889">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Chars.CharTable-Tuple{HeckeAlgebra}" href="#Gapjm.Chars.CharTable-Tuple{HeckeAlgebra}"><code>Gapjm.Chars.CharTable</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p><code>CharTable(H::HeckeAlgebra or HeckeCoset)</code></p><p>returns  the <code>CharTable</code> of  <code>H</code>. For the  primitive groups <code>Gâ‚ƒâ‚, Gâ‚ƒâ‚‚, Gâ‚ƒâ‚„</code> there are <code>Unknown()</code> entries corresponding to missing representations (see <a href="chars.html#Gapjm.Chars.representation-Tuple{Union{Spets, FiniteCoxeterGroup, PermRootGroup}, Integer}"><code>representation</code></a>).</p><pre><code class="language-julia-repl hljs">julia&gt; H=hecke(crg(4),Pol())
hecke(Gâ‚„,q)

julia&gt; CharTable(H)
CharTable(hecke(Gâ‚„,q))
    â”‚.    z 212   12    z12     1        1z
â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Ï†â‚â€šâ‚€â”‚1   qâ¶  qÂ³   qÂ²     qâ¸     q        qâ·
Ï†â‚â€šâ‚„â”‚1    1   1  Î¶â‚ƒÂ²    Î¶â‚ƒÂ²    Î¶â‚ƒ        Î¶â‚ƒ
Ï†â‚â€šâ‚ˆâ”‚1    1   1   Î¶â‚ƒ     Î¶â‚ƒ   Î¶â‚ƒÂ²       Î¶â‚ƒÂ²
Ï†â‚‚â€šâ‚…â”‚2   -2   .    1     -1    -1         1
Ï†â‚‚â€šâ‚ƒâ”‚2 -2qÂ³   . Î¶â‚ƒÂ²q -Î¶â‚ƒÂ²qâ´ q+Î¶â‚ƒÂ² -qâ´-Î¶â‚ƒÂ²qÂ³
Ï†â‚‚â€šâ‚â”‚2 -2qÂ³   .  Î¶â‚ƒq  -Î¶â‚ƒqâ´  q+Î¶â‚ƒ  -qâ´-Î¶â‚ƒqÂ³
Ï†â‚ƒâ€šâ‚‚â”‚3  3qÂ²  -q    .      .   q-1     qÂ³-qÂ²</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/3b53d0f4c72f407ebafb3ea0229d9669c036252f/src/HeckeAlgebras.jl#L414-L437">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.HeckeAlgebras.central_monomials" href="#Gapjm.HeckeAlgebras.central_monomials"><code>Gapjm.HeckeAlgebras.central_monomials</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p><code>central_monomials(H)</code></p><p>Let  <code>H</code>  be  an  Hecke  algebra  for  the finite reflection group <code>W</code>. The function  returns the scalars by which the image  in <code>H</code> of <code>Ï€</code> acts on the irreducible representations of <code>H</code>.</p><p>When  <code>W</code> is irreducible,  <code>Ï€</code> is the  generator of the  center of the pure braid  group.  In  general,  it  is  the  product of such elements for each irreducible  component. When  <code>W</code> is  a Coxeter  group, the  image of  Ï€ in <code>H</code> is <span>$T_{w_0}^2$</span>.</p><pre><code class="language-julia-repl hljs">julia&gt; H=hecke(coxgroup(:H,3),Pol(:q))
hecke(Hâ‚ƒ,q)

julia&gt; central_monomials(H)
10-element Vector{Pol{Cyc{Int64}}}:
 1  
 qÂ³â°
 qÂ¹Â²
 qÂ¹â¸
 qÂ¹â°
 qÂ¹â°
 qÂ²â°
 qÂ²â°
 qÂ¹âµ
 qÂ¹âµ</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/3b53d0f4c72f407ebafb3ea0229d9669c036252f/src/HeckeAlgebras.jl#L652-L681">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.HeckeAlgebras.class_polynomials" href="#Gapjm.HeckeAlgebras.class_polynomials"><code>Gapjm.HeckeAlgebras.class_polynomials</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p><code>class_polynomials(h::HeckeElt)</code></p><p>returns  the  class  polynomials  of  the  element <code>h</code> of the Iwahori-Hecke algebra  or Hecke coset <code>H=h.H</code> with respect to the <code>T</code> basis for a set <code>R</code> of  representatives  of  minimal  length  in  the  conjugacy classes of the Coxeter  group <code>W=H.W</code>.  Such minimal  length representatives  are given by <code>representative.(conjugacy_classes(W))</code>.    The   vector   <code>p</code>   of   these polynomials has the property that if <code>X</code> is the matrix of the values of the irreducible characters of <code>H</code> on <code>T_w</code> (for <code>wâˆˆ R</code>), then the product <code>X*p</code> is the list of values of the irreducible characters on <code>h</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=CoxSym(4)
ğ”– â‚„

julia&gt; H=hecke(W,Pol(:q))
hecke(ğ”– â‚„,q)

julia&gt; h=Tbasis(H,longest(W))
Tâ‚â‚‚â‚â‚ƒâ‚‚â‚

julia&gt; p=class_polynomials(h)
5-element Vector{Pol{Int64}}:
 0        
 0        
 qÂ²       
 qÂ³-2qÂ²+q 
 qÂ³-qÂ²+q-1</code></pre><p>The class polynomials were introduced in <a href="biblio.htm#GP93">Geck-Pfeiffer1993</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/3b53d0f4c72f407ebafb3ea0229d9669c036252f/src/HeckeAlgebras.jl#L892-L923">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.HeckeAlgebras.char_values" href="#Gapjm.HeckeAlgebras.char_values"><code>Gapjm.HeckeAlgebras.char_values</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p><code>char_values(h::HeckeTElt)</code></p><p><code>h</code> is an element of an Iwahori-Hecke algebra <code>H</code>. The function returns the values  of the irreducible characters of <code>H</code>  on <code>h</code> (the method used is to convert to the <code>T</code> basis, and then use <code>class_polynomials</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:B,2)
Bâ‚‚

julia&gt; H=hecke(W,q^2;rootpara=q)
hecke(Bâ‚‚,qÂ²,rootpara=q)

julia&gt; char_values(Cpbasis(H)(1,2,1))
5-element Vector{Pol{Int64}}:
 -q-qâ»Â¹        
 q+qâ»Â¹         
 0             
 qÂ³+2q+2qâ»Â¹+qâ»Â³
 0             </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/3b53d0f4c72f407ebafb3ea0229d9669c036252f/src/HeckeAlgebras.jl#L978-L1000">source</a></section><section><div><p><code>char_values(H::HeckeAlgebra,v::Vector{&lt;:Integer})</code></p><p>For an Iwahori-Hecke algebra this computes the character values of <code>H</code> on the <code>Tbasis(H)(v)</code>.</p><p>For  <code>H</code> the Hecke algebra  of a complex reflection  group <code>W</code> this routine computes  character values on a  lift of the element  of <code>W</code> defined by the word <code>v</code> in <code>gens(W)</code>.</p><p>For  complex reflection  groups the  character table  of the  generic Hecke algebra  of  <code>W</code>  has  been  computed  (not  entirely for 3 exceptions, see <code>representation</code>)  in the  sense that,  if <code>sâ‚,â€¦,sâ‚™</code>  are generators of the braid  group lifting  the BrouÃ©-Malle-Rouquier-Bessis-Michel  generators of <code>W</code>,  there is at least one element <code>v</code>  in each conjugacy class of <code>W</code> and one  expression in the generators for it  such that the character values of the  image <code>Táµ¥</code>  in the  Hecke algebra  of the  lift to the braid group are known.  Such an expression in the generators  will be called a <em>known</em> word (the  list of known words  is obtained by <code>word.(conjugacy_classes(W))</code>. If the  word <code>v</code> is known, the computation is quick using the character table. If  not,  the  function  computes  the  trace  of  <code>Táµ¥</code> in each irreducible representation.   The   values   returned   are   <code>Unknown()</code>  for  missing representations (see <code>representation</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; W=crg(4)
Gâ‚„

julia&gt; H=hecke(W,Pol(:q))
hecke(Gâ‚„,q)

julia&gt; char_values(H,[2,1,2])
7-element Vector{Pol{Cyc{Int64}}}:
 qÂ³
 1
 1
 0
 0
 0
 -q</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/3b53d0f4c72f407ebafb3ea0229d9669c036252f/src/HeckeAlgebras.jl#L1003-L1043">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.HeckeAlgebras.schur_elements" href="#Gapjm.HeckeAlgebras.schur_elements"><code>Gapjm.HeckeAlgebras.schur_elements</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p><code>schur_elements(H)</code></p><p>returns the list of Schur elements for the Hecke algebra <code>H</code></p><pre><code class="language-julia-repl hljs">julia&gt; H=hecke(complex_reflection_group(4),Pol(:q))
hecke(Gâ‚„,q)

julia&gt; s=schur_elements(H)
7-element Vector{Pol{Cyc{Rational{Int64}}}}:
 qâ¸+2qâ·+3qâ¶+4qâµ+4qâ´+4qÂ³+3qÂ²+2q+1              
 2âˆš-3+(6+4âˆš-3)qâ»Â¹+12qâ»Â²+(6-4âˆš-3)qâ»Â³-2âˆš-3qâ»â´
 -2âˆš-3+(6-4âˆš-3)qâ»Â¹+12qâ»Â²+(6+4âˆš-3)qâ»Â³+2âˆš-3qâ»â´
 2+2qâ»Â¹+4qâ»Â²+2qâ»Â³+2qâ»â´
 Î¶â‚ƒÂ²âˆš-3qÂ³+(3-âˆš-3)qÂ²+3q+3+âˆš-3-Î¶â‚ƒâˆš-3qâ»Â¹
 -Î¶â‚ƒâˆš-3qÂ³+(3+âˆš-3)qÂ²+3q+3-âˆš-3+Î¶â‚ƒÂ²âˆš-3qâ»Â¹
 qÂ²+2q+2+2qâ»Â¹+qâ»Â²

julia&gt; CycPol.(s)
7-element Vector{CycPol{Cyc{Rational{Int64}}}}:
 Î¦â‚‚Â²Î¦â‚ƒÎ¦â‚„Î¦â‚†
 2âˆš-3qâ»â´Î¦â‚‚Â²Î¦â€²â‚ƒÎ¦â€²â‚†
 -2âˆš-3qâ»â´Î¦â‚‚Â²Î¦â€³â‚ƒÎ¦â€³â‚†
 2qâ»â´Î¦â‚ƒÎ¦â‚„
 Î¶â‚ƒÂ²âˆš-3qâ»Â¹Î¦â‚‚Â²Î¦â€²â‚ƒÎ¦â€³â‚†
 -Î¶â‚ƒâˆš-3qâ»Â¹Î¦â‚‚Â²Î¦â€³â‚ƒÎ¦â€²â‚†
 qâ»Â²Î¦â‚‚Â²Î¦â‚„</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/3b53d0f4c72f407ebafb3ea0229d9669c036252f/src/HeckeAlgebras.jl#L1064-L1093">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.HeckeAlgebras.factorized_schur_element" href="#Gapjm.HeckeAlgebras.factorized_schur_element"><code>Gapjm.HeckeAlgebras.factorized_schur_element</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p><code>factorized_schur_element(H,phi)</code></p><p>returns  the factorized <code>schur_element</code>  (see <code>factorized_schur_elements</code>) of the  Hecke algebra  <code>H</code> for  the irreducible  character of <code>H</code> of parameter <code>phi</code> (see <code>charinfo(W).charparams</code>)</p><pre><code class="language-julia-repl hljs">julia&gt; W=complex_reflection_group(4)
Gâ‚„

julia&gt; @Mvp x,y; H=hecke(W,[[1,x,y]])
hecke(Gâ‚„,Vector{Mvp{Int64, Int64}}[[1, x, y]])

julia&gt; factorized_schur_element(H,[[2,5]])
-xâ»Â¹yÎ¦â‚‚(xy)Î¦â‚(x)Î¦â‚†(xyâ»Â¹)Î¦â‚(y)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/3b53d0f4c72f407ebafb3ea0229d9669c036252f/src/HeckeAlgebras.jl#L1286-L1303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.HeckeAlgebras.factorized_schur_elements" href="#Gapjm.HeckeAlgebras.factorized_schur_elements"><code>Gapjm.HeckeAlgebras.factorized_schur_elements</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p><code>factorized_schur_elements(H)</code></p><p>Let  <code>H</code> be  a Hecke  algebra for  the complex  reflection group <code>W</code>, whose parameters are all (Laurent) monomials in some variables <code>xâ‚,â€¦,xâ‚™</code>, and let K  be the field of definition of <code>W</code>. Then Maria Chlouveraki has shown that the  Schur elements of <code>H</code> take the  particular form <code>M âˆáµ© Ï†(Máµ©)</code> where <code>Ï†</code> runs  over  a  list  of  K-cyclotomic  polynomials,  and  <code>M</code>  and <code>Máµ©</code> are (Laurent)  monomials (in possibly some  fractional powers) of the variables <code>xáµ¢</code>.  The  function  <code>factorized_schur_elements</code>  returns a data structure (see <code>HeckeAlgebras.FactSchur</code>) which shows this factorization.</p><pre><code class="language-julia-repl hljs">julia&gt; W=complex_reflection_group(4)
Gâ‚„

julia&gt; @Mvp x,y; H=hecke(W,[[1,x,y]])
hecke(Gâ‚„,Vector{Mvp{Int64, Int64}}[[1, x, y]])

julia&gt; factorized_schur_elements(H)
7-element Vector{Gapjm.HeckeAlgebras.FactSchur}:
 xâ»â´yâ»â´Î¦â‚‚(xy)Î¦â‚Î¦â‚†(x)Î¦â‚Î¦â‚†(y)
 Î¦â‚‚(xÂ²yâ»Â¹)Î¦â‚Î¦â‚†(x)Î¦â‚Î¦â‚†(xyâ»Â¹)
 -xâ»â´yâµÎ¦â‚Î¦â‚†(xyâ»Â¹)Î¦â‚‚(xyâ»Â²)Î¦â‚Î¦â‚†(y)
 -xâ»Â¹yÎ¦â‚‚(xy)Î¦â‚(x)Î¦â‚†(xyâ»Â¹)Î¦â‚(y)
 -xâ»â´yÎ¦â‚‚(xÂ²yâ»Â¹)Î¦â‚(x)Î¦â‚(xyâ»Â¹)Î¦â‚†(y)
 xâ»Â¹yâ»Â¹Î¦â‚†(x)Î¦â‚(xyâ»Â¹)Î¦â‚‚(xyâ»Â²)Î¦â‚(y)
 xâ»Â²yÎ¦â‚‚(xÂ²yâ»Â¹)Î¦â‚‚(xy)Î¦â‚‚(xyâ»Â²)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/3b53d0f4c72f407ebafb3ea0229d9669c036252f/src/HeckeAlgebras.jl#L1314-L1343">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.HeckeAlgebras.FactSchur" href="#Gapjm.HeckeAlgebras.FactSchur"><code>Gapjm.HeckeAlgebras.FactSchur</code></a> â€” <span class="docstring-category">Type</span></header><section><div><p>A  <code>FactSchur</code> representing  a Schur  element of  the form  <code>Mâˆáµ©Ï†(Máµ©)</code> is a <code>struct</code>  with a field <code>factor</code>  which holds the monomial  <code>M</code>, and a field <code>vcyc</code>  which holds a  list of <code>NamedTuples</code>  describing each factor in the product.  An  element  of  <code>vcyc</code>  representing  a term <code>Ï†(Máµ©)</code> is itself a <code>struct</code>  with fields  <code>monomial</code> holding  <code>Máµ©</code> (as  an <code>Mvp</code> with a single term),  and a  field <code>pol</code>  holding a  <code>CycPol</code> (see <code>CycPol</code>) representing <code>Ï†</code>.</p><p>A few operations are implemented for <code>FactSchur</code>, like <code>*, lcm</code>. They can be evaluated partially or completely keeping as much as possible the factored form.</p><pre><code class="language-julia-repl hljs">julia&gt; @Mvp x,y; W=crg(4); H=hecke(W,[[1,x,y]])
hecke(Gâ‚„,Vector{Mvp{Int64, Int64}}[[1, x, y]])

julia&gt; p=factorized_schur_element(H,[[2,5]])
-xâ»Â¹yÎ¦â‚‚(xy)Î¦â‚(x)Î¦â‚†(xyâ»Â¹)Î¦â‚(y)

julia&gt; q=p(;x=E(3)) # partial evaluation
Î¶â‚ƒÂ²âˆš-3yâ»Â¹Î¦â‚Î¦â‚‚Î¦â€²â‚†Â²(y)

julia&gt; q(;y=2//1)
-9âˆš-3/2</code></pre><p>In contrast, the next operation expands <code>p</code> to an <code>Mvp</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; HeckeAlgebras.expand(p)
Mvp{Cyc{Rational{Int64}},Rational{Int64}}: -xÂ³y+xÂ³+xÂ²yÂ²-2xÂ²+xÂ²yâ»Â¹-xyÂ³+2xy-xyâ»Â¹+yÂ³-2yÂ²+1+xâ»Â¹yÂ²-xâ»Â¹y</code></pre><p>julia-repl</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/3b53d0f4c72f407ebafb3ea0229d9669c036252f/src/HeckeAlgebras.jl#L1098-L1131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Chars.representation-Tuple{HeckeAlgebra, Integer}" href="#Gapjm.Chars.representation-Tuple{HeckeAlgebra, Integer}"><code>Gapjm.Chars.representation</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p><code>representation(H::HeckeAlgebra or HeckeCoset,i)</code></p><p>returns,  for the <code>i</code>-th irreducible representation of the Hecke algebra or Hecke  coset <code>H</code>, a list  of matrices images of  the generators of <code>H</code> in a model of the representation (for Hecke cosets, the result is a <code>NamedTuple</code> with fields <code>gens</code>, a representation of <code>hecke(H)</code>, and <code>F</code>, the matrix for the automorphism of <code>H</code> in the representation).</p><p>This  function  is  based  on  the  classification,  and  is  not yet fully implemented for the Hecke algebras of the groups <code>Gâ‚ƒâ‚</code>, <code>Gâ‚ƒâ‚‚</code> and <code>Gâ‚ƒâ‚„</code>: we have 50 representations out of 59 for type <code>Gâ‚ƒâ‚</code>, 30 representations out of 102  for  type  <code>Gâ‚ƒâ‚‚</code>  and  38  representations  out of 169 for type <code>Gâ‚ƒâ‚„</code>; <code>nothing</code> is returned for a missing representation.</p><pre><code class="language-julia-repl hljs">julia&gt; W=crg(24)
Gâ‚‚â‚„

julia&gt; H=hecke(W,Pol(:q))
hecke(Gâ‚‚â‚„,q)

julia&gt; representation(H,3)
3-element Vector{Matrix{Pol{Cyc{Int64}}}}:
 [q 0 0; -q -1 0; -q 0 -1]
 [-1 0 -1; 0 -1 ((1-âˆš-7)/2)q; 0 0 q]
 [-1 -1 0; 0 q 0; 0 (1+âˆš-7)/2 -1]</code></pre><p>The  models  implemented  for  imprimitive  types <code>G(de,e,n)</code> for <code>n&gt;2</code> and <code>de&gt;1</code> (this includes Coxeter type <code>Dâ‚™</code>), excepted for <code>G(2,2,4), G(3,3,3), G(3,3,4), G(3,3,5)</code> and <code>G(4,4,3)</code>, involve rational fractions.</p><pre><code class="language-julia-repl hljs">julia&gt; H=hecke(coxgroup(:D,5),Pol())
hecke(Dâ‚…,q)

julia&gt; representation(H,7)
5-element Vector{Matrix{Frac{Pol{Int64}}}}:
 [q 0 0 0; 0 -1 0 0; 0 0 -1 0; 0 0 0 -1]
 [q 0 0 0; 0 -1 0 0; 0 0 -1 0; 0 0 0 -1]
 [1/(-q-1) -q/(-q-1) 0 0; (qÂ²+q+1)/(q+1) qÂ²/(q+1) 0 0; 0 0 -1 0; 0 0 0 -1]
 [-1 0 0 0; 0 1/(-qÂ²-q-1) (-qÂ²-q)/(-qÂ²-q-1) 0; 0 (qÂ³+qÂ²+q+1)/(qÂ²+q+1) qÂ³/(qÂ²+q+1) 0; 0 0 0 -1]
 [-1 0 0 0; 0 -1 0 0; 0 0 1/(-qÂ³-qÂ²-q-1) (-qÂ³-qÂ²-q)/(-qÂ³-qÂ²-q-1); 0 0 (qâ´+qÂ³+qÂ²+q+1)/(qÂ³+qÂ²+q+1) qâ´/(qÂ³+qÂ²+q+1)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/3b53d0f4c72f407ebafb3ea0229d9669c036252f/src/HeckeAlgebras.jl#L459-L504">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.Chars.representations-Tuple{Union{HeckeAlgebra, HeckeCoset}}" href="#Gapjm.Chars.representations-Tuple{Union{HeckeAlgebra, HeckeCoset}}"><code>Gapjm.Chars.representations</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p><code>representations(H)</code></p><p>returns  the list  of representations  of the  Hecke algebra or Hecke coset <code>H</code> (see <code>representation</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; WF=rootdatum(&quot;2B2&quot;)
Â²Bâ‚‚

julia&gt; H=hecke(WF,Pol(:x)^2;rootpara=Pol())
hecke(Â²Bâ‚‚,xÂ²,rootpara=x)

julia&gt; representations(H)
3-element Vector{NamedTuple{(:gens, :F)}}:
 (gens = Matrix{Pol{Int64}}[[xÂ²;;], [xÂ²;;]], F = [1;;])
 (gens = Matrix{Pol{Int64}}[[-1;;], [-1;;]], F = [1;;])
 (gens = Matrix{Pol{Cyc{Int64}}}[[-1 0; âˆš2x xÂ²], [xÂ² âˆš2x; 0 -1]], F = [0 -1; -1 0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/3b53d0f4c72f407ebafb3ea0229d9669c036252f/src/HeckeAlgebras.jl#L1457-L1476">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.HeckeAlgebras.isrepresentation" href="#Gapjm.HeckeAlgebras.isrepresentation"><code>Gapjm.HeckeAlgebras.isrepresentation</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p><code>isrepresentation(H::HeckeAlgebra,r)</code></p><p>returns <code>true</code> or <code>false</code>, according to whether a given set <code>r</code> of elements corresponding  to  the  standard  generators  of the reflection group <code>H.W</code> defines a representation of the Hecke algebra <code>H</code> or not.</p><pre><code class="language-julia-repl hljs">julia&gt; H=hecke(coxgroup(:F,4))
hecke(Fâ‚„,1)

julia&gt; isrepresentation(H,reflrep(H))
true

julia&gt; isrepresentation(H,Tbasis(H).(1:4))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/3b53d0f4c72f407ebafb3ea0229d9669c036252f/src/HeckeAlgebras.jl#L524-L541">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.reflrep-Tuple{HeckeAlgebra}" href="#Gapjm.PermRoot.reflrep-Tuple{HeckeAlgebra}"><code>Gapjm.PermRoot.reflrep</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p><code>reflrep(H)</code></p><p>returns  a list of matrices which give the reflection representation of the Iwahori-Hecke algebra <code>H</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:B,2);H=hecke(W,Pol(:q))
hecke(Bâ‚‚,q)

julia&gt; reflrep(H)
2-element Vector{Matrix{Pol{Int64}}}:
 [-1 0; -q q]
 [q -2; 0 -1]

julia&gt; H=hecke(coxgroup(:H,3))
hecke(Hâ‚ƒ,1)

julia&gt; reflrep(H)
3-element Vector{Matrix{Cyc{Int64}}}:
 [-1 0 0; -1 1 0; 0 0 1]
 [1 (-3-âˆš5)/2 0; 0 -1 0; 0 -1 1]
 [1 0 0; 0 1 -1; 0 0 -1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/3b53d0f4c72f407ebafb3ea0229d9669c036252f/src/HeckeAlgebras.jl#L562-L586">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.HeckeAlgebras.HeckeCoset" href="#Gapjm.HeckeAlgebras.HeckeCoset"><code>Gapjm.HeckeAlgebras.HeckeCoset</code></a> â€” <span class="docstring-category">Type</span></header><section><div><p><code>HeckeCoset</code>s  are  <code>HÏ•</code>  where  <code>H</code>  is  an  Iwahori-Hecke algebra of some Coxeter  group <code>W</code> on which the automorphism <code>Ï•</code> of some Spets <code>WÏ•</code> acts by <code>Ï•(T_w)=T_{Ï•(w)}</code>.  For Weyl groups, this corresponds  to the action of the Frobenius  automorphism  on  the  commuting  algebra  of the induced of the trivial  representation from the  rational points of  some <code>F</code>-stable Borel subgroup to <code>ğ† ^F</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; WF=rootdatum(:u,3)
uâ‚ƒ

julia&gt; HF=hecke(WF,Pol(:v)^2;rootpara=Pol())
hecke(uâ‚ƒ,vÂ²,rootpara=v)

julia&gt; CharTable(HF)
CharTable(hecke(uâ‚ƒ,vÂ²,rootpara=v))
   â”‚ 111 21  3
â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
111â”‚  -1  1 -1
21 â”‚-2vÂ³  .  v
3  â”‚  vâ¶  1 vÂ²</code></pre><p>Thanks  to the work of Xuhua He and Sian Nie, &#39;class_polynomials&#39; also make sense for these cosets. This is used to compute such character tables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/3b53d0f4c72f407ebafb3ea0229d9669c036252f/src/HeckeAlgebras.jl#L1349-L1374">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.HeckeAlgebras.hecke-Tuple{HeckeCoset}" href="#Gapjm.HeckeAlgebras.hecke-Tuple{HeckeCoset}"><code>Gapjm.HeckeAlgebras.hecke</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p><code>hecke(HF::HeckeCoset)</code> returns the underlying Hecke algebra</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/3b53d0f4c72f407ebafb3ea0229d9669c036252f/src/HeckeAlgebras.jl#L1380">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.HeckeAlgebras.hecke-Tuple{Spets, HeckeAlgebra}" href="#Gapjm.HeckeAlgebras.hecke-Tuple{Spets, HeckeAlgebra}"><code>Gapjm.HeckeAlgebras.hecke</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p><code>hecke(WF::Spets, H)</code></p><p><code>hecke(WF::Spets, params)</code></p><p>Construct  a <code>HeckeCoset</code>  from a  Coxeter coset  <code>WF</code> and an Hecke algebra associated to <code>Group(WF)</code>. The second form is equivalent to <code>Hecke(WF,Hecke(Group(WF),params))</code>. See the doc for <code>HeckeCoset</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/3b53d0f4c72f407ebafb3ea0229d9669c036252f/src/HeckeAlgebras.jl#L1383-L1391">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="chars.html">Â« Classes/characters of reflection groups</a><a class="docs-footer-nextpage" href="kl.html">Kazhdan-Lusztig polynomials and bases Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 17 February 2023 00:39">Friday 17 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
