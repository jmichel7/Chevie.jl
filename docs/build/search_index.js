var documenterSearchIndex = {"docs":
[{"location":"#Gapjm.jl-Documentation-1","page":"Gapjm.jl Documentation","title":"Gapjm.jl Documentation","text":"","category":"section"},{"location":"#","page":"Gapjm.jl Documentation","title":"Gapjm.jl Documentation","text":"Gapjm","category":"page"},{"location":"#Gapjm","page":"Gapjm.jl Documentation","title":"Gapjm","text":"This  is  my  effort  porting  GAP  code  to Julia, specifically the Chevie package  of GAP3 plus the minimal other GAP functionality needed for Chevie to   work:  Cyclotomics,  Permutations,   Laurent  polynomials,  and  basic permutation group operations.\n\nI am rather new to Julia, git and github so I am not even sure this package is  properly constituted; I did not try yet to register it. If you are more competent  that me and see anything to  be improved in this package, please write me or make a pull request.\n\nInstalling\n\nIf you are new to Julia, to install this package, at the Julia command line:\n\nenter package mode with ]\ndo the command\n\n(v1.0) pkg> add \"https://github.com/jmichel7/Gapjm.jl\"\n\nexit package mode with backspace and then do \n\njulia> using Gapjm\n\nand you are set up.\n\nTo update later to the latest version, do\n\n``` (v1.0) pkg> update \"https://github.com/jmichel7/Gapjm.jl\"\n\nThe package now contains:\n\ninfrastructure: permutations,  cyclotomic numbers,  Laurent polynomials.\n\nThere  are also  permutation groups,  for which  I have  often replaced the proper  algorithms of GAP by naive but  easy to write methods only suitable for  small groups (sufficient for the rest of the package but maybe not for your needs).\n\nfrom  Chevie  ported:  Weyl  groups,  Coxeter  groups,  Hecke  algebras,\n\nKazhdan-Lusztig   polynomials,  braid  and   Garside  groups  and  monoids, factorisations into cyclotomic polynomials, character tables of Weyl groups and  Hecke algebras, Unipotent characters  of Spetses, unipotent classes of reductive groups.\n\nThe  code for infrastructure  is often competitive  with GAP, despite being much  shorter (often 100 lines of Julia replace 1000 lines of C); I am sure there  are more optimisations possible. Any comments about the code and the design  are welcome. The code for Chevie  is often 10 times faster than the GAP3 Chevie (after the maddeningly long compilation time on first execution).\n\n\n\n\n\n","category":"module"},{"location":"#","page":"Gapjm.jl Documentation","title":"Gapjm.jl Documentation","text":"","category":"page"},{"location":"#Perms.jl-Documentation-1","page":"Gapjm.jl Documentation","title":"Perms.jl Documentation","text":"","category":"section"},{"location":"#","page":"Gapjm.jl Documentation","title":"Gapjm.jl Documentation","text":"Perms\nlargest_moved_point\nsmallest_moved_point\norder\nGroups.orbit(a::Perm,i::Integer,check=false)\ncycles\ncycletype\nsign\nrestricted","category":"page"},{"location":"#Gapjm.Perms","page":"Gapjm.jl Documentation","title":"Gapjm.Perms","text":"This module is a port of the GAP permutations type.\n\nA  permutation here is a permutation of the set 1:n and is represented as a  vector of n integers representing the images of 1:n. The integer n is called the degree of the permutation, even if it is not moved. We follow the  GAP design: it is possible to multiply, or to store in the same group, permutations of different degrees; this is implemented by promoting both to the   higher  degree.  Slightly  faster  is  the  MAGMA  design  where  any permutation  has to belong to a group  and the degree is determined by that group. Then multiplication of permutations within a given group is slightly faster,  but  it  is  more  difficult  to multiply permutations coming from different  groups, like a group and one  of its subgroups. The degree is an implementation  detail so usually  it should not  be used. One sould rather use the function largest_moved_point.\n\nA  permutation  can  be  defined  by  the  list  of  images  of 1:n, like Perm([2,3,1,5,4]).  Usually it is rather  given by its cycle decomposion: the  permutation whose cycle decomposition is (1,2,3)(4,5) can be written Perm(1,2,3)*Perm(4,5)  or  perm\"(1,2,3)(4,5)\".  The  list  of images of 1:n  is gotten back from the permutation by the function vec; note that since  equal  permutations  may  have  different  degrees,  they  may  have different vec.\n\nThe  complete  type  of  our  permutations is Perm{T} where T<:Integer, where Vector{T} is the type of the vector which holds the image of 1:n. This   can  used  to  save  space  or  time  when  possible.  For  instance Perm{UInt8}  uses less  space than  Perm{Int} and  can be used for Weyl groups of rank <=8 since they have at most 240 roots.\n\nExamples\n\njulia> a=Perm(1,2,3)\n(1,2,3)\n\njulia> vec(a)\n3-element Array{Int64,1}:\n 2\n 3\n 1\n\njulia> a==Perm(vec(a))\ntrue\n\njulia> b=Perm(1,2,3,4)\n(1,2,3,4)\n\njulia> a*b     # product\n(1,3,2,4)\n\njulia> inv(a)  # inverse\n(1,3,2)\n\njulia> a/b     # quotient  a*inv(b)\n(3,4)\n\njulia> a\\b     # left quotient inv(a)*b\n(1,4)\n\njulia> a^b     # conjugation inv(b)*a*b\n(2,3,4)\n\njulia> b^2\n(1,3)(2,4)\n\njulia> 1^a     # apply a to point 1\n2\n\njulia> one(a)\n()\n\njulia> sign(a)\n1\n\njulia> order(a)\n3\n\njulia> largest_moved_point(a)\n3\n\njulia> smallest_moved_point(a)\n1\n\njulia> Perm{Int8}(a) # convert to Perm{Int8}\nInt8(1,2,3)\n\njulia> Matrix(b)\n4√ó4 Array{Int64,2}:\n 0  1  0  0\n 0  0  1  0\n 0  0  0  1\n 1  0  0  0\n\njulia> rand(Perm,10)\n(1,8,4,2,9,7,5,10,3,6)\n\n\nPerms  have methods copy, hash, ==, cmp, isless (total order) so they can be  keys  in  hashes  or  elements  of sets. Permutations are considered as scalars for broadcasting.\n\nother functions are: cycles, cycletype, orbits, rand, sign.  See individual documentations.\n\nGAP‚Üí Julia dictionary\n\n     PermList(v)                      ‚Üí  Perm(v) \n     Permuted(v,p)                    ‚Üí  v[p.d]\n     ListPerm(p)                      ‚Üí  vec(p)\n     PermListList(l1,l2)              ‚Üí  Perm(l1,l2)\n     OnTuples(l,p)                    ‚Üí  l.^p\n     RestrictedPerm(p,d)              ‚Üí  restricted(p,d)\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.Perms.largest_moved_point","page":"Gapjm.jl Documentation","title":"Gapjm.Perms.largest_moved_point","text":"largest_moved_point(a::Perm) is the largest integer moved by a\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Perms.smallest_moved_point","page":"Gapjm.jl Documentation","title":"Gapjm.Perms.smallest_moved_point","text":"smallest_moved_point(a::Perm) is the smallest integer moved by a\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Perms.order","page":"Gapjm.jl Documentation","title":"Gapjm.Perms.order","text":"order(a) is the order of the permutation a\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Groups.orbit","page":"Gapjm.jl Documentation","title":"Gapjm.Groups.orbit","text":"orbit(a::Perm,i::Integer) returns the orbit of a on i\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Perms.cycles","page":"Gapjm.jl Documentation","title":"Gapjm.Perms.cycles","text":"cycles(a::Perm) returns the non-trivial cycles of a\n\nExample\n\njulia> cycles(Perm(1,2)*Perm(4,5))\n3-element Array{Array{Int64,1},1}:\n [1, 2]\n [4, 5]\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Perms.cycletype","page":"Gapjm.jl Documentation","title":"Gapjm.Perms.cycletype","text":"cycletype(a::Perm) describes the partition of degree(a) associated to the   conjugacy class of a in the symmetric group, with ones removed. It is   represented as a Dict of cyclesize=>multiplicity\n\nExample\n\njulia> cycletype(Perm(1,2)*Perm(3,4))\n1-element Array{Pair{Tuple{Int64,Int64},Int64},1}:\n (2, 1) => 2\n\n\n\n\n\n","category":"function"},{"location":"#Base.sign","page":"Gapjm.jl Documentation","title":"Base.sign","text":"sign(a::Perm) is the signature of  the permutation a\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.restricted","page":"Gapjm.jl Documentation","title":"Gapjm.restricted","text":"restricted(a::Perm{T},l::AbstractVector{<:Integer})\n\nl should be a union of cycles of p; returns p restricted to l\n\n\n\n\n\n","category":"function"},{"location":"#Groups.jl-Documentation-1","page":"Gapjm.jl Documentation","title":"Groups.jl Documentation","text":"","category":"section"},{"location":"#","page":"Gapjm.jl Documentation","title":"Gapjm.jl Documentation","text":"Groups\norbit\norbits\ntransversal\ncentralizer\nword(G::Group,w)\nelements\nlength\nclass_reps\nminimal_words","category":"page"},{"location":"#Gapjm.Groups","page":"Gapjm.jl Documentation","title":"Gapjm.Groups","text":"This module is a port of some GAP functionality on groups.\n\nThe only field of a Group G at the start is gens, the list of generators of G.  To  mimic  GAP  records  where  attributes/properties  of an object are computed  on demand when asked for, other attributes computed on demand are stored in the field .prop of the Group, which starts as Dict{Symbol,Any}()\n\nExamples\n\njulia> G=Group([Perm(1,2),Perm(1,2,3)])\nGroup([(1,2),(1,2,3)])\n\njulia> gens(G)\n2-element Array{Perm{Int64},1}:\n (1,2)  \n (1,2,3)\n\njulia> nbgens(G)\n2\n\nThe group itself, applied to a sequence of integers, returns the element defined by the corresponding word in the generators\n\njulia> G(2,1,-2) # returns gens(G)[2]*gens(G)[1]*inv(gens(G)[2])\n(1,3)\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.Groups.orbit","page":"Gapjm.jl Documentation","title":"Gapjm.Groups.orbit","text":"orbit(G::Group,p;action::Function=^)\n\nthe orbit of p under Group G\"\n\njulia> G=Group([Perm(1,2),Perm(1,2,3)]);\njulia> orbit(G,1) \n3-element Array{Int64,1}:\n 2\n 3\n 1\n\n\n\n\n\norbit(a::Perm,i::Integer) returns the orbit of a on i\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Groups.orbits","page":"Gapjm.jl Documentation","title":"Gapjm.Groups.orbits","text":"orbits(G,v;action=^) \nthe orbits of G on v\n\njulia> G=Group([Perm(1,2),Perm(1,2,3)]);\njulia> orbits(G,1:4)\n2-element Array{Array{Int64,1},1}:\n [2, 3, 1]\n [4]      \n\n\n\n\n\norbits(a::Perm,d::Vector=1:length(vec(a))) returns the orbits of a on domain d\n\nExample\n\njulia> orbits(Perm(1,2)*Perm(4,5),1:5)\n3-element Array{Array{Int64,1},1}:\n [1, 2]\n [3]\n [4, 5]\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Groups.transversal","page":"Gapjm.jl Documentation","title":"Gapjm.Groups.transversal","text":"transversal(G::Group,p;action::Function=^)\n\nreturns  a Dict with entries x=>g where x runs over orbit(G,p) and where g  is such that x=action(p,g)\n\njulia> G=Group([Perm(1,2),Perm(1,2,3)]);\njulia> transversal(G,1)\nDict{Int64,Perm{Int64}} with 3 entries:\n  2 => (1,2)\n  3 => (1,3,2)\n  1 => ()\n\norbit functions can take any action of G as keyword argument\n\njulia> transversal(G,[1,2],action=(x,y)->x.^y)\nDict{Array{Int64,1},Perm{Int64}} with 6 entries:\n  [1, 3] => (2,3)\n  [1, 2] => ()\n  [2, 3] => (1,2,3)\n  [3, 2] => (1,3)\n  [2, 1] => (1,2)\n  [3, 1] => (1,3,2)\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Groups.centralizer","page":"Gapjm.jl Documentation","title":"Gapjm.Groups.centralizer","text":"centralizer(G,p;action=^) \ncomputes the centralizer C_G(p)\n\njulia> G=Group([Perm(1,2),Perm(1,2,3)]);\njulia> centralizer(G,1)\nGroup([(2,3)])\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.word-Tuple{Group,Any}","page":"Gapjm.jl Documentation","title":"Gapjm.word","text":"word(G::Group,w): a word in  gens(G) representing element w of G\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.elements","page":"Gapjm.jl Documentation","title":"Gapjm.elements","text":"elements(G::Group): the list of elements of G\n\n\n\n\n\nelements(M,l) returns the elements of M of length l.\n\n\n\n\n\n","category":"function"},{"location":"#Base.length","page":"Gapjm.jl Documentation","title":"Base.length","text":"length(G::PermGroup) returns the cardinality of G \n\n\n\n\n\nlength(G::Group): the number of elements of G\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Groups.class_reps","page":"Gapjm.jl Documentation","title":"Gapjm.Groups.class_reps","text":"class_reps(G::Group): representatives of conjugacy classes of G\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Groups.minimal_words","page":"Gapjm.jl Documentation","title":"Gapjm.Groups.minimal_words","text":"`minimal_words(G)`\n\nreturns a Dict giving for each element of G a minimal positive word in    the generators representing it.\n\njulia> G=Group([Perm(1,2),Perm(1,2,3)]);\njulia> minimal_words(G)\nDict{Perm{Int64},Array{Int64,1}} with 6 entries:\n  ()      => Int64[]\n  (2,3)   => [2, 1]\n  (1,3,2) => [1, 2, 1]\n  (1,3)   => [1, 2]\n  (1,2)   => [1]\n  (1,2,3) => [2]\n\nThis Dict is stored in G.prop[:words] for further use.\n\n\n\n\n\n","category":"function"},{"location":"#PermGroups.jl-Documentation-1","page":"Gapjm.jl Documentation","title":"PermGroups.jl Documentation","text":"","category":"section"},{"location":"#","page":"Gapjm.jl Documentation","title":"Gapjm.jl Documentation","text":"PermGroups\nbase\ncentralizers\ntransversals\nsymmetric_group","category":"page"},{"location":"#Gapjm.PermGroups","page":"Gapjm.jl Documentation","title":"Gapjm.PermGroups","text":"This module is a port of some GAP functionality on permutation groups.\n\nThis code refers to Holt \"Handbook of computational group theory\" chapter 4 for basic algorithms.\n\nA  PermGroup is  a group  where gens  are Perms,  which allows  for all the algorithms like base, centralizer chain, etc...\n\nExamples\n\njulia> G=Group([Perm(i,i+1) for i in 1:2])\nGroup([(1,2),(2,3)])\n\n# PermGroups are iterators over their elements\njulia> collect(G)  \n6-element Array{Perm{Int64},1}:\n (1,2)\n (1,3,2)\n ()\n (1,2,3)\n (1,3)\n (2,3)\n\n# maximum degree of an element of G\njulia> degree(G)  \n3\n\njulia> Perm(1,2) in G\ntrue\n\njulia> Perm(1,2,4) in G\nfalse\n\n# Elements,  appartenance test and  other function are  computed on G using\n# Schreier-Sims theory, that is computing the following\n\n# a list of points that no element of G fixes\njulia> base(G) \n2-element Array{Int64,1}:\n 1\n 2\n\n# the i-th element is the centralizer of base[1:i-1]\njulia> centralizers(G) \n2-element Array{PermGroup{Int64},1}:\n Group([(1,2),(2,3)])\n Group([(2,3)])\n\n# i-th element is transversal of centralizer[i] on base[i]\njulia> transversals(G)\n2-element Array{Dict{Int64,Perm{Int64}},1}:\n Dict(2=>(1,2),3=>(1,3,2),1=>())\n Dict(2=>(),3=>(2,3))\n\nfinally, benchmarks on julia 1.0.1\n\njulia> @btime length(collect(symmetric_group(8)))\n  5.481 ms (270429 allocations: 12.40 MiB)\n\njulia> @btime minimal_words(symmetric_group(8));\n  10.477 ms (122062 allocations: 15.22 MiB)\n\nCompare to GAP3 Elements(SymmetricGroup(8)); takes 3.8 ms\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.PermGroups.base","page":"Gapjm.jl Documentation","title":"Gapjm.PermGroups.base","text":"A list of points stabilized by no element of G \n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.PermGroups.centralizers","page":"Gapjm.jl Documentation","title":"Gapjm.PermGroups.centralizers","text":"centralizers: the i-th element is the centralizer of base[1:i-1]\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.PermGroups.transversals","page":"Gapjm.jl Documentation","title":"Gapjm.PermGroups.transversals","text":"The  i-th element  is  a description of  the orbit of :centralizers[i] on   :base[i]  as a Dict where each point q is the key to a permutation p such   that :base[i]^p=q\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.PermGroups.symmetric_group","page":"Gapjm.jl Documentation","title":"Gapjm.PermGroups.symmetric_group","text":"The symmetric group of degree n \n\n\n\n\n\n","category":"function"},{"location":"#Cycs.jl-Documentation-1","page":"Gapjm.jl Documentation","title":"Cycs.jl Documentation","text":"","category":"section"},{"location":"#","page":"Gapjm.jl Documentation","title":"Gapjm.jl Documentation","text":"Cycs\ngalois\nER\nquadratic","category":"page"},{"location":"#Gapjm.Cycs","page":"Gapjm.jl Documentation","title":"Gapjm.Cycs","text":"Cyclotomic  numbers means complex numbers which are sums of rationals times roots of unity.\n\nThey are a very important feature of GAP, since entries of character tables of finite groups are cyclotomics.\n\nThey  have a normal form given by the Zumbroich basis, which allows to find the  smallest Cyclotomic field which contains a given number, and decide in particular if a cyclotomic is zero. Let Œ∂n:=e^{2iœÄ/n}. The Zumbroich basis of Q(Œ∂n) is a particular subset of 1,Œ∂,Œ∂^2,...,Œ∂^{n-1} which forms a basis of Q(Œ∂_n) with good properties.\n\nI  ported here Christian Stump's Sage  code, which is simpler to understand than GAP's code. The reference for the algorithms is\n\nT. Breuer, Integral bases for subfields of cyclotomic fields AAECC 8 (1997)\n\nAs in GAP, I lower automatically numbers after each computation; this makes this code about twice slower than GAP since lower is not as much optimized. GAP  also converts a Cyclotomic which is rational to a Rational, a Rational which is integral to an Int, etc... This is tremendously useful but needs a new  type of  number to  be added  to Julia,  which requires more competent people than me.\n\nThe main way to build a Cyclotomic number is to use the function E(n,k=1) which constructs Œ∂_n^k.\n\nExamples\n\njulia> E(3)+E(4)\nŒ∂‚ÇÅ‚ÇÇ‚Å¥-Œ∂‚ÇÅ‚ÇÇ‚Å∑-Œ∂‚ÇÅ‚ÇÇ¬π¬π\n\njulia> E(3,2)\nŒ∂‚ÇÉ¬≤\n\njulia> 1+E(3,2)\n-Œ∂‚ÇÉ\n\njulia> a=E(4)-E(4)\n0\n\njulia> conductor(a) # a is lowered to Q(Œ∂_1)=Q\n1\n\njulia> typeof(convert(Int,a))\nInt64\n\njulia> convert(Int,E(4))\nERROR: InexactError: convert(Int64, E(4))\n\njulia> c=inv(1+E(4)) # inverses need Rationals\n1//2+(-1//2)Œ∂‚ÇÑ\n\njulia> typeof(c)\nCyc{Rational{Int64}}\n\njulia> typeof(1+E(4))\nCyc{Int64}\n\njulia> Cyc(1+im) # one can convert Gaussian integers or rationals\n1+Œ∂‚ÇÑ\n\njulia> 1//(1+E(4))\n1//2+(-1//2)Œ∂‚ÇÑ\n\njulia> typeof(Cyc(1//2)) # another way of building a Cyc\nCyc{Rational{Int64}}\n\njulia> conj(1+E(4))\n1-Œ∂‚ÇÑ\n\njulia> c=E(9)   # an effect of the Zumbroich basis\n-Œ∂‚Çâ‚Å¥-Œ∂‚Çâ‚Å∑\n\njulia> Root1(c) # but you can decide whether a Cyc is a root of unity\nRoot1(1//9)\n\njulia> c=Complex(E(3))   # convert to float is probably not very useful\n-0.4999999999999998 + 0.8660254037844387im\n\njulia> Cyc(c) # even less useful\n-0.4999999999999998+0.8660254037844387Œ∂‚ÇÑ\n\nFor more information see ER, quadratic, galois. \n\nFinally, a benchmark:\n\njulia> function testmat(p) \n         ss=vcat([[[i,j] for j in i+1:p-1] for i in 0:p-1]...)\n         [(E(p,i'*reverse(j))-E(p,i'*j))//p for i in ss,j in ss]\n       end\ntestmat (generic function with 1 method)\n\njulia> @btime testmat(12)^2;\n  472.964 ms (8324504 allocations: 707.18 MiB)\n\nThe equivalent in GAP:\n\ntestmat:=function(p)local ss;ss:=Combinations([0..p-1],2);\n  return List(ss,i->List(ss,j->(E(p)^(i*Reversed(j))-E(p)^(i*j))/p));\nend; \n\nfor testmat(12) takes 0.4s in GAP3, 0.3s in GAP4\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.Cycs.galois","page":"Gapjm.jl Documentation","title":"Gapjm.Cycs.galois","text":"galois(c::Cyc,n::Int) applies to c the galois automorphism   of Q(Œ∂_conductor(c)) raising all roots of unity to the n-th power.   n should be prime to c.\n\nExamples\n\njulia> galois(1+E(4),-1) # galois(c,-1) is the same as conj(c)\n1-Œ∂‚ÇÑ\n\njulia> galois(ER(5),2)==-ER(5)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Cycs.ER","page":"Gapjm.jl Documentation","title":"Gapjm.Cycs.ER","text":"ER(n::Int) computes as a Cyc the square root of the integer n.\n\nExamples\n\njulia> ER(-3)\nŒ∂‚ÇÉ-Œ∂‚ÇÉ¬≤\n\njulia> ER(3)\n-Œ∂‚ÇÅ‚ÇÇ‚Å∑+Œ∂‚ÇÅ‚ÇÇ¬π¬π\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Cycs.quadratic","page":"Gapjm.jl Documentation","title":"Gapjm.Cycs.quadratic","text":"quadratic(c::Cyc) determines if c lives in a quadratic extension of Q   it  returns a named  tuple (a=a,b=b,root=root,d=d) of  integers such that   c=(a + b ER(root))//d or nothing if no such tuple exists\n\nExamples\n\njulia> quadratic(1+E(3))\n(a = 1, b = 1, root = -3, den = 2)\n\njulia> quadratic(1+E(5))\n\n\n\n\n\n\n","category":"function"},{"location":"#Pols.jl-Documentation-1","page":"Gapjm.jl Documentation","title":"Pols.jl Documentation","text":"","category":"section"},{"location":"#","page":"Gapjm.jl Documentation","title":"Gapjm.jl Documentation","text":"Pols\ndivrem\ndivrem1\ngcd","category":"page"},{"location":"#Gapjm.Pols","page":"Gapjm.jl Documentation","title":"Gapjm.Pols","text":"An implementation of univariate Laurent polynomials.  A Pol contains two fields: its vector of coefficients, and its valuation.\n\nExamples\n\njulia> Pol(:q) # define string used for printing and set variable q\nq\n\njulia> Pol([1,2],0) # coefficients should have no leading or trailing zeroes.\n2q+1\n\njulia> p=Pol([1,2],-1)\n2+q‚Åª¬π\n\njulia> valuation(p)\n-1\n\njulia> p=(q+1)^2\nq¬≤+2q+1\n\njulia> degree(p)\n2\n\njulia> p(1//2) # a Pol is a callable object, where the call evaluates the Pol\n9//4\n\njulia> divrem(q^3+1,q+2) # changes coefficients to field elements\n(1.0q¬≤-2.0q+4.0, -7.0)\n\njulia> divrem1(q^3+1,q+2) # keeps the ring, but needs second argument unitary\n(q¬≤-2q+4, -7)\n\njulia> cyclotomic_polynomial(24) # the 24-th cyclotomic polynomial\nq‚Å∏-q‚Å¥+1\n\n\nsee also the individual documentation of gcd.\n\n\n\n\n\n","category":"module"},{"location":"#Base.divrem","page":"Gapjm.jl Documentation","title":"Base.divrem","text":"computes (p,q) such that a=p*b+q\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Pols.divrem1","page":"Gapjm.jl Documentation","title":"Gapjm.Pols.divrem1","text":"divrem when b unitary: does not change type\n\n\n\n\n\n","category":"function"},{"location":"#Base.gcd","page":"Gapjm.jl Documentation","title":"Base.gcd","text":"gcd(p::Pol, q::Pol)   the coefficients of p and q must be elements of a field for   gcd to be type-stable\n\nExamples\n\njulia> gcd(q+1,q^2-1)\n1.0q+1.0\n\njulia> gcd(q+1//1,q^2-1//1)\n(1//1)q+1//1\n\n\n\n\n\n","category":"function"},{"location":"#CoxGroups.jl-Documentation-1","page":"Gapjm.jl Documentation","title":"CoxGroups.jl Documentation","text":"","category":"section"},{"location":"#","page":"Gapjm.jl Documentation","title":"Gapjm.jl Documentation","text":"CoxGroups\nreduced\nword(W::CoxeterGroup,w)\nbruhatless\ncoxsym\nlongest\nnref","category":"page"},{"location":"#Gapjm.CoxGroups","page":"Gapjm.jl Documentation","title":"Gapjm.CoxGroups","text":"A  suitable  reference  for  the  general  theory of Coxeter groups is, for example, Bourbaki \"Lie Groups and Lie Algebras\" chapter 4.\n\nA Coxeter group is a group which has the presentation W=‚ü®S|(st)^m(s,t)=1  for  s,t‚àà  S‚ü©  for  some  symmetric  integer matrix m(s,t)  called  the  Coxeter  matrix,  where  m(s,t)>1  for s‚â†t and m(s,s)=1.  It is true (but a non-trivial theorem) that in a Coxeter group the  order of st is exactly m(s,t), thus a Coxeter group is the same as a  Coxeter system, that is a pair (W,S) of a group W and a set S of involutions,  such that the group is  presented by relations describing the order  of the product of two elements of S. A Coxeter group has a natural representation, its reflection representation, on a real vector space V of  dimension length(S) (the Coxeter rank  of W), where each element of S  acts as a  reflection; the faithfulness  of this representation in the main  argument to prove  that the order  of st is  exactly m(s,t). Thus Coxeter groups are real reflection groups. The converse need not be true if the  set of reflecting  hyperplanes has bad  topological properties, but it turns out that finite Coxeter groups are the same as finite real reflection groups.  The possible Coxeter matrices for  finite Coxeter groups have been completely  classified; the corresponding finite groups play a deep role in several areas of mathematics.\n\nCoxeter  groups  have  a  nice  solution  to the word problem. The length l(w)  of an element  w‚àà W is  the minimum number  of elements of S of which it is a product (since the elements of S are involutions, we do not need inverses). An expression of w of minimal length is called a reduced word  for w. The main property of  reduced words is the exchange lemma which  states that if s‚ÇÅ‚Ä¶s‚Çñ is a  reduced word for w (thusk=l(w)) and s‚àà  S is such that l(sw)‚â§l(w) then one  of the s·µ¢ in the word for w can be deleted to obtain a reduced word for sw. Thus given s‚àà S and w‚àà W,  either l(sw)=l(w)+1 or  l(sw)=l(w)-1 and we  say in this last case that  s belongs to  the left descent  set of w.  The computation of a reduced word for an element, and other word problems, are easily done if we know  the left descent sets. For the Coxeter groups that we implement, this left  descent set  can be  easily determined  (see e.g. 'coxsym' below), so this suggests how to deal with Coxeter groups.\n\nThe type CoxeterGroup is an abstact type; an actual struct which implements it must define a function\n\nisleftdescent(W,w,i) which tells whether the       i-th element of S is in the left descending set of w.\n\nthe other functions needed in an instance of a Coxeter group are\n\ngens(W) which returns the set S (the list of Coxeter generators)\nnref(W) which  returns the  number of  reflections of  W, if  W is  finite or nothing if W is infinite\n\nIt  should be  noted that  a Coxeter group can be any kind of group implementing the above functions.\n\nA  common occurrence in code for Coxeter groups is a loop like:\n\nfindfirst(eachindex(gens(W)),x->isleftdescent(W,w,x))\n\nif you provide a function firstleftdescent(W,w) it will be called instead of the above loop.\n\nBecause  of the  easy solution  of the  word problem  in Coxeter  groups, a convenient  way  to  represent  their  elements  is as words in the Coxeter generators.  They are represented as lists of labels for the generators. By default  these labels are  given as the  index of a  generator in S, so a Coxeter  word is just  a list of  integers in 1:length(S). For reflection subgroups, the labels are indices of the reflections in the parent group.\n\nThe functions 'word' and 'W(...)' will do the conversion between Coxeter words and elements of the group.\n\nExamples\n\njulia> W=coxsym(4)\nùîñ ‚ÇÑ\n\njulia> p=W(1,3,2,1,3)\nUInt8(1,4)\n\njulia> word(W,p)\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 2\n 1\n\n\nWe  notice that the word we started with and the one that we ended up with, are not the same, though they represent the same element of W. The reason is  that the function 'word' computes a lexicographically smallest word for w.  Below  are  some  other  possible  computations with the same Coxeter group:\n\njulia> word(W,longest(W))  # the (unique) longest element in W\n6-element Array{Int64,1}:\n 1\n 2\n 1\n 3\n 2\n 1\n\njulia> w0=longest(W)\nUInt8(1,4)(2,3)\njulia> length(W,w0)\n6\njulia> map(i->word(W,reflection(W,i)),1:nref(W))\n6-element Array{Array{Int64,1},1}:\n [1]            \n [2]            \n [3]            \n [1, 2, 1]      \n [2, 3, 2]      \n [1, 2, 3, 2, 1]\njulia> [length(elements(W,i)) for i in 0:nref(W)]\n7-element Array{Int64,1}:\n 1\n 3\n 5\n 6\n 5\n 3\n 1\n\n\nThe above line tells us that there is 1 element of length 0, there are 6 of length 3, ‚Ä¶\n\nFor  most basic functions the convention is that the input is an element of the  group, rather than  a Coxeter word.  The reason is  that for a Coxeter group  which  is  a  permutation  group,  using the low level functions for permutations  is usually  much faster  than manipulating lists representing reduced expressions.\n\nThis  file contains mostly a port of  the basic functions on Coxeter groups in  CHEVIE. The only Coxeter group  constructor implemented here is coxsym. The file Weyl.jl defines coxgroup.\n\nThe dictionary from CHEVIE is as follows:\n\n     CoxeterElements(W[,l])                ‚Üí elements(W[,l])\n     CoxeterLength(W,w)                    ‚Üí length(W,w)\n     CoxeterWord(W,w)                      ‚Üí word(W,w)\n     LongestCoxeterElement(W)              ‚Üí longest(W)\n     FirstLeftDescending(W,w)              ‚Üí firstleftdescent(W,w)\n     LeftDescenTSet(W,w)                   ‚Üí leftdescents(W,w)\n     ReducedInRightCoset(W,w)              ‚Üí reduced(W,w)\n     ReducedRightCosetRepresentatives(W,H) ‚Üí reduced(H,W)\n     SemiSimpleRank(W)                     ‚Üí coxrank(W)\n     CoxeterGroupSymmetricGroup(n)         ‚Üí coxsym(n)\n     ReflectionSubGroup                    only standard parabolics now\n     IsLeftDescending(W,w,i)               ‚Üí isleftdescent(W,w,i)\n     ReflectionDegrees(W)                  ‚Üí degrees(W)\n     ReflectionLength(W,w)                 ‚Üí reflength(W,w)\n     W.N                                   ‚Üí nref(W)\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.CoxGroups.reduced","page":"Gapjm.jl Documentation","title":"Gapjm.CoxGroups.reduced","text":"reduced(W,w)   The unique element in the coset W.w which stabilises the positive roots of W\n\njulia> W=coxgroup(:G,2)\nG‚ÇÇ\n\njulia> H=reflection_subgroup(W,[2,6])\nG‚ÇÇ‚Çç‚ÇÇ‚ÇÑ‚Çé\n\njulia> Set(word.(Ref(W),reduced.(Ref(H),elements(W))))\nSet(Array{Int64,1}[[1], []])\n\n\n\n\n\n\nreduced(H,W)   The elements in W which are H-reduced\n\njulia> W=coxgroup(:G,2)\nG‚ÇÇ\n\njulia> H=reflection_subgroup(W,[2,6])\nG‚ÇÇ‚Çç‚ÇÇ‚ÇÑ‚Çé\n\njulia> [word(W,w) for S in reduced(H,W) for w in S]\n2-element Array{Array{Int64,1},1}:\n [] \n [1]\n\n\n\n\n\n\nreduced(H,W,S)   The elements in W which are H-reduced of length i from the set S of length i-1\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.word-Tuple{CoxeterGroup,Any}","page":"Gapjm.jl Documentation","title":"Gapjm.word","text":"word(W::CoxeterGroup,w)   The Coxeter word for element w of W\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.CoxGroups.bruhatless","page":"Gapjm.jl Documentation","title":"Gapjm.CoxGroups.bruhatless","text":"bruhatless(W, x, y)  whether x‚â§y in the Bruhat order, for x, y ‚àà W.\n\n\n\n\n\nbruhatless(W, y)  all x‚â§y in the Bruhat order, for y ‚àà W.\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.CoxGroups.coxsym","page":"Gapjm.jl Documentation","title":"Gapjm.CoxGroups.coxsym","text":"The symmetric group on n letters as a Coxeter group\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.CoxGroups.longest","page":"Gapjm.jl Documentation","title":"Gapjm.CoxGroups.longest","text":"The longest element of reflection_subgroup(W,I) ‚Äì- never ends if infinite\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.CoxGroups.nref","page":"Gapjm.jl Documentation","title":"Gapjm.CoxGroups.nref","text":"number of reflections of W\n\n\n\n\n\n","category":"function"},{"location":"#Weyl.jl-Documentation-1","page":"Gapjm.jl Documentation","title":"Weyl.jl Documentation","text":"","category":"section"},{"location":"#","page":"Gapjm.jl Documentation","title":"Gapjm.jl Documentation","text":"Weyl\ncartan\ntwo_tree\nreflection_subgroup\ncoxgroup\nrootdatum","category":"page"},{"location":"#Gapjm.Weyl","page":"Gapjm.jl Documentation","title":"Gapjm.Weyl","text":"Let  V be a  real vector space.  Finite Coxeter groups  coincide with the finite  subgroups of  GL(V) which  can be  generated y reflections. Weyl groups  are  the  finite  Coxeter  groups  which  can  be defined over the rational   numbers.  We  implement  finite   Coxter  groups  as  groups  of permutations  of  a  root  system.  Root  systems play an important role in mathematics as they classify semi-simple Lie algebras and algebraic groups.\n\nLet  us give precise definitions. Let V  be a real vector space, V‚±Ω its dual  and let (,)  be the natural  pairing between V‚±Ω  and V. A root system  is a finite set  of vectors R which  generate V (the roots), together  with  a  map  r‚Ü¶  r‚±Ω  from  R  to  a subset R‚±Ω of V‚±Ω (the coroots) such that:\n\nFor any r‚àà  R, we have  (r‚±Ω,r)=2 so that  the formula x‚Ü¶ x-(r‚±Ω,x)r\n\ndefines a reflection s_r:V‚Üí V with root r and coroot r‚±Ω.\n\nThe reflection s_r stabilizes R.\n\nWe  will only  consider reduced  root systems,  i.e., such  that the only elements  of R colinear with r‚àà R are r and -r; for Weyl groups, we also ask that the root system be crystallographic, that is (r‚±Ω,s) is an integer, for any s‚àà R,r‚±Ω‚àà R‚±Ω.\n\nThe  subgroup W=W(R) of  GL(V) generated by  the reflections s_r is a finite  Coxeter group; when R is crystallographic, the representation V of  W  is  defined  over  the  rational  numbers.  All finite-dimensional (complex)  representations of a  finite Coxeter group  can be realized over the  same field  as V.  Weyl groups  can be  characterized amongst finite Coxeter  groups by the fact that all numbers m(s,t) in the Coxeter matrix are in {2,3,4,6}.\n\nIf  we identify  V with  V‚±Ω by  choosing a  W-invariant bilinear form (.;.);  then we have r‚±Ω=2r/(r;r). A root system R is irreducible if it is not the union of two orthogonal subsets. If R is reducible then the corresponding  Coxeter group  is the  direct product  of the Coxeter groups associated with the irreducible components of R.\n\nThe  irreducible  crystallographic  root  systems  are  classified  by  the following  list of  Dynkin diagrams,  which, in  addition to  the Coxeter matrix,  encode also the relative length of the roots. We show the labeling of the nodes given by the function 'Diagram' described below.\n\nA_n O‚ÄîO‚ÄîO‚Äî‚Ä¶‚ÄîO   B_n O‚áêO‚ÄîO‚Äî‚Ä¶‚ÄîO  C_n O‚áí O‚ÄîO‚Äî‚Ä¶‚ÄîO  D_n  O 2\n    1 2 3 ‚Ä¶ n       1 2 3 ‚Ä¶ n      1  2 3 ‚Ä¶ n       Ôø®\n                                                  O‚ÄîO‚Äî‚Ä¶‚ÄîO\n                                                  1 3 ‚Ä¶ n\n\nG‚ÇÇ O‚áõ O  F‚ÇÑ O‚ÄîO‚áí O‚ÄîO  E‚ÇÜ   O 2   E‚Çá   O 2     E‚Çà    O 2\n   1  2     1 2  3 4       Ôø®          Ôø®             Ôø®\n                       O‚ÄîO‚ÄîO‚ÄîO‚ÄîO  O‚ÄîO‚ÄîO‚ÄîO‚ÄîO‚ÄîO   O‚ÄîO‚ÄîO‚ÄîO‚ÄîO‚ÄîO‚ÄîO\n                       1 3 4 5 6  1 3 4 5 6 7   1 3 4 5 6 7 8\n\nThese diagrams encode the presentation of the Coxeter group W as follows: the vertices represent the generating reflections; an edge is drawn between s  and t if the order m(s,t) of st is greater than 2; the edge is single  if  m(s,t)=3,  double  if  m(s,t)=4,  triple if m(s,t)=6. The arrows  indicate the relative root lengths when W has more than one orbit on  R, as explained below; we  get the Coxeter Diagram, which describes the  underlying Weyl group, if  we ignore the arrows:  we see that the root systems B_n and C_n correspond to the same Coxeter group.\n\nHere  are  the  diagrams  for  the  finite  Coxeter  groups which  are  not crystallographic:\n\n       e        5         5\nI‚ÇÇ(e) O‚ÄîO   H‚ÇÉ O‚ÄîO‚ÄîO  H‚ÇÑ O‚ÄîO‚ÄîO‚ÄîO\n      1 2      1 2 3     1 2 3 4 \n\nLet us now describe how the root systems are encoded in these diagrams. Let R  be a root system in V. Then we can choose a linear form on V which vanishes  on no element of R. According to  the sign of the value of this linear  form on a root  r ‚àà R we  call r positive or negative. Then there  exists a unique subset Œ† of  the positive roots, called the set of simple  roots, such that  any positive root  is a linear combination with non-negative  coefficients of  roots in  Œ†. Any  two sets of simple roots (corresponding  to  different  choices  of  linear  forms  as above) can be transformed into each other by a unique element of W(R). Hence, since the pairing  between V and V‚±Ω  is W-invariant, if Œ†  is a set of simple roots  and if  we define  the Cartan  matrix as  being the  n times n matrix   C={r‚±Ω(s)}_{rs},  for  r,s‚ààŒ†  this   matrix  is  unique  up  to simultaneous  permutation of rows and columns.  It is precisely this matrix which is encoded in a Dynkin diagram, as follows.\n\nThe  indices for the rows of C label the nodes of the diagram. The edges, for  r ‚â† s, are  given as follows. If  C_{rs} and C_{sr} are integers such  that |C_{rs}|‚â•|C_{sr}|=1  the vertices  are connected by |C_{rs}| lines,  and if |C_{rs}|>1  then we put  an additional arrow  on the lines pointing  towards the node with label s.  In other cases, we simply put a single   line  equipped  with  the  unique  integer  p_{rs}‚â•1  such  that C_{rs}C_{sr}=cos^2 (œÄ/p_{sr}).\n\nConversely,  the whole root  system can be  recovered from the simple roots and  the corresponding coroots. The  reflections in W(R) corresponding to the  simple roots are called  simple reflections or Coxeter generators. They are precisely the generators for which the Coxeter diagram encodes the defining  relations of W(R). Each root is  in the orbit of a simple root, so  that R is obtained  as the orbit of  the simple roots under the group generated  by  the  simple  reflections.  The  restriction  of  the  simple reflections  to the span of R is  determined by the Cartan matrix, so R is determined by the Cartan matrix and the set of simple roots.\n\nThe  Cartan  matrix  corresponding  to  one  of  the above irreducible root systems  (with the specified labeling) is  returned by the command 'cartan' which  takes as input  a Symbol giving  the type (that  is ':A', ':B', ‚Ä¶, ':I')  and a positive Int giving the  rank (plus an Int giving the bond for  type :I).  This function  returns a  matrix with  entries in ‚Ñ§ for crystallographic  types, and a  matrix of Cyc  for the other types. Given two  Cartan matrices c1 and c2,  their matrix direct sum (corresponding to  the  orthogonal  direct  sum  of  the  root systems) can be produced by cat(c1,c2,dims=[1,2]).\n\nThe  function 'rootdatum' takes as input a  list of simple roots and a list of the corresponding coroots and produces a struct containing information about  the root system R and about W(R). If we label the positive roots by  '1:N', and the negative roots  by 'N+1:2N', then each simple reflection is  represented by the permutation of '1:2N' which it induces on the roots. If  only one argument is given, the Cartan matrix of the root system, it is taken  as the list  of coroots and  the list of  roots is assumed to be the canonical basis of V.\n\nIf one only wants to work with Cartan matrices with a labeling as specified by  the  above  list,  the  function  call  can  be  simplified. Instead of 'rootdatum(cartan(:D,4))' the following is also possible.\n\njulia> W=coxgroup(:D,4)\nD‚ÇÑ\n\njulia> cartan(W)\n4√ó4 Array{Int64,2}:\n  2   0  -1   0\n  0   2  -1   0\n -1  -1   2  -1\n  0   0  -1   2\n\nAlso,  the Weyl group struct associated to a direct sum of irreducible root systems can be obtained as a product\n\njulia> W=coxgroup(:A,2)*coxgroup(:B,2)\nA‚ÇÇ√ó B‚ÇÇ‚Çç‚ÇÉ‚ÇÑ‚Çé\n\njulia> cartan(W)\n4√ó4 Array{Int64,2}:\n  2  -1   0   0\n -1   2   0   0\n  0   0   2  -2\n  0   0  -1   2\n\nThe  same struct  is constructed  by applying  'coxgroup' to  the matrix 'cat(cartan(:A,2), cartan(:B,2),dims=[1,2])'.\n\nThe elements of a Weyl group are permutations of the roots:\n\njulia> W=coxgroup(:D,4)\nD‚ÇÑ\n\njulia> p=W(1,3,2,1,3)\nInt16(1,14,13,2)(3,17,8,18)(4,12)(5,20,6,15)(7,10,11,9)(16,24)(19,22,23,21)\n\njulia> word(W,p)\n5-element Array{Int64,1}:\n 1\n 3\n 1\n 2\n 3\n\n\nThis module is mostly a port of the basic functions on Weyl groups in CHEVIE. The dictionary from CHEVIE is as follows:\n\n     CartanMat(\"A\",5)                       ‚Üí  cartan(:A,5) \n     CoxeterGroup(\"A\",5)                    ‚Üí  coxgroup(:A,5) \n     Size(W)                                ‚Üí  length(W) \n     ForEachElement(W,f)                    ‚Üí  for w in W f(w) end \n     ReflectionDegrees(W)                   ‚Üí  degrees(W) \n     IsLeftDescending(W,w,i)                ‚Üí  isleftdescent(W,w,i) \n     ReflectionSubgroup                     ‚Üí  reflection_subgroup\n     TwoTree(m)                             ‚Üí  twotree(m) \n     FiniteCoxeterTypeFromCartanMat(m)      ‚Üí  type_cartan(m) \n     RootsCartan(m)                         ‚Üí  roots(m) \n     PrintDiagram(W)                        ‚Üí  Diagram(W) \n     Inversions                             ‚Üí  inversions \n     Reflection                             ‚Üí  reflection \n     W.orbitRepresentative[i]               ‚Üí  simple_representative(W,i) \n     ElementWithInversions                  ‚Üí  with_inversions\n\nfinally, a benchmark on julia 1.0.2\n\njulia> @btime length(elements(coxgroup(:E,7)))\n  531.385 ms (5945569 allocations: 1.08 GiB)\n\nGAP3 for the same computation takes 2.2s\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.PermRoot.cartan","page":"Gapjm.jl Documentation","title":"Gapjm.PermRoot.cartan","text":"`cartan(type, rank)`\n\nCartan matrix for a Weyl group:\n\njulia> cartan(:A,4)\n4√ó4 Array{Int64,2}:\n  2  -1   0   0\n -1   2  -1   0\n  0  -1   2  -1\n  0   0  -1   2\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Weyl.two_tree","page":"Gapjm.jl Documentation","title":"Gapjm.Weyl.two_tree","text":"two_tree(m)\n\nGiven  a square  matrix m  with zeroes  (or falses,  for a boolean matrix)  symmetric  with respect to the diagonal, let  G be the graph with vertices  axes(m)[1] and an edge between i and j iff !iszero(m[i,j]).  If G  is a line this function returns it as a Vector{Int}.   If  G  is  a  tree  with  one  vertex  c of valence 3 the function returns  (c,b1,b2,b3)  where b1,b2,b3 are  the branches from  this vertex sorted by  increasing length.  Otherwise the function returns nothing\n\njulia> Weyl.two_tree(cartan(:A,4))\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\njulia> Weyl.two_tree(cartan(:E,8))\n(4, [2], [3, 1], [5, 6, 7, 8])\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.PermRoot.reflection_subgroup","page":"Gapjm.jl Documentation","title":"Gapjm.PermRoot.reflection_subgroup","text":"reflection_subgroup(W,I) The subgroup of W generated by reflections(W)[I]\n\nA   theorem  discovered  by  Deodhar  cite{Deo89}  and  Dyer  cite{Dye90} independently  is that a subgroup H of a Coxeter system (W,S) generated by  reflections has  a canonical  Coxeter generating  set, formed of the t ‚ààRef(H)  such l(tt')>l(t) for any t'‚àà  Ref(H) different from t. This is used by 'reflection_subgroup' to determine the Coxeter system of H.\n\njulia> W=coxgroup(:G,2)\nG‚ÇÇ\n\njulia> Diagram(W)\nO‚áõ O\n1  2\n\njulia> H=reflection_subgroup(W,[2,6])\nG‚ÇÇ‚Çç‚ÇÇ‚ÇÑ‚Çé\n\njulia> Diagram(H)\nO‚ÄîO\n1 2\n\nThe  notation G‚ÇÇ‚Çç‚ÇÇ‚ÇÉ‚Çé means  that 'W.roots[2:3]' form  a system of simple roots for H.\n\nA  reflection subgroup has specific properties  the most important of which is  'inclusion' which gives the positions of the roots of H in the roots of W. The inverse (partial) map is 'restriction'.\n\njulia> inclusion(H)\n6-element Array{Int64,1}:\n  2\n  4\n  6\n  8\n 10\n 12\n\njulia> restriction(H)\n12-element Array{Int64,1}:\n 0\n 1\n 0\n 2\n 0\n 3\n 0\n 4\n 0\n 5\n 0\n 6\n\n\nIf H is a standard parabolic subgroup  of a Coxeter group W then the length function  on H (with respect  to its set of  generators) is the restriction of  the length function on  W. This need not  no longer be true for arbitrary reflection subgroups of W:\n\njulia> word(W,H(2))\n3-element Array{Int64,1}:\n 1\n 2\n 1\n\nIn  this package, finite  reflection groups are  represented as permutation groups  on a set of roots. Consequently,  a reflection subgroup H‚äÜ W is a permutation  subgroup, thus its elements are represented as permutations of the roots of the parent group.\n\njulia> elH=word.(Ref(H),elements(H))\n6-element Array{Array{Int64,1},1}:\n []       \n [2]      \n [1]      \n [2, 1]   \n [1, 2]   \n [1, 2, 1]\n\njulia> elW=word.(Ref(W),elements(H))\n6-element Array{Array{Int64,1},1}:\n []             \n [1, 2, 1]      \n [2]            \n [1, 2, 1, 2]   \n [2, 1, 2, 1]   \n [2, 1, 2, 1, 2]\n\njulia> map(w->H(w...),elH)==map(w->W(w...),elW)\ntrue\n\n\nAnother  basic result about reflection subgroups  of Coxeter groups is that each  coset of  H in  W contains  a unique  element of  minimal length, see reduced.\n\n\n\n\n\nOnly parabolics defined are I=1:m for m‚â§n\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Weyl.coxgroup","page":"Gapjm.jl Documentation","title":"Gapjm.Weyl.coxgroup","text":"Coxeter group from type\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Weyl.rootdatum","page":"Gapjm.jl Documentation","title":"Gapjm.Weyl.rootdatum","text":"Adjoint root datum from cartan mat\n\n\n\n\n\nroot datum\n\n\n\n\n\n","category":"function"},{"location":"#Hecke.jl-Documentation-1","page":"Gapjm.jl Documentation","title":"Hecke.jl Documentation","text":"","category":"section"},{"location":"#","page":"Gapjm.jl Documentation","title":"Gapjm.jl Documentation","text":"Hecke\nhecke","category":"page"},{"location":"#Gapjm.Hecke","page":"Gapjm.jl Documentation","title":"Gapjm.Hecke","text":"This   module  ports   Chevie  functionality   for  Iwahori-Hecke  algebras associated to Coxeter groups.\n\nLet  (W,S) be a Coxeter  system where m‚Çõ‚Çú is  the order of st for s,t‚àà S. Let R be a commutative ring with 1 and for s‚àà S let u‚Çõ‚ÇÄ,u‚Çõ‚ÇÅ‚àà R be elements which depend ony on the conjugacy class of s in W (this is the same  as requiring that u‚Çõ·µ¢=u‚Çú·µ¢ whenever m‚Çõ‚Çú is odd). The Iwahori-Hecke algebra of W over R with parameters u‚Çõ·µ¢ is a deformation of the group algebra  of W over R defined as  follows: it is the unitary associative R-algebra generated by elements T‚Çõ, s‚àà S subject to the relations:\n\n(T‚Çõ-u‚Çõ‚ÇÄ)(T‚Çõ-u‚Çõ‚ÇÅ)=0 for all s‚àà S (the quadratic relations)\n\nT‚ÇõT‚ÇúT‚Çõ= T‚ÇúT‚ÇõT‚Çú with m‚Çõ‚Çú factors on each side (the braid relations)\n\nIf  u‚Çõ‚ÇÄ=1 and  u‚Çõ‚ÇÅ=-1 for  all s  then the quadratic relations become T‚Çõ¬≤=1 and the deformation of the group algebra is trivial.\n\nSince  the generators T‚Çõ satisfy the  braid relations, the algebra H is in  fact a quotient of the group algebra of the braid group associated with W.  It follows that, if w=s_1‚ãØ s_m  is a reduced expression of w ‚àà W then  the  product  T‚Çõ_1‚ãØ T‚Çõ_m  depends  only  on w. We will therefore denote by T_w. We have T_1=1.\n\nIf  one of u‚Çõ‚ÇÄ or u‚Çõ‚ÇÅ is invertible  in R, for example u‚Çõ‚ÇÅ, then by changing  the generators  to T‚Ä≤‚Çõ=-T‚Çõ/u‚Çõ‚ÇÅ,  and setting q‚Çõ=-u‚Çõ‚ÇÄ/u‚Çõ‚ÇÅ, the braid  relations do no change  (since when m‚Çõ‚Çú is  odd we have u‚Çõ·µ¢=u‚Çú·µ¢) but  the quadratic relations become  (T‚Ä≤‚Çõ-q‚Çõ)(T‚Ä≤‚Çõ+1)=0. This last form is the  most common  form considered  in the  literature. Another common form, considered  in  the  context  of  Kazhdan-Lusztig  theory, is u‚Çõ‚ÇÄ=‚àöq‚Çõ and u‚Çõ‚ÇÅ=-‚àöq‚Çõ‚Åª¬π.  The general form of parameters provided is a special case of general cyclotomic Hecke algebras, and can be useful in many contexts.\n\nFor  some  algebras  the  character  table,  and in general Kazhdan-Lusztig bases,  require a square root of -u‚Çõ‚ÇÄu‚Çõ‚ÇÅ.  We provide a way to specify it with  the  field  .rootpara  which  can  be  given  when constructing the algebra. If not given a root is automatically extracted when needed (and we know  how to compute it) by the function RootParameter. Note however that sometimes  an  explicit  choice  of  root  is  necessary  which  cannot  be automatically determined.\n\nThere  is a universal choice  for R and u‚Çõ·µ¢:  Let u‚Çõ·µ¢:s‚àà S,i‚àà[0,1] be indeterminates   such  that  u‚Çõ·µ¢=u‚Çú·µ¢  whenever  m‚Çõ‚Çú  is  odd,  and  let A=‚Ñ§[u‚Çõ·µ¢] be the corresponding polynomial ring. Then the Hecke algebra H of  W over a  with parameters u‚Çõ·µ¢  is called the generic Iwahori-Hecke algebra  of  with  W.  Any  other  algebra  with parameters v‚Çõ·µ¢ can be obtained  by specialization from  H: There is  a unique ring homomorphism f:A  ‚Üí R such that f(u‚Çõ·µ¢)=v‚Çõ·µ¢  for all i. Then we  can view R as an A-module via f and we can identify the other algebra to R _A H.\n\nThe  elements {T_w‚à£w‚àà W} actually form an  R-basis of H if one of the u‚Çõ·µ¢  is invertible for all s. The  structure constants in that basis is obtained  as  follows.  To  multiply  T_v  by  T_w,  choose  a  reduced expression for v, say v=s_1 ‚ãØ s_k and apply inductively the formula:\n\nT_sT_w=T_sw               if l(sw)=l(w)+1\n\nT_sT_w=-u‚Çõ‚ÇÄu‚Çõ‚ÇÅT_sw+(u‚Çõ‚ÇÄ+u‚Çõ‚ÇÅ)T_w if l(sw)=l(w)-1.\n\nIf all s we have u‚Çõ‚ÇÄ=q, u‚Çõ‚ÇÅ=-1 then we call the corresponding algebra the one-parameter or Spetsial Iwahori-Hecke algebra associated with W; it can  be obtained with the  simplified call 'Hecke(W,q)'. Certain invariants of  the irreducible characters of  this algebra play a  special role in the representation  theory of the underlying  finite Coxeter groups, namely the a- and A-invariants. For basic properties of Iwahori-Hecke algebras and their  relevance to the representation theory of finite groups of Lie type, see for example Curtis and Reiner 1987, Sections~67 and 68.\n\nIn  the  following  example,  we  compute  the multiplication table for the 0-Iwahori‚ÄìHecke algebra associated with the Coxeter group of type A_2.\n\njulia> W=coxgroup(:A,2)\nA‚ÇÇ\n\njulia> H=hecke(W,0)             # One-parameter algebra with `q=0`\nHecke(A‚ÇÇ,0)\n\njulia> T=Tbasis(H)              # Create the `T` basis\n(::getfield(Gapjm.Hecke, Symbol(\"#f#25\")){Int64,Perm{Int16},HeckeAlgebra{Int64,Gapjm.Weyl.FCG{Int16,Int64,PRG{Int64,Int16}}}}) (generic function with 4 methods)\n\njulia> el=words(W)\n6-element Array{Array{Int8,1},1}:\n []       \n [2]      \n [1]      \n [2, 1]   \n [1, 2]   \n [1, 2, 1]\n\njulia> T.(el)*permutedims(T.(el))        # multiplication table\n6√ó6 Array{HeckeTElt{Perm{Int16},Int64,Gapjm.Weyl.FCG{Int16,Int64,PRG{Int64,Int16}}},2}:\n T.    T‚ÇÇ     T‚ÇÅ     T‚ÇÇ‚ÇÅ    T‚ÇÅ‚ÇÇ    T‚ÇÅ‚ÇÇ‚ÇÅ \n T‚ÇÇ    -T‚ÇÇ    T‚ÇÇ‚ÇÅ    -T‚ÇÇ‚ÇÅ   T‚ÇÅ‚ÇÇ‚ÇÅ   -T‚ÇÅ‚ÇÇ‚ÇÅ\n T‚ÇÅ    T‚ÇÅ‚ÇÇ    -T‚ÇÅ    T‚ÇÅ‚ÇÇ‚ÇÅ   -T‚ÇÅ‚ÇÇ   -T‚ÇÅ‚ÇÇ‚ÇÅ\n T‚ÇÇ‚ÇÅ   T‚ÇÅ‚ÇÇ‚ÇÅ   -T‚ÇÇ‚ÇÅ   -T‚ÇÅ‚ÇÇ‚ÇÅ  -T‚ÇÅ‚ÇÇ‚ÇÅ  T‚ÇÅ‚ÇÇ‚ÇÅ \n T‚ÇÅ‚ÇÇ   -T‚ÇÅ‚ÇÇ   T‚ÇÅ‚ÇÇ‚ÇÅ   -T‚ÇÅ‚ÇÇ‚ÇÅ  -T‚ÇÅ‚ÇÇ‚ÇÅ  T‚ÇÅ‚ÇÇ‚ÇÅ \n T‚ÇÅ‚ÇÇ‚ÇÅ  -T‚ÇÅ‚ÇÇ‚ÇÅ  -T‚ÇÅ‚ÇÇ‚ÇÅ  T‚ÇÅ‚ÇÇ‚ÇÅ   T‚ÇÅ‚ÇÇ‚ÇÅ   -T‚ÇÅ‚ÇÇ‚ÇÅ\n\n\nThus,  we work  with algebras  with arbitrary  parameters. We will see that this also works on the level of characters and representations.\n\nfinally, benchmarks on julia 1.0.2\n\njulia> function test_w0(n)\n         W=coxgroup(:A,n)\n         Tbasis(hecke(W,Pol([1],1)))(longest(W))^2\n       end\ntest_w0 (generic function with 1 method)\n\njulia> @btime test_w0(7);\n  132.737 ms (1788153 allocations: 157.37 MiB)\n\nCompare to GAP3 where the following function takes 0.92s\n\ntest_w0:=function(n)local W,T,H;\n  W:=CoxeterGroup(\"A\",n);H:=Hecke(W,X(Rationals));T:=Basis(H,\"T\");\n  T(LongestCoxeterWord(W))^2;\nend;\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.Hecke.hecke","page":"Gapjm.jl Documentation","title":"Gapjm.Hecke.hecke","text":"hecke( W [, parameter][,rootpara=r]) return a Hecke algebra for W\n\nExample\n\njulia> W=coxgroup(:B,2)\nB‚ÇÇ\n\njulia> Pol(:q)\nq\n\njulia> H=hecke(W,q)\nHecke(B‚ÇÇ,q)\n\njulia> H.para\n2-element Array{Array{Pol{Int64},1},1}:\n [q, -1]\n [q, -1]\n\njulia> H=hecke(W,q^2,rootpara=q)\nHecke(B‚ÇÇ,q¬≤,rootpara=q)\n\njulia> [H.para,rootpara(H)]\n2-element Array{Array{T,1} where T,1}:\n Array{Pol{Int64},1}[[q¬≤, -1], [q¬≤, -1]]\n Pol{Int64}[q, q]                                  \n\njulia> H=hecke(W,[q^2,q^4],rootpara=[q,q^2])\nHecke(B‚ÇÇ,Pol{Int64}[q¬≤, q‚Å¥],rootpara=Pol{Int64}[q, q¬≤])\n\njulia> [H.para,rootpara(H)]\n2-element Array{Array{T,1} where T,1}:\n Array{Pol{Int64},1}[[q¬≤, -1], [q‚Å¥, -1]]\n Pol{Int64}[q, q¬≤]\n\njulia> H=hecke(W,9,rootpara=3)\nHecke(B‚ÇÇ,9,rootpara=3)\n\njulia> [H.para,rootpara(H)]\n2-element Array{Array{T,1} where T,1}:\n Array{Int64,1}[[9, -1], [9, -1]]\n [3, 3]                              \n\n\n\n\n\n","category":"function"},{"location":"#KL.jl-Documentation-1","page":"Gapjm.jl Documentation","title":"KL.jl Documentation","text":"","category":"section"},{"location":"#","page":"Gapjm.jl Documentation","title":"Gapjm.jl Documentation","text":"KL\nKLPol\nTbasis","category":"page"},{"location":"#Gapjm.KL","page":"Gapjm.jl Documentation","title":"Gapjm.KL","text":"This  module ports Chevie functionality for Kazhdan-Lusztig polynomials and bases.\n\nLet  ‚Ñã be  the Iwahori-Hecke algebra  of a Coxeter  system (W,S), with quadratic  relations (T‚Çõ-u‚Çõ‚ÇÄ)(T‚Çõ-u‚Çõ‚ÇÅ)=0  for s‚àà  S. If  -u‚Çõ‚ÇÄu‚Çõ‚ÇÅ has a square  root  w‚Çõ,  we  can  scale  the  basis  T‚Çõ  to  get  a new basis t‚Çõ=-T‚Çõ/w‚Çõ    with   quadratic    relations   (t‚Çõ-v‚Çõ)(t‚Çõ+v‚Çõ‚Åª¬π)=0   where v‚Çõ=w‚Çõ/u‚Çõ‚ÇÅ.   The  most  general  case   when  Kazhdan-Lusztig  bases  and polynomials  can be defined is when the parameters v‚Çõ belong to a totally ordered  abelian group Œì  for multiplication, see  Lus83. We set Œì‚Å∫= {Œ≥‚àà Œì‚à£Œ≥>0} and Œì‚Åª={Œ≥‚Åª¬π‚à£Œ≥‚àà Œì‚Å∫}={Œ≥‚àà Œì‚à£Œ≥<0}.\n\nThus  we assume ‚Ñã defined over the ring ‚Ñ§[Œì], the group algebra of Œì over  ‚Ñ§, and the quadratic  relations of ‚Ñã  associate to each s‚àà S a v‚Çõ‚àà  Œì‚Å∫ such that  (t‚Çõ-v‚Çõ)(t‚Çõ+v‚Çõ‚Åª¬π)=0. We also  set q‚Çõ=v‚Çõ¬≤ and define the  basis T‚Çõ=v‚Çõt‚Çõ with quadratic relations (T‚Çõ-q‚Çõ)(T‚Çõ+1)=0; for w‚àà W with reduced expression w=s‚ÇÅ‚Ä¶s‚Çô we define q_w‚àà Œì‚Å∫ by q_w^¬Ω=v_{s‚ÇÅ}‚Ä¶v_{s‚Çô} and let q_w=(q_w^¬Ω)¬≤.\n\nWe  define the bar involution on ‚Ñã  by linearity: on ‚Ñ§[Œì] we define it by  overline_Œ≥ Œìa_Œ≥Œ≥= _Œ≥ Œì a_Œ≥ Œ≥¬π and we extend it to ‚Ñã by  overline  T‚Çõ=T‚Çõ¬π.  Then  the  Kazhdan-Lusztig  basis C‚Ä≤_w is defined  as  the  only  basis  of  ‚Ñã  stable  by the bar involution and congruent to t_w modulo _w WŒì t_w.\n\nThe  basis C‚Ä≤_w can be computed  as follows. We define elements R_xy of  ‚Ñ§[Œì] by  T_y¬π=_x overlineR_xy¬π  q_x¬πT_x. We  then define inductively  the Kazhdan-Lusztig  polynomials (in  this general  context we should  say the  Kazhdan-Lusztig elements  of ‚Ñ§[Œì],  which belong  to the subalgebra  of ‚Ñ§[Œì] generated by  the q‚Çõ) by P_xw=œÑ_(q_wq_x)^¬Ω (_xywR_xyP_yw)  where œÑ  is the  truncation: œÑ_nu _Œ≥ Œì a_Œ≥Œ≥= _Œ≥nua_Œ≥Œ≥; the induction is thus on decreasing x for the Bruhat order  and  starts  at  P_ww=1.  We  have  then  C_w=_y q_w^-12 P_ywT_y.\n\nThe  Chevie code  for the  Kazhdan-Lusztig bases  C, D and their primed versions, has been initially written by Andrew Mathas around 1994, who also contributed  to  the  design  of  the programs dealing with Kazhdan-Lusztig bases. He also implemented some other bases, such as the Murphy basis which can  be  found  in  the  Chevie  contributions  directory. The code for the unequal  parameters  case  has  been  written  around  1999  by F.Digne and J.Michel. The other Kazhdan-Lusztig bases are computed in terms of the C‚Ä≤ basis.\n\nWhen  the ‚Ñ§[Œì] is a  Laurent polynomial ring the  bar operation is taking the  inverse of  the variables,  and truncation  is keeping terms of degree smaller or equal to that of ŒΩ. It is possible to use arbitrary groups Œì as   long   as   methods   bar:_Œ≥   Œì   a_Œ≥Œ≥  _Œ≥  Œì  a_Œ≥Œ≥¬π, positive_part  : _Œ≥  Œì a_Œ≥Œ≥  _Œ≥ 1  a_Œ≥Œ≥ and negative_part: _Œ≥  Œì  a_Œ≥Œ≥    _Œ≥  1  a_Œ≥Œ≥  have been defined on ‚Ñ§[Œì]. These operations   will   be   used   internally   by  the  programs  to  compute Kazhdan-Lusztig bases.\n\nfinally, benchmarks on julia 1.0.2\n\njulia> function test_kl(W)\n         q=Pol([1],1); H=hecke(W,q^2,rootpara=q)\n         C=Cpbasis(H); T=Tbasis(H)\n         [T(C(w)) for w in elements(W)]\n       end\ntest_kl (generic function with 1 method)\n\njulia> @btime test_kl(coxgroup(:F,4));\n2.265 s (22516606 allocations: 1.81 GiB)\n\nCompare to GAP3 where the following function takes 11s for F4\n\ntest_kl:=function(W)local q,H,T,C;\n  q:=X(Rationals);H:=Hecke(W,q^2,q);\n  T:=Basis(H,\"T\");C:=Basis(H,\"C'\");\n  List(Elements(W),e->T(C(e)));\nend;\n\nAnother benchmark:\n\nfunction test_kl2(W)\n  el=elements(W)\n  [KLPol(W,x,y) for x in el, y in el]\nend\n\ntest_kl2 (generic function with 1 method)\n\njulia>@btime test_kl2(coxgroup(:F,4));\n  8s (97455915 allocations: 6.79 GiB)\n\nCompare to GAP3 where the following function takes 42s for F4\n\ntest_kl2:=function(W)local el;\n  el:=Elements(W);\n  List(el,x->List(el,y->KazhdanLusztigPolynomial(W,x,y)));\nend;\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.KL.KLPol","page":"Gapjm.jl Documentation","title":"Gapjm.KL.KLPol","text":"KLPol(W,y,w) returns the Kazhdan-Lusztig polynomial P_{y,w} of W\n\nTo  compute Kazhdan-Lusztig polynomials in  the one-parameter case it seems that  the best  approach still  is by  using the  recursion formula  in the original  article KL79. One can first run  a number of standard checks on a given  pair  of  elements  to  see  if the computation of the corresponding polynomial  can be reduced to a similar computation for elements of smaller length. One such check involves the notion of critical pairs (cf. Alv87): a pair  of elements w‚ÇÅ,w‚ÇÇ‚àà  W such that  w‚ÇÅ‚â§w‚ÇÇ is critical  if ‚Ñí(w‚ÇÇ) ‚äÜ ‚Ñí(w‚ÇÅ)  and ‚Ñõ (w‚ÇÇ)‚äÜ ‚Ñõ (w‚ÇÅ), where ‚Ñí  and ‚Ñõ denote the left and right descent  set, respectively.  Now if  y‚â§w ‚àà  W are arbitrary elements then there   always  exists  a  critical  pair   z‚â§w  with  y‚â§z‚â§w  and  then P_{y,w}=P_{z,w}.  Given two elements y and w, such a critical pair is found by the function 'critical_pair'. Whenever the polynomial corresponding to a critical pair is computed then this pair and the polynomial are stored in the property :klpol of the underlying Coxeter group.\n\njulia> W=coxgroup(:B,3)\nB‚ÇÉ\n\njulia> map(i->map(x->KLPol(W,one(W),x),elements(W,i)),1:W.N)\n9-element Array{Array{Pol{Int64},1},1}:\n [1, 1, 1]                       \n [1, 1, 1, 1, 1]                 \n [1, 1, 1, 1, 1, 1, 1]           \n [1, 1, 1, x+1, 1, 1, 1, 1]      \n [x+1, 1, 1, x+1, x+1, 1, x+1, 1]\n [1, x+1, 1, x+1, x+1, x¬≤+1, 1]  \n [x+1, x+1, x¬≤+x+1, 1, 1]        \n [x¬≤+1, x+1, 1]                  \n [1]\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Hecke.Tbasis","page":"Gapjm.jl Documentation","title":"Gapjm.Hecke.Tbasis","text":"julia> W=coxgroup(:B,3)\nB‚ÇÉ\n\njulia> Pol(:v);H=hecke(W,v^2,rootpara=v)\nHecke(B‚ÇÉ,v¬≤,rootpara=v)\n\njulia> C=Cpbasis(H)\n(::getfield(Gapjm.KL, Symbol(\"#f#10\")){Pol{Int64},Perm{Int16},HeckeAlgebra{Pol{Int64},Gapjm.Weyl.FCG{Int16,Int64,PRG{Int64,Int16}}}}) (generic function with 4 methods)\n\njulia> T=Tbasis(H)\n(::getfield(Gapjm.Hecke, Symbol(\"#f#25\")){Pol{Int64},Perm{Int16},HeckeAlgebra{Pol{Int64},Gapjm.Weyl.FCG{Int16,Int64,PRG{Int64,Int16}}}}) (generic function with 4 methods)\n\njulia> T(C(1,2))\nv‚Åª¬≤T.+v‚Åª¬≤T‚ÇÇ+v‚Åª¬≤T‚ÇÅ+v‚Åª¬≤T‚ÇÅ‚ÇÇ\n\n\n\n\n\n","category":"function"},{"location":"#Garside.jl-Documentation-1","page":"Gapjm.jl Documentation","title":"Garside.jl Documentation","text":"","category":"section"},{"location":"#","page":"Gapjm.jl Documentation","title":"Gapjm.jl Documentation","text":"Garside\nleft_divisors\nDualBraidMonoid\nfraction\nword(b::Garside.GarsideElm)\nrepresentative_operation\ncentralizer_generators\nshrink","category":"page"},{"location":"#Gapjm.Garside","page":"Gapjm.jl Documentation","title":"Gapjm.Garside","text":"Garside  monoids are a general class  of monoids whose most famous examples are  the braid  and dual  braid monoids.  The implementation  of these last monoids is in the framework of a general implementation of Garside monoids.\n\nTo   define  them  we  first  need   to  introduce  some  vocabulary  about divisibility  in monoids. A left divisor of  x is a d such that there exists  y with x=dy (and then we say  that x is a right multiple of d).  We say  that a  monoid M  is left  (resp. right) cancellable if an equality dx=dy (resp. xd=yd) implies x=y. The divisor d is proper if  y‚â†1. We say  that x is  an atom if  it has no proper left divisor apart from 1. A left gcd of x and y is a common left divisor d of x  and y such that  any other common left  divisor is a left divisor of d. Similarly a right lcm of x and y is a common multiple which is a left divisor of any other common multiple.\n\nWe  call Garside a monoid M which is:\n\nleft and right cancellable.\ngenerated by its atoms,  which are finite in number.\nsuch that any element has only finitely many divisors.\nadmits left and  right  gcds  and  lcms.\nadmits a Garside element, which is an element Œî whose set of left and right divisors coincide and generate M.\n\nGarside  elements are not  unique, but there  is a unique  minimal one (for divisibility); we assume such an element has been chosen. Then the divisors of  Œî are called the  simples of M. A  Garside monoid embeds into its group  of fractions, which is called a Garside group (a Garside group may have  several distinct Garside structures, as  we will see for Braid groups of finite Coxeter groups).\n\nWe  also implement locally Garside monoids,  which are monoids where lcms do  not always exist, but exist when any common multiple exists; the set of simples  is then not defined using a  Garside element, but by the condition that  they contain the atoms and are  closed under lcms and taking divisors (see  [BDM01]); since it is not ensured by the existence of Œî, one has to add  the condition that  any element is  divisible by finitely many simples (but  the number of simples can be infinite). The main example is the braid monoid of an infinite Coxeter group. It is not known if these monoids embed in  their group of fractions (though that has been proved for braid monoids of Coxeter groups by Paris [Paris01]) and thus computing in the monoid does not help for computing in the group (only the monoid is implemented here).\n\nWhat allows computing with Garside and locally Garside monoids, and Garside groups,  is the fact  that they admit  normal forms ‚Äì-  these normal forms where  first exhibited for  braid monoids by  Deligne [Del72], who extended previous work of Brieskorn, Saito [BS72] and Garside [Gar69]:\n\n(i) Let  M be a locally Garside monoid and let b‚àà M. Then there is a unique maximal left simple divisor Œ±(b) of b, called the head of b ‚Äì- any other simple dividing b on the left divides Œ±(b) on the left.\n\n(ii) Assume  M is a Garside monoid, Œî is  its Garside element and G is its group  of fractions. Then,  given any element  x‚àà G, there  is some power Œî‚Å± such that Œî‚Å± x‚àà M.\n\nA consequence of (i) is that any element has a canonical decomposition as a product of simples, called its left-greedy normal form. If we define œâ(x) by  x=Œ±(x)œâ(x), then the normal form of x is Œ±(x)Œ±(œâ(x))Œ±(œâ^2(x))‚Ä¶ We use  the normal form to represent elements  of M, and when M is Garside (ii)  to represent elements  of G: given  x‚àà G we  compute the smallest power  i  such  that  Œî‚Å±  x‚àà  M,  and  we  represent  x by the couple (i,Œî‚Åª‚Å±x).  We are thus reduced to the case where x‚àà M, not divisible by Œî,  where we represent  x by the  sequence of simples which constitutes its normal form. We now describe Artin-Tits braid monoids. Let (W,S) be a Coxeter system, that is W has presentation\n\n‚ü®s‚àà S‚à£s^2=1, sts‚ãØ =tst‚ãØ   (m‚Çõ‚Çú factors on each side) for s,t‚àà S‚ü©\n\nfor  some Coxeter matrix m‚Çõ‚Çú for s,t‚àà S. The braid group B associated to (W,S) is the group defined by the presentation\n\n‚ü®ùê¨‚àà ùêí‚à£ ùê¨ùê≠ùê¨‚ãØ =ùê≠ùê¨ùê≠‚ãØ  (m‚Çõ‚Çú factors on each side) for ùê¨,ùê≠‚àà ùêí‚ü©\n\nThe positive braid monoid B‚Å∫ associated to W is the monoid defined by the  presentation above ‚Äì- it identifies to the submonoid of B generated by  ùêí by  the result  of Paris  mentioned above.  This monoid  is locally Garside,  with set of simples  in bijection with elements  of W and atoms the elements of ùêí; we will denote by ùêñ the set of simples, and by ùê∞ ‚Ü¶ w  the bijection between simples and elements  of W. The group W has a length  defined  in  terms  of  reduced expressions. Similarly, having only homogeneous relations, B‚Å∫ has a natural length function. Then ùêñ can be characterized  as the subset of the elements  of B‚Å∫ of the same length as their image in W.\n\nIf  W is finite, then B‚Å∫ is Garside with Garside element the element of ùêñ whose image is the longest element  of W. A finite Coxeter group is also  a reflection group in  a real vector space,  thus in its complexified V,  and B has also a topological definition as the fundamental group of the  space V ≥·µâ·µç/W, where V ≥·µâ·µç  is the set of  elements of V which are fixed  by no  non-identity element  of S;  however, we  will not use this here.\n\nGiven a Coxeter group W,\n\nExamples\n\njulia> W=coxgroup(:A,4)\nA‚ÇÑ\n\njulia> B=BraidMonoid(W)\nBraidMonoid(A‚ÇÑ)\n\nconstructs  the  associated  braid  monoid,  and  then  as  a  function 'B' constructs  elements of the braid monoid (or group when W is finite) from a list of generators.\n\njulia> w=B(1,2,3,4)\n1234\n\njulia> w^3\n121321432.343\n\njulia> word(W,Œ±(w^3))\n9-element Array{Int64,1}:\n 1\n 2\n 1\n 3\n 2\n 1\n 4\n 3\n 2\n\njulia> w^4\nŒ¥.232432\n\njulia> inv(w)\n(1234)‚Åª¬π\n\nAs  seen in the fourth  line above, the function  'Œ±(b)' returns the simple Œ±(b)‚àà ùêñ as an element of W.\n\nHow  an element of  a Garside group  is printed is  controlled by IOcontext ':greedy'.  By default, elements are printed  as fractions a‚Åª¬πb where a and  b have no left common divisor. Each  of a and b is printed using its left-greedy normal form, that is a maximal power of the Garside element followed  the rest.  One can  print the  entire element  in the left-greedy normal  from by setting the ':greedy' IOContext; with the same w as above we have:\n\njulia> repr(w^-1,context=IOContext(stdout,:greedy=>true,:limit=>true))\n\"Œ¥‚Åª¬π.232432\"\n\nFinally,  repr gives   w  back   in  a   form  which   after  assigning 'B=braid(braid_monoid(W))' can be input back into Julia:\n\njulia> repr(w)\n\"B(1,2,3,4)\"\n\njulia> repr(w^3)\n\"B(1,2,1,3,2,1,4,3,2,3,4,3)\"\n\njulia> repr(w^-1)\n\"B(-4,-3,-2,-1)\"\n\nIn  general elements of  a Garside monoid  are displayed thus  as a list of their constituting atoms.\n\nWe  now describe the dual braid monoid.  For that, we first give a possible approach  to construct Garside monoids. Given a  group W and a set S of generators  of W as a monoid, we  define the length l(w) as the minimum number of elements of S needed to write w. We then define left divisors of   x  as  the  d   such  that  there  exists   y  with  x=dy  and l(d)+l(y)=l(x).  We say that w‚àà W is  balanced if its set of left and right  divisors coincide,  is a  lattice (where  upper and lower bounds are lcms and gcds) and generates W. Then we have:\n\nsuppose w is balanced and let [1,w] be its set of divisors (an interval for  the partial order  defined by divisibility).  Then the monoid M with generators  [1,w] and relations  xy=z whenever xy=z  holds in W and l(x)+l(y)=l(z)  is Garside,  with simples  [1,w] and  atoms S.  It is called the interval monoid defined by the interval [1,w].\n\nThe  Artin-Tits braid monoid  is an interval  monoid by taking  for S the Coxeter generators, in which case l is the Coxeter length, and taking for w  the longest element of W. The dual monoid, constructed by Birman, Ko and  Lee  for  type  A  and  by  Bessis  for  all  well-generated complex reflection  groups, is obtained in  a similar way, by  taking this time for S  the set of all reflections, and for w a Coxeter element; then l is the  reflection length  'reflength' (for  well-generated complex reflection groups  whihc are not real S contains only those reflections which divide w  for the  reflection length);  for the  dual monoid  the simples are of cardinality  the  generalized  Catalan  numbers.  An  interval  monoid  has naturally  an inverse morphism from M  to W, called 'EltBraid' which is the  quotient map from the  interval monoid to W  which sends back simple braids to [1,w]. #A  last notable  notion is  reversible monoids.  Since in CHEVIE we store #only  left normal forms, it is easy to compute left lcms and gcds, but hard #to  compute right ones.  But this becomes  easy to do  if the monoid has an #operation  'reverse', which has the property that  'a' is a left divisor of #'b'  if and only if  'reverse(a)' is a right  divisor of 'reverse(b)'. This #holds  for Artin-Tits  and dual  braid monoids;  Artin-Tits monoids  have a #reverse  operation which consists of reversing a word, written as a list of #atoms.  The dual monoid  also has a  reverse operation defined  in the same #way,  but this operation changes  monoid: it goes from  the dual monoid for #the  Coxeter element w to the dual  monoid for the Coxeter element w‚Åª¬π. #The  operations 'RightLcm' and  'RightGcd', as well  quite a few algorithms #have faster implementations if the monoid has a reverse operation.\n\nThis module implements functions to solve the conjugacy problem and compute centralizers  in Garside groups, following the work of Franco, Gebhardt and Gonzalez-Meneses.\n\nTwo  elements w and w' of a monoid  M are conjugate in M if there exists  x‚àà M such that wx=xw'; if  M satisfies the √ñre conditions, it has  a  group  of  fractions  where  this  becomes  x‚Åª¬πwx=w',  the  usual definition  of conjugacy. A special case  which is even closer to conjugacy in  the group is if there exists y‚àà  M such that w=xy and w'=yx. This relation  is not transitive in general,  but we call cyclic conjugacy the transitive closure of this relation, a restricted form of conjugacy.\n\nThe  next  observation  is  that  if  w,w'  are conjugate in the group of fractions  of the Garside monoid M then  they are conjugate in M, since if  wx=xw' then  there is  a power  Œî‚Å± which  is central and such that xŒî‚Å±‚àà M. Then wxŒî‚Å±=xŒî‚Å± w' is a conjugation in M.\n\nThe  crucial observation for solving the  conjugacy problem is to introduce inf(w):=sup{i such  that  Œî‚Å±   divides  w}  and sup(w):=inf{i such  that  w  divides Œî‚Å±}, and to notice  that the number of  conjugates of w with  same inf and sup as w  is finite. Further, a  theorem of Birman shows  that the maximum inf and  minimum sup in a conjugacy class can be achieved simultaneously; the elements  achieving this are called the super summit set of w. Thus a way to  determine if two elements are conjugate  is to find a representative of both  of them in  their super summit  set, and then  solve conjugacy within that  set. This can also be used  to compute the centralizer of an element: if  we consider  the super  summit set  as the  objects of a category whose morphisms are the conjugations by simple elements, the centralizer is given by the endomorphisms of the given object.\n\nWe illustrate this on an example:\n\njulia> b=B(2,1,4,1,4)\n214.14\n\njulia> c=B(1,4,1,4,3)\n14.143\n\njulia> d=representative_operation(b,c)\n(1)‚Åª¬π21321432\n\njulia> b^d\n14.143\n\njulia> centralizer_generators(b)\n3-element Array{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},Gapjm.Weyl.FCG{Int16,Int64,PRG{Int64,Int16}}}},1}:\n 21.1         \n 321432.213243\n 4\n\njulia> C=conjcat(b,:ss)\ncategory with 10 objects and 32 generating maps\n\njulia> C.obj\n10-element Array{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},Gapjm.Weyl.FCG{Int16,Int64,PRG{Int64,Int16}}}},1}:\n 214.14\n 14.124\n 143.13\n 1214.4\n 13.134\n 124.24\n 1343.1\n 24.214\n 134.14\n 14.143\n\nThere  is a faster  solution to the  conjugacy problem given in [gebgon10]: for  each b‚àà M, they define a  particular simple left divisor of b, its preferred  prefix  such  that  the  operation  sliding which cyclically conjugates  b by  its preferred  prefix, is  eventually periodic, and the period  is contained in the super summit set  of x. We say that x is in its  sliding circuit if some  iterated sliding of x  is equal to x. The set  of sliding  circuits in  a given  conjugacy class  is smaller than the super  summit  set,  thus  allows  to  solve  the conjugacy problem faster. Continuing from the above example,\n\njulia> word(W,preferred_prefix(b))\n2-element Array{Int64,1}:\n 2\n 1\n\njulia> b^B(preferred_prefix(b))\n1214.4\n\njulia> b1=b^B(preferred_prefix(b))\n1214.4\n\njulia> C=conjcat(b)\ncategory with 3 objects and 7 generating maps\n\njulia> C.obj\n3-element Array{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},Gapjm.Weyl.FCG{Int16,Int64,PRG{Int64,Int16}}}},1}:\n 214.14\n 1214.4\n 1343.1\n\nFinally,  we have implemented  Hao Zheng's algorithm  to extract roots in a Garside monoid:\n\njulia> W=coxgroup(:A,3)\nA‚ÇÉ\n\njulia> B=BraidMonoid(W)\nBraidMonoid(A‚ÇÉ)\n\njulia> pi=B(B.delta)^2\nŒ¥¬≤\n\njulia> root(pi,2)\nŒ¥\n\njulia> root(pi,3)\n1232\n\njulia> root(pi,4)\n132\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.Garside.left_divisors","page":"Gapjm.jl Documentation","title":"Gapjm.Garside.left_divisors","text":"left_divisors( M, s)\n\nall  the left divisors of the simple element s of the Garside monoid M, as  a vector  of vectors,  where the  i+1-th vector  holds the  divisors of length i in the atoms.\n\njulia> W=coxgroup(:A,3)\nA‚ÇÉ\n\njulia> B=BraidMonoid(W)\nBraidMonoid(A‚ÇÉ)\n\njulia> map(x->B.(x),Garside.left_divisors(B,W(1,3,2)))\n4-element Array{Array{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},Gapjm.Weyl.FCG{Int16,Int64,PRG{Int64,Int16}}}},1},1}:\n [.]   \n [1, 3]\n [13]  \n [132] \n\njulia> B=DualBraidMonoid(W)\nDualBraidMonoid(A‚ÇÉ,c=[1, 3, 2])\n\njulia> map(x->B.(x),Garside.left_divisors(B,W(1,3,2)))\n4-element Array{Array{Gapjm.Garside.GarsideElm{Perm{Int16},DualBraidMonoid{Perm{Int16},Gapjm.Weyl.FCG{Int16,Int64,PRG{Int64,Int16}}}},1},1}:\n [.]                     \n [1, 2, 3, 4, 5, 6]      \n [12, 13, 15, 25, 34, 45]\n [Œ¥]                     \n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Garside.DualBraidMonoid","page":"Gapjm.jl Documentation","title":"Gapjm.Garside.DualBraidMonoid","text":"Let  W be a well generated complex  reflection group and c be a Coxeter element  of W (if W is a Coxeter group and no c is given a particular one  is chosen  by making  the product  of elements  in a  partition of the Coxeter  diagram in two sets where  elements in each commute pairwise). The result  is the dual braid  monoid determined by W  and c: let w be an element  of W or a sequence  s‚ÇÅ,‚Ä¶,s‚Çô of integers indices of reflections of W.\n\njulia> W=coxgroup(:A,3)\nA‚ÇÉ\n\njulia> B=DualBraidMonoid(W)\nDualBraidMonoid(A‚ÇÉ,c=[1, 3, 2])\n\njulia> B(2,1,2,1,1)\n12.1.1.1\n\njulia> B(-1,-2,-3,1,1)\n(25.1)‚Åª¬π1.1\n\n\n\n\n\n","category":"type"},{"location":"#Gapjm.Garside.fraction","page":"Gapjm.jl Documentation","title":"Gapjm.Garside.fraction","text":"fraction(b) returns a tuple (x,y)  of two  elements with  no non-trivial  common left divisor and such that b=inv(x)*y.\n\njulia> B=BraidMonoid(coxgroup(:A,3))\nBraidMonoid(A‚ÇÉ)\n\njulia> b=B( 2, 1, -3, 1, 1)\n(23)‚Åª¬π321.1.1\n\njulia> fraction(b)\n(23, 321.1.1)\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.word-Tuple{Gapjm.Garside.GarsideElm}","page":"Gapjm.jl Documentation","title":"Gapjm.word","text":"word(b::GarsideElm) returns  a description  of b  as a  list of  the atoms  of which  it is a product.  If b is in the Garside group  but not the Garside monoid, it is represented  in  fraction  normal  form  where  as a special convention the inverses  of  the  atoms  are  represented  by  negating  the corresponding integer.\n\njulia> B=BraidMonoid(coxgroup(:A,3))\nBraidMonoid(A‚ÇÉ)\n\njulia> b=B(2,1,2,1,1)*inv(B(2,2))\n(21)‚Åª¬π1.12.21\n\njulia> word(b)\n7-element Array{Int64,1}:\n -1\n -2\n  1\n  1\n  2\n  2\n  1\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.Garside.representative_operation","page":"Gapjm.jl Documentation","title":"Gapjm.Garside.representative_operation","text":"representative_operation(b,b1)\n\nThe  function returns a such that  b^a=b1 if such exists, and nothing otherwise.  If an argument <type> is given,  the computation is done in the corresponding category ‚Äì- see \"conjcat\".\n\njulia> W=coxgroup(:D,4)\nD‚ÇÑ\n\njulia> B=BraidMonoid(coxgroup(:D,4))\nBraidMonoid(D‚ÇÑ)\n\njulia> b=B(2,3,1,2,4,3);b1=B(1,4,3,2,2,2)\n1432.2.2\n\njulia> representative_operation(b,b1)\n(134312.23)‚Åª¬π\n\njulia> representative_operation(b,b1,:cyc)\n232.2\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Garside.centralizer_generators","page":"Gapjm.jl Documentation","title":"Gapjm.Garside.centralizer_generators","text":"centralizer_generators(b)\n\na list of generators  of the centralizer of b.  The computation is done by computing the  endomorphisms  of  the  object  b  in  the  category  of its sliding circuits.  If an argument type  is given, the computation  is done in the corresponding  category ‚Äì- see conjcat. The  main use of this is to compute  the  centralizer  in  the  category  of cyclic conjugacy by giving :cyc as the type.\n\njulia> W=coxgroup(:D,4)\nD‚ÇÑ\n\njulia> B=BraidMonoid(W)\nBraidMonoid(D‚ÇÑ)\n\njulia> w=B(4,4,4)\n4.4.4\n\njulia> cc=centralizer_generators(w)\n8-element Array{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},Gapjm.Weyl.FCG{Int16,Int64,PRG{Int64,Int16}}}},1}:\n (31432)‚Åª¬π231432\n 1              \n (2)‚Åª¬π34.432    \n (1)‚Åª¬π34.431    \n 34.43          \n 4              \n (32431)‚Åª¬π132431\n 2              \n\njulia> shrink(cc)\n5-element Array{Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},Gapjm.Weyl.FCG{Int16,Int64,PRG{Int64,Int16}}}},1}:\n 4            \n 2            \n 1            \n 34.43        \n (3243)‚Åª¬π13243\n\njulia> centralizer_generators(w,:cyc)\nSet(Gapjm.Garside.GarsideElm{Perm{Int16},BraidMonoid{Perm{Int16},Gapjm.Weyl.FCG{Int16,Int64,PRG{Int64,Int16}}}}[4])\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Garside.shrink","page":"Gapjm.jl Documentation","title":"Gapjm.Garside.shrink","text":"shrink(l)\n\nThe  list l is a  list of  elements of  the same Garside group G. This function  tries to find  another set of  generators of the  subgroup of G generated by the elements of l, of smaller total length (the length being counted  as returned by the function  word).\n\njulia> B=BraidMonoid(coxsym(3))\nBraidMonoid(ùîñ ‚ÇÉ)\n\njulia> b=[B(1)^3,B(2)^3,B(-2,-1,-1,2,2,2,2,1,1,2),B(1,1,1,2)]\n4-element Array{Gapjm.Garside.GarsideElm{Perm{UInt8},BraidMonoid{Perm{UInt8},Gapjm.CoxGroups.CoxSymmetricGroup{UInt8}}},1}:\n 1.1.1              \n 2.2.2              \n (1.12)‚Åª¬π2.2.2.21.12\n 1.1.12             \n\njulia> shrink(b)\n2-element Array{Gapjm.Garside.GarsideElm{Perm{UInt8},BraidMonoid{Perm{UInt8},Gapjm.CoxGroups.CoxSymmetricGroup{UInt8}}},1}:\n 2  \n 1  \n\n\n\n\n\n","category":"function"},{"location":"#HasType.jl-Documentation-1","page":"Gapjm.jl Documentation","title":"HasType.jl Documentation","text":"","category":"section"},{"location":"#","page":"Gapjm.jl Documentation","title":"Gapjm.jl Documentation","text":"CharTable","category":"page"},{"location":"#Gapjm.HasType.CharTable","page":"Gapjm.jl Documentation","title":"Gapjm.HasType.CharTable","text":"CharTable is a structure to hold character tables of groups and Hecke  algebras\n\n\n\n\n\n","category":"type"},{"location":"#Util.jl-Documentation-1","page":"Gapjm.jl Documentation","title":"Util.jl Documentation","text":"","category":"section"},{"location":"#","page":"Gapjm.jl Documentation","title":"Gapjm.jl Documentation","text":"Util\ngroupby\nconstant\nblocks\nformat\nprime_residues\nphi\nprimitiveroot\nechelon!","category":"page"},{"location":"#Gapjm.Util","page":"Gapjm.jl Documentation","title":"Gapjm.Util","text":"This  module contains  various utility  functions used  in the  rest of the code.  Maybe some  of them  exist in  some Julia  module I am not aware of; please tell me.\n\nThe code is divided in sections  according to semantics.\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.Util.groupby","page":"Gapjm.jl Documentation","title":"Gapjm.Util.groupby","text":"group items of list l according to the corresponding values in list v\n\njulia> groupby([31,28,31,30,31,30,31,31,30,31,30,31],\n       [:Jan,:Feb,:Mar,:Apr,:May,:Jun,:Jul,:Aug,:Sep,:Oct,:Nov,:Dec])\nDict{Int64,Array{Symbol,1}} with 3 entries:\n  31 => Symbol[:Jan, :Mar, :May, :Jul, :Aug, :Oct, :Dec]\n  28 => Symbol[:Feb]\n  30 => Symbol[:Apr, :Jun, :Sep, :Nov]\n\n\n\n\n\ngroup items of list l according to the values taken by function f on them\n\njulia> groupby(iseven,1:10)\nDict{Bool,Array{Int64,1}} with 2 entries:\n  false => [1, 3, 5, 7, 9]\n  true  => [2, 4, 6, 8, 10]\n\nNote:in this version l is required to be non-empty since I do not know how to access the return type of a function\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Util.constant","page":"Gapjm.jl Documentation","title":"Gapjm.Util.constant","text":"whether all elements in list a are equal\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Util.blocks","page":"Gapjm.jl Documentation","title":"Gapjm.Util.blocks","text":"blocks(M::Matrix)\n\nM  should be a square matrix. Define  a graph G with vertices 1:size(M,1)   and  with an edge between i and j  if either M[i,j] or M[j,i] is not zero   or false. blocks returns a vector of vectors I such that I[1],I[2], etc..   are  the  vertices  in  each  connected  component  of G. In other words,   M[I[1],I[1]],M[I[2],I[2]],etc... are blocks of M.\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Util.format","page":"Gapjm.jl Documentation","title":"Gapjm.Util.format","text":"format( table; options )\n\nGeneral routine to format a table. Used for character tables.   Options:      rowlabels          Labels for rows      columnlabels       Labels for columns      rowslabel          Label for column of rowLabels      separators          line numbers after which to put a separator      columnrepartition  display in pieces of sizes these numbers of cols      rows                show only these rows      columns             show only these columns\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Util.prime_residues","page":"Gapjm.jl Documentation","title":"Gapjm.Util.prime_residues","text":"the numbers less than n and prime to n \n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Util.phi","page":"Gapjm.jl Documentation","title":"Gapjm.Util.phi","text":"the Euler function œï \n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Util.primitiveroot","page":"Gapjm.jl Documentation","title":"Gapjm.Util.primitiveroot","text":"primitiveroot(m::Integer) a primitive root mod. m,   that is it generates multiplicatively prime_residues(m).   It exists if m is of the form 4, 2p^a or p^a for p prime>2.\n\n\n\n\n\n","category":"function"},{"location":"#Cycpols.jl-Documentation-1","page":"Gapjm.jl Documentation","title":"Cycpols.jl Documentation","text":"","category":"section"},{"location":"#","page":"Gapjm.jl Documentation","title":"Gapjm.jl Documentation","text":"CycPols","category":"page"},{"location":"#Gapjm.CycPols","page":"Gapjm.jl Documentation","title":"Gapjm.CycPols","text":"Cyclotomic  numbers, and cyclotomic polynomials  over the rationals or some cyclotomic field, are important in reductive groups or Spetses. This module deals  with them: the type CycPol  represents the product of a polynomial with  a rational fraction in one variable with all poles or zeroes equal to 0  or  roots  of  unity.  The  advantages  of representing as CycPol such objects    are:   nice   display   (factorized),   less   storage,   faster multiplication,  division and evaluation. The drawback is that addition and subtraction are not implemented!\n\njulia> Pol(:q)\nq\n\njulia> p=CycPol(q^25-q^24-2q^23-q^2+q+2)\n(q-2)Œ¶‚ÇÅŒ¶‚ÇÇŒ¶‚ÇÇ‚ÇÉ\n\njulia> p(q) # a CycPol is a callable object, this call evaluates p at q\nq¬≤‚Åµ-q¬≤‚Å¥-2q¬≤¬≥-q¬≤+q+2\n\njulia> p*inv(CycPol(q^2+q+1))\n(q-2)Œ¶‚ÇÅŒ¶‚ÇÇŒ¶‚ÇÉ‚Åª¬πŒ¶‚ÇÇ‚ÇÉ\n\n\nThe variable name in a CycPol is set by default to the same as for Pols.\n\nCycPols are internally a struct with fields:\n\n.coeff:  a coefficient, usually a cyclotomic number or a polynomial.\n\n.valuation: an Int.\n\n.v: a list of pairs r=>m of a root of unity r and a multiplicity m. Here r is a Root1, internally a fraction n//e with n<e representing E(r)=E(e,n).\n\nSo CycPol(c,val,v) represents c*q^val*prod((q-E(r))^m for (r,m) in v).\n\nWhen   showing,  some  factors  of   the  cyclotomic  polynomial  Œ¶‚Çô  are represented.  If n  has a  primitive root,  œï‚Ä≤‚Çô is  the product  of the (q-Œ∂)  where Œ∂ runs over the odd powers of a primitive root of n, and œï‚Ä≥‚Çô  is the product for the even powers. Some other factors of cyclotomic polynomials are:\n\nŒ¶‚Ä≤‚Çà=q¬≤-Œ∂‚ÇÑ\nŒ¶‚Ä≥‚Çà=q¬≤+Œ∂‚ÇÑ\nŒ¶‚Ä¥‚Çà=q¬≤-‚àö2q+1\nŒ¶‚Åó‚Çà=q¬≤+‚àö2q+1\nŒ¶‚ÅΩ‚Åµ‚Åæ‚Çà=q¬≤-‚àö-2q-1\nŒ¶‚ÅΩ‚Å∂‚Åæ‚Çà=q¬≤+‚àö-2q-1\nŒ¶‚Ä≤‚ÇÅ‚ÇÇ=q¬≤-Œ∂‚ÇÑq-1\nŒ¶‚Ä≥‚ÇÅ‚ÇÇ=q¬≤+Œ∂‚ÇÑq-1\nŒ¶‚Ä¥‚ÇÅ‚ÇÇ=q¬≤+Œ∂‚ÇÉ¬≤\nŒ¶‚Åó‚ÇÅ‚ÇÇ=q¬≤+Œ∂‚ÇÉ\nŒ¶‚ÅΩ‚Åµ‚Åæ‚ÇÅ‚ÇÇ=q¬≤-‚àö3q+1\nŒ¶‚ÅΩ‚Å∂‚Åæ‚ÇÅ‚ÇÇ=q¬≤+‚àö3q+1\nŒ¶‚Ä≤‚ÇÅ‚ÇÖ=q‚Å¥-q(1+‚àö5)(q^2-q+1)/2+1\nŒ¶‚Ä≥‚ÇÅ‚ÇÖ=q‚Å¥-q(1-‚àö5)(q^2-q+1)/2+1\nŒ¶‚Ä¥‚ÇÅ‚ÇÖ=q‚Å¥+Œ∂‚ÇÉ¬≤q¬≥+Œ∂‚ÇÉq¬≤+q+Œ∂‚ÇÉ¬≤\nŒ¶‚Åó‚ÇÅ‚ÇÖ=q‚Å¥+Œ∂‚ÇÉq¬≥+Œ∂‚ÇÉ¬≤q¬≤+q+Œ∂‚ÇÉ\nŒ¶‚ÅΩ‚Åµ‚Åæ‚ÇÅ‚ÇÖ=q¬≤+Œ∂‚ÇÉ¬≤(1+‚àö5)q/2+Œ∂‚ÇÉ\nŒ¶‚ÅΩ‚Å∂‚Åæ‚ÇÅ‚ÇÖ=q¬≤+Œ∂‚ÇÉ¬≤(1-‚àö5)q/2+Œ∂‚ÇÉ\nŒ¶‚ÅΩ‚Å∑‚Åæ‚ÇÅ‚ÇÖ=q¬≤+Œ∂‚ÇÉ(1+‚àö5)q/2+Œ∂‚ÇÉ\nŒ¶‚ÅΩ‚Å∏‚Åæ‚ÇÅ‚ÇÖ=q¬≤+Œ∂‚ÇÉ(1-‚àö5)q/2+Œ∂‚ÇÉ\nŒ¶‚Ä≤‚ÇÇ‚ÇÄ=q‚Å¥-(1+‚àö5)/2q¬≤+1\nŒ¶‚Ä≥‚ÇÇ‚ÇÄ=q‚Å¥-(1-‚àö5)/2q¬≤+1\nŒ¶‚Ä¥‚ÇÇ‚ÇÄ=q‚Å¥+Œ∂‚ÇÑq¬≥-q¬≤-Œ∂‚ÇÑq+1\nŒ¶‚Åó‚ÇÇ‚ÇÄ=q‚Å¥-Œ∂‚ÇÑq¬≥-q¬≤+Œ∂‚ÇÑq+1\nŒ¶‚Ä≤‚ÇÇ‚ÇÑ=q‚Å¥+Œ∂‚ÇÉ¬≤\nŒ¶‚Ä≥‚ÇÇ‚ÇÑ=q‚Å¥+Œ∂‚ÇÉ\nŒ¶‚Ä¥‚ÇÇ‚ÇÑ=q‚Å¥-‚àö2q¬≥+q¬≤-‚àö2q+1\nŒ¶‚Åó‚ÇÇ‚ÇÑ=q‚Å¥+‚àö2q¬≥+q¬≤+‚àö2q+1\nŒ¶‚ÅΩ‚Åµ‚Åæ‚ÇÇ‚ÇÑ=q‚Å¥-‚àö6q¬≥+3q¬≤-‚àö6q+1\nŒ¶‚ÅΩ‚Å∂‚Åæ‚ÇÇ‚ÇÑ=q‚Å¥+‚àö6q¬≥+3q¬≤+‚àö6q+1\nŒ¶‚ÅΩ‚Å∑‚Åæ‚ÇÇ‚ÇÑ=q‚Å¥+‚àö-2q¬≥-q¬≤-‚àö-2q+1\nŒ¶‚ÅΩ‚Å∏‚Åæ‚ÇÇ‚ÇÑ=q‚Å¥-‚àö-2q¬≥-q¬≤+‚àö-2q+1\nŒ¶‚ÅΩ‚Åπ‚Åæ‚ÇÇ‚ÇÑ=q¬≤+Œ∂‚ÇÉ¬≤‚àö-2q-Œ∂‚ÇÉ\nŒ¶‚ÅΩ¬π‚Å∞‚Åæ‚ÇÇ‚ÇÑ=q¬≤-Œ∂‚ÇÉ¬≤‚àö-2q-Œ∂‚ÇÉ\nŒ¶‚ÅΩ¬π¬π‚Åæ‚ÇÇ‚ÇÑ=q¬≤+Œ∂‚ÇÉ‚àö-2q-Œ∂‚ÇÉ¬≤\nŒ¶‚ÅΩ¬π¬≤‚Åæ‚ÇÇ‚ÇÑ=q¬≤-Œ∂‚ÇÉ‚àö-2q-Œ∂‚ÇÉ¬≤\nŒ¶‚Ä≤‚ÇÉ‚ÇÄ=q‚Å¥-q(1-‚àö5)(q^2+q+1)/2+1\nŒ¶‚Ä≥‚ÇÉ‚ÇÄ=q‚Å¥-q(1+‚àö5)(q^2+q+1)/2+1\nŒ¶‚Ä¥‚ÇÉ‚ÇÄ=q‚Å¥-Œ∂‚ÇÉq¬≥+Œ∂‚ÇÉ¬≤q¬≤-q+Œ∂‚ÇÉ\nŒ¶‚Åó‚ÇÉ‚ÇÄ=q‚Å¥-Œ∂‚ÇÉ¬≤q¬≥+Œ∂‚ÇÉq¬≤-q+Œ∂‚ÇÉ¬≤\nŒ¶‚ÅΩ‚Åµ‚Åæ‚ÇÉ‚ÇÄ=q¬≤-Œ∂‚ÇÉ¬≤(1-‚àö5)q/2+Œ∂‚ÇÉ\nŒ¶‚ÅΩ‚Å∂‚Åæ‚ÇÉ‚ÇÄ=q¬≤-Œ∂‚ÇÉ¬≤(1+‚àö5)q/2+Œ∂‚ÇÉ\nŒ¶‚ÅΩ‚Å∑‚Åæ‚ÇÉ‚ÇÄ=q¬≤-Œ∂‚ÇÉ(1-‚àö5)q/2+Œ∂‚ÇÉ¬≤\nŒ¶‚ÅΩ‚Å∏‚Åæ‚ÇÉ‚ÇÄ=q¬≤-Œ∂‚ÇÉ(1+‚àö5)q/2+Œ∂‚ÇÉ¬≤\nŒ¶‚Ä≤‚ÇÑ‚ÇÇ=q‚Å∂-Œ∂‚ÇÉ¬≤q‚Åµ+Œ∂‚ÇÉq‚Å¥-q¬≥+Œ∂‚ÇÉ¬≤q¬≤-Œ∂‚ÇÉq+1\nŒ¶‚Ä≥‚ÇÑ‚ÇÇ=q‚Å∂-Œ∂‚ÇÉq‚Åµ+Œ∂‚ÇÉ¬≤q‚Å¥-q¬≥+Œ∂‚ÇÉq¬≤-Œ∂‚ÇÉ¬≤q+1\n\n\n\n\n\n","category":"module"}]
}
