var documenterSearchIndex = {"docs":
[{"location":"#Gapjm-Documentation","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"","category":"section"},{"location":"","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"Gapjm","category":"page"},{"location":"#Gapjm","page":"Gapjm Documentation","title":"Gapjm","text":"This  is  my  effort  porting  GAP  code  to Julia, specifically the Chevie package  of  GAP3  plus  the  GAP  functionality needed for Chevie to work: Cyclotomics,   Permutations,   Laurent   and   Puiseux  polynomials,  basic permutation group operations, etcâ€¦.\n\nI am rather new to Julia, git and github so I am not even sure this package is  properly constituted; I did not try yet to register it. If you are more competent  that me and see anything to  be improved in this package, please write me or make a pull request.\n\nInstalling\n\nTo install this package, at the Julia command line:\n\nenter package mode with ]\ndo the command\n\n(v1.0) pkg> add \"https://github.com/jmichel7/Gapjm.jl\"\n\nexit package mode with backspace and then do\n\njulia> using Gapjm\n\nand you are set up.\n\nTo update later to the latest version, do\n\n(v1.0) pkg> update \"https://github.com/jmichel7/Gapjm.jl\"\n\nThe package currently contains as infrastructure:\n\npermutations\ncyclotomic numbers\nunivariate Laurent and multivariate Puiseux polynomials\ncombinatorics\nlinear algebra on any field/ring\nposets\ncyclotomic polynomials\nsigned permutations\nfinite fields\ngroups\npermutation groups\n\nfor  permutation groups I have  often replaced the sophisticated algorithms of  GAP by naive but  easy to write methods  only suitable for small groups (sufficient  for the  rest of  the package  but maybe  not for your needs). Otherwise  the  code  for  infrastructure  is  often  competitive with GAP, despite  being much shorter (often 100 lines of Julia replace 1000 lines of C); I am sure there are more optimisations possible. Any comments about the code and the design are welcome.\n\nThis  package contains about 90% of Chevie functionality, ported from Gap3. The  function gap can help you discover the equivalent functionality to a Gap3  function:  it  takes  a  string  and  gives you Julia translations of functions in Gap3 which match this string.\n\njulia> gap(\"words\")\nCoxeterWords(W[,l])      =>  word.(Ref(W),elements(W[,l])\nGarsideWords             =>  elements\nCharRepresentationWords  =>  traces_words_mats\n\nThen you can call on-line help on the discovered functions.\n\nThe data library of Chevie has been automatically ported by a transpiler so its code is \"strange\". Otherwise the code in this package is often 10 times faster  than the  equivalent GAP3  Chevie code  (after the maddeningly long compilation time on first execution).\n\nI  tried  that  as  any  submodules  as  possible in my package can be used independently  of the rest, thus could be independent packages. This is the case  for the  modules Combinat,  Groups, ModuleElts, Perms, Util which  can  be  used  stand-alone.  In  addition  modules MatInt, Cycs, Pols, Mvp, Posets, FFields can be used stand-alone except they each use one or two functions from Util.\n\n\n\n\n\n","category":"module"},{"location":"","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"","category":"page"},{"location":"#Permutations","page":"Gapjm Documentation","title":"Permutations","text":"","category":"section"},{"location":"","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"Perms\nPerm\nPerm(::Integer...)\nPerm(::AbstractVector,::AbstractVector)\n@perm_str\nlargest_moved_point\nsmallest_moved_point\nBase.:^(::AbstractVector,::Perm) \nsortPerm\nPerms.orbit\nPerms.orbits\nPerms.order\ncycles\ncycletype\nsupport\nsign\nBase.Matrix(::Perm,n)\nBase.:^(::AbstractMatrix,::Perm)\nrestricted(::Perm,::AbstractVector{<:Integer})\nreflength(::Perm)\nmappingPerm","category":"page"},{"location":"#Gapjm.Perms","page":"Gapjm Documentation","title":"Gapjm.Perms","text":"This  module implements permutations with the  same semantics as in the GAP language.\n\nPerms  are permutations  of the  set 1:n,  represented internally  as a vector  of n  integers holding  the images  of 1:n.  The integer n is called  the degree  of the  permutation; two  permutations are equal if and only  if they move the same points in  the same way, so two permutations of different  degree can be equal; the degree is thus an implementation detail so  usually  it  should  not  be  used.  One should rather use the function largest_moved_point.\n\nThis follows the GAP design: it is possible to multiply, or to store in the same  group,  permutations  of  different  degrees;  this is implemented by promoting both to the higher degree. Slightly different is the MAGMA design where any permutation has to belong to a group and the degree is determined by  that group; then multiplication of permutations within a given group is (very  slightly) faster, but it is  more difficult to multiply permutations coming  from different groups, like  a group and one  of its subgroups.\n\nThe default constructor for a permutation uses the list of images of 1:n, like  Perm([2,3,1,5,4]).  Often  it  is  more  convenient  to  use  cycle decompositions:    the   above   permutation    has   cycle   decomposition (1,2,3)(4,5)    thus   can   be    written   Perm(1,2,3)*Perm(4,5)   or perm\"(1,2,3)(4,5)\" (this last form can parse a GAP permutation). The list of  images of 1:n can  be recovered from the  permutation by the function vec;  note  that  equal  permutations  with  different  degrees will have different vec.\n\nThe  complete type of a permutation  is Perm{T} where T<:Integer, where Vector{T}  is the type of the vector which holds the image of 1:n. This can  be used to save space or  time. For instance Perm{UInt8} can be used for  Weyl groups of rankâ‰¤8 since they permute  at most 240 roots. If T is not  specified we  take it  to be  Int16 since  this is a good compromise between   speed,  compactness  and  possible  size  of  n.  One  can  mix permutations of different integer types; they are promoted to the wider one when multiplying.\n\nExamples of operations with permutations\n\njulia> a=Perm(1,2,3)\n(1,2,3)\n\njulia> vec(a)\n3-element Vector{Int16}:\n 2\n 3\n 1\n\njulia> a==Perm(vec(a))\ntrue\n\njulia> b=Perm(1,2,3,4)\n(1,2,3,4)\n\njulia> a*b     # product\n(1,3,2,4)\n\njulia> inv(a)  # inverse\n(1,3,2)\n\njulia> a/b     # quotient  a*inv(b)\n(3,4)\n\njulia> a\\b     # left quotient inv(a)*b\n(1,4)\n\njulia> a^b     # conjugation inv(b)*a*b\n(2,3,4)\n\njulia> b^2     # square\n(1,3)(2,4)\n\njulia> 1^a     # image by a of point 1\n2\n\njulia> one(a)  # trivial permutation\n()\n\njulia> sign(a) # signature of permutation\n1\n\njulia> order(a) # order (least trivial power) of permutation\n3\n\njulia> largest_moved_point(a)\n3\n\njulia> smallest_moved_point(a)\n1\n\njulia> Perm{Int8}(a) # convert a to Perm{Int8}\nPerm{Int8}: (1,2,3)\n\njulia> Matrix(b)  # permutation matrix of b\n4Ã—4 Matrix{Bool}:\n 0  1  0  0\n 0  0  1  0\n 0  0  0  1\n 1  0  0  0\n\njulia> rand(Perm,10)\n(1,8,4,2,9,7,5,10,3,6)\n\nPerms have methods copy, hash, ==, so they can be keys in hashes or elements  of sets; two permutations are equal  if they move the same points to  the same images. They have methods cmp, isless (lexicographic order on   moved  points)  so  they  can  be  sorted.  Perms  are  scalars  for broadcasting.\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.Perms.Perm","page":"Gapjm Documentation","title":"Gapjm.Perms.Perm","text":"struct Perm{T<:Integer}\n\nA  Perm represents a permutation  of the set 1:n  and is implemented by a struct with one field, a Vector{T} holding the images of 1:n.\n\n\n\n\n\n","category":"type"},{"location":"#Gapjm.Perms.Perm-Tuple{Vararg{Integer, N} where N}","page":"Gapjm Documentation","title":"Gapjm.Perms.Perm","text":"Perm{T}(x::Integer...)where T<:Integer\n\nreturns  a cycle.  For example  Perm{Int8}(1,2,3) constructs the cycle    (1,2,3) as a Perm{Int8}. If omitted {T} is taken to be Int16.\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.Perms.Perm-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}","page":"Gapjm Documentation","title":"Gapjm.Perms.Perm","text":"Perm{T}(l::AbstractVector,l1::AbstractVector)\n\nreturns p, a Perm{T}, such that l1^p==l if such a p exists; returns nothing otherwise. If not given {T} is taken to be {Int16}. Needs the elements of l and l1 to be sortable.\n\njulia> Perm([0,2,4],[4,0,2])\n(1,3,2)\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.Perms.@perm_str","page":"Gapjm Documentation","title":"Gapjm.Perms.@perm_str","text":"@perm\"...\"\n\nmake a Perm from a string; allows GAP-style perm\"(1,2)(5,6,7)(4,9)\"\n\n\n\n\n\n","category":"macro"},{"location":"#Gapjm.Perms.largest_moved_point","page":"Gapjm Documentation","title":"Gapjm.Perms.largest_moved_point","text":"largest_moved_point(a::Perm) is the largest integer moved by a\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Perms.smallest_moved_point","page":"Gapjm Documentation","title":"Gapjm.Perms.smallest_moved_point","text":"smallest_moved_point(a::Perm) is the smallest integer moved by a\n\n\n\n\n\n","category":"function"},{"location":"#Base.:^-Tuple{AbstractVector{T} where T, Perm}","page":"Gapjm Documentation","title":"Base.:^","text":"Base.:^(l::AbstractVector,p::Perm) \n\nreturns l permuted by p, a vector r such that r[i^p]==l[i]\n\nExamples\n\njulia> [5,4,6,1,7,5]^Perm(1,3,5,6,4)\n6-element Vector{Int64}:\n 1\n 4\n 5\n 5\n 6\n 7\n\nnote that we follow here the convention for the GAP function Permuted, but this has the consequence that sort(a)==a^inv(Perm(sortperm(a))).\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.Perms.sortPerm","page":"Gapjm Documentation","title":"Gapjm.Perms.sortPerm","text":"for convenience: sortPerm(a)=Perm(sortperm(a))\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Perms.orbit","page":"Gapjm Documentation","title":"Gapjm.Perms.orbit","text":"orbit(a::Perm,i::Integer) returns the orbit of a on i\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Perms.orbits","page":"Gapjm Documentation","title":"Gapjm.Perms.orbits","text":"orbits(a::Perm,d::Vector=1:length(a.d)) \n\nreturns the orbits of a on domain d\n\nExample\n\njulia> orbits(Perm(1,2)*Perm(4,5),1:5)\n3-element Vector{Vector{Int16}}:\n [1, 2]\n [3]\n [4, 5]\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Perms.order","page":"Gapjm Documentation","title":"Gapjm.Perms.order","text":"order(a::Perm) is the order of the permutation a\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Perms.cycles","page":"Gapjm Documentation","title":"Gapjm.Perms.cycles","text":"cycles(a::Perm) returns the non-trivial cycles of a\n\nExample\n\njulia> cycles(Perm(1,2)*Perm(4,5))\n2-element Vector{Vector{Int16}}:\n [1, 2]\n [4, 5]\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Perms.cycletype","page":"Gapjm Documentation","title":"Gapjm.Perms.cycletype","text":"cycletype(a::Perm,domain=1:length(a.d))\n\ndescribes the partition of length(a.d) associated to the conjugacy class of a in the symmetric group of domain, with ones removed (thus it does not depend on length(a.d) but just on the moved points). It is represented as a sorted list of pairs cyclesize=>multiplicity.\n\nExample\n\njulia> cycletype(Perm(1,2)*Perm(3,4))\n1-element Vector{Pair{Int64, Int64}}:\n 2 => 2\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Perms.support","page":"Gapjm Documentation","title":"Gapjm.Perms.support","text":"support(a::Perm) is the set of all points moved by a\n\n\n\n\n\n","category":"function"},{"location":"#Base.sign","page":"Gapjm Documentation","title":"Base.sign","text":"sign(a::Perm) is the signature of  the permutation a\n\n\n\n\n\n","category":"function"},{"location":"#Base.Matrix-Tuple{Perm, Any}","page":"Gapjm Documentation","title":"Base.Matrix","text":"Matrix(a::Perm,n=length(a.d))  the  permutation matrix  for a  operating on  n points (by default, the degree of a). If given, n should be larger than largest_moved_point(a).\n\njulia> Matrix(Perm(2,3,4),5)\n5Ã—5 Matrix{Bool}:\n 1  0  0  0  0\n 0  0  1  0  0\n 0  0  0  1  0\n 0  1  0  0  0\n 0  0  0  0  1\n\n\n\n\n\n","category":"method"},{"location":"#Base.:^-Tuple{AbstractMatrix{T} where T, Perm}","page":"Gapjm Documentation","title":"Base.:^","text":"Base.:^(m::AbstractMatrix,p::Perm;dims=1)\n\nApplies the permutation p on the lines, columns or both of the matrix m depending on the value of dims\n\njulia> m=[3*i+j for i in 0:2,j in 1:3]\n3Ã—3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n 7  8  9\n\njulia> p=Perm(1,2,3)\n(1,2,3)\n\njulia> m^p\n3Ã—3 Matrix{Int64}:\n 7  8  9\n 1  2  3\n 4  5  6\n\njulia> ^(m,p;dims=2)\n3Ã—3 Matrix{Int64}:\n 3  1  2\n 6  4  5\n 9  7  8\n\njulia> ^(m,p;dims=(1,2))\n3Ã—3 Matrix{Int64}:\n 9  7  8\n 3  1  2\n 6  4  5\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.Perms.restricted-Tuple{Perm, AbstractVector{var\"#s26\"} where var\"#s26\"<:Integer}","page":"Gapjm Documentation","title":"Gapjm.Perms.restricted","text":"restricted(a::Perm,l::AbstractVector{<:Integer})\n\nl should be a union of cycles of p; returns p restricted to l\n\njulia> restricted(Perm(1,2)*Perm(3,4),3:4)\n(3,4)\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.Perms.reflength-Tuple{Perm}","page":"Gapjm Documentation","title":"Gapjm.Perms.reflength","text":"reflength(a::Perm)\n\nis   the  \"reflection   length\"  of   a,  that   is,  minimum  number  of transpositions of which a is the product\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.Perms.mappingPerm","page":"Gapjm Documentation","title":"Gapjm.Perms.mappingPerm","text":"mappingPerm(a,b)\n\ngiven two lists of positive integers without repetition a and b, this function finds a permutation p such that a.^p==b.\n\njulia> mappingPerm([1,2,5,3],[2,3,4,6])\n(1,2,3,6,5,4)\n\n\n\n\n\n","category":"function"},{"location":"#Groups","page":"Gapjm Documentation","title":"Groups","text":"","category":"section"},{"location":"","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"Groups\nGroup\norbit(::Vector,::Any)\norbits(::Group,::AbstractVector)\nelements(::Group)\ntransversal\ncentralizer\nstabilizer\nword(::Group,w)\nlength(::Group)\nclassreps(::Group)\nminimal_words\ntransporting_elt","category":"page"},{"location":"#Gapjm.Groups","page":"Gapjm Documentation","title":"Gapjm.Groups","text":"This module gives some basic functionality on groups.\n\nGroup  is  an  abstract  type,  but  the  following is assumed of all its concrete implementations:\n\nThe function gens(G) returns the list of generators of the group G. \nThe function one(G) returns the identity element of G.\n\nFurther,  a group  is a  GapObj, a  kind of  object where  properties are computed on demand when asked for; such properties when computed are stored in the field .prop of G, which is of type Dict{Symbol, Any}().\n\nExamples\n\njulia> G=Group([Perm(1,2),Perm(1,2,3)])\nGroup([(1,2),(1,2,3)])\n\njulia> gens(G)\n2-element Vector{Perm{Int16}}:\n (1,2)  \n (1,2,3)\n\njulia> ngens(G)\n2\n\njulia> minimal_words(G)\nDict{Perm{Int16}, Vector{Int64}} with 6 entries:\n  ()      => []\n  (1,2)   => [1]\n  (1,3)   => [1, 2]\n  (1,2,3) => [2]\n  (2,3)   => [2, 1]\n  (1,3,2) => [1, 2, 1]\n\njulia> G.prop\nDict{Symbol, Any} with 1 entry:\n  :words => Dict(()=>[], (1,2)=>[1], (1,3)=>[1, 2], (1,2,3)=>[2], (2,3)=>[2, 1]â€¦\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.Groups.Group","page":"Gapjm Documentation","title":"Gapjm.Groups.Group","text":"(G::Group)(i...)\n\nA  Group  may  be  used  as  a  function  wich  takes  integer arguments in eachindex(gens(W)).  This constructs  the element  of G  product of the generators  with the specified  indices. An argument  can also be negative, then the inverse of the corresponding generator is used.\n\njulia> G=Group([Perm(1,2),Perm(1,2,3)])\nGroup([(1,2),(1,2,3)])\n\njulia> G(2,1,-2) # returns gens(G)[2]*gens(G)[1]/gens(G)[2]\n(1,3)\n\n\n\n\n\nGroup(l::AbstractVector{T}[,one]) where T\n\nA  group may be constructed  from a list of  l elements of the same type. These  elements must respond  to the function  * and inv.  If it is not possible to compute one from the elements (because they do not respond to one,  or  l  is  empty  and  T  does  not respond to one), then the identity element of the group must be given as a second argument.\n\njulia> G=Group([[-1 -1;1 0]])\nGapjm.Groups.Groupof{Matrix{Int64}}([[-1 -1; 1 0]], [1 0; 0 1], Dict{Symbol, Any}())\n\njulia> elements(G)\n3-element Vector{Matrix{Int64}}:\n [0 1; -1 -1]\n [1 0; 0 1]\n [-1 -1; 1 0]\n\n\n\n\n\n","category":"type"},{"location":"#Gapjm.Groups.orbit-Tuple{Vector{T} where T, Any}","page":"Gapjm Documentation","title":"Gapjm.Groups.orbit","text":"orbit(gens::vector,p;action::Function=^)\n\norbit(G::Group,p;action::Function=^)\n\nthe  orbit of point  p under repeated  action of generators gens. Point p  should be hashable. The default action  of a group element is ^. For example  if g is a permutation and p  an integer, p^g is the image of p  by g; if h and g are group elements, then h^g is the conjugate inv(g)*h*g.  If a group  is given instead  of generators, the orbit under gens(G) is returned.\n\njulia> orbit([Perm(1,2),Perm(2,3)],1) \n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> orbit([Perm(1,2),Perm(2,3)],[1,3];action=(v,g)->v.^g)\n6-element Vector{Vector{Int64}}:\n [1, 3]\n [2, 3]\n [1, 2]\n [3, 2]\n [2, 1]\n [3, 1]\n\njulia> orbit([Perm(1,2),Perm(2,3)],[1,3];action=(v,g)->sort(v.^g))\n3-element Vector{Vector{Int64}}:\n [1, 3]\n [2, 3]\n [1, 2]\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.Groups.orbits-Tuple{Group, AbstractVector{T} where T}","page":"Gapjm Documentation","title":"Gapjm.Groups.orbits","text":"orbits(gens::Vector,v;action=^)\n\norbits(G,v;action=^)\n\nthe  orbits on v  of the repeated  action of gens;  the elements of v should  be hashable. If a  group is given instead  of generators, the orbit under gens(G) is returned.\n\njulia> G=Group([Perm(1,2),Perm(2,3)]);\njulia> orbits(G,1:4)\n2-element Vector{Vector{Int64}}:\n [1, 2, 3]\n [4]\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.Groups.elements-Tuple{Group}","page":"Gapjm Documentation","title":"Gapjm.Groups.elements","text":"elements(G::Group): the list of elements of G\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.Groups.transversal","page":"Gapjm Documentation","title":"Gapjm.Groups.transversal","text":"transversal(G::Group,p;action::Function=^)\n\nreturns  a Dict with entries x=>g  where x runs over orbit(G,p) and where g is such that x=action(p,g)\n\njulia> G=Group([Perm(1,2),Perm(2,3)]);\njulia> transversal(G,1)\nDict{Int64, Perm{Int16}} with 3 entries:\n  2 => (1,2)\n  3 => (1,3,2)\n  1 => ()\n\norbit functions can take any action of G as keyword argument\n\njulia> transversal(G,[1,2],action=(x,y)->x.^y)\nDict{Vector{Int64}, Perm{Int16}} with 6 entries:\n  [3, 2] => (1,3)\n  [1, 2] => ()\n  [2, 1] => (1,2)\n  [1, 3] => (2,3)\n  [2, 3] => (1,2,3)\n  [3, 1] => (1,3,2)\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Groups.centralizer","page":"Gapjm Documentation","title":"Gapjm.Groups.centralizer","text":"Centralizer(W,s)\n\nW  should  be  a  Weyl  group  or  an extended reflection group and s a semisimple  element of the  algebraic group G  corresponding to W. This function  returns the  Weyl group  of C_G(s),  which describes  it. The stabilizer  is an extended reflection group, with the reflection group part equal to the Weyl group of C_Gâ°(s), and the diagram automorphism part being those induced by C_G(s).\n\njulia> G=coxgroup(:A,3)\nAâ‚ƒ\njulia> s=SS(G,[0,1//2,0])\nSemisimpleElement{Root1}: <1,-1,1>\njulia> centralizer(G,s)\nAâ‚ƒâ‚â‚â‚ƒâ‚Ž=(Aâ‚Aâ‚)Î¦â‚‚\n\n\n\n\n\ncentralizer(G::Group,p;action=^)\n\ncomputes  the centralizer of  p in group  G (by default  for the action action(g,p)=g^p)\n\njulia> G=Group([Perm(1,2),Perm(1,2,3)]);\njulia> centralizer(G,1)\nGroup([(2,3)])\n\n\n\n\n\ncentralizer(WF::Spets,t::SemisimpleElement{Root1})  \n\nWF  should be  a Coxeter  coset representing  an algebraic coset ð† â‹…Ïƒ, where ð† is a connected reductive group (represented by 'W:=Group(WF)'), and  Ïƒ  is  a  quasi-central  automorphism  of ð† defined by WF. The element  t should be a semisimple  element of ð†. The function returns an  extended reflection  group describing  C_ð† (tÏƒ), with the reflection group  part representing  C_ð† â°(tÏƒ), and  the diagram  automorphism part being those induced by C_ð† (tÏƒ)/C_ð† (tÏƒ)â° on C_ð† (tÏƒ)â°.\n\njulia> WF=rootdatum(:u,6)\nÂ²Aâ‚…Î¦â‚‚\n\njulia> s=SS(Group(WF),[1//4,0,0,0,0,3//4])\nSemisimpleElement{Root1}: <Î¶â‚„,1,1,1,1,Î¶â‚„Â³>\n\njulia> centralizer(WF,s)\nBâ‚‚Î¦â‚\n\njulia> centralizer(WF,one(s))\nExtended(Câ‚ƒâ‚â‚ƒâ‚‚â‚â‚Ž)\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Groups.stabilizer","page":"Gapjm Documentation","title":"Gapjm.Groups.stabilizer","text":"stabilizer(G::Group,s)\n\nAssume that s is a set, represented as a sorted list without repetitions. The  action  of  gâˆˆ  G  on  sets  is  given  by  (g,p)->sort(p.^g). The stabilizer of s in G is the centralizer of s for that action.\n\njulia> G=Group([Perm(1,2),Perm(1,2,3,4)])\nGroup([(1,2),(1,2,3,4)])\n\njulia> centralizer(G,[1,2];action=(s,g)->sort(s.^g))\nGroup([(3,4),(1,2),(1,2)(3,4)])\n\njulia> stabilizer(G,[1,2])\nGroup([(3,4),(1,2),(1,2)(3,4)])\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Groups.word-Tuple{Group, Any}","page":"Gapjm Documentation","title":"Gapjm.Groups.word","text":"word(G::Group,w): a word in  gens(G) representing element w of G\n\n\n\n\n\n","category":"method"},{"location":"#Base.length-Tuple{Group}","page":"Gapjm Documentation","title":"Base.length","text":"length(G::Group): the number of elements of G\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.Groups.classreps-Tuple{Group}","page":"Gapjm Documentation","title":"Gapjm.Groups.classreps","text":"classreps(G::Group): representatives of conjugacy classes of G\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.Groups.minimal_words","page":"Gapjm Documentation","title":"Gapjm.Groups.minimal_words","text":"`minimal_words(G)`\n\nreturns a Dict giving for each element of G a minimal positive word in    the generators representing it.\n\njulia> G=Group([Perm(1,2),Perm(1,2,3)]);\njulia> minimal_words(G)\nDict{Perm{Int16}, Vector{Int64}} with 6 entries:\n  ()      => []\n  (1,2)   => [1]\n  (1,3)   => [1, 2]\n  (1,2,3) => [2]\n  (2,3)   => [2, 1]\n  (1,3,2) => [1, 2, 1]\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Groups.transporting_elt","page":"Gapjm Documentation","title":"Gapjm.Groups.transporting_elt","text":"transporting_elt(G,p,q;action=^,dist=nothing)   \n\nreturns  an  element  gâˆˆ G  such  that  p^g==q (or action(p,g)==q if action  is given) if such a g  exists and nothing otherwise. The set of possible g forms a right coset of the centralizer of p in G.\n\njulia> g=Group(perm\"(1,2,3)(6,7)\",perm\"(3,4,5)(7,8)\")\nGroup([(1,2,3)(6,7),(3,4,5)(7,8)])\n\njulia> transporting_elt(g,1,5)\n(1,5,4,3,2)\n\njulia> transporting_elt(g,1,6)\n\njulia> transporting_elt(g,[1,2,3,4],[2,3,4,5];action=(s,g)->sort(s.^g))\n(1,2,3,4,5)(6,7,8)\n\njulia> transporting_elt(g,[1,2,3,4],[3,4,5,2];action=(s,g)->s.^g)\n\n\n\n\n\n","category":"function"},{"location":"#Permutation-groups","page":"Gapjm Documentation","title":"Permutation groups","text":"","category":"section"},{"location":"","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"PermGroups\nbase\ncentralizers\ntransversals\non_classes\nsymmetric_group\nstab_onmats\nPerm_onmats\nPerm_rowcolmat\nBase.in(::Perm,::PermGroup)","category":"page"},{"location":"#Gapjm.PermGroups","page":"Gapjm Documentation","title":"Gapjm.PermGroups","text":"This module is a port of some GAP functionality on permutation groups.\n\nThis code refers to Holt \"Handbook of computational group theory\" chapter 4 for basic algorithms.\n\nA  PermGroup is  a group  where gens  are Perms,  which allows  for all the algorithms like base, centralizer chain, etc...\n\nExamples\n\njulia> G=Group([Perm(i,i+1) for i in 1:2])\nGroup([(1,2),(2,3)])\n\n# PermGroups are iterators over their elements\njulia> collect(G)  \n6-element Vector{Perm{Int16}}:\n (1,2)\n (1,3,2)\n ()\n (1,2,3)\n (1,3)\n (2,3)\n\n# maximum degree of an element of G\njulia> degree(G)  \n3\n\njulia> Perm(1,2) in G\ntrue\n\njulia> Perm(1,2,4) in G\nfalse\n\n# Elements,  appartenance test and  other function are  computed on G using\n# Schreier-Sims theory, that is computing the following\n\n# a list of points that no element of G fixes\njulia> base(G) \n2-element Vector{Int16}:\n 1\n 2\n\n# the i-th element is the centralizer of base[1:i-1]\njulia> centralizers(G) \n2-element Vector{PermGroup{Int16}}:\n Group([(1,2),(2,3)])\n Group([(2,3)])\n\n# i-th element is transversal of centralizer[i] on base[i]\njulia> transversals(G)\n2-element Vector{Dict{Int16, Perm{Int16}}}:\n Dict(2 => (1,2), 3 => (1,3,2), 1 => ())\n Dict(2 => (), 3 => (2,3))\n\nfinally, benchmarks on julia 1.1\n\njulia> @btime length(collect(symmetric_group(8)))\n  5.995 ms (391728 allocations: 13.89 MiB)\n\njulia> @btime minimal_words(symmetric_group(8));\n  10.477 ms (122062 allocations: 15.22 MiB)\n  \njulia> @btime length(elements(symmetric_group(8)))\n  1.713 ms (49599 allocations: 5.19 MiB)\n\nCompare to GAP3 Elements(SymmetricGroup(8)); takes 9.5 ms (GAP4 17ms)\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.PermGroups.base","page":"Gapjm Documentation","title":"Gapjm.PermGroups.base","text":"base(G) A list of points stabilized by no element of G \n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.PermGroups.centralizers","page":"Gapjm Documentation","title":"Gapjm.PermGroups.centralizers","text":"centralizers: the i-th element is the centralizer of base[1:i-1]\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.PermGroups.transversals","page":"Gapjm Documentation","title":"Gapjm.PermGroups.transversals","text":"The  i-th element  is  a description of  the orbit of :centralizers[i] on   :base[i]  as a Dict where each point q is the key to a permutation p such   that :base[i]^p=q\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.PermGroups.on_classes","page":"Gapjm Documentation","title":"Gapjm.PermGroups.on_classes","text":"on_classes(G, aut)\n\naut  is an automorphism of  the group G (for  a permutation group, this could  be  given  as  a  permutation  normalizing  G).  The result is the permutation of 1:nconjugacy_classes(G) induced ny aut.\n\njulia> WF=rootdatum(\"3D4\")\nÂ³Dâ‚„\n\njulia> on_classes(Group(WF),WF.phi)\nPerm{Int64}: (2,8,7)(5,13,12)\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.PermGroups.symmetric_group","page":"Gapjm Documentation","title":"Gapjm.PermGroups.symmetric_group","text":"The symmetric group of degree n \n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.PermGroups.stab_onmats","page":"Gapjm Documentation","title":"Gapjm.PermGroups.stab_onmats","text":"stab_onmats([G,]M[,l])\n\nIf  onmats(m,p)=^(M,p;dims=(1,2)), and  the argument  G is given (which should   be  a  PermGroup)   this  is  just   a  fast  implementation  of centralizer(G,M;action=onmats).  If  G  is  omitted  it  is taken to be symmetric_group(size(M,1)).  The  program  uses sophisticated algorithms, and can handle matrices up to 80Ã—80.\n\njulia> uc=UnipotentCharacters(ComplexReflectionGroup(34));\n\njulia> stab_onmats(fourier(uc.families[20]))\nGroup([(7,38),(39,44)(40,43)(41,42)])\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.PermGroups.Perm_onmats","page":"Gapjm Documentation","title":"Gapjm.PermGroups.Perm_onmats","text":"Perm_onmats(M, N[, m ,n]) \n\nIf  onmats(M,p)=^(M,p;dims=(1,2)), return p  such that onmats(M,p)=N. If  in  addition  the  vectors  m  and  n are given, p should satisfy m^p=n.\n\nEfficient version of  transporting_elt(symmetric_group(size(M,1)),M,N;action=onmats)\n\njulia> m=cartan(:D,12);\n\njulia> n=^(m,Perm(1,5,2,8,12,4,7)*Perm(3,9,11,6);dims=(1,2));\n\njulia> Perm_onmats(m,n)\n(1,5,2,8,12,4,7)(3,9,11,6)\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.PermGroups.Perm_rowcolmat","page":"Gapjm Documentation","title":"Gapjm.PermGroups.Perm_rowcolmat","text":"Perm_rowcolmat(m1,m2)   whether matrix m1 is conjugate to matrix m2 by row/col permutations\n\nm1  and m2 should be rectangular matrices of the same dimensions. The   function   returns   a   pair   of   permutations   [p1,p2]  such  that   ^(m1^p[1],p[2];dims=2)==m2   if  such   permutations  exist,  nothing   otherwise.\n\n\n\n\n\n","category":"function"},{"location":"#Base.in-Tuple{Perm, PermGroup}","page":"Gapjm Documentation","title":"Base.in","text":"g in G Tells whether permutation g is an element of G \n\n\n\n\n\n","category":"method"},{"location":"#Cyclotomic-numbers","page":"Gapjm Documentation","title":"Cyclotomic numbers","text":"","category":"section"},{"location":"","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"Cycs\nconductor\ncoefficients(c::Cyc)\nE\ngalois\nER\nQuadratic\nRoot1\nCycs.root","category":"page"},{"location":"#Gapjm.Cycs","page":"Gapjm Documentation","title":"Gapjm.Cycs","text":"Cyclotomic  numbers means complex numbers which are sums of rationals times roots of unity.\n\nThey  are a very important feature of GAP, since character values of finite groups are cyclotomics.\n\nThey  have a normal form given by writing them in the Zumbroich basis. This form  allows to find  the smallest Cyclotomic  field which contains a given number,   and  decide   in  particular   if  a   cyclotomic  is  zero.  Let Î¶â‚™=exp(2iÏ€/n).  The Zumbroich basis is a  particular subset of size Ï†(n) of 1,Î¶â‚™,Î¶â‚™Â²,â€¦,Î¶â‚™â¿â»Â¹ which forms a basis of â„š (Î¶â‚™).\n\nI  started  this  file  by  porting  Christian  Stump's Sage code, which is simpler to understand than GAP's code. The reference for the algorithms is\n\nT. Breuer, Integral bases for subfields of cyclotomic fields AAECC 8 (1997)\n\nAs  does  GAP,  I  lower  automatically  numbers  after  each  computation; currently  the code about 50% slower than the C code in GAP since it is not as  much optimized. GAP also  converts a Cyclotomic which  is rational to a Rational,  a Rational which is integral to  an Int, a BigInt which is small to  a small Int, etc... This is tremendously useful but needs a new type of number to be added to Julia, which I am not competent enough to try.\n\nThe main way to build a Cyclotomic number is to use the function E(n,k=1) which constructs Î¶â‚™áµ.\n\nExamples\n\njulia> E(3)+E(4)\nCyc{Int64}: Î¶â‚â‚‚â´-Î¶â‚â‚‚â·-Î¶â‚â‚‚Â¹Â¹\n\njulia> E(3,2)\nCyc{Int64}: Î¶â‚ƒÂ²\n\njulia> 1+E(3,2)\nCyc{Int64}: -Î¶â‚ƒ\n\njulia> a=E(4)-E(4)\nCyc{Int64}: 0\n\njulia> conductor(a) # a has been lowered to â„š (Î¶â‚)=â„š \n1\n\njulia> typeof(convert(Int,a))\nInt64\n\njulia> convert(Int,E(4))\nERROR: InexactError: convert(Int64, E(4))\n\njulia> inv(1+E(4)) # inverses often need Rational coefficients\nCyc{Rational{Int64}}: (1-Î¶â‚„)/2\n\njulia> inv(E(5)+E(5,4)) # but not always\nCyc{Int64}: -Î¶â‚…Â²-Î¶â‚…Â³\n\njulia> Cyc(1//2+im) # one can convert Gaussian integers or rationals\nCyc{Rational{Int64}}: (1+2Î¶â‚„)/2\n\njulia> conj(1+E(4)) # complex conjugate\nCyc{Int64}: 1-Î¶â‚„\n\njulia> real(E(5))  # real part\nCyc{Rational{Int64}}: (-1+âˆš5)/4\n\njulia> imag(E(5))  # imaginary part\nCyc{Rational{Int64}}: (Î¶â‚…-Î¶â‚…â´)/2\n\njulia> c=E(9)   # an effect of the Zumbroich basis\nCyc{Int64}: -Î¶â‚‰â´-Î¶â‚‰â·\n\njulia> Root1(c) # but you can decide whether a Cyc is a root of unity\nRoot1: Î¶â‚‰\n\njulia> Root1(1+E(4)) # it returns nothing for a non-root\n\njulia> Root1(4,1)\nRoot1: Î¶â‚„\n\njulia> c=Root1(;r=1//4)*Root1(3,1) # faster computation for roots of unity\nRoot1: Î¶â‚â‚‚â·\n\njulia> E(c) # convert back to Cyc\nCyc{Int64}: Î¶â‚â‚‚â·\n\njulia> c=Complex{Float64}(E(3))  # convert to float is sometimes useful\n-0.4999999999999998 + 0.8660254037844387im\n\nCycs have methods copy, hash, ==, cmp, isless (total order) so they can be  keys in hashes or  elements of sets. Cyclotomics  which are integers or rationals compare correctly to integers or rationals:\n\njulia> -1<Cyc(0)<1\ntrue\n\nFor more information see the methods conductor, coefficients, denominator, ER, Quadratic, galois, root. \n\nFinally, a benchmark:\n\njulia> function testmat(p) \n         ss=[[i,j] for i in 0:p-1 for j in i+1:p-1]\n         [(E(p,i'*reverse(j))-E(p,i'*j))//p for i in ss,j in ss]\n       end\ntestmat (generic function with 1 method)\n\njulia> @btime Cycs.testmat(12)^2;\n  346.079 ms (4367402 allocations: 366.17 MiB)\n\nThe equivalent in GAP:\n\ntestmat:=function(p)local ss;ss:=Combinations([0..p-1],2);\n  return List(ss,i->List(ss,j->(E(p)^(i*Reversed(j))-E(p)^(i*j))/p));\nend; \n\ntestmat(12)^2 takes 0.35s in GAP3, 0.29s in GAP4\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.Cycs.conductor","page":"Gapjm Documentation","title":"Gapjm.Cycs.conductor","text":"conductor(c::Cyc)    conductor(v::AbstractVector)\n\nreturns the smallest positive integer  n  uch that câˆˆ â„š (Î¶â‚™) (resp. all elements of v are in â„š (Î¶â‚™)).\n\njulia> conductor(E(9))\n9\n\njulia> conductor([E(3),1//2,E(4)])\n12\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Cycs.coefficients-Tuple{Cyc}","page":"Gapjm Documentation","title":"Gapjm.Cycs.coefficients","text":"coefficients(c::Cyc)\n\nfor  a cyclotomic c of conductor n,  returns a vector v of length n such that c==âˆ‘áµ¢ váµ¢â‚‹â‚ Î¶â±.\n\njulia> coefficients(E(9))\n9-element Vector{Int64}:\n  0\n  0\n  0\n  0\n -1\n  0\n  0\n -1\n  0\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.Cycs.E","page":"Gapjm Documentation","title":"Gapjm.Cycs.E","text":"E(n::Integer,k::Integer=1) is exp(2i k Ï€/n)\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Cycs.galois","page":"Gapjm Documentation","title":"Gapjm.Cycs.galois","text":"galois(f::Family,p::Int)\n\nx->galois(x,p)  is  applied  to  the  Fourier  matrix  and eigenvalues of Frobenius of the family.\n\njulia> f=UnipotentCharacters(ComplexReflectionGroup(3,1,1)).families[2]\nFamily(0011,[4, 3, 2])\nclassical family\nlabelâ”‚eigen      1        2        3\nâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n1    â”‚  Î¶â‚ƒÂ²  âˆš-3/3    âˆš-3/3   -âˆš-3/3\n2    â”‚    1  âˆš-3/3 Î¶â‚ƒÂ²âˆš-3/3 -Î¶â‚ƒâˆš-3/3\n3    â”‚    1 -âˆš-3/3 -Î¶â‚ƒâˆš-3/3 Î¶â‚ƒÂ²âˆš-3/3\n\njulia> galois(f,-1)\nFamily(overline 0011,[4, 3, 2])\nComplexConjugate(classical family)\nlabelâ”‚eigen      1        2        3\nâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n1    â”‚   Î¶â‚ƒ -âˆš-3/3   -âˆš-3/3    âˆš-3/3\n2    â”‚    1 -âˆš-3/3 -Î¶â‚ƒâˆš-3/3 Î¶â‚ƒÂ²âˆš-3/3\n3    â”‚    1  âˆš-3/3 Î¶â‚ƒÂ²âˆš-3/3 -Î¶â‚ƒâˆš-3/3\n\n\n\n\n\ngalois(c::Cyc,n::Int) applies to c the galois automorphism   of Q(Î¶_conductor(c)) raising all roots of unity to the n-th power.   n should be prime to conductor(c).\n\nExamples\n\njulia> galois(1+E(4),-1) # galois(c,-1) is the same as conj(c)\nCyc{Int64}: 1-Î¶â‚„\n\njulia> galois(ER(5),2)==-ER(5)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Cycs.ER","page":"Gapjm Documentation","title":"Gapjm.Cycs.ER","text":"ER(n::Int) computes as a Cyc the square root of the integer n.\n\nExamples\n\njulia> ER(-1)\nCyc{Int64}: Î¶â‚„\n\njulia> ER(3)\nCyc{Int64}: âˆš3\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Cycs.Quadratic","page":"Gapjm Documentation","title":"Gapjm.Cycs.Quadratic","text":"Quadratic(c::Cyc) \n\ndetermines  if c  lives in  a quadratic  extension of  â„š. It  returns a Quadratic  struct with fields a, b, root, den representing c as (a  + b ER(root))//den  if such a  representation is possibe or nothing otherwise\n\nExamples\n\njulia> Quadratic(1+E(3))\n(1+âˆš-3)/2\n\njulia> Quadratic(1+E(5))\n\n\n\n\n\n\n","category":"type"},{"location":"#Gapjm.Cycs.Root1","page":"Gapjm Documentation","title":"Gapjm.Cycs.Root1","text":"Root1(c)\n\nc should be a cyclotomic number (a Cyc), or a Real. Root1 returns a Root1 object containing the rational e/n with 0â‰¤e<n (that is, e/nâˆˆ â„š /â„¤) if c==E(n,e), and nothing if c is not a root of unity.\n\njulia> r=Root1(-E(9,2)-E(9,5))\nRoot1: Î¶â‚‰â¸\n\njulia> conductor(r)\n9\n\njulia> exponent(r)\n8\n\njulia> E(r)\nCyc{Int64}: -Î¶â‚‰Â²-Î¶â‚‰âµ\n\njulia> Root1(-E(9,4)-E(9,5))\n\n\n\n\n\n","category":"type"},{"location":"#Gapjm.Cycs.root","page":"Gapjm Documentation","title":"Gapjm.Cycs.root","text":"root(x,n=2)\n\ncomputes  the n-th root of x when we know  how to do it. We know how to compute  n-th  roots  for  roots  of  unity, square roots of integers and n-th  roots of  integers wich  are perfect  n-th powers  of integers or square roots of integers.\n\njulia> root(-1)\nCyc{Int64}: Î¶â‚„\n\njulia> root(E(4))\nCyc{Int64}: Î¶â‚ˆ\n\njulia> root(27,6)\nCyc{Int64}: âˆš3\n\n\n\n\n\n","category":"function"},{"location":"#Univariate-(Laurent)-polynomials","page":"Gapjm Documentation","title":"Univariate (Laurent) polynomials","text":"","category":"section"},{"location":"","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"Pols\ndivrem\ngcd(::Pol,::Pol)\ncyclotomic_polynomial","category":"page"},{"location":"#Gapjm.Pols","page":"Gapjm Documentation","title":"Gapjm.Pols","text":"An   implementation  of  univariate  Laurent  polynomials,  and  univariate rational fractions.\n\nA Pol contains two fields: a vector of coefficients, and the valuation.\n\nExamples\n\njulia> Pol(:q) # define string used for printing and set variable q\nPol{Int64}: q\n\njulia> Pol([1,2]) # valuation is 0 if not specified\nPol{Int64}: 2q+1\n\njulia> 2q+1       # same result\nPol{Int64}: 2q+1\n\njulia> p=Pol([1,2],-1) # here the valuation is specified to be -1\nPol{Int64}: 2+qâ»Â¹\n\njulia> Pol()   # omitting all arguments gives Pol([1],1)\nPol{Int64}: q\n\njulia> valuation(p),degree(p)\n(-1, 0)\n\njulia> derivative(p)\nPol{Int64}: -qâ»Â²\n\njulia> p=(q+1)^2\nPol{Int64}: qÂ²+2q+1\n\njulia> valuation(p),degree(p)\n(0, 2)\n\njulia> p(1//2) # value of p at 1//2\n9//4\n\njulia> p[0], p[1], p[-1] # indexing gives the coefficients\n(1, 2, 0)\n\njulia> p[-1:1]\n3-element Vector{Int64}:\n 0\n 1\n 2\n\njulia> divrem(q^3+1,2q+1) # changes coefficients to field elements\n(0.5qÂ²-0.25q+0.125, 0.875)\n\njulia> divrem(q^3+1,2q+1//1) # case of field elements\n((1//2)qÂ²+(-1//4)q+1//8, 7//8)\n\njulia> divrem(q^3+1,q+2)  # keeps the ring if leading coeff of divisor is Â±1\n(qÂ²-2q+4, -7)\n\njulia> m=[q+1 q+2;q-2 q-3]\n2Ã—2 Matrix{Pol{Int64}}:\n q+1  q+2\n q-2  q-3\n\njulia> inv(m)  # when dividing by a non-monomial, get rational fraction\n2Ã—2 Matrix{RatFrac{Int64}}:\n (-q+3)/(2q-1)   (q+2)/(2q-1)\n (-q+2)/(-2q+1)  (q+1)/(-2q+1)\n\nsee also the individual documentation of divrem, gcd.\n\n\n\n\n\n","category":"module"},{"location":"#Base.divrem","page":"Gapjm Documentation","title":"Base.divrem","text":"divrem(a::Pol, b::Pol)\n\ncomputes  (q,r) such  that a=q*b+r  and degree(r)<degree(b). When the leading  coefficient  of  b  is  Â±1  does  not  use  inverse.  For true polynomials (errors if the valuation of a or of b is negative).\n\n\n\n\n\n","category":"function"},{"location":"#Base.gcd-Tuple{Pol, Pol}","page":"Gapjm Documentation","title":"Base.gcd","text":"gcd(p::Pol, q::Pol)\n\nExamples\n\njulia> gcd(2q+2,q^2-1)\nPol{Int64}: q+1\n\njulia> gcd(q+1//1,q^2-1//1)\nPol{Rational{Int64}}: (1//1)q+1//1\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.CycPols.cyclotomic_polynomial","page":"Gapjm Documentation","title":"Gapjm.CycPols.cyclotomic_polynomial","text":"cyclotomic_polynomial(n)\n\nreturns the n-th cyclotomic polynomial.\n\njulia> cyclotomic_polynomial(5)\nPol{Int64}: qâ´+qÂ³+qÂ²+q+1\n\njulia> cyclotomic_polynomial(24)\nPol{Int64}: qâ¸-qâ´+1\n\n\n\n\n\n","category":"function"},{"location":"#Multivariate-(Puiseux)-polynomials","page":"Gapjm Documentation","title":"Multivariate (Puiseux) polynomials","text":"","category":"section"},{"location":"","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"Mvps\nMvp\nvariables\nMvps.coefficients(::Mvp,::Symbol)\nMvps.coefficient\nPol(::Mvp)\nPol(::Mvp,::Symbol)\nvaluation\ndegree\nMvps.value\nMvps.degree(::Mvp)\nMvps.conj\nfactor(::Mvp)\nMvps.derivative\nlaurent_denominator\ngcd(::Mvp,::Mvp)\nlcm(::Mvp,::Mvp)\nscal","category":"page"},{"location":"#Gapjm.Mvps","page":"Gapjm Documentation","title":"Gapjm.Mvps","text":"The  type Mvp  (\"multivariate polynomials\")  implemented here is \"Puiseux polynomials\",  that  is  linear  combinations  of  monomials  of  the  type xâ‚^{aâ‚}â€¦  xâ‚™^{aâ‚™} where xáµ¢  are variables and  aáµ¢ are exponents which can  be  arbitrary  rational  numbers  (we  need  Puiseux  polynomial  with cyclotomic  coefficients as splitting fields of cyclotomic Hecke algebras). Some  functions described below work  only with polynomials where variables are  raised to integral powers;  we will refer to  such objects as \"Laurent polynomials\"; some functions require further that variables are raised only to  positive powers: we refer then to \"true polynomials\". We implement also multivariate  rational  fractions  (type  Mvrf)  where  the numerator and denominator are true polynomials.\n\n@Mvp xâ‚,â€¦,xâ‚™\n\nassigns   to  the  Julia  names   xáµ¢  indeterminates  suitable  to  build multivariate  polynomials  or  rational  fractions.  Mvp(:x1) creates the indeterminate x1 without assigning a Julia variable.\n\njulia> @Mvp x,y\n\njulia> (x+y^-1)^3\nMvp{Int64}: xÂ³+3xÂ²yâ»Â¹+3xyâ»Â²+yâ»Â³\n\nMvp(x::Number)   returns  the  constant   multivariate  polynomial  whose constant term is x.\n\njulia> degree(Mvp(1))\n0\n\nOnly  monomials and one-term Mvps can  be raised to a non-integral power; the  Mvp with one  term cm which  is c times  the monomial m can be raised  to a fractional power of denominator d if and only if root(c,d) is  defined (this is  equivalent to c^{1//d}  but one may  want to define root  differently;  for  instance,  in  my  other package Cycs I define square  roots of rationals as cyclotomics;  I also have implement in Cycs arbitrary roots of roots of unity).\n\njulia> (4x)^(1//2)\nMvp{Int64,Rational{Int64}}: 2xÂ½\n\njulia> (2.0x)^(1//2)\nMvp{Float64,Rational{Int64}}: 1.4142135623730951xÂ½\n\njulia> root(2.0x)\nMvp{Float64,Rational{Int64}}: 1.4142135623730951xÂ½\n\nUsing the package Cycs:\n\njulia> (2x)^(1//2)\nMvp{Cyc{Int64},Rational{Int64}}: âˆš2xÂ½\n\njulia> (E(3)*x)^(2//3)\nMvp{Cyc{Int64},Rational{Int64}}: Î¶â‚‰Â²xâ…”\n\nOne can divide an Mvp by another when the division is exact\n\njulia> exactdiv(x^2-y^2,x-y)\nMvp{Int64}: x+y\n\njulia> (x+y)/(2x^2)   # or by a monomial\nMvp{Rational{Int64}}: (1//2)xâ»Â¹+(1//2)xâ»Â²y\n\njulia> (x+y)/(x-y)    # otherwise one gets a rational fraction.\nMvrf{Int64}: (x+y)/(x-y)\n\nRaising  a non-monomial  Laurent polynomial  to a  negative power returns a rational fraction.\n\njulia> (x+1)^-2\nMvrf{Int64}: 1/(xÂ²+2x+1)\n\nOne can compute the value Mvp or a Ratfrac when setting some variables  by the call syntax:\n\njulia> p=x+y\nMvp{Int64}: x+y\n\njulia> p(x=2)\nMvp{Int64}: y+2\n\njulia> p(x=2,y=x)\nMvp{Int64}: x+2\n\njulia> ((x+y)/(x-y))(x=y+1)\nMvp{Int64}: 2y+1\n\nNote  that the value of  an Mvp is always  an Mvp, for consistency. The function  scal converts  a constant  Mvp to  that constant (and returns nothing if the argument is not constant:\n\njulia> p(x=1,y=2)\nMvp{Int64}: 3\n\njulia> scal(p(x=1,y=2))\n3\n\njulia> v=(x^(1//2))(x=2.0)\nMvp{Float64}: 1.4142135623730951\n\njulia> scal(v)\n1.4142135623730951\n\nsee the functions coefficient, coefficients,Polto take apartMvps.Mvrfare dissected usingnumeratoranddenominator`.\n\nDespite  the degree of generality of our  polynomials, the speed is not too shabby. For the Fateman test f(f+1) where f=(1+x+y+z+t)^15, we take 4sec. According to the Nemo paper, Sagemath takes 10sec and Nemo takes 1.6sec.\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.Mvps.Mvp","page":"Gapjm Documentation","title":"Gapjm.Mvps.Mvp","text":"Mvp(p) converts  the Pol  p to  an  Mvp. \n\njulia> Pol(:q)\nPol{Int64}: q\n\njulia> Mvp(q^2+q)\nMvp{Int64}: qÂ²+q\n\n\n\n\n\n","category":"type"},{"location":"#Gapjm.Mvps.variables","page":"Gapjm Documentation","title":"Gapjm.Mvps.variables","text":"variables(p::Mvp) variables(v::Array{Mvp})\n\nreturns the list of variables of all p as a sorted list of Symbols.\n\njulia> @Mvp x,y,z\n\njulia> variables([x+y+1,z])\n3-element Vector{Symbol}:\n :x\n :y\n :z\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Mvps.coefficients-Tuple{Mvp, Symbol}","page":"Gapjm Documentation","title":"Gapjm.Mvps.coefficients","text":"coefficients(p::Mvp, var::Symbol) \n\nreturns  a Dict with keys the degree  in var and values the corresponding coefficient of p with respect to var.\n\njulia> p=(x+y+inv(y))^4\nMvp{Int64}: xâ´+4xÂ³y+4xÂ³yâ»Â¹+6xÂ²yÂ²+12xÂ²+6xÂ²yâ»Â²+4xyÂ³+12xy+12xyâ»Â¹+4xyâ»Â³+yâ´+4yÂ²+6+4yâ»Â²+yâ»â´\n\njulia> coefficients(p,:x)\nDict{Int64, Mvp{Int64, Int64}} with 5 entries:\n  0 => yâ´+4yÂ²+6+4yâ»Â²+yâ»â´\n  4 => 1\n  2 => 6yÂ²+12+6yâ»Â²\n  3 => 4y+4yâ»Â¹\n  1 => 4yÂ³+12y+12yâ»Â¹+4yâ»Â³\n\njulia> coefficients(p,:y)\nDict{Int64, Mvp{Int64, Int64}} with 9 entries:\n  0  => xâ´+12xÂ²+6\n  4  => 1\n  -1 => 4xÂ³+12x\n  2  => 6xÂ²+4\n  -3 => 4x\n  -2 => 6xÂ²+4\n  -4 => 1\n  3  => 4x\n  1  => 4xÂ³+12x\n\nThe  same  caveat  is  applicable  to  coefficients as to evaluating: the values  are always Mvps. To get a list of scalars for the coefficients of a  univariate polynomial represented  as a Mvp,  one should use scal on the values of coefficients.\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.Mvps.coefficient","page":"Gapjm Documentation","title":"Gapjm.Mvps.coefficient","text":"coefficient(p::Mvp,m::Monomial)\n\nThe coefficient of the polynomial p on the monomial m.\n\njulia> @Mvp x,y; p=(x-y)^3\nMvp{Int64}: xÂ³-3xÂ²y+3xyÂ²-yÂ³\n\njulia> coefficient(p,Monomial(:x,:x,:y)) # coefficient on xÂ²y\n-3\n\njulia> coefficient(p,Monomial()) # constant coefficient\n0\n\n\n\n\n\ncoefficient(p::Mvp, var::Symbol, d) \n\nreturns  the coefficient of degree d in the variable var in the Mvp p.\n\njulia> @Mvp x,y; p=(x+y^(1//2)+1)^3\nMvp{Int64,Rational{Int64}}: xÂ³+3xÂ²yÂ½+3xÂ²+3xy+6xyÂ½+3x+yÂ³â„â‚‚+3y+3yÂ½+1\n\njulia> coefficient(p,:y,1//2)\nMvp{Int64,Rational{Int64}}: 3xÂ²+6x+3\n\njulia> coefficient(p,:x,1)\nMvp{Int64,Rational{Int64}}: 3y+6yÂ½+3\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Pols.Pol-Tuple{Mvp}","page":"Gapjm Documentation","title":"Gapjm.Pols.Pol","text":"Pol(p::Mvp)\n\nconverts the one-variable Mvp p to a polynomial. It is an error if p   has more than one variable.\n\njulia> @Mvp x; Pol(:q); Pol(x^2+x)\nPol{Int64}: qÂ²+q\n\n\n\n\n\nPol(p::Mvp,v::Symbol)\n\nreturns  a polynomial whose coefficients are  the coefficients of the Mvp p  with respect to the variable v.  The variable v should appear only with integral powers in p.\n\njulia> p=(x+y^(1//2))^3\nMvp{Int64,Rational{Int64}}: xÂ³+3xÂ²yÂ½+3xy+yÂ³â„â‚‚\n\njulia> Pol(:q); Pol(p,:x)\nPol{Mvp{Int64, Rational{Int64}}}: qÂ³+3yÂ½qÂ²+3yq+yÂ³â„â‚‚\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.Pols.Pol-Tuple{Mvp, Symbol}","page":"Gapjm Documentation","title":"Gapjm.Pols.Pol","text":"Pol(p::Mvp,v::Symbol)\n\nreturns  a polynomial whose coefficients are  the coefficients of the Mvp p  with respect to the variable v.  The variable v should appear only with integral powers in p.\n\njulia> p=(x+y^(1//2))^3\nMvp{Int64,Rational{Int64}}: xÂ³+3xÂ²yÂ½+3xy+yÂ³â„â‚‚\n\njulia> Pol(:q); Pol(p,:x)\nPol{Mvp{Int64, Rational{Int64}}}: qÂ³+3yÂ½qÂ²+3yq+yÂ³â„â‚‚\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.Pols.valuation","page":"Gapjm Documentation","title":"Gapjm.Pols.valuation","text":"The valuation of an Mvp is the minimal degree of a monomial.\n\njulia> @Mvp x,y; a=x^2+x*y\nMvp{Int64}: xÂ²+xy\n\njulia> valuation(a)\n2\n\nWith  second argument a variable name, valuation returns the valuation of the polynomial in that variable.\n\njulia> valuation(a,:y)\n0\n\njulia> valuation(a,:x)\n1\n\n\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.degree","page":"Gapjm Documentation","title":"Gapjm.degree","text":"The degree of a monomial is the sum of  the exponents of the variables. The degree of an Mvp is the largest degree of a monomial.\n\njulia> a=x^2+x*y\nMvp{Int64}: xÂ²+xy\n\njulia> degree(a)\n2\n\nWith  second argument a  variable name, degree  returns the degree of the polynomial in that variable.\n\njulia> degree(a,:y)\n1\n\njulia> degree(a,:x)\n2\n\n\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Mvps.value","page":"Gapjm Documentation","title":"Gapjm.Mvps.value","text":"`value(p::Mvp,:xâ‚=>vâ‚,:xâ‚‚=>vâ‚‚,...)`\n Ì€(p::Mvp)(xâ‚=vâ‚,â€¦,xâ‚™=vâ‚™)`\n\nreturns  the value of  p when doing  the simultaneous substitution of the variable :x1 by v1, of x2 by v2, â€¦\n\njulia> p=-2+7x^5*inv(y)\nMvp{Int64}: 7xâµyâ»Â¹-2\n\njulia> p(x=2)\nMvp{Int64}: -2+224yâ»Â¹\n\njulia> p(y=1)\nMvp{Int64}: 7xâµ-2\n\njulia> p(x=2,y=1)\nMvp{Int64}: 222\n\nOne should pay attention to the fact that the last value is not an integer, but  a constant Mvp (for consistency). See the function scal for how to convert such constants to their base ring.\n\njulia> p(x=y)\nMvp{Int64}: 7yâ´-2\n\njulia> p(x=y,y=x)\nMvp{Int64}: -2+7xâ»Â¹yâµ\n\nEvaluating an Mvp which is a Puiseux polynomial may cause calls to root\n\njulia> p=x^(1//2)*y^(1//3)\nMvp{Int64,Rational{Int64}}: xÂ½yâ…“\n\njulia> p(;x=y)\nMvp{Int64,Rational{Int64}}: yâµâ„â‚†\n\n\njulia> p(;x=4)\nMvp{Int64,Rational{Int64}}: 2yâ…“\n\njulia> p(;y=2.0)\nMvp{Float64,Rational{Int64}}: 1.2599210498948732xÂ½\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Mvps.degree-Tuple{Mvp}","page":"Gapjm Documentation","title":"Gapjm.Mvps.degree","text":"The degree of a monomial is the sum of  the exponents of the variables. The degree of an Mvp is the largest degree of a monomial.\n\njulia> a=x^2+x*y\nMvp{Int64}: xÂ²+xy\n\njulia> degree(a)\n2\n\nWith  second argument a  variable name, degree  returns the degree of the polynomial in that variable.\n\njulia> degree(a,:y)\n1\n\njulia> degree(a,:x)\n2\n\n\n\n\n\n","category":"method"},{"location":"#Base.conj","page":"Gapjm Documentation","title":"Base.conj","text":"conj(f::Family):   is    a    synonym    for 'galois(f,-1)'.\n\n\n\n\n\nconj(p::Mvp) acts on the coefficients of p\n\njulia> @Mvp x;conj(im*x+1)\nMvp{Complex{Int64}}: (0 - 1im)x+1 + 0im\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Util.factor-Tuple{Mvp}","page":"Gapjm Documentation","title":"Gapjm.Util.factor","text":"factor(p::Mvp)\n\np  should be of degree <=2 thus represents a quadratic form. The function returns  a list  of two  linear forms  of which  p is the product if such exist, otherwise it returns [p].\n\njulia> @Mvp x,y\n\njulia> factor(x^2-y^2+x+3y-2)\n2-element Vector{Mvp{Int64, Int64}}:\n x-y+2\n x+y-1\n\njulia> factor(x^2+x+1)\n2-element Vector{Mvp{Cyc{Int64}, Int64}}:\n x-Î¶â‚ƒ\n x-Î¶â‚ƒÂ²\n\njulia> factor(x*y-1)\n1-element Vector{Mvp{Int64, Int64}}:\n xy-1\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.Mvps.derivative","page":"Gapjm Documentation","title":"Gapjm.Mvps.derivative","text":"The  function 'Derivative(p,v)' returns the  derivative of 'p' with respect to  the variable given by the string 'v'; if 'v' is not given, with respect to the first variable in alphabetical order.\n\njulia> @Mvp x,y;p=7x^5*y^-1-2\nMvp{Int64}: 7xâµyâ»Â¹-2\n\njulia> derivative(p,:x)\nMvp{Int64}: 35xâ´yâ»Â¹\n\njulia> derivative(p,:y)\nMvp{Int64}: -7xâµyâ»Â²\n\njulia> derivative(p)\nMvp{Int64}: 35xâ´yâ»Â¹\n\njulia> p=x^(1//2)*y^(1//3)\nMvp{Int64,Rational{Int64}}: xÂ½yâ…“\n\njulia> derivative(p,:x)\nMvp{Rational{Int64},Rational{Int64}}: (1//2)xâ»Â½yâ…“\n\njulia> derivative(p,:y)\nMvp{Rational{Int64},Rational{Int64}}: (1//3)xÂ½yâ»Â²â„â‚ƒ\n\njulia> derivative(p,:z)\nMvp{Rational{Int64},Rational{Int64}}: 0\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Mvps.laurent_denominator","page":"Gapjm Documentation","title":"Gapjm.Mvps.laurent_denominator","text":"laurent_denominator(p1,p2,â€¦)\n\nreturns  the unique true monomial  m of minimal degree  such that for all the Laurent polynomials p1,p2,â€¦ the product m*páµ¢ is a true polynomial.\n\njulia> laurent_denominator(x^-1,y^-2+x^4)\nMonomial{Int64}:xyÂ²\n\n\n\n\n\n","category":"function"},{"location":"#Base.gcd-Tuple{Mvp, Mvp}","page":"Gapjm Documentation","title":"Base.gcd","text":"Returns  the Gcd  of the  'Mvp' arguments.  The arguments  must be  true polynomials.\n\njulia> gcd(x^2-y^2,(x+y)^2)\nMvp{Int64}: x+y\n\n\n\n\n\n","category":"method"},{"location":"#Base.lcm-Tuple{Mvp, Mvp}","page":"Gapjm Documentation","title":"Base.lcm","text":"lcm(p1,p2,...)\n\nReturns  the Lcm  of the  Mvp arguments.  The arguments  must be  true polynomials.\n\njulia> lcm(x^2-y^2,(x+y)^2)\nMvp{Int64}: xÂ³+xÂ²y-xyÂ²-yÂ³\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.Mvps.scal","page":"Gapjm Documentation","title":"Gapjm.Mvps.scal","text":"scal(p::Mvp)\n\nIf p is a scalar, return that scalar, otherwise return nothing.\n\njulia> p=Mvp(:x)+1\nMvp{Int64}: x+1\n\njulia> w=p(x=4)\nMvp{Int64}: 5\n\njulia> scal(w)\n5\n\njulia> typeof(scal(w))\nInt64\n\nif  p is an array, then apply scal to its elements and return nothing if it contains any Mvp which is not a scalar.\n\n\n\n\n\n","category":"function"},{"location":"#Cyclotomic-polynomials","page":"Gapjm Documentation","title":"Cyclotomic polynomials","text":"","category":"section"},{"location":"","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"CycPols\nCycPol","category":"page"},{"location":"#Gapjm.CycPols","page":"Gapjm Documentation","title":"Gapjm.CycPols","text":"Cyclotomic  numbers, and cyclotomic polynomials  over the rationals or some cyclotomic field, are important in reductive groups or Spetses. This module deals  with them: the type CycPol  represents the product of a polynomial with  a rational fraction in one variable with all poles or zeroes equal to 0  or  roots  of  unity.  The  advantages  of representing as CycPol such objects    are:   nice   display   (factorized),   less   storage,   faster multiplication,  division and evaluation. The drawback is that addition and subtraction are not implemented!\n\njulia> q=Pol(:q)\nPol{Int64}: q\n\njulia> p=CycPol(q^25-q^24-2q^23-q^2+q+2)\n(q-2)Î¦â‚Î¦â‚‚Î¦â‚‚â‚ƒ\n\njulia> p(q) # a CycPol is a callable object, this call evaluates p at q\nPol{Int64}: qÂ²âµ-qÂ²â´-2qÂ²Â³-qÂ²+q+2\n\njulia> p*inv(CycPol(q^2+q+1))\n(q-2)Î¦â‚Î¦â‚‚Î¦â‚ƒâ»Â¹Î¦â‚‚â‚ƒ\n\n\nThe variable name in a CycPol is set by default to the same as for Pols.\n\nCycPols are internally a struct with fields:\n\n.coeff:  a coefficient, usually a cyclotomic number or a polynomial.\n\n.valuation: an Int.\n\n.v: a list of pairs r=>m of a root of unity r and a multiplicity m. Here r is a Root1, internally a fraction n//e with n<e representing E(r)=E(e,n).\n\nSo CycPol(c,val,v) represents c*q^val*prod((q-E(r))^m for (r,m) in v).\n\nWhen   showing,  some  factors  of   the  cyclotomic  polynomial  Î¦â‚™  are represented.  If n has a primitive root  Î¾, Ï•â€²â‚™ is the product of the (q-Î¶) where Î¶ runs over the odd powers of Î¾, and Ï•â€³â‚™ is the product for the even powers. The function show_factors gives the complete list of recognized factors:\n\njulia> CycPols.show_factors(24)\nÎ¦â‚‚â‚„=qâ¸-qâ´+1\nÎ¦â€²â‚‚â‚„=qâ´+Î¶â‚ƒÂ²\nÎ¦â€³â‚‚â‚„=qâ´+Î¶â‚ƒ\nÎ¦â€´â‚‚â‚„=qâ´-âˆš2qÂ³+qÂ²-âˆš2q+1\nÎ¦â—â‚‚â‚„=qâ´+âˆš2qÂ³+qÂ²+âˆš2q+1\nÎ¦â½âµâ¾â‚‚â‚„=qâ´-âˆš6qÂ³+3qÂ²-âˆš6q+1\nÎ¦â½â¶â¾â‚‚â‚„=qâ´+âˆš6qÂ³+3qÂ²+âˆš6q+1\nÎ¦â½â·â¾â‚‚â‚„=qâ´+(âˆš-2)qÂ³-qÂ²+(-âˆš-2)q+1\nÎ¦â½â¸â¾â‚‚â‚„=qâ´+(-âˆš-2)qÂ³-qÂ²+(âˆš-2)q+1\nÎ¦â½â¹â¾â‚‚â‚„=qâ´-Î¶â‚„qÂ²-1\nÎ¦â½Â¹â°â¾â‚‚â‚„=qâ´+Î¶â‚„qÂ²-1\nÎ¦â½Â¹Â¹â¾â‚‚â‚„=qÂ²+(Î¶â‚‚â‚„+Î¶â‚‚â‚„Â¹â¹)q-Î¶â‚ƒ\nÎ¦â½Â¹Â²â¾â‚‚â‚„=qÂ²+(-Î¶â‚‚â‚„-Î¶â‚‚â‚„Â¹â¹)q-Î¶â‚ƒ\nÎ¦â½Â¹Â³â¾â‚‚â‚„=qÂ²+(Î¶â‚‚â‚„Â¹Â¹+Î¶â‚‚â‚„Â¹â·)q-Î¶â‚ƒÂ²\nÎ¦â½Â¹â´â¾â‚‚â‚„=qÂ²+(-Î¶â‚‚â‚„Â¹Â¹-Î¶â‚‚â‚„Â¹â·)q-Î¶â‚ƒÂ²\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.CycPols.CycPol","page":"Gapjm Documentation","title":"Gapjm.CycPols.CycPol","text":"CycPol(p::Pol)\n\nConverts a polynomial to CycPol\n\njulia> CycPol(3*q^3-3)\n3Î¦â‚Î¦â‚ƒ\n\n\n\n\n\nCycPol(v::AbstractVector)\n\nThis  form is an  compact way unsed  in the Chevie  library of specifying a CycPol  with only  positive multiplicities:  v should  be a vector. The first  element is taken as the .coeff  of the CycPol, the second as the .valuation.   Subsequent  elements  are   rationals  i//d  representing (q-E(d)^i) or are integers d representing Î¦_d(q).\n\njulia> CycPol([3,-5,6,3//7])\n3qâ»âµÎ¦â‚†(q-Î¶â‚‡Â³)\n\n\n\n\n\n","category":"type"},{"location":"#Utilities","page":"Gapjm Documentation","title":"Utilities","text":"","category":"section"},{"location":"","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"Util\n@forward\ngroupby\ntally\ncollectby\nconstant\nshowtable\ncut\nprime_residues\nphi\nprimitiveroot","category":"page"},{"location":"#Gapjm.Util","page":"Gapjm Documentation","title":"Gapjm.Util","text":"This  module contains  various utility  functions used  in the  rest of the code.  Maybe some  of them  exist in  some Julia  module I am not aware of; please tell me.\n\nThe code is divided in sections  according to semantics.\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.Util.@forward","page":"Gapjm Documentation","title":"Gapjm.Util.@forward","text":"@forward T.f f1,f2,...   generates  f1(a::T,args...)=f1(a.f,args...) f2(a::T,args...)=f2(a.f,args...) ...\n\n\n\n\n\n","category":"macro"},{"location":"#Gapjm.Combinat.groupby","page":"Gapjm Documentation","title":"Gapjm.Combinat.groupby","text":"groupby(v,l)\n\ngroup  elements of collection l according  to the corresponding values in the collection v (which should have same length as l).\n\njulia> groupby([31,28,31,30,31,30,31,31,30,31,30,31],\n  [:Jan,:Feb,:Mar,:Apr,:May,:Jun,:Jul,:Aug,:Sep,:Oct,:Nov,:Dec])\nDict{Int64,Vector{Symbol}} with 3 entries:\n  31 => Symbol[:Jan, :Mar, :May, :Jul, :Aug, :Oct, :Dec]\n  28 => Symbol[:Feb]\n  30 => Symbol[:Apr, :Jun, :Sep, :Nov]\n\n\n\n\n\ngroupby(f::Function,l)\n\ngroup  elements of collection l according to the values taken by function f on them. The values of f must be hashable.\n\njulia> groupby(iseven,1:10)\nDict{Bool, Vector{Int64}} with 2 entries:\n  0 => [1, 3, 5, 7, 9]\n  1 => [2, 4, 6, 8, 10]\n\nNote:  keys of the result will  have type Any if l  is empty since I do not know how to access the return type of a function\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Combinat.tally","page":"Gapjm Documentation","title":"Gapjm.Combinat.tally","text":"tally(v)\n\ncount  how many times  each element of  collection v occurs  and return a sorted  Vector of  elt=>count (a  variation on  StatsBase.countmap; the elements of v must be sortable).\n\njulia> tally(\"a tally test\")\n7-element Vector{Pair{Char, Int64}}:\n ' ' => 2\n 'a' => 2\n 'e' => 1\n 'l' => 2\n 's' => 1\n 't' => 3\n 'y' => 1\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Combinat.collectby","page":"Gapjm Documentation","title":"Gapjm.Combinat.collectby","text":"collectby(f,v)\n\ngroup  the elements of v in packets  (Vectors) where f takes the same value.  The resulting Vector{Vector} is sorted  by the values of f (the values  of  f  must  be  sortable;  otherwise  you  can  use  the  slower values(groupby(f,v))).  Here f can  be a function  of one variable or a collection of same length as v.\n\njulia> l=[:Jan,:Feb,:Mar,:Apr,:May,:Jun,:Jul,:Aug,:Sep,:Oct,:Nov,:Dec];\n\njulia> collectby(x->first(string(x)),l)\n8-element Vector{Vector{Symbol}}:\n [:Apr, :Aug]\n [:Dec]\n [:Feb]\n [:Jan, :Jun, :Jul]\n [:Mar, :May]\n [:Nov]\n [:Oct]\n [:Sep]\n\njulia> collectby(\"JFMAMJJASOND\",l)\n8-element Vector{Vector{Symbol}}:\n [:Apr, :Aug]\n [:Dec]\n [:Feb]\n [:Jan, :Jun, :Jul]\n [:Mar, :May]\n [:Nov]\n [:Oct]\n [:Sep]\n\njulia-repl\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Combinat.constant","page":"Gapjm Documentation","title":"Gapjm.Combinat.constant","text":"constant(a) whether all elements in collection a are equal\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Util.showtable","page":"Gapjm Documentation","title":"Gapjm.Util.showtable","text":"showtable(io, table::AbstractMatrix; options )\n\nGeneral  routine to format a table. The  following options can be passed as properties of the io or as keywords.\n\nrow_labels         labels for rows (default axes(table,1))\nrows_label         label for first column (column of row labels)\ncol_labels         labels for other columns\nrowseps            line numbers after which to put a separator\nrows               show only these rows\ncols               show only these columns\nTeX                give LaTeX output (useful in Jupyter or Pluto)\ncolumn_repartition display in vertical pieces of sizes indicated (default if not TeX: take in account displaysize(io,2))\n\njulia> m=[1 2 3 4;5 6 7 8;9 1 2 3;4 5 6 7];\n\njulia> showtable(stdout,m)\n1â”‚1 2 3 4\n2â”‚5 6 7 8\n3â”‚9 1 2 3\n4â”‚4 5 6 7\n\njulia> labels=[\"x\",\"y\",\"z\",\"t\"];\n\njulia> showtable(stdout,m;cols=2:4,col_labels=labels,rowseps=[0,2,4])\n â”‚y z t\nâ”€â”¼â”€â”€â”€â”€â”€â”€\n1â”‚2 3 4\n2â”‚6 7 8\nâ”€â”¼â”€â”€â”€â”€â”€â”€\n3â”‚1 2 3\n4â”‚5 6 7\nâ”€â”´â”€â”€â”€â”€â”€â”€\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Util.cut","page":"Gapjm Documentation","title":"Gapjm.Util.cut","text":"cut(string;options)\n\noptions:\n\nwidth=displaysize(stdout)[2]-2 cutting width\nafter=\",\"                      cutting after these chars\nbefore=\"\"                      cutting before these chars\nfile=stdout                    where to print result\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Util.prime_residues","page":"Gapjm Documentation","title":"Gapjm.Util.prime_residues","text":"the numbers less than n and prime to n \n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Util.phi","page":"Gapjm Documentation","title":"Gapjm.Util.phi","text":"the Euler function Ï• \n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Util.primitiveroot","page":"Gapjm Documentation","title":"Gapjm.Util.primitiveroot","text":"primitiveroot(m::Integer) a primitive root mod. m,   that is it generates multiplicatively prime_residues(m).   It exists if m is of the form 4, 2p^a or p^a for p prime>2.\n\n\n\n\n\n","category":"function"},{"location":"#Combinatorics","page":"Gapjm Documentation","title":"Combinatorics","text":"","category":"section"},{"location":"","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"Combinat\narrangements\ncombinations\npartitions\npartition_tuples\ncompositions\nsubmultisets\npartitions_set\nlcm_partitions\ngcd_partitions\nconjugate_partition\ndominates\nbell\nstirling2","category":"page"},{"location":"#Gapjm.Combinat","page":"Gapjm Documentation","title":"Gapjm.Combinat","text":"This  self-contained module (it has no dependencies) is a port of some GAP3 combinatorics  functions needed by my port  of the Chevie GAP3 package. The list of functions it exports are:\n\nClassical enumerations:\n\ncombinations, ncombinations, arrangements, narrangements,   partitions, npartitions, partition_tuples, npartition_tuples,   partitions_set, npartitions_set, compositions, submultisets\n\nsome more functions on partitions and set partitions, and counting functions:\n\nlcm_partitions, gcd_partitions, conjugate_partition, dominates, bell,  stirling2\n\nand finally some structural manipulations not yet in Julia:\n\ngroupby, constant, tally, collectby, cartesian, unique_sorted!\n\nHave  a  look  at  the  individual  docstrings  and  enjoy (any feedback is welcome).\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.Combinat.arrangements","page":"Gapjm Documentation","title":"Gapjm.Combinat.arrangements","text":"arrangements(mset[,k])\n\nnarrangements(mset[,k])\n\narrangements  returns  the  arrangements  of  the  multiset mset (a not necessarily  sorted  collection  with  possible  repetitions).  If a second argument   k  is  given,  it  returns  arrangements  with  k  elements. narrangements returns the number of arrangements.\n\nAn  arrangement  of  mset  is  a  subsequence taken in arbitrary order, representated as a Vector.\n\nAs  an example of arrangements  of a multiset, think  of the game Scrabble. Suppose  you have the six  characters of the word  'settle' and you have to make a four letter word. Then the possibilities are given by\n\njulia> narrangements(collect(\"settle\"),4)\n102\n\nwhile all possible words (including the empty one) are:\n\njulia> narrangements(collect(\"settle\"))\n523\n\nThe  result returned  by 'arrangements'  is sorted  (the elements of mset must  be sortable), which means in  this example that the possibilities are listed  in the same  order as they  appear in the  dictionary. Here are the two-letter words:\n\njulia> String.(arrangements(collect(\"settle\"),2))\n14-element Vector{String}:\n \"ee\"\n \"el\"\n \"es\"\n \"et\"\n \"le\"\n \"ls\"\n \"lt\"\n \"se\"\n \"sl\"\n \"st\"\n \"te\"\n \"tl\"\n \"ts\"\n \"tt\"\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Combinat.combinations","page":"Gapjm Documentation","title":"Gapjm.Combinat.combinations","text":"combinations(mset[,k])\n\nncombinations(mset[,k])\n\n'combinations'  returns  all  combinations  of  the  multiset mset (a not necessarily  sorted  collection  with  possible  repetitions).  If a second argument  k  is  given,  it  returns  the combinations with k elements. ncombinations returns the number of combinations.\n\nA  combination is an unordered subsequence and is represented by a sorted Vector  (the  elements  of  mset  must  be  sortable). If mset has no repetitions, the list of all combinations is just the powerset of mset.\n\njulia> ncombinations([1,2,2,3])\n12\n\njulia> combinations([1,2,2,3])\n12-element Vector{Vector{Int64}}:\n []\n [1]\n [2]\n [3]\n [1, 2]\n [1, 3]\n [2, 2]\n [2, 3]\n [1, 2, 2]\n [1, 2, 3]\n [2, 2, 3]\n [1, 2, 2, 3]\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Combinat.partitions","page":"Gapjm Documentation","title":"Gapjm.Combinat.partitions","text":"partitions(n[,k])\n\nnpartitions(n[,k])\n\npartitions returns the set of all partitions of the positive integer n (the partitions with k parts if k is given). npartitions is the number of partitions.\n\nThere are approximately exp(Ï€âˆš(2n/3))/(4âˆš3 n) partitions of n.\n\nA  partition  is  a  decomposition  n=pâ‚+pâ‚‚+â€¦+pâ‚–  in integers such that pâ‚â‰¥pâ‚‚â‰¥â€¦â‰¥pâ‚–>0, and is represented by the vector p=[pâ‚,pâ‚‚,â€¦,pâ‚–]. We write pâŠ¢n.\n\njulia> npartitions(7)\n15\n\njulia> partitions(7)\n15-element Vector{Vector{Int64}}:\n [1, 1, 1, 1, 1, 1, 1]\n [2, 1, 1, 1, 1, 1]\n [2, 2, 1, 1, 1]\n [2, 2, 2, 1]\n [3, 1, 1, 1, 1]\n [3, 2, 1, 1]\n [3, 2, 2]\n [3, 3, 1]\n [4, 1, 1, 1]\n [4, 2, 1]\n [4, 3]\n [5, 1, 1]\n [5, 2]\n [6, 1]\n [7]\n\njulia> npartitions(7,3)\n4\n\njulia> partitions(7,3)\n4-element Vector{Vector{Int64}}:\n [3, 2, 2]\n [3, 3, 1]\n [4, 2, 1]\n [5, 1, 1]\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Combinat.partition_tuples","page":"Gapjm Documentation","title":"Gapjm.Combinat.partition_tuples","text":"partition_tuples(n,r)\n\nnpartition_tuples(n,r)\n\nthe r-tuples of partitions that together partition n. npartition_tuples is the number of partition tuples.\n\njulia> npartition_tuples(3,2)\n10\n\njulia> partition_tuples(3,2)\n10-element Vector{Vector{Vector{Int64}}}:\n [[1, 1, 1], []]\n [[1, 1], [1]]\n [[1], [1, 1]]\n [[], [1, 1, 1]]\n [[2, 1], []]\n [[1], [2]]\n [[2], [1]]\n [[], [2, 1]]\n [[3], []]\n [[], [3]]\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Combinat.compositions","page":"Gapjm Documentation","title":"Gapjm.Combinat.compositions","text":"compositions(n[,k];start=1)\n\nThis  function returns the compositions of  n (the compositions of length k  if a second argument k is given), where a composition of the integer n is a decomposition n=pâ‚+â€¦+pâ‚– in integers â‰¥start, represented as the vector  [pâ‚,â€¦,pâ‚–]. Unless k  is given, start  must be >0. There are 2^n-1  compositions of n in  integers â‰¥1, and binomial(n-1,k-1) compositions of n in k parts â‰¥1.\n\njulia> compositions(4)\n8-element Vector{Vector{Int64}}:\n [1, 1, 1, 1]\n [2, 1, 1]\n [1, 2, 1]\n [3, 1]\n [1, 1, 2]\n [2, 2]\n [1, 3]\n [4]\n\njulia> compositions(4,2)\n3-element Vector{Vector{Int64}}:\n [3, 1]\n [2, 2]\n [1, 3]\n\njulia> compositions(4,2;start=0)\n5-element Vector{Vector{Int64}}:\n [4, 0]\n [3, 1]\n [2, 2]\n [1, 3]\n [0, 4]\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Combinat.submultisets","page":"Gapjm Documentation","title":"Gapjm.Combinat.submultisets","text":"submultisets(set,k)\n\nsubmultisets  returns  the  set  of  all  multisets of length k made of elements of the set set (a collection without repetitions).\n\nAn  multiset of length k is  an unordered selection with repetitions of length  k from set and is represented  by a sorted vector of length k made  of  elements  from  set.  There  are  binomial(|set|+k-1,k)  such sub-multisets.\n\njulia> submultisets(1:4,3)\n20-element Vector{Vector{Int64}}:\n [1, 1, 1]\n [1, 1, 2]\n [1, 1, 3]\n [1, 1, 4]\n [1, 2, 2]\n [1, 2, 3]\n [1, 2, 4]\n [1, 3, 3]\n [1, 3, 4]\n [1, 4, 4]\n [2, 2, 2]\n [2, 2, 3]\n [2, 2, 4]\n [2, 3, 3]\n [2, 3, 4]\n [2, 4, 4]\n [3, 3, 3]\n [3, 3, 4]\n [3, 4, 4]\n [4, 4, 4]\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Combinat.partitions_set","page":"Gapjm Documentation","title":"Gapjm.Combinat.partitions_set","text":"partitions_set(set[,k])\n\nnpartitions_set(set[,k])\n\nthe  set of all unordered partitions of the set set (a collection without repetitions);  if  k  is  given  the  unordered  partitions  in k sets. npartitions_set returns the number of unordered partitions.\n\nAn unordered partition of set is  a set of pairwise disjoint nonempty sets with union set  and is represented by  a sorted Vector of Vectors.\n\njulia> npartitions_set(1:3)\n5\n\njulia> partitions_set(1:3)\n5-element Vector{Vector{Vector{Int64}}}:\n [[1], [2], [3]]\n [[1], [2, 3]]\n [[1, 2], [3]]\n [[1, 2, 3]]\n [[1, 3], [2]]\n\njulia> npartitions_set(1:4,2)\n7\n\njulia> partitions_set(1:4,2)\n7-element Vector{Vector{Vector{Int64}}}:\n [[1], [2, 3, 4]]\n [[1, 2], [3, 4]]\n [[1, 2, 3], [4]]\n [[1, 2, 4], [3]]\n [[1, 3], [2, 4]]\n [[1, 3, 4], [2]]\n [[1, 4], [2, 3]]\n\nNote  that partitions_set does not currently support multisets and that there is currently no ordered counterpart.\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Combinat.lcm_partitions","page":"Gapjm Documentation","title":"Gapjm.Combinat.lcm_partitions","text":"lcm_partitions(p1,â€¦,pn)\n\neach  argument is  a partition  of the  same set  S, given  as a  list of disjoint  vectors whose  union is  S. Equivalently  each argument  can be interpreted as an equivalence relation on S.\n\nThe result is the finest partition of S such that each argument partition refines it. It represents the 'or' of the equivalence relations represented by the arguments.\n\njulia> lcm_partitions([[1,2],[3,4],[5,6]],[[1],[2,5],[3],[4],[6]])\n2-element Vector{Vector{Int64}}:\n [1, 2, 5, 6]\n [3, 4]      \n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Combinat.gcd_partitions","page":"Gapjm Documentation","title":"Gapjm.Combinat.gcd_partitions","text":"gcd_partitions(p1,â€¦,pn)\n\nEach  argument is  a partition  of the  same set  S, given  as a  list of disjoint  vectors whose  union is  S. Equivalently  each argument  can be interpreted as an equivalence relation on S.\n\nThe result is the coarsest partition which refines all argument partitions. It  represents the  'and' of  the equivalence  relations represented by the arguments.\n\njulia> gcd_partitions([[1,2],[3,4],[5,6]],[[1],[2,5],[3],[4],[6]])\n6-element Vector{Vector{Int64}}:\n [1]\n [2]\n [3]\n [4]\n [5]\n [6]\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Combinat.conjugate_partition","page":"Gapjm Documentation","title":"Gapjm.Combinat.conjugate_partition","text":"conjugate_partition(Î»)\n\nreturns  the  conjugate  partition  of  the  partition  Î»,  that  is, the partition having the transposed of the Young diagram of Î».\n\njulia> conjugate_partition([4,2,1])\n4-element Vector{Int64}:\n 3\n 2\n 1\n 1\n\njulia> conjugate_partition([6])\n6-element Vector{Int64}:\n 1\n 1\n 1\n 1\n 1\n 1\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Combinat.dominates","page":"Gapjm Documentation","title":"Gapjm.Combinat.dominates","text":"dominates(Î»,Î¼)\n\nThe  dominance  order  on  partitions  is  an  important  partial  order in representation theory. Î» dominates Î¼ if and only if for all i we have sum(Î»[1:i])â‰¥sum(Î¼[1:i]).\n\njulia> dominates([5,4],[4,4,1])\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Combinat.bell","page":"Gapjm Documentation","title":"Gapjm.Combinat.bell","text":"'bell(n)'\n\nThe  Bell numbers are  defined by bell(0)=1  and bell(n+1)=_k=0^n n choose  kbell(k), or by the fact  that bell(n)/n! is the coefficient of xâ¿ in the formal series e^(eË£-1).\n\njulia> bell.(0:6)\n7-element Vector{Int64}:\n   1\n   1\n   2\n   5\n  15\n  52\n 203\n\njulia> bell(14)\n190899322\n\njulia-repl\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Combinat.stirling2","page":"Gapjm Documentation","title":"Gapjm.Combinat.stirling2","text":"stirling2(n,k)\n\nthe   Stirling  number   of  the   second  kind.   They  are  defined  by stirling2(0,0)=1,  stirling2(n,0)=stirling2(0,k)=0  if  n,  k!=0  and stirling2(n,k)=k   stirling2(n-1,k)+stirling2(n-1,k-1),   and   also   as coefficients of the generating function x^n=sum_k=0^nstirling2(nk) kxchoose k.\n\njulia> stirling2.(4,0:4)\n5-element Vector{Int64}:  # Knuth calls this the trademark of stirling2\n 0\n 1\n 7\n 6\n 1\n\njulia> [stirling2(i,j) for i in 0:6, j in 0:6]\n7Ã—7 Matrix{Int64}:\n 1  0   0   0   0   0  0 # Note the similarity with Pascal's triangle\n 0  1   0   0   0   0  0\n 0  1   1   0   0   0  0\n 0  1   3   1   0   0  0\n 0  1   7   6   1   0  0\n 0  1  15  25  10   1  0\n 0  1  31  90  65  15  1\n\njulia> stirling2(50,big(10))\n26154716515862881292012777396577993781727011\n\n\n\n\n\n","category":"function"},{"location":"#Module-Elements","page":"Gapjm Documentation","title":"Module Elements","text":"","category":"section"},{"location":"","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"ModuleElts","category":"page"},{"location":"#Gapjm.ModuleElts","page":"Gapjm Documentation","title":"Gapjm.ModuleElts","text":"A  ModuleElt{K,V}  represents  an  element  of  a free module where basis elements  are of type  K and coefficients  of type V.  Usually you want objects  of type V to be elements of  a ring, but it could also be useful if they just belong to an abelian group. \n\nThis  basic data structure is  used in the package  Gapjm as an efficient representation   for  multivariate   polynomials  (and   their  monomials), cyclotomics, CycPols, elements of Hecke algebras, etcâ€¦\n\nA  ModuleElt is essentially a  list of pairs b=>c  where b is a basis element  and c its coefficient. The  constructor takes as argument a list of  pairs, or a variable number of pair arguments, or a generator of pairs.\n\nWe provide two implementations:\n\none by Dicts \n\nthis is easy since the interface of the type is close to that of dicts; the only  difference is weeding out keys which have a zero cofficient â€“- which thus demands that the keys are hashable.\n\na faster  one (the default)  by sorting pairs by key\n\nthis  demands that keys are comparable.  This implementation is two to four times faster than the Dict one and requires half the memory.\n\nHere  is an example where basis elements are Symbols and coefficients are Int.\n\njulia> a=ModuleElt(:xy=>1,:yx=>-1)\n:xy-:yx\n\njulia> a-a\n0\n\njulia> a*99\n99:xy-99:yx\n\njulia> a+ModuleElt(:yx=>1)\n:xy\n\njulia> a[:xy]\n1\n\njulia> a[:xx]  # the coefficient of an absent basis element is zero.\n0\n\njulia> haskey(a,:xx)\nfalse\n\njulia> first(a)\n:xy => 1\n\njulia> collect(a)\n2-element Vector{Pair{Symbol, Int64}}:\n :xy => 1\n :yx => -1\n\njulia> keys(a)\n2-element Vector{Symbol}:\n :xy\n :yx\n\njulia> values(a)\n2-element Vector{Int64}:\n  1\n -1\n\njulia> length(a)\n2\n\njulia> eltype(a)\nPair{Symbol, Int64}\n\nIn both implementations the constructor normalizes the constructed element, removing  zero  coefficients  and  merging  duplicate  basis  elements (and sorting  the  basis  in  the  default  implementation).  If  you know it is unnecessary,  to  het  maximum  speed  you  can  disable this by giving the keyword check=false.\n\njulia> a=ModuleElt(:yy=>1, :yx=>2, :xy=>3, :yy=>-1;check=false)\n:yy+2:yx+3:xy-:yy\n\njulia> a=ModuleElt(:yy=>1, :yx=>2, :xy=>3, :yy=>-1)\n3:xy+2:yx\n\nsetting  the IOContext property showbasis to a custom printing function changes how the basis elements are printed.\n\njulia> show(IOContext(stdout,:showbasis=>(io,s)->string(\"<\",s,\">\")),a)\n3<xy>+2<yx>\n\nAdding  or subtracting ModuleElts does promotion  on the type of the keys and the coefficients if needed:\n\njulia> a+ModuleElt([:z=>1.0])\n3.0:xy+2.0:yx+1.0:z\n\n\n\n\n\n","category":"module"},{"location":"#Posets","page":"Gapjm Documentation","title":"Posets","text":"","category":"section"},{"location":"","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"Posets\nPoset\nhasse\nincidence\ntransitive_closure\nlinear_extension\nreverse\npartition\nPosets.restricted(::Poset,::AbstractVector{<:Integer})\nis_join_lattice\nis_meet_lattice\nPoset(::CoxeterGroup,w=longest(W))","category":"page"},{"location":"#Gapjm.Posets","page":"Gapjm Documentation","title":"Gapjm.Posets","text":"Posets  are represented as objects where at  least one of the two following fields is present:\n\nincidence:  a  boolean  matrix  such that incidence[i][j]==true iff\n\ni<=j in the poset.\n\nhasse:  a list representing  the Hasse diagram  of the poset: the i-th entry is the list of indices of elements which are immediate successors (covers) of the i-th element, that is the list of j such that i<j and such that there is no k such that i<k<j.\n\nThere   are  thus  two   constructors,  Poset(I::Matrix{Bool})  from  the incidence  matrix I, and Poset(H::Vector{<:Vector{<:Integer}}) from the Hasse diagram.\n\nPosets  are  printed  as  a  list  of covering chains. Elements which are equivalent for the Poset are printed together separated by commas.\n\njulia> p=Poset(coxgroup(:A,2))\n.<1,2<21,12<121\n\njulia> length(p) # the number of elements of the `Poset`\n6\n\nnote in the above example that the poset has been printed with labels which are  the words in coxgroup(:A,2). If no labels have been set for p, the labels  shown are 1:length(p). The labels should have same length as Â p but can be any objects.\n\njulia> p.labels=\"abcdef\"; p\na<b,c<d,e<f\n\njulia> hasse(p)\n6-element Vector{Vector{Int64}}:\n [2, 3]\n [4, 5]\n [4, 5]\n [6]   \n [6]   \n []    \n\njulia> incidence(p)\n6Ã—6 Matrix{Bool}:\n 1  1  1  1  1  1\n 0  1  0  1  1  1\n 0  0  1  1  1  1\n 0  0  0  1  0  1\n 0  0  0  0  1  1\n 0  0  0  0  0  1\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.Posets.Poset","page":"Gapjm Documentation","title":"Gapjm.Posets.Poset","text":"Poset(m::Matrix{Bool})\n\nCreates a poset from an incidence matrix m, that is m[i,j]==true if and only if iâ‰¤j in the poset,\n\njulia> Poset(Bool[1 1 1 1 1;0 1 0 1 1;0 0 1 1 1;0 0 0 1 0;0 0 0 0 1])\n1<2,3<4,5\n\n\n\n\n\nPoset(h::Vector{<:Vector{<:Integer}})\n\nCreates a poset from a Hasse diagram given as a Vector whose i-th entry is  the list of indices of elements which are immediate successors (covers) of the i-th element, that is h[i] is the list of j such that i<j in the poset and such that there is no k such that i<k<j.\n\njulia> Poset([[2,3],[4,5],[4,5],Int[],Int[]])\n1<2,3<4,5\n\n\n\n\n\nPoset(W::CoxeterGroup,w=longest(W))\n\nreturns  as a poset the Bruhat interval [1,w]of W. If w is not given, the whole Bruhat Poset of W is returned (W must then be finite).\n\njulia> W=coxgroup(:A,2)\nAâ‚‚\n\njulia> Poset(W)\n.<1,2<21,12<121\n\njulia> W=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> Poset(W,W(1,3))\n.<3,1<13\n\n\n\n\n\n","category":"type"},{"location":"#Gapjm.Posets.hasse","page":"Gapjm Documentation","title":"Gapjm.Posets.hasse","text":"hasse(P)\n\nreturns the Hasse diagram of the poset P.\n\njulia> p=Poset([j%i==0 for i in 1:5, j in 1:5])\n1<3,5\n1<2<4\n\njulia> hasse(p)\n5-element Vector{Vector{Int64}}:\n [2, 3, 5]\n [4]      \n []       \n []       \n []       \n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Posets.incidence","page":"Gapjm Documentation","title":"Gapjm.Posets.incidence","text":"incidence(P)\n\nreturns the incidence matrix of the poset P.\n\njulia> p=Poset(push!([[i+1] for i in 1:5],Int[]))\n1<2<3<4<5<6\n\njulia> incidence(p)\n6Ã—6 Matrix{Bool}:\n 1  1  1  1  1  1\n 0  1  1  1  1  1\n 0  0  1  1  1  1\n 0  0  0  1  1  1\n 0  0  0  0  1  1\n 0  0  0  0  0  1\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Posets.transitive_closure","page":"Gapjm Documentation","title":"Gapjm.Posets.transitive_closure","text":"transitive_closure(M)\n\nM  should be a  square boolean matrix  representing a relation; returns a boolean  matrix representing the  transitive closure of  this relation. The transitive  closure is computed  by the Floyd-Warshall  algorithm, which is quite fast even for large matrices.\n\njulia> m=[j-i in [0,1] for i in 1:5, j in 1:5]\n5Ã—5 Matrix{Bool}:\n 1  1  0  0  0\n 0  1  1  0  0\n 0  0  1  1  0\n 0  0  0  1  1\n 0  0  0  0  1\n\njulia>transitive_closure(m)\n5Ã—5 Matrix{Bool}:\n 1  1  1  1  1\n 0  1  1  1  1\n 0  0  1  1  1\n 0  0  0  1  1\n 0  0  0  0  1\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Posets.linear_extension","page":"Gapjm Documentation","title":"Gapjm.Posets.linear_extension","text":"linear_extension(P)\n\nreturns  a  linear  extension  of  the  poset  P,  that  is  a vector l containing  a permutation of the integers  1:length(P) such that if i<j in P, then findfirst(==(i),l)<findfirst(==(j),l). This is also called a topological sort of P.\n\njulia> p=Poset([j%i==0 for i in 1:6, j in 1:6])\n1<5\n1<2<4\n1<3<6\n2<6\n\njulia> linear_extension(p)\n6-element Vector{Int64}:\n 1\n 2\n 3\n 5\n 4\n 6\n\n\n\n\n\n","category":"function"},{"location":"#Base.reverse","page":"Gapjm Documentation","title":"Base.reverse","text":"reverse(P)\n\nthe opposed poset to P.\n\njulia> p=Poset([i==j || i%4<j%4 for i in 1:8, j in 1:8])\n4,8<1,5<2,6<3,7\n\njulia> reverse(p)\n3,7<2,6<1,5<4,8\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Posets.partition","page":"Gapjm Documentation","title":"Gapjm.Posets.partition","text":"partition(P::Poset)\n\nreturns  the  partition  of  1:length(P)  determined  by  the equivalence relation  associated to P; that  is, i and j  are in the same part of the  partition if the k such that i<k and j<k are the same as well as the k such that k<i and k<j.\n\njulia> p=Poset([i==j || i%4<j%4 for i in 1:8, j in 1:8])\n4,8<1,5<2,6<3,7\n\njulia> partition(p)\n4-element Vector{Vector{Int64}}:\n [4, 8]\n [2, 6]\n [3, 7]\n [1, 5]\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Posets.restricted-Tuple{Poset, AbstractVector{var\"#s26\"} where var\"#s26\"<:Integer}","page":"Gapjm Documentation","title":"Gapjm.Posets.restricted","text":"restricted(P::Poset,inds::AbstractVector{<:Integer})\n\nreturns  the sub-poset of P determined by inds, which must be a sublist of 1:length(P). The indices in this sub-poset will be renumbered to their position in inds. If P has labels, they will be transmitted to the sub-poset.\n\njulia> p=Poset([i==j || i%4<j%4 for i in 1:8, j in 1:8])\n4,8<1,5<2,6<3,7\n\njulia> restricted(p,2:6)\n3<4<1,5<2\n\njulia> p.labels=1:8; restricted(p,2:6)\n4<5<2,6<3\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.Posets.is_join_lattice","page":"Gapjm Documentation","title":"Gapjm.Posets.is_join_lattice","text":"is_join_lattice(P::Poset)\n\nreturns  true if P is  a join semilattice, that  is any two elements of P have a unique smallest upper bound; returns false otherwise.\n\njulia> p=Poset([i==j || i%4<j%4 for i in 1:8, j in 1:8])\n4,8<1,5<2,6<3,7\n\njulia> is_join_lattice(p)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Posets.is_meet_lattice","page":"Gapjm Documentation","title":"Gapjm.Posets.is_meet_lattice","text":"is_meet_lattice(P)\n\nreturns  true if P is  a meet semilattice, that  is any two elements of P have a unique highest lower bound; returns false otherwise.\n\njulia> p=Poset([i==j || i%4<j%4 for i in 1:8, j in 1:8])\n4,8<1,5<2,6<3,7\n\njulia> is_meet_lattice(p)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Posets.Poset-2","page":"Gapjm Documentation","title":"Gapjm.Posets.Poset","text":"Poset(W::CoxeterGroup,w=longest(W))\n\nreturns  as a poset the Bruhat interval [1,w]of W. If w is not given, the whole Bruhat Poset of W is returned (W must then be finite).\n\njulia> W=coxgroup(:A,2)\nAâ‚‚\n\njulia> Poset(W)\n.<1,2<21,12<121\n\njulia> W=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> Poset(W,W(1,3))\n.<3,1<13\n\n\n\n\n\n","category":"type"},{"location":"#Signed-permutations","page":"Gapjm Documentation","title":"Signed permutations","text":"","category":"section"},{"location":"","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"SPerms\nSPerm\nPerm(::SPerm)\n@sperm_str\norbit(::SPerm,::Integer)\norder(::SPerm)\nMatrix\nCoxHyperoctaedral\nreflection_subgroup(::CoxHyperoctaedral,::AbstractVector{Int})\nsstab_onmats\nSPerm_onmats","category":"page"},{"location":"#Gapjm.SPerms","page":"Gapjm Documentation","title":"Gapjm.SPerms","text":"A  signed permutation of 1:n is  a permutation of the set -n,â€¦,-1,1,â€¦,n which  preserves the  pairs (-i,i).  It is  represented internally as the images of 1:n. It is printed as a product of signed cycles.\n\nExamples\n\njulia> SPerm([-2,-1,-3])\nSPerm{Int64}: (1,-2)(3,-3)\n\njulia> p=SPerm(-1)\n(1,-1)\n\njulia> q=SPerm(1,2)\n(1,2)\n\njulia> sort(elements(Group([p,q])))\n8-element Vector{SPerm{Int16}}:\n (1,-2)\n (1,-2,-1,2)\n (1,-1)(2,-2)\n (1,-1)\n (2,-2)\n ()\n (1,2,-1,-2)\n (1,2)\n\nThe  complete type of signed permutations is SPerm{T} where T<:Integer, where Vector{T} is the type of the vector which holds the image of 1:n. This  can used to save space or time when possible. If T is not specified we  take it to be Int16 since this is a good compromise between speed and compactness.\n\nSPerms  have methods copy, hash, ==, isless  (total order) so they can be keys in hashes or elements of sets; two SPerms are equal if they move the same points to the same images. For instance,\n\njulia> SPerm([-2,-1,-3])==SPerm([-2,-1,-3,4])\ntrue\n\nSPerms are considered as scalars for broadcasting.\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.SPerms.SPerm","page":"Gapjm Documentation","title":"Gapjm.SPerms.SPerm","text":"struct SPerm\n\nAn  SPerm represents a signed permutation of 1:n, that is a permutation of  the  set  -n,â€¦,-1,1,â€¦,n  which  preserves  the  pairs (-i,i). It is implemented  by a struct SPerm  with one field d,  a vector holding the images of 1:n.\n\n\n\n\n\n","category":"type"},{"location":"#Gapjm.Perms.Perm-Tuple{SPerm}","page":"Gapjm Documentation","title":"Gapjm.Perms.Perm","text":"Perm(p::SPerm) returns the underlying Perm of an SPerm\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.SPerms.@sperm_str","page":"Gapjm Documentation","title":"Gapjm.SPerms.@sperm_str","text":"@sperm\"...\"\n\nmake a SPerm from a string; allows style sperm\"(1,-2)(5,-6,7)(-4,9)\"\n\n\n\n\n\n","category":"macro"},{"location":"#Gapjm.Groups.orbit-Tuple{SPerm, Integer}","page":"Gapjm Documentation","title":"Gapjm.Groups.orbit","text":"orbit(a::SPerm,i::Integer) returns the orbit of a on i\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.Groups.order-Tuple{SPerm}","page":"Gapjm Documentation","title":"Gapjm.Groups.order","text":"order(a)\n\norder of the signed permutation a\n\n\n\n\n\n","category":"method"},{"location":"#Base.Matrix","page":"Gapjm Documentation","title":"Base.Matrix","text":"Matrix(a::SPerm) is the permutation matrix for a\n\nExamples\n\njulia> Matrix(SPerm([-2,-1,-3]))\n3Ã—3 Matrix{Int64}:\n  0  -1   0\n -1   0   0\n  0   0  -1\n\n\n\n\n\nMatrix(a::Perm,n=length(a.d))  the  permutation matrix  for a  operating on  n points (by default, the degree of a). If given, n should be larger than largest_moved_point(a).\n\njulia> Matrix(Perm(2,3,4),5)\n5Ã—5 Matrix{Bool}:\n 1  0  0  0  0\n 0  0  1  0  0\n 0  0  0  1  0\n 0  1  0  0  0\n 0  0  0  0  1\n\n\n\n\n\n","category":"type"},{"location":"#Gapjm.SPerms.CoxHyperoctaedral","page":"Gapjm Documentation","title":"Gapjm.SPerms.CoxHyperoctaedral","text":"CoxHyperoctaedral(n)  The Hyperoctaedral  group on  Â±1,â€¦,Â±n as  a Coxeter group  of type  B, with  generators (1,-1)  and (i,i+1)(-i,-i-1); it is the group of all signed permutations of 1:n.\n\njulia> elements(CoxHyperoctaedral(2))\n8-element Vector{SPerm{Int8}}:\n ()\n (1,2)\n (1,-1)\n (1,2,-1,-2)\n (1,-2,-1,2)\n (2,-2)\n (1,-2)\n (1,-1)(2,-2)\n\n\n\n\n\n","category":"type"},{"location":"#Gapjm.PermRoot.reflection_subgroup-Tuple{CoxHyperoctaedral, AbstractVector{Int64}}","page":"Gapjm Documentation","title":"Gapjm.PermRoot.reflection_subgroup","text":"Only parabolics defined are I=1:m for mâ‰¤n\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.SPerms.sstab_onmats","page":"Gapjm Documentation","title":"Gapjm.SPerms.sstab_onmats","text":"sstab_onmats([G,]M[,l])\n\nIf onmats(m,p)=^(M,p;dims=(1,2)) (simultaneous signed conjugation of rows and  columns, or conjugating by the  matrix of the signed permutation p), and  the argument G  is given (which  should be an  SPermGroup) this is just  a fast implementation of  centralizer(G,M;action=onmats). If G is omitted  it is taken to be CoxHyperoctaedral(size(M,1)). The program uses sophisticated  algorithms, and can  handle matrices up  to 80Ã—80. If l is given the return group should also centralize l (for the action ^)\n\njulia> uc=UnipotentCharacters(ComplexReflectionGroup(6));\n\njulia> g=sstab_onmats(fourier(uc.families[2]))\nGroup([(1,18)(3,-6)(8,-21)(10,-16)(11,22)(13,15),(1,-15)(2,-19)(3,-11)(6,22)(7,-12)(13,-18),(2,19)(4,-14)(5,20)(7,12),(1,-11)(2,-19)(3,-15)(5,-20)(6,13)(8,10)(16,21)(17,-17)(18,-22),(1,-22)(2,-19)(3,-13)(5,-20)(6,15)(8,-16)(10,-21)(11,-18)(17,-17),(1,6)(2,-19)(3,-18)(4,14)(8,16)(9,-9)(10,21)(11,-13)(15,-22),(1,13)(3,22)(4,14)(5,-20)(6,-11)(8,21)(9,-9)(10,16)(15,18)(17,-17)])\njulia> length(g)\n32\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.SPerms.SPerm_onmats","page":"Gapjm Documentation","title":"Gapjm.SPerms.SPerm_onmats","text":"SPerm_onmats(M,N[,m,n])\n\nM  and N should be symmetric  matrices. SPerm_onmats returns a signed permutation p such that onmats(M,p)=N if such a permutation exists, and nothing  otherwise. If  in addition  vectors m  and n  are given, the signed permutation p should also satisfy m^p==n.\n\nThis  routine is  useful to  identify two  objects which are isomorphic but with  different  labelings.  It  is  used  in   Chevie  to identify Lusztig Fourier  transform matrices  with standard  (classified) data.  The program uses  sophisticated  algorithms,  and  can  often  handle  matrices  up  to 80Ã—80.\n\nEfficient version of transporting_elt(CoxHyperoctaedral(size(M,1)),M,N;action=onmats)\n\njulia> f=SubFamilyij(chevieget(:families,:X)(12),1,3,(3+ER(-3))/2);\n\njulia> M=fourier(conj(f));\n\njulia> uc=UnipotentCharacters(ComplexReflectionGroup(6));\n\njulia> N=fourier(uc.families[2]);\n\njulia> p=SPerm_onmats(M,N)\n(1,3)(2,19,-2,-19)(4,-14,-4,14)(5,-5)(6,-18)(7,-7)(8,10)(11,15,-11,-15)(12,-12)(13,22)(16,21,-16,-21)\n\njulia> ^(M,p;dims=(1,2))==N\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#Linear-algebra-on-any-field/ring","page":"Gapjm Documentation","title":"Linear algebra on any field/ring","text":"","category":"section"},{"location":"","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"GLinearAlgebra\nGLinearAlgebra.echelon!\nGLinearAlgebra.echelon\nbigcell_decomposition\ndiagblocks\nblocks\nratio\nexterior_power\ncharpoly\ncomatrix\npermanent\nsymmetric_power\nschur_functor\ntransporter\ndiagconj_elt\ntraces_words_mats\nsolutionmat","category":"page"},{"location":"#Gapjm.GLinearAlgebra","page":"Gapjm Documentation","title":"Gapjm.GLinearAlgebra","text":"GLinearAlgebra: linear algebra over arbitrary fields and rings\n\nThe  linear  algebra  package  in  Julia  is  not  suitable  for  a general mathematics  package: it assumes  the field is  the Real or Complex numbers and uses floating point to do approximate computations. Here we are interested in functions which work over any field (or sometimes any ring).\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.GLinearAlgebra.echelon!","page":"Gapjm Documentation","title":"Gapjm.GLinearAlgebra.echelon!","text":"`echelon!(m)`\n\nputs m in echelon form and returns:   (m, indices of linearly independent rows of m)   The  echelon form transforms the rows of m into a particular basis of the   rowspace.  The first  non-zero element  of each  line is  1, and  such an   element is also the only non-zero in its column.   works in any field.\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.GLinearAlgebra.echelon","page":"Gapjm Documentation","title":"Gapjm.GLinearAlgebra.echelon","text":"echelon(m)\n\nreturns: (echelon form of m, indices of linearly independent rows of m)   works in any field.   The  echelon form transforms the rows of m into a particular basis of the   rowspace  of m: the first non-zero element  of each line is 1, and such   an element is also the only non-zero in its column.\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.GLinearAlgebra.bigcell_decomposition","page":"Gapjm Documentation","title":"Gapjm.GLinearAlgebra.bigcell_decomposition","text":"bigcell_decomposition(M [, b])\n\nM  should be a square  matrix, and b specifies  a block structure for a matrix  of  same  size  as  M  (it  is  a  Vector  of  Vectors  whose concatenation  is 1:size(M,1)).  If b  is not  given, the trivial block structure [[i] for i in axes(M,1)] is assumed.\n\nThe  function  decomposes  M  as  a  product  Pâ‚ L P where P is upper block-unitriangular   (with  identity  diagonal   blocks),  Pâ‚  is  lower block-unitriangular  and L is block-diagonal for the block structure b. If  M is symmetric then  Pâ‚ is the transposed  of P and the result is the  pair  [P,L];  else  the  result  is  the triple [Pâ‚,L,P]. The only condition  for  this  decomposition  of  M  to  be  possible  is that the principal  minors  according  to  the  block  structure be invertible. This routine  is used  in the  Lusztig-Shoji algorithm  for computing  the Green functions  and the example  below is extracted  from the computation of the Green functions for Gâ‚‚.\n\njulia> Pol(:q)\nPol{Int64}: q\n\njulia> M=[q^6 q^0 q^3 q^3 q^5+q q^4+q^2; q^0 q^6 q^3 q^3 q^5+q q^4+q^2; q^3 q^3 q^6 q^0 q^4+q^2 q^5+q; q^3 q^3 q^0 q^6 q^4+q^2 q^5+q; q^5+q q^5+q q^4+q^2 q^4+q^2 q^6+q^4+q^2+1 q^5+2*q^3+q; q^4+q^2 q^4+q^2 q^5+q q^5+q q^5+2*q^3+q q^6+q^4+q^2+1]\n6Ã—6 Matrix{Pol{Int64}}:\n qâ¶     1      qÂ³     qÂ³     qâµ+q        qâ´+qÂ²\n 1      qâ¶     qÂ³     qÂ³     qâµ+q        qâ´+qÂ²\n qÂ³     qÂ³     qâ¶     1      qâ´+qÂ²       qâµ+q\n qÂ³     qÂ³     1      qâ¶     qâ´+qÂ²       qâµ+q\n qâµ+q   qâµ+q   qâ´+qÂ²  qâ´+qÂ²  qâ¶+qâ´+qÂ²+1  qâµ+2qÂ³+q\n qâ´+qÂ²  qâ´+qÂ²  qâµ+q   qâµ+q   qâµ+2qÂ³+q    qâ¶+qâ´+qÂ²+1\n\njulia> bb=[[2],[4],[6],[3,5],[1]];\n\njulia> (P,L)=bigcell_decomposition(M,bb);\n\njulia> P\n6Ã—6 Matrix{Pol{Int64}}:\n 1    0  0    0    0        0\n qâ»â¶  1  qâ»Â³  qâ»Â³  qâ»Â¹+qâ»âµ  qâ»Â²+qâ»â´\n 0    0  1    0    0        0\n qâ»Â³  0  0    1    qâ»Â²      qâ»Â¹\n qâ»Â¹  0  0    0    1        0\n qâ»Â²  0  qâ»Â¹  0    qâ»Â¹      1\n\njulia> L\n6Ã—6 Matrix{Pol{Int64}}:\n qâ¶-qâ´-1+qâ»Â²  0   0            0     0            0\n 0            qâ¶  0            0     0            0\n 0            0   qâ¶-qâ´-1+qâ»Â²  0     0            0\n 0            0   0            qâ¶-1  0            0\n 0            0   0            0     qâ¶-qâ´-1+qâ»Â²  0\n 0            0   0            0     0            qâ¶-1\n\njulia> M==permutedims(P)*L*P\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.GLinearAlgebra.diagblocks","page":"Gapjm Documentation","title":"Gapjm.GLinearAlgebra.diagblocks","text":"diagblocks(M::Matrix)\n\nM  should  be  a  square  matrix.  Define  a  graph  G  with vertices 1:size(M,1) and with an edge between i  and j if either M[i,j] or M[j,i] is not zero or false. diagblocks returns a vector of vectors I  such that  I[1],I[2], etc..  are the  vertices in each connected component  of G.  In other  words, M[I[1],I[1]],M[I[2],I[2]],etc... are diagonal blocks of M.\n\njulia> m=[0 0 0 1;0 0 1 0;0 1 0 0;1 0 0 0]\n4Ã—4 Matrix{Int64}:\n 0  0  0  1\n 0  0  1  0\n 0  1  0  0\n 1  0  0  0\n\njulia> diagblocks(m)\n2-element Vector{Vector{Int64}}:\n [1, 4]\n [2, 3]\n\njulia> m[[1,4],[1,4]]\n2Ã—2 Matrix{Int64}:\n 0  1\n 1  0\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.GLinearAlgebra.blocks","page":"Gapjm Documentation","title":"Gapjm.GLinearAlgebra.blocks","text":"blocks(M)\n\nFinds  if the  matrix  M admits a block decomposition.\n\nDefine  a bipartite  graph G  with vertices  axes(M,1), axes(M,2) and with an edge between i and j if M[i,j] is not zero. BlocksMat returns a  list of pairs of  lists I such that  I[i], etc.. are the vertices in the i-th connected component of G. In other words, M[I[1][1],I[1][2]], M[I[2][1],I[2][2]],etc... are blocks of M.\n\nThis  function may  also be  applied to  boolean matrices.\n\njulia> m=[1 0 0 0;0 1 0 0;1 0 1 0;0 0 0 1;0 0 1 0]\n5Ã—4 Matrix{Int64}:\n 1  0  0  0\n 0  1  0  0\n 1  0  1  0\n 0  0  0  1\n 0  0  1  0\n\njulia> blocks(m)\n3-element Vector{Tuple{Vector{Int64}, Vector{Int64}}}:\n ([1, 3, 5], [1, 3])\n ([2], [2])\n ([4], [4])\n\njulia> m[[1,3,5,2,4],[1,3,2,4]]\n5Ã—4 Matrix{Int64}:\n 1  0  0  0\n 1  1  0  0\n 0  1  0  0\n 0  0  1  0\n 0  0  0  1\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.GLinearAlgebra.ratio","page":"Gapjm Documentation","title":"Gapjm.GLinearAlgebra.ratio","text":"ratio of two vectors\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.GLinearAlgebra.exterior_power","page":"Gapjm Documentation","title":"Gapjm.GLinearAlgebra.exterior_power","text":"exterior_power(mat,n)\n\nmat  should be a square matrix.  The function returns the n-th exterior power  of  mat,  in  the  basis naturally indexed bycombinations(1:r,n) wherer=size(mat,1)\n\njulia> M=[1 2 3 4;2 3 4 1;3 4 1 2;4 1 2 3]\n4Ã—4 Matrix{Int64}:\n 1  2  3  4\n 2  3  4  1\n 3  4  1  2\n 4  1  2  3\n\njulia> exterior_power(M,2)\n6Ã—6 Matrix{Int64}:\n  -1   -2   -7   -1  -10  -13\n  -2   -8  -10  -10  -12    2\n  -7  -10  -13    1    2    1\n  -1  -10    1  -13    2    7\n -10  -12    2    2    8   10\n -13    2    1    7   10   -1\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.GLinearAlgebra.charpoly","page":"Gapjm Documentation","title":"Gapjm.GLinearAlgebra.charpoly","text":"charpoly(M)  characteristic polynomial\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.GLinearAlgebra.comatrix","page":"Gapjm Documentation","title":"Gapjm.GLinearAlgebra.comatrix","text":"the comatrix of the square matrix M is defined by comatrix(M)M=det(M)one(M)\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.GLinearAlgebra.permanent","page":"Gapjm Documentation","title":"Gapjm.GLinearAlgebra.permanent","text":"permanent(m)\n\nreturns the permanent of the square matrix m, which is defined by  sum_p in frak S_nprod_i=1^n mii^p.\n\nNote the similarity of the definition of  the permanent to the definition of the determinant.  In  fact the only  difference is the missing sign of the permutation.  However the  permanent is quite unlike the determinant, for example   it is  not  multilinear or  alternating.  It   has  however important combinatorical properties.\n\njulia> permanent([0 1 1 1;1 0 1 1;1 1 0 1;1 1 1 0])\n9 # inefficient way to compute the number of derangements of 1:4\n\njulia> permanent([1 1 0 1 0 0 0; 0 1 1 0 1 0 0;0 0 1 1 0 1 0; 0 0 0 1 1 0 1;1 0 0 0 1 1 0;0 1 0 0 0 1 1;1 0 1 0 0 0 1])\n24 # 24 permutations fit the projective plane of order 2 \n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.GLinearAlgebra.symmetric_power","page":"Gapjm Documentation","title":"Gapjm.GLinearAlgebra.symmetric_power","text":"symmetric_power(m,n)\n\nreturns the n-th symmetric power of the square matrix m, in the basis  naturally indexed by the submultisets of 1:n, where n=size(m,1).\n\njulia> m=[1 2;3 4]\n2Ã—2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> Int.(symmetric_power(m,2))\n3Ã—3 Matrix{Int64}:\n 1   2   4\n 6  10  16\n 9  12  16\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.GLinearAlgebra.schur_functor","page":"Gapjm Documentation","title":"Gapjm.GLinearAlgebra.schur_functor","text":"schur_functor(mat,l)\n\nmat  should be  a square  matrix and  l a  partition. The result is the Schur  functor  of  the  matrix  mat  corresponding to partition l; for example,   if  l==[n]  it  returns  the   n-th  symmetric  power  and  if l==[1,1,1] it returns the 3rd exterior power. The current algorithm (from Littlewood)  is rather inefficient so it is  quite slow for partitions of n where n>6.\n\njulia> m=cartan(:A,3)\n3Ã—3 Matrix{Int64}:\n  2  -1   0\n -1   2  -1\n  0  -1   2\n\njulia> schur_functor(m,[2,2])\n6Ã—6 Matrix{Rational{Int64}}:\n   9//1   -6//1    4//1   3//2   -2//1    1//1\n -12//1   16//1  -16//1  -4//1    8//1   -4//1\n   4//1   -8//1   16//1   2//1   -8//1    4//1\n  12//1  -16//1   16//1  10//1  -16//1   12//1\n  -4//1    8//1  -16//1  -4//1   16//1  -12//1\n   1//1   -2//1    4//1   3//2   -6//1    9//1\n\njulia-repl\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.GLinearAlgebra.transporter","page":"Gapjm Documentation","title":"Gapjm.GLinearAlgebra.transporter","text":"transporter(l1, l2 )\n\nl1  and l2 should be vectors of  the same length of square matrices all of the same size. The result is a basis of the vector space of matrices A such  that for any i we have  A*l1[i]=l2[i]*A â€“- the basis is returned as  a vector of matrices, empty if the vector space is 0. This is useful to find whether two representations are isomorphic.\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.GLinearAlgebra.diagconj_elt","page":"Gapjm Documentation","title":"Gapjm.GLinearAlgebra.diagconj_elt","text":"representative_diagconj(M,N)\n\nM and N must be square matrices of the same size. This function returns a  list  d  such  that  N==inv(Diagonal(d)*M*Diagonal(d) if such a list exists, and nothing otherwise.\n\njulia> M=[1 2;2 1];N=[1 4;1 1]\n2Ã—2 Matrix{Int64}:\n 1  4\n 1  1\n\njulia> diagconj_elt(M,N)\n2-element Vector{Rational{Int64}}:\n 1//1\n 2//1\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.HasType.traces_words_mats","page":"Gapjm Documentation","title":"Gapjm.HasType.traces_words_mats","text":"traces_words_mats(mats,words)\n\ngiven  a list mats  of matrices and  a list words  of words returns the list of traces of the corresponding products of the matrices\n\njulia> W=coxgroup(:F,4)\nFâ‚„\n\njulia> r=classinfo(W)[:classtext];\n\njulia> R=representation(W,17)\n4-element Vector{Matrix{Int64}}:\n [-1 -1 0 0; 0 1 0 0; 0 0 1 0; 0 0 0 1]\n [1 0 0 0; -1 -1 -1 0; 0 0 1 0; 0 0 0 1]\n [1 0 0 0; 0 1 0 0; 0 -2 -1 -1; 0 0 0 1]\n [1 0 0 0; 0 1 0 0; 0 0 1 0; 0 0 -1 -1]\n\njulia> traces_words_mats(R,r)==CharTable(W).irr[17,:]\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.GLinearAlgebra.solutionmat","page":"Gapjm Documentation","title":"Gapjm.GLinearAlgebra.solutionmat","text":"solutionmat(mat,v)\n\nreturns one solution of the equation permutedims(x)*mat=permutedims(v) or nothing if no such solution exists. Similar to permutedims(mat)\\v when mat is invertible\n\njulia> solutionmat([2 -4 1;0 0 -4;1 -2 -1],[10, -20, -10])\n3-element Vector{Rational{Int64}}:\n  5//1\n 15//4\n  0//1\njulia> solutionmat([2 -4 1;0 0 -4;1 -2 -1],[10, 20, -10])\n\n\n\n\n\nreturn matrix x such that x*m==n\n\n\n\n\n\n","category":"function"},{"location":"#Integral-matrices-and-lattices","page":"Gapjm Documentation","title":"Integral matrices and lattices","text":"","category":"section"},{"location":"","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"DiaconisGraham","category":"page"},{"location":"#Gapjm.MatInt.DiaconisGraham","page":"Gapjm Documentation","title":"Gapjm.MatInt.DiaconisGraham","text":"DiaconisGraham(m, moduli)\n\nDiaconis-Graham1999 defined a normal form for generating sets of abelian groups. Here moduli should be a list of positive integers such  that moduli[i+1] divides moduli[i]  for all i, representing the abelian group A=Z/moduli[1]Ã—â€¦Ã—Z/moduli[n]. The integral matrix m should have  n columns where n=Length(moduli), and  each line (with the i-th element  taken mod moduli[i]) represents an element of the group A, and such that the set of lines of m generates A.\n\nThe  function returns 'false' if the set  of elements of A represented by the  lines of m does not generate  A. Otherwise it returns a Dict r with fields\n\n:normal:  the Diaconis-Graham normal form, a  matrix of same shape as m where  either the first n lines are the identity matrix and the remaining lines  are 0,  or length(m)=n  and :normal  differs from the identity matrix only in the entry :normal[n][n], which is prime to moduli[n].\n\n:rowtrans: a unimodular matrix such that   r[:normal]=map(v->mod.(v,moduli),r[:rowtrans]*m)\n\nHere is an example:\n\njulia> DiaconisGraham([[3,0],[4,1]],[10,5])\nDict{Symbol, Any} with 2 entries:\n  :normal   => [[1, 0], [0, 2]]\n  :rowtrans => [[-13, 10], [4, -3]]\n\n\n\n\n\n","category":"function"},{"location":"#Finite-fields","page":"Gapjm Documentation","title":"Finite fields","text":"","category":"section"},{"location":"","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"FFields\nmod(::Cyc,::Any)","category":"page"},{"location":"#Gapjm.FFields","page":"Gapjm Documentation","title":"Gapjm.FFields","text":"This module introduces modular arithmetic and finite fields.\n\nThe ring of integers mod. n is given by the type Mod{n}.\n\nExample:\n\njulia> a=Mod{19}(5)\nMod{19}(5)\n\njulia> a^2\nMod{19}(6)\n\njulia> inv(a)\nMod{19}(4)\n\njulia> a*inv(a)\nMod{19}(1)\n\njulia> a+2\nMod{19}(7)\n\njulia> a*2\nMod{19}(10)\n\njulia> a+1//2\nMod{19}(15)\n\njulia> Int(a) # get back an integer from a\n5\n\njulia> order(a) # multiplicative order of a\n9\n\nThe finite field with p^n elements is obtained as FF(p^n). To work with elements  of this  field, the  function Z(p^n)  returns a genertor of the multiplicative group of FF(p^n) (this is a particular generator, obtained as a root of the n-th Conway polynomial of characteristic p). All other elements  of  FF(p^n)  can  be  obtained  as  a  power  of Z(p^n) or as 0*Z(p^n).\n\njulia> a=Z(64)\nZâ‚†â‚„\n\njulia> a^9\nZâ‚ˆ\n\njulia> a^21\nZâ‚„\n\njulia> a+1\nZâ‚†â‚„âµâ¶\n\nElements of the prime field can be converted back to integers Mod{p}\n\njulia> a=Z(19)+3\nZâ‚â‚‰Â¹â¶\n\njulia> Mod{19}(a)\nMod{19}(5)\n\njulia> order(a) # order as element of the multiplicative group\n9\n\nThe  field, p, n and p^n can be  obtained back as well as which power of Z(p^n) is considered\n\njulia> a=Z(8)^5\nZâ‚ˆâµ\n\njulia> F=field(a)\nFF(2^3)\n\njulia> F.p\n2\n\njulia> F.n\n3\n\njulia> F.q\n8\n\njulia> log(a)\n5\n\nThe type of an element of FF(p^n) is FFE{p}. An integer or a Mod{p} can be converted to the prime field using this type as constructor.\n\njulia> FFE{19}(2)\nZâ‚â‚‰\n\njulia> FFE{19}(Mod{19}(2))\nZâ‚â‚‰\n\n\n\n\n\n","category":"module"},{"location":"#Base.mod-Tuple{Cyc, Any}","page":"Gapjm Documentation","title":"Base.mod","text":"mod(z::Cyc,p::Integer)\n\np  should be a  prime and z  a cyclotomic number  which is p-integral (that  is, z times some number prime to p is a cyclotomic integer). The function  returns  the  reduction  of  z  mod.  p,  an  element of some extension  F_(p^r) of the prime field  F_p.\n\njulia> mod(E(7),3)\nZâ‚‡â‚‚â‚‰Â¹â°â´\n\n\n\n\n\n","category":"method"},{"location":"#Coxeter-groups","page":"Gapjm Documentation","title":"Coxeter groups","text":"","category":"section"},{"location":"","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"CoxGroups\nisleftdescent\nfirstleftdescent\nleftdescents\nreduced\nword(::CoxeterGroup,w)\nlength(::CoxeterGroup,w)\nelements(::CoxeterGroup)\nCoxGroups.words\nbruhatless\nCoxSym\nreflection_subgroup(::CoxSym,::AbstractVector{Int})\nlongest\nnref\nbraid_relations\ncoxmat\nstandard_parabolic_class\nGenCox","category":"page"},{"location":"#Gapjm.CoxGroups","page":"Gapjm Documentation","title":"Gapjm.CoxGroups","text":"A  suitable  reference  for  the  general  theory of Coxeter groups is, for example, Bourbaki \"Lie Groups and Lie Algebras\" chapter 4.\n\nA Coxeter group is a group which has the presentation W=S(st)^m(st)=1 for st  S  for some symmetric integer matrix m(s,t) called the Coxeter matrix, where m(s,t)>1 for sâ‰ t and m(s,s)=1.  It is true (but a non-trivial theorem) that in a Coxeter group the  order of st is exactly m(s,t), thus a Coxeter group is the same as a  Coxeter system, that is a pair (W,S)  of a group W and a set SâŠ‚W of  involutions, such  that the  group is  presented by  generators S and relations  describing the order  of the product  of two elements  of S. A Coxeter group has a natural representation, its reflection representation, on a real vector space V of dimension length(S) (which is  the  Coxeter  rank  of  W),  where  each  element  of  S  acts as a reflection; the faithfulness of this representation in the main argument to prove  that the order of st is  exactly m(s,t). Thus Coxeter groups are real  reflection  groups.  The  converse  need  not  be  true if the set of reflecting  hyperplanes has  bad topological  properties, but  it turns out that  finite Coxeter groups are the  same as finite real reflection groups. The   possible  Coxeter  matrices  for  finite  Coxeter  groups  have  been completely  classified,  see  the  Weyl  module; the corresponding finite groups play a deep role in several areas of mathematics.\n\nCoxeter  groups  have  a  nice  solution  to the word problem. The length l(w)  of an element  wâˆˆ W is  the minimum number  of elements of S of which it is a product (since the elements of S are involutions, we do not need inverses). An expression of w of minimal length is called a reduced word  for w. The main property of  reduced words is the exchange lemma which  states that if sâ‚â€¦sâ‚– is a  reduced word for w (thusk=l(w)) and sâˆˆ  S is such that l(sw)â‰¤l(w) then one  of the sáµ¢ in the word for w can be deleted to obtain a reduced word for sw. Thus given sâˆˆ S and wâˆˆ W,  either l(sw)=l(w)+1 or  l(sw)=l(w)-1 and we  say in this last case that  s belongs to  the left descent  set of w.  The computation of a reduced  word for an element, and other  word problems, are easy if we know how  to multiply elements  and the left  descent sets. In  each case of the Coxeter  groups that we implement, the left  descent set is easy to compute (see  e.g.  'CoxSym'  below),  so  this  suggests  how to deal with Coxeter groups generically:\n\nThe  type  CoxeterGroup  is  an  abstract  type;  an  actual struct which implements it must define a function\n\nisleftdescent(W,w,i) which tells whether the       i-th element of S is in the left descending set of w.\n\nthe other functions needed in an instance of a Coxeter group are\n\ngens(W) which returns the set S (the list of Coxeter generators)\nnref(W) which  returns the  number of  reflections of  W, if  W is  finite or nothing if W is infinite\n\nIt  should  be  noted  that  a  Coxeter  group  can  be any kind of group implementing the above functions.\n\nBecause  of the  easy solution  of the  word problem  in Coxeter  groups, a convenient  way  to  represent  their  elements  is as words in the Coxeter generators. They are represented as lists of integers in 1:length(S). The functions  'word' and 'W(...)' will do the conversion between Coxeter words and elements of the group.\n\nExamples\n\njulia> W=CoxSym(4)\nð”– â‚„\n\njulia> p=W(1,3,2,1,3)\nPerm{UInt8}: (1,4)\n\njulia> word(W,p)\n5-element Vector{Int64}:\n 1\n 2\n 3\n 2\n 1\n\nWe  notice that the word we started with and the one that we ended up with, are not the same, though they represent the same element of W. The reason is  there are  several reduced  words for  an element  of W. The function 'word'  computes a lexicographically smallest word  for w. Below are some other possible computations with the same Coxeter group:\n\njulia> word(W,longest(W))  # the (unique) longest element in W\n6-element Vector{Int64}:\n 1\n 2\n 1\n 3\n 2\n 1\n\njulia> w0=longest(W)\nPerm{UInt8}: (1,4)(2,3)\njulia> length(W,w0)\n6\njulia> map(i->word(W,reflection(W,i)),1:nref(W))\n6-element Vector{Vector{Int64}}:\n [1]\n [2]\n [3]\n [1, 2, 1]\n [2, 3, 2]\n [1, 2, 3, 2, 1]\njulia> [length(elements(W,i)) for i in 0:nref(W)]\n7-element Vector{Int64}:\n 1\n 3\n 5\n 6\n 5\n 3\n 1\n\nThe above line tells us that there is 1 element of length 0, there are 6 of length 3, â€¦\n\nFor  most basic functions the convention is that the input is an element of the  group, rather than  a Coxeter word.  The reason is  that for a Coxeter group  which  is  a  permutation  group,  using the low level functions for permutations  is usually  much faster  than manipulating lists representing reduced expressions.\n\nThis module contains mostly a port of the basic functions on Coxeter groups in  Chevie. The only Coxeter group  constructor implemented here is CoxSym. The  module Weyl defines coxgroup, a function building a finite Coxeter groups given its type.\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.CoxGroups.isleftdescent","page":"Gapjm Documentation","title":"Gapjm.CoxGroups.isleftdescent","text":"isleftdescent(W,w,i)\n\nreturns  true  if  and  only  if  the i-th generating reflection of the Coxeter  group W is  in the left  descent set of  the element w of W, that is iff length(W,W(i)*w)<length(W,w).\n\njulia> W=CoxSym(3)\nð”– â‚ƒ\n\njulia> isleftdescent(W,Perm(1,2),1)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.CoxGroups.firstleftdescent","page":"Gapjm Documentation","title":"Gapjm.CoxGroups.firstleftdescent","text":"firstleftdescent(W,w)\n\nreturns the index in gens(W) of the first element of the left descent set of w â€“- that is, the first i such that if s=W(i) then `l(sw)<l(w).\n\njulia> W=CoxSym(3)\nð”– â‚ƒ\n\njulia> firstleftdescent(W,Perm(2,3))\n2\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.CoxGroups.leftdescents","page":"Gapjm Documentation","title":"Gapjm.CoxGroups.leftdescents","text":"leftdescents(W,w)\n\nThe  left descents of the element w of the Coxeter group W, that is the set of i such that length(W,W(i)*w)<length(W,w).\n\njulia> W=CoxSym(3)\nð”– â‚ƒ\n\njulia> leftdescents(W,Perm(1,3))\n2-element Vector{Int64}:\n 1\n 2\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.PermGroups.reduced","page":"Gapjm Documentation","title":"Gapjm.PermGroups.reduced","text":"reduced(W,w)\n\nThe unique element of minimal length in the coset W.w\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> H=reflection_subgroup(W,[2,6])\nGâ‚‚â‚â‚‚â‚†â‚Ž=AÌƒâ‚Ã—Aâ‚\n\njulia> word.(Ref(W),unique(reduced.(Ref(H),elements(W))))\n3-element Vector{Vector{Int64}}:\n []\n [1]\n [1, 2]\n\n\n\n\n\nreduced(H,W,i=nref(W))\n\nThe  elements wâˆˆ W which are H-reduced  (of minimal length in the coset Hw), and of length â‰¤i (by default all of them), grouped by length.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> H=reflection_subgroup(W,[2,6])\nGâ‚‚â‚â‚‚â‚†â‚Ž=AÌƒâ‚Ã—Aâ‚\n\njulia> [word(W,w) for S in reduced(H,W) for w in S]\n3-element Vector{Vector{Int64}}:\n []\n [1]\n [1, 2]\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Groups.word-Tuple{CoxeterGroup, Any}","page":"Gapjm Documentation","title":"Gapjm.Groups.word","text":"word(W::CoxeterGroup,w)\n\nreturns  a reduced word in the standard generators of the Coxeter group W for  the  element  w  (represented  as  the  vector  of the corresponding generator indices).\n\njulia> W=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> w=perm\"(1,11)(3,10)(4,9)(5,7)(6,12)\"\n(1,11)(3,10)(4,9)(5,7)(6,12)\n\njulia> w in W\ntrue\n\njulia> word(W,w)\n5-element Vector{Int64}:\n 1\n 2\n 3\n 2\n 1\n\nThe  result  of  Â word  is  the  lexicographically  smallest reduced word for~w (for the ordering of the Coxeter generators given by gens(W)).\n\n\n\n\n\n","category":"method"},{"location":"#Base.length-Tuple{CoxeterGroup, Any}","page":"Gapjm Documentation","title":"Base.length","text":"length(W::CoxeterGroup ,w)\n\nreturns the length of a reduced expression in the Coxeter generators of the element w of W.\n\njulia> W=CoxSym(4)\nð”– â‚„\n\njulia> p=W(1,2,3,1,2,3)\nPerm{UInt8}: (1,3)(2,4)\n\njulia> length(W,p)\n4\n\njulia> word(W,p)\n4-element Vector{Int64}:\n 2\n 1\n 3\n 2\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.Groups.elements-Tuple{CoxeterGroup}","page":"Gapjm Documentation","title":"Gapjm.Groups.elements","text":"elements(G::Group): the list of elements of G\n\n\n\n\n\nelements(W::CoxeterGroup[,l])\n\nWith  one argument this works only if  W is finite; the returned elements are  sorted  by  increasing  Coxeter  length.  If the second argument is an integer  l, the elements  of Coxeter length  l are returned.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> e=elements(W,6)\n1-element Vector{Perm{Int16}}:\n (1,7)(2,8)(3,9)(4,10)(5,11)(6,12)\n\njulia> e[1]==longest(W)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.words","page":"Gapjm Documentation","title":"Gapjm.words","text":"words(W::CoxeterGroup[,l])\n\nWith  one argument this works only if W is finite; it returns the reduced Coxeter  words  of  elements  of  W  by  increasing length. If the second argument  is an integer l, only the  elements of length l are returned; this works for infinite Coxeter groups.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> e=elements(W,6)\n1-element Vector{Perm{Int16}}:\n (1,7)(2,8)(3,9)(4,10)(5,11)(6,12)\n\njulia> e[1]==longest(W)\ntrue\n\n\n\n\n\nwords(W,w)\n\nreturns  the list  of all  reduced expressions  of the  element w  of the Coxeter group W.\n\njulia> W=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> words(W,longest(W))\n16-element Vector{Vector{Int64}}:\n [1, 2, 1, 3, 2, 1]\n [1, 2, 3, 1, 2, 1]\n [1, 2, 3, 2, 1, 2]\n [1, 3, 2, 1, 3, 2]\n [1, 3, 2, 3, 1, 2]\n [2, 1, 2, 3, 2, 1]\n [2, 1, 3, 2, 1, 3]\n [2, 1, 3, 2, 3, 1]\n [2, 3, 1, 2, 1, 3]\n [2, 3, 1, 2, 3, 1]\n [2, 3, 2, 1, 2, 3]\n [3, 1, 2, 1, 3, 2]\n [3, 1, 2, 3, 1, 2]\n [3, 2, 1, 2, 3, 2]\n [3, 2, 1, 3, 2, 3]\n [3, 2, 3, 1, 2, 3]\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.CoxGroups.bruhatless","page":"Gapjm Documentation","title":"Gapjm.CoxGroups.bruhatless","text":"bruhatless(W, x, y)\n\nwhether xâ‰¤y in the Bruhat order, for x,yâˆˆ W. We have xâ‰¤y if a reduced expression  for x  can be  extracted from  one for  w). See  (5.9) and (5.10) Humphreys1990 for properties of the Bruhat order.\n\njulia> W=coxgroup(:H,3)\nHâ‚ƒ\n\njulia> w=W(1,2,1,3);\n\njulia> b=filter(x->bruhatless(W,x,w),elements(W));\n\njulia> word.(Ref(W),b)\n12-element Vector{Vector{Int64}}:\n []\n [3]\n [2]\n [1]\n [2, 3]\n [1, 3]\n [2, 1]\n [1, 2]\n [2, 1, 3]\n [1, 2, 3]\n [1, 2, 1]\n [1, 2, 1, 3]\n\n\n\n\n\nbruhatless(W, y)\n\nreturns  a vector  whose i-th  element is  the vector  of elements of W smaller for the Bruhat order than w and of Coxeter length i-1. Thus the first  element  of  the  returned  list  contains  only  one(W)  and  the length(W,w)-th element contains only w.\n\njulia> W=CoxSym(3)\nð”– â‚ƒ\n\njulia> bruhatless(W,Perm(1,3))\n4-element Vector{Vector{Perm{Int16}}}:\n [()]\n [(1,2), (2,3)]\n [(1,2,3), (1,3,2)]\n [(1,3)]\n\nsee also the method Poset for Coxeter groups.\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.CoxGroups.CoxSym","page":"Gapjm Documentation","title":"Gapjm.CoxGroups.CoxSym","text":"Coxsym(n) The symmetric group on n letters as a Coxeter group\n\njulia> W=CoxSym(3)\nð”– â‚ƒ\n\njulia> e=elements(W)\n6-element Vector{Perm{UInt8}}:\n ()     \n (2,3)  \n (1,2)  \n (1,2,3)\n (1,3,2)\n (1,3)  \n\njulia> length.(Ref(W),e)\n6-element Vector{Int64}:\n 0\n 1\n 1\n 2\n 2\n 3\n\n\n\n\n\n","category":"type"},{"location":"#Gapjm.PermRoot.reflection_subgroup-Tuple{CoxSym, AbstractVector{Int64}}","page":"Gapjm Documentation","title":"Gapjm.PermRoot.reflection_subgroup","text":"reflection_subgroup(W::CoxSym,I)\n\nOnly parabolics defined are I=1:m for mâ‰¤n\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.CoxGroups.longest","page":"Gapjm Documentation","title":"Gapjm.CoxGroups.longest","text":"longest(W)\n\nIf  W is  finite, returns  the unique  element of  maximal length  of the Coxeter group W. May loop infinitely otherwise.\n\njulia> longest(CoxSym(4))\nPerm{UInt8}: (1,4)(2,3)\n\nlongest(W,I)\n\nreturns  the longest element of the  parabolic subgroup of W generated by the generating reflections of indices in I.\n\njulia> longest(CoxSym(4))\nPerm{UInt8}: (1,4)(2,3)\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.CoxGroups.nref","page":"Gapjm Documentation","title":"Gapjm.CoxGroups.nref","text":"number of reflections of W\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.CoxGroups.braid_relations","page":"Gapjm Documentation","title":"Gapjm.CoxGroups.braid_relations","text":"braid_relations(W)\n\nthis  function returns the  relations which present  the braid group of the reflection group W. These are homogeneous (both sides of the same length) relations  between generators in bijection  with the generating reflections of  W. A presentation  of W is  obtained by adding relations specifying the order of the generators.\n\njulia> W=ComplexReflectionGroup(29)\nGâ‚‚â‚‰\n\njulia> braid_relations(W)\n7-element Vector{Vector{Vector{Int64}}}:\n [[1, 2, 1], [2, 1, 2]]\n [[2, 4, 2], [4, 2, 4]]\n [[3, 4, 3], [4, 3, 4]]\n [[2, 3, 2, 3], [3, 2, 3, 2]]\n [[1, 3], [3, 1]]\n [[1, 4], [4, 1]]\n [[4, 3, 2, 4, 3, 2], [3, 2, 4, 3, 2, 4]]\n\neach  relation  is  represented  as  a  pair  of lists, specifying that the product  of the  generators according  to the  indices on  the left side is equal  to the product according to the  indices on the right side. See also Diagram.\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.CoxGroups.coxmat","page":"Gapjm Documentation","title":"Gapjm.CoxGroups.coxmat","text":"coxmat(m::AbstractMatrix)\n\nreturns  the  Coxeter  matrix  of  the  Coxeter group defined by the cartan matrix m\n\njulia> C=cartan(:H,3)\n3Ã—3 Matrix{Cyc{Int64}}:\n       2  Î¶â‚…Â²+Î¶â‚…Â³   0\n Î¶â‚…Â²+Î¶â‚…Â³        2  -1\n       0       -1   2\n\njulia> coxmat(C)\n3Ã—3 Matrix{Int64}:\n 1  5  2\n 5  1  3\n 2  3  1\n\n\n\n\n\ncoxmat(W)\n\nreturns the Coxeter matrix of the Coxeter group W, that is the matrix m whose  entry m[i,j] contains the order of W(i)*W(j) where W(i) is the i-th  Coxeter generator of  W. An infinite  order is represented by the entry 0.\n\njulia> W=CoxSym(4)\nð”– â‚„\n\njulia> coxmat(W)\n3Ã—3 Matrix{Int64}:\n 1  3  2\n 3  1  3\n 2  3  1\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.CoxGroups.standard_parabolic_class","page":"Gapjm Documentation","title":"Gapjm.CoxGroups.standard_parabolic_class","text":"standard_parabolic_class(W,I)\n\nI  should be a  subset of eachindex(gens(W)).  The function returns the list of such subsets conjugate to the given subset.\n\njulia> CoxGroups.standard_parabolic_class(coxgroup(:E,8),[7,8])\n7-element Vector{Vector{Int64}}:\n [7, 8]\n [6, 7]\n [5, 6]\n [4, 5]\n [2, 4]\n [3, 4]\n [1, 3]\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.CoxGroups.GenCox","page":"Gapjm Documentation","title":"Gapjm.CoxGroups.GenCox","text":"GenCox(m)\n\nm  should be a square  matrix of real cyclotomic  numbers. It returns the Coxeter  group  whose  Cartan  matrix  is  m.  This  is  a  matrix  group constructed  as  follows.  Let  V  be  a  real  vector space of dimension size(m,1),  and  let  âŸ¨,âŸ©  be  the  bilinear  form defined by âŸ¨eáµ¢,eâ±¼âŸ©= m[i,j]  where eáµ¢ is the  canonical basis of V.  Then the result is the matrix group generated by the reflections sáµ¢(x)=x-2âŸ¨x,eáµ¢âŸ©eáµ¢.\n\njulia> W=GenCox([2 -2;-2 2])\nGenCox([2 -2; -2 2])\n\nAbove is a way to construct the affine Weyl group  ÌƒAâ‚.\n\n\n\n\n\n","category":"type"},{"location":"#Finite-Coxeter-groups-and-Weyl-groups","page":"Gapjm Documentation","title":"Finite Coxeter groups and Weyl groups","text":"","category":"section"},{"location":"","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"Weyl\ncartan\ntwo_tree\nroots\nreflection_subgroup\ncoxgroup\nrootdatum\ndescribe_involution\nbadprimes\nWeyl.standard_parabolic\ninversions\nwith_inversions\ntorus\nSubTorus\nrelative_group","category":"page"},{"location":"#Gapjm.Weyl","page":"Gapjm Documentation","title":"Gapjm.Weyl","text":"Let  V be a  real vector space.  Finite Coxeter groups  coincide with the finite  reflection subgroups of GL(V), that is finite subgroups which can be  generated by reflections.  Weyl groups are  the finite Coxeter groups which can be defined over the rational numbers. We implement finite Coxeter groups  as groups of  permutations of a  root system. Root  systems play an important role in mathematics as they classify semi-simple Lie algebras and algebraic groups.\n\nLet  us give precise definitions. Let V  be a real vector space, Vâ±½ its dual  and let (,)  be the natural  pairing between Vâ±½  and V. A root system  is a finite set  of vectors RâŠ‚ V  (the roots), together with a map râ†¦ râ±½ from R to a subset Râ±½ of Vâ±½ (the coroots) such that:\n\nFor any râˆˆ R,  we have (râ±½,r)=2, so  that the formula xâ†¦ x-(râ±½,x)r defines  a  reflection  sáµ£:Vâ†’  V  with  root  r  and coroot râ±½. \nThe reflection sáµ£ stabilizes R.\n\nWe  will only  consider reduced  root systems,  i.e., such  that the only elements  of R colinear with râˆˆ R are r and -r; for Weyl groups, we also ask that the root system be crystallographic, that is (râ±½,s) is an integer, for any sâˆˆ R,râ±½âˆˆ Râ±½.\n\nThe  subgroup W=W(R)  of GL(V)  generated by  the reflections sáµ£ is a finite  Coxeter group; when R is crystallographic, the representation V of  W  is  defined  over  the  rational  numbers.  All finite-dimensional (complex) representations of a finite reflection group can be realized over the  same field as V. Weyl groups can also be characterized as the finite Coxeter  groups such that all entries m(s,t) of the Coxeter matrix are in {2,3,4,6}.\n\nIf  we identify  V with  Vâ±½ by  choosing a  W-invariant bilinear form (.;.),  then we have râ±½=2r/(r;r). A root system R is irreducible if it is not the union of two orthogonal subsets. If R is reducible then the corresponding  Coxeter group  is the  direct product  of the Coxeter groups associated with the irreducible components of R.\n\nThe  irreducible  crystallographic  root  systems  are  classified  by  the following  list of  Dynkin diagrams,  which, in  addition to  the Coxeter matrix,  encode also the relative length of the roots. We show the labeling of the nodes given by the function 'Diagram' described below.\n\nA_n Oâ€”Oâ€”Oâ€”â€¦â€”O   B_n Oâ‡Oâ€”Oâ€”â€¦â€”O  C_n Oâ‡’Oâ€”Oâ€”â€¦â€”O  D_n  O 2\n    1 2 3 â€¦ n       1 2 3 â€¦ n      1 2 3 â€¦ n       ï¿¨\n                                                 Oâ€”Oâ€”â€¦â€”O\n                                                 1 3 â€¦ n\n\nGâ‚‚ Oâ‡›O  Fâ‚„ Oâ€”Oâ‡’Oâ€”O    Eâ‚†   O 2   Eâ‚‡   O 2     Eâ‚ˆ    O 2\n   1  2     1 2  3 4       ï¿¨          ï¿¨             ï¿¨\n                       Oâ€”Oâ€”Oâ€”Oâ€”O  Oâ€”Oâ€”Oâ€”Oâ€”Oâ€”O   Oâ€”Oâ€”Oâ€”Oâ€”Oâ€”Oâ€”O\n                       1 3 4 5 6  1 3 4 5 6 7   1 3 4 5 6 7 8\n\nThese diagrams encode the presentation of the Coxeter group W as follows: the vertices represent the generating reflections; an edge is drawn between s  and t if the order m(s,t) of st is greater than 2; the edge is single  if  m(s,t)=3,  double  if  m(s,t)=4,  triple if m(s,t)=6. The arrows  indicate the relative root lengths when W has more than one orbit on  R, as explained below; we  get the Coxeter Diagram, which describes the  underlying Weyl group, if  we ignore the arrows:  we see that the root systems B_n and C_n correspond to the same Coxeter group.\n\nHere  are the Coxeter diagrams for the  finite Coxeter groups which are not crystallographic:\n\n       e        5         5\nIâ‚‚(e) Oâ€”O   Hâ‚ƒ Oâ€”Oâ€”O  Hâ‚„ Oâ€”Oâ€”Oâ€”O\n      1 2      1 2 3     1 2 3 4\n\nLet  us  now  describe  how  the  root  systems  are  encoded in the Dynkin diagrams. Let R be a root system in V. Then we can choose a linear form on  V which vanishes on  no element of R.  According to the sign of the value  of this  linear form  on a  root r  âˆˆ R  we call r positive or negative.  Then there exists  a unique subset  Î  of the positive roots, the  simple roots,  such that  any positive  root is a linear combination with  non-negative coefficients  of roots  in Î .  Any two  sets of simple roots  (corresponding to different choices of linear forms as above) can be transformed into each other by a unique element of W(R). Hence, since the pairing  between V and Vâ±½  is W-invariant, if Î   is a set of simple roots  and if  we define  the Cartan  matrix as  being the  n times n matrix  C={râ±½(s)}áµ£â‚›, for r,sâˆˆÎ  this matrix is unique up to simultaneous permutation  of  rows  and  columns.  It  is precisely this matrix which is encoded in a Dynkin diagram, as follows.\n\nThe  indices for the rows of C label the nodes of the diagram. The edges, for  r â‰  s,  are given as  follows. If Cáµ£â‚›  and Câ‚›áµ£ are integers such that  |Cáµ£â‚›|â‰¥|Câ‚›áµ£|=1 the vertices  are connected by  |Cáµ£â‚›| lines, and if |Cáµ£â‚›|>1 then we put an additional arrow on the lines pointing towards the node  with label s. In other cases,  we simply put a single line equipped with the unique integer páµ£â‚›â‰¥1 such that Cáµ£â‚›Câ‚›áµ£=cos^2 (Ï€/pâ‚›áµ£).\n\nConversely,  the whole root  system can be  recovered from the simple roots and  the corresponding coroots. The  reflections in W(R) corresponding to the  simple roots are called  simple reflections or Coxeter generators. They are precisely the generators for which the Coxeter diagram encodes the defining  relations of W(R). Each root is  in the orbit of a simple root, so  that R is obtained  as the orbit of  the simple roots under the group generated  by  the  simple  reflections.  The  restriction  of  the  simple reflections  to the span of R is  determined by the Cartan matrix, so R is determined by the Cartan matrix and the set of simple roots.\n\nThe  Cartan  matrix  corresponding  to  one  of  the above irreducible root systems  (with the specified labeling) is  returned by the command 'cartan' which  takes as input  a Symbol giving  the type (that  is ':A', ':B', â€¦, ':I')  and a positive Int giving the  rank (plus an Int giving the bond for  type :I).  This function  returns a  matrix with  entries in â„¤ for crystallographic  types, and a  matrix of Cyc  for the other types. Given two  Cartan matrices c1 and c2,  their matrix direct sum (corresponding to  the  orthogonal  direct  sum  of  the  root systems) can be produced by cat(c1,c2,dims=[1,2]).\n\nThe  function 'rootdatum' takes as input a  list of simple roots and a list of the corresponding coroots and produces a struct containing information about  the root system R and about W(R). If we label the positive roots by  '1:N', and the negative roots  by 'N+1:2N', then each simple reflection is  represented by the permutation of '1:2N' which it induces on the roots. If  only one argument is given, the Cartan matrix of the root system, it is taken  as the list  of coroots and  the list of  roots is assumed to be the canonical basis of V.\n\nIf one only wants to work with Cartan matrices with a labeling as specified by  the  above  list,  the  function  call  can  be  simplified. Instead of 'rootdatum(cartan(:D,4))' the following is also possible.\n\njulia> W=coxgroup(:D,4)\nDâ‚„\n\njulia> cartan(W)\n4Ã—4 Matrix{Int64}:\n  2   0  -1   0\n  0   2  -1   0\n -1  -1   2  -1\n  0   0  -1   2\n\nAlso,  the Weyl group struct associated to a direct sum of irreducible root systems can be obtained as a product\n\njulia> W=coxgroup(:A,2)*coxgroup(:B,2)\nAâ‚‚Ã—Bâ‚‚\n\njulia> cartan(W)\n4Ã—4 Matrix{Int64}:\n  2  -1   0   0\n -1   2   0   0\n  0   0   2  -2\n  0   0  -1   2\n\nThe  same struct  is constructed  by applying  'coxgroup' to  the matrix 'cat(cartan(:A,2), cartan(:B,2),dims=[1,2])'.\n\nThe elements of a Weyl group are permutations of the roots:\n\njulia> W=coxgroup(:D,4)\nDâ‚„\n\njulia> p=W(1,3,2,1,3)\n(1,14,13,2)(3,17,8,18)(4,12)(5,20,6,15)(7,10,11,9)(16,24)(19,22,23,21)\n\njulia> word(W,p)\n5-element Vector{Int64}:\n 1\n 3\n 1\n 2\n 3\n\n\nfinally, a benchmark on julia 1.0.2\n\njulia> @btime length(elements(coxgroup(:E,7)))\n  531.385 ms (5945569 allocations: 1.08 GiB)\n\nGAP3 for the same computation takes 2.2s\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.PermRoot.cartan","page":"Gapjm Documentation","title":"Gapjm.PermRoot.cartan","text":"cartan(W::PermRootGroup,i,j) the cartan coefficient cáµ¢(râ±¼) of the i-th coroot and the j-th root of W\n\n\n\n\n\ncartan(W::PermRootGroup)    Cartan matrix of W.\n\nLet  sâ‚,â€¦,sâ‚™ be reflections with associated  roots ráµ¢ and coroots cáµ¢. The  matrix C with  entries Cáµ¢,â±¼=cáµ¢(râ±¼) is  called a Cartan matrix of sâ‚,â€¦,sâ‚™.  It is uniquely  determined by sâ‚,â€¦,sâ‚™  up to conjugation by a diagonal matrix.\n\nIf sâ‚,â€¦,sâ‚™ generate a reflection group W, then C up to conjugation by a  diagonal matrix is an invariant of the reflection representation of W. If invertible C determines this representation since then the ráµ¢ form a basis  in which the matrix  for sáµ¢ differs from  the identity only on the i-th line, where the corresponding line of C has been subtracted.\n\njulia> W=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> cartan(W)\n3Ã—3 Matrix{Int64}:\n  2  -1   0\n -1   2  -1\n  0  -1   2\n\n\n\n\n\ncartan(M::AbstractMatrix) Cartan matrix from Coxeter matrix\n\nThe  argument should be the Coxeter matrix  M for a Coxeter group W and the   result  is  the  Cartan  Matrix   C  for  the  standard  reflection representation  of W. We have C[s,t]=-2cos(Ï€/M[s,t]), where M[s,s]==1 and  by  convention  Ï€/M[s,t]==0  if  M[s,t]==âˆž,  which we represent by 'M[s,t]==0'.  Since  M  is  symmetric,  the  resulting  C is symmetric, meaning  that all roots  in the constructed  reflection representation have same length.\n\njulia> cartan([1 3;3 1])\n2Ã—2 Matrix{Cyc{Int64}}:\n  2  -1\n -1   2\n\n\n\n\n\ncartan(type, rank [,bond])\n\nreturn  the Cartan matrix for a finite  Coxeter group described by type and rank.  The recognized types are :A, :B,  :Bsym, :C, :D, :E, :F, :Fsym, :G, :Gsym, :I, :H. For type :I a third argument must be given describing the bond between the two generators. The sym types correspond to root systems where all roots have the same length.\n\njulia> cartan(:F,4)\n4Ã—4 Matrix{Int64}:\n  2  -1   0   0\n -1   2  -1   0\n  0  -2   2  -1\n  0   0  -1   2\n\njulia> cartan(:I,2,5)\n2Ã—2 Matrix{Cyc{Int64}}:\n       2  Î¶â‚…Â²+Î¶â‚…Â³\n Î¶â‚…Â²+Î¶â‚…Â³        2\n\njulia> cartan(:Bsym,2)\n2Ã—2 Matrix{Cyc{Int64}}:\n   2  -âˆš2\n -âˆš2    2\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Weyl.two_tree","page":"Gapjm Documentation","title":"Gapjm.Weyl.two_tree","text":"two_tree(m)\n\nGiven  a square matrix  m with zeroes  (or falses, for  a boolean matrix) symmetric  with respect to the diagonal, let G be the graph with vertices axes(m)[1]  and an edge between i and j iff !iszero(m[i,j]). \n\nIf  G is a line this function returns  it as a Vector{Int}. If G is a tree with one vertex c of valence 3 the function returns (c,b1,b2,b3) where  b1,b2,b3 are  the branches  from this  vertex sorted by increasing length. Otherwise the function returns nothing\n\njulia> Weyl.two_tree(cartan(:A,4))\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\njulia> Weyl.two_tree(cartan(:E,8))\n(4, [2], [3, 1], [5, 6, 7, 8])\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.roots","page":"Gapjm Documentation","title":"Gapjm.roots","text":"roots(C)\n\nreturn the set of positive roots defined by the Cartan matrix C  works for any finite Coxeter group\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.PermRoot.reflection_subgroup","page":"Gapjm Documentation","title":"Gapjm.PermRoot.reflection_subgroup","text":"Only parabolics defined are I=1:m for mâ‰¤n\n\n\n\n\n\nreflection_subgroup(W,I)\n\nThe subgroup of W generated by reflections(W)[I]\n\nA  theorem discovered independently  by Deodhar1989 and Dyer1990  is that  a subgroup  H of  a Coxeter system (W,S)  generated by reflections  has a canonical  Coxeter generating set, formed  of  the  t  âˆˆ  Ref(H)  such  l(tt')>l(t)  for  any t'âˆˆ Ref(H) different  from t. This is used by reflection_subgroup to determine the Coxeter system of H.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> Diagram(W)\nOâ‡› O\n1  2\n\njulia> H=reflection_subgroup(W,[2,6])\nGâ‚‚â‚â‚‚â‚†â‚Ž=AÌƒâ‚Ã—Aâ‚\n\njulia> Diagram(H)\nO\n1\nO\n2\n\nThe  notation Gâ‚‚â‚â‚‚â‚†â‚Ž means  that W.G.roots[2:6] form  a system of simple roots for H.\n\nA  reflection subgroup has specific properties  the most important of which is  inclusion which gives the positions of  the roots of H in the roots of W. The inverse (partial) map is restriction.\n\njulia> inclusion(H)\n4-element Vector{Int64}:\n  2\n  6\n  8\n 12\n\njulia> restriction(H)\n12-element Vector{Int64}:\n 0\n 1\n 0\n 0\n 0\n 2\n 0\n 3\n 0\n 0\n 0\n 4\n\nIf  H is a  standard parabolic subgroup  of a Coxeter  group W then the length  function on  H (with  respect to  its set  of generators)  is the restriction  of the length function on W. This need not no longer be true for arbitrary reflection subgroups of W:\n\njulia> word(W,H(2))\n5-element Vector{Int64}:\n 1\n 2\n 1\n 2\n 1\n\nIn  this package, finite  reflection groups are  represented as permutation groups  on a set of roots. Consequently,  a reflection subgroup HâŠ† W is a permutation  subgroup, thus its elements are represented as permutations of the roots of the parent group.\n\njulia> elH=word.(Ref(H),elements(H))\n4-element Vector{Vector{Int64}}:\n []\n [2]\n [1]\n [1, 2]\n\njulia> elW=word.(Ref(W),elements(H))\n4-element Vector{Vector{Int64}}:\n []\n [1, 2, 1, 2, 1]\n [2]\n [1, 2, 1, 2, 1, 2]\n\njulia> map(w->H(w...),elH)==map(w->W(w...),elW)\ntrue\n\n\nAnother  basic result about reflection subgroups  of Coxeter groups is that each  coset of H in W contains  a unique element of minimal length, see reduced.\n\n\n\n\n\nreflection_subgroup(W::CoxSym,I)\n\nOnly parabolics defined are I=1:m for mâ‰¤n\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Weyl.coxgroup","page":"Gapjm Documentation","title":"Gapjm.Weyl.coxgroup","text":"coxgroup(type,rank[,bond])\n\nThis is equivalent to 'rootdatum(cartan(type,rank[,bond]))`.\n\nThe  resulting object, that we will  call a Coxeter datum, has additional entries and functions describing various information on the root system and Coxeter group that we describe below.\n\nnref(W):   the number of positive roots\nW.rootdec: the root vectors, given  as linear combinations of simple roots. The first nref(W) roots are positive, the next nref(W) are the corresponding  negative  roots.  Moreover,  the first semisimplerank(W) roots  are the simple roots. The positive roots are ordered by increasing height.\ncoroots(W): the same information for  the simple coroots. The coroot corresponding  to a given root has same index in the list of coroots as the root in the list of roots.\nrootlengths(W): the vector  of the (squared)  length of the roots. The  shortest roots in an irreducible subsystem are given the length 1. The  others then have  length 2 (or  3 in type Gâ‚‚). The matrix of the W-invariant bilinear form is given by map(i->rootlengths(W)[i]*W.cartan[i,:],1:semisimplerank(W)).\nsimple_reps(W,i): this  gives the  smallest index  of a root in the same W-orbit as the i-th root.\nsimple_conjugating(W,i): returns  an element  w of  W of minimal length such that `i==simple_reps(W,i)^w'.\nreflrep(W):  the  reflection  representation  of  W, that is the matrices  (in row convention â€“- the matrices operate from the right) of the simple reflections generating W.\ngens(W): the generators, as permutations of the root vectors. They are in the same order as the simple roots.\n\njulia> W=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> cartan(W)\n3Ã—3 Matrix{Int64}:\n  2  -1   0\n -1   2  -1\n  0  -1   2\n\njulia> W.rootdec\n12-element Vector{Vector{Int64}}:\n [1, 0, 0]\n [0, 1, 0]\n [0, 0, 1]\n [1, 1, 0]\n [0, 1, 1]\n [1, 1, 1]\n [-1, 0, 0]\n [0, -1, 0]\n [0, 0, -1]\n [-1, -1, 0]\n [0, -1, -1]\n [-1, -1, -1]\n\n julia> reflrep(W)\n3-element Vector{Matrix{Int64}}:\n [-1 0 0; 1 1 0; 0 0 1]\n [1 1 0; 0 -1 0; 0 1 1]\n [1 0 0; 0 1 1; 0 0 -1]\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Weyl.rootdatum","page":"Gapjm Documentation","title":"Gapjm.Weyl.rootdatum","text":"Adjoint root datum from cartan mat\n\n\n\n\n\nroot datum from 2 matrices: roots on basis of X(T), coroots on basis of Y(T)\n\n\n\n\n\nroot datum from type \n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Weyl.describe_involution","page":"Gapjm Documentation","title":"Gapjm.Weyl.describe_involution","text":"describe_involution(W,w)\n\nGiven  an  involution  w  of  a  Coxeter  group  W,  by  a  theorem  of Richardson1982  there is  a unique  parabolic subgroup P of W such that that w is the longest element of P, and is central in P. The function returns I such that P=reflection_subgroup(W,I), so that w=longest(reflection_subgroup(W,I)).\n\njulia> W=coxgroup(:A,2)\nAâ‚‚\n\njulia> w=longest(W)\n(1,5)(2,4)(3,6)\n\njulia> describe_involution(W,w)\n1-element Vector{Int64}:\n 3\n\njulia> w==longest(reflection_subgroup(W,[3]))\ntrue\n\nFor now does not work for abscox groups.\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Weyl.badprimes","page":"Gapjm Documentation","title":"Gapjm.Weyl.badprimes","text":"badprimes(W)\n\nLet  W  be  a  Weyl  group.  A  prime  is  bad  for W if it divides a coefficient  of some  root on  the simple  roots. The  function badprimes returns the list of primes which are bad for W.\n\njulia> W=coxgroup(:E,8)\nEâ‚ˆ\n\njulia> badprimes(W)\n3-element Vector{Int64}:\n 5\n 2\n 3\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Weyl.standard_parabolic","page":"Gapjm Documentation","title":"Gapjm.Weyl.standard_parabolic","text":"standard_parabolic(W,H)\n\nGiven  a reflection subgroup H or the indices of its simple roots returns nothing if H is not parabolic, otherwise returns w such that H^w is a standard parabolic subgroup of W.\n\njulia> W=coxgroup(:E,6)\nEâ‚†\n\njulia> R=reflection_subgroup(W,[20,30,19,22])\nEâ‚†â‚â‚â‚‰â€šâ‚â€šâ‚‰â€šâ‚‚â‚€â‚Ž=Aâ‚„â‚â‚ƒâ‚â‚‚â‚„â‚ŽÎ¦â‚Â²\n\njulia> p=standard_parabolic(W,R)\n(1,4,49,12,10)(2,54,62,3,19)(5,17,43,60,9)(6,21,34,36,20)(7,24,45,41,53)(8,65,50,15,22)(11,32,31,27,28)(13,48,46,37,40)(14,51,58,44,29)(16,23,35,33,30)(18,26,39,55,38)(42,57,70,72,56)(47,68,67,63,64)(52,59,71,69,66)\n\njulia> reflection_subgroup(W,[20,30,19,22].^p)\nEâ‚†â‚â‚‚â‚„â‚…â‚†â‚Ž=Aâ‚„Î¦â‚Â²\n\njulia> R=reflection_subgroup(W,[1,2,3,5,6,35])\nEâ‚†â‚â‚â€šâ‚ƒâ€šâ‚‚â€šâ‚ƒâ‚…â€šâ‚…â€šâ‚†â‚Ž=Aâ‚‚â‚â‚â‚ƒâ‚ŽÃ—Aâ‚‚â‚â‚‚â‚†â‚ŽÃ—Aâ‚‚â‚â‚„â‚…â‚Ž\n\njulia> standard_parabolic(W,R)\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Weyl.inversions","page":"Gapjm Documentation","title":"Gapjm.Weyl.inversions","text":"inversions(W,w)\n\nReturns  the inversions of the element w of the finite Coxeter group W, that  is, the list of the  indices of roots of W  sent by w to negative roots.  The element w can also be  a word sâ‚â€¦sâ‚™ (a vector of integers), in  which  case  the  function  returns  inversions  in  the  order  of the reflections W(sâ‚), W(sâ‚,sâ‚‚,sâ‚), â€¦, W(sâ‚,sâ‚‚,â€¦,sâ‚™,sâ‚™â‚‹â‚,â€¦,sâ‚).\n\njulia> W=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> inversions(W,W(1,2,1))\n3-element Vector{Int64}:\n 1\n 2\n 4\n\njulia> inversions(W,[1,2,1])\n3-element Vector{Int16}:\n 1\n 4\n 2\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Weyl.with_inversions","page":"Gapjm Documentation","title":"Gapjm.Weyl.with_inversions","text":"with_inversions(W,N)\n\nW  should be  a finite  Coxeter group  and N  a subset  of 1:nref(W). Returns  the  element  w  of  W such that N==inversions(W,w). Returns nothing if no such element exists.\n\njulia> W=coxgroup(:A,2)\nAâ‚‚\n\njulia> map(N->with_inversions(W,N),combinations(1:nref(W)))\n8-element Vector{Union{Nothing, Perm{Int16}}}:\n ()\n (1,4)(2,3)(5,6)\n (1,3)(2,5)(4,6)\n nothing\n nothing\n (1,6,2)(3,5,4)\n (1,2,6)(3,4,5)\n (1,5)(2,4)(3,6)\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Weyl.torus","page":"Gapjm Documentation","title":"Gapjm.Weyl.torus","text":"torus(rank)\n\nThis  function returns the object corresponding to the notion of a torus of dimension  rank, a Coxeter  group of semisimple  rank 0 and given rank. This  corresponds to a split torus; the extension to Coxeter cosets is more useful.\n\njulia> torus(3)\nÎ¦â‚Â³\n\n\n\n\n\ntorus(m::Matrix)\n\nm  should be an integral matrix of finite order. The function returns the coset T of the trivial Coxeter group such that T.F==m. This corresponds to  an algebraic torus ð“ of rank size(m,1), with an isogeny which acts by m on X(ð“).\n\njulia> torus([0 -1;1 -1])\nÎ¦â‚ƒ\n\n\n\n\n\ntorus(W,i)\n\nThis  returns the torus twisted by a representative of the i-th conjugacy class of W. This is the same as twistings(W,Int[])[i].\n\njulia> W=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> twistings(W,Int[])\n5-element Vector{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}}:\n Aâ‚ƒâ‚â‚Ž=Î¦â‚Â³\n Aâ‚ƒâ‚â‚Ž=Î¦â‚Â²Î¦â‚‚\n Aâ‚ƒâ‚â‚Ž=Î¦â‚Î¦â‚‚Â²\n Aâ‚ƒâ‚â‚Ž=Î¦â‚Î¦â‚ƒ\n Aâ‚ƒâ‚â‚Ž=Î¦â‚‚Î¦â‚„\n\njulia> torus(W,2)\nAâ‚ƒâ‚â‚Ž=Î¦â‚Â²Î¦â‚‚\n\njulia> WF=spets(W,Perm(1,3))\nÂ²Aâ‚ƒ\n\njulia> twistings(WF,Int[])\n5-element Vector{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}}:\n Aâ‚ƒâ‚â‚Ž=Î¦â‚‚Â³\n Aâ‚ƒâ‚â‚Ž=Î¦â‚Î¦â‚‚Â²\n Aâ‚ƒâ‚â‚Ž=Î¦â‚Â²Î¦â‚‚\n Aâ‚ƒâ‚â‚Ž=Î¦â‚‚Î¦â‚†\n Aâ‚ƒâ‚â‚Ž=Î¦â‚Î¦â‚„\n\njulia> torus(WF,2)\nAâ‚ƒâ‚â‚Ž=Î¦â‚Î¦â‚‚Â²\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Semisimple.SubTorus","page":"Gapjm Documentation","title":"Gapjm.Semisimple.SubTorus","text":"SubTorus(W,Y::Matrix)\n\nThe  function  returns  the  subtorus  ð’  of  the  maximal torus ð“ of the reductive  group represented by the Weyl group  W such that Y(ð’) is the (pure)  sublattice of  Y(ð“) generated  by the  (integral) vectors  Y. A basis  of Y(ð’)  adapted to  Y(ð“) is  computed and  stored in  the field 'S.gens' of the returned SubTorus struct. Here, adapted means that there is a   set  of   integral  vectors,   stored  in   'S.complement',  such  that 'M=vcat(S.gens,S.complement)'   is   a   basis   of   Y(ð“)  (equivalently MâˆˆGL(Z^{rank(W)}).  An  error  is  raised  if  Y does not define a pure sublattice.\n\njulia> W=coxgroup(:A,4)\nAâ‚„\n\njulia> SubTorus(W,[1 2 3 4;2 3 4 1;3 4 1 1])\nSubTorus(Aâ‚„,[[1, 0, 3, -13], [0, 1, 2, 7], [0, 0, 4, -3]])\n\njulia> SubTorus(W,[1 2 3 4;2 3 4 1;3 4 1 2])\nERROR: not a pure sublattice\nStacktrace:\n [1] error(::String) at ./error.jl:33\n [2] Gapjm.Weyl.SubTorus(::FiniteCoxeterGroup{Perm{Int16},Int64}, ::Matrix{Int64}) at /home/jmichel/julia/Gapjm.jl/src/Weyl.jl:1082\n [3] top-level scope at REPL[25]:1\n\n\n\n\n\n","category":"type"},{"location":"#Gapjm.Weyl.relative_group","page":"Gapjm Documentation","title":"Gapjm.Weyl.relative_group","text":"relative_group(W::FiniteCoxeterGroup,J)\n\nJ  should be a if distinguished subset of S==eachindex(gens(W)), that is  if for sâˆˆ S-J we set v(s,J)=wâ‚€^{Jâˆª  s}wâ‚€á´¶ then J is stable by all v(s,J).  Then R=N_W(W_J)W_J is  a Coxeter group  with Coxeter system the  v(s,J). The program returns R  in its reflection representation on X(ZL_JZG).  (according to Lusztig's \"Coxeter Orbits...\", the images of the roots of W in X(ZL_JZG) form a root system).\n\nR.prop has the fields: :relativeIndices=setdiff(S,J) :parentMap= the list of v(s,J) :MappingFromNormalizer maps J-reduced elements of N_W(W_J) to   elements of R\n\n\n\n\n\n","category":"function"},{"location":"#Finite-reflection-groups","page":"Gapjm Documentation","title":"Finite reflection groups","text":"","category":"section"},{"location":"","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"PermRoot\nreflection\ncartan(::PermRootGroup)\nDiagram\nhyperplane_orbits\nrank\nsemisimplerank\ndegrees(::Group)\ncodegrees\nbipartite_decomposition\ncatalan\nreflrep(::PermRootGroup,w)\nPermX\nreflections\nrefleigen\nreflchar\nsimple_conjugating\nsimple_reps\ninvariant_form\ninvariants\ngeneric_order\ntorus_order\nparabolic_reps\nparabolic_closure\nis_parabolic\nComplexReflectionGroup","category":"page"},{"location":"#Gapjm.PermRoot","page":"Gapjm Documentation","title":"Gapjm.PermRoot","text":"Let  V be a vector space over a subfield K of the complex numbers; here it  usually means  a Rational  or a  Cyc. A  complex reflection is an element  sâˆˆ GL(V) of finite order whose  fixed point set is an hyperplane (we  will in the  following just call  it a reflection  to abbreviate; in some  literature the term reflection  is only employed when  the order is 2 and  the  more  general  case  is  called  a  pseudo-reflection).  Thus a reflection  has a unique  eigenvalue not equal  to 1, which  is a root of unity.  If  K  is  a  subfield  of  the  real numbers, this eigenvalue is necessarily equal to -1.\n\nA  reflection group W is a group  generated by a finite number of complex reflections.\n\nSince  when W contains  a reflection s  it contains its  powers, W is always  generated  by  reflections  s  with non-trivial eigenvalue E(d) where  d is the order of s; we may in addition assume that s is not a power  of another reflection with larger order. Such a reflection is called distinguished;  it is  a canonical  generator of  the cyclic  subgroup it generates.  The  generators  of  reflection  groups we construct are always distinguished  reflections. In a real  reflection group all reflections are distinguished.\n\nReflection groups for us are groups W with the following methods defined\n\ngens(W): the reflections which generate W\n\nreflections(W): a list of distinguished reflections, given as elements of W, which starts with gens(W).\n\nNote  that W  does not  need to  be a  matrix group. The meaning of the above  fields is just that W has a representation (called the reflection representation  of W) where  reflections(W) act as  reflections. It is much  more efficient  to compute  with permutation  groups than with matrix groups,  when possible.  Information sufficient  to determine  a particular reflection  representation  is  stored  for  such  groups  (see roots and coroots). Note that when W is finite, the distinguished reflections are in bijection with the reflecting hyperplanes.\n\nLet  W  be  a  finite  reflection  group  on  the vector space V over a subfield  K of the  complex numbers. An  efficient representation that we use  for computing with such group is, is a permutation representation on a W-invariant  set of root and coroot  vectors for reflections of W; that is,  a  set  R  of  pairs  (r,ráµ›)âˆˆ  VÃ—Váµ› invariant by W and such each distinguished  reflection  in  W  is  defined  by  some  pair in R (see reflection). There may be several pairs for each reflection, differing by roots  of unity. This generalizes the usual construction for Coxeter groups (the  case K=â„) where to each reflection of W is associated two roots, a  positive and a negative one.  For irreducible complex reflection groups, there are at least as many roots on a given line as the order of the center of W.\n\nThe  finite  irreducible  complex  reflection  groups  have been completely classified   by  Shepard  and  Todd.   They  contain  one  infinite  family G(de,e,r) depending on 3 parameters, and 34 exceptional groups which have been  given by Shephard and Todd names which range from Gâ‚„ to Gâ‚ƒâ‚‡. They cover the exceptional Coxeter groups, e.g., coxgroup(:E,8) is the same as Gâ‚ƒâ‚‡.\n\nWe provide functions to build any finite reflection group, either by giving a  list of  roots and  corrots defining  the generating  reflections, or in terms  of the classification. The  output is a permutation  group on set of roots  (see ComplexReflectionGroup  and PermRootGroup).  In the context e.g.  of  Weyl  groups,  one  wants  to describe the particular root system chosen  in term of the  traditional classification of crystallographic root systems. This is done via calls to the function coxgroup (see the chapter on  finite Coxeter  groups). There  is not  yet a  general theory on how to construct  a nice set of  roots for a non-real  reflection group; the roots chosen  here  where  obtained  case-by-case;  however, they satisfy several important properties:\n\nThe  generating  reflections  satisfy  braid relations which  present the braid group associated to W (see Diagram).\nThe field of definition of W is the field K generated by the traces of the elements of W acting on V.\n\nIt  is a theorem that  W may be realized  as a reflection group over K. For  almost  all  irreducible  complex  reflection  groups,  the generating matrices  for W  we give  have coefficients  in K.  Further, the set of matrices  for all  elements of  W is  globally invariant under the Galois group  of K/â„š, thus the Galois  action induces automorphisms of W. The exceptions  are Gâ‚‚â‚‚, Gâ‚‚â‚‡ where the matrices are in a degree two extension of   K  (this  is  needed  to   have  a  globally  invariant  model,  see MarinMichel2010)  and  some  dihedral groups as well  as  H_3  and  H_4,  where  the  matrices given (the usual Coxeter reflection representation over K) are not globally invariant.\n\nIt turns out that all representations of a complex reflection group W are defined  over the  field of  definition of  W (cf.  [Ben76] and D.~Bessis thesis).  This has been known for a long  time in the case K=â„š, the case of Weyl groups: their representations are defined over the rationals.\n\nThe Cartan matrix (see \"CartanMat\") for the generating roots (those which  correspond  to the generating reflections) has  entries in the ring â„¤â‚–  of integers of K, and the roots (resp. coroots) are linear combination  with coefficients in â„¤â‚– of a linearly independent subset of them.\n\nThe finite reflection groups have thus the following additional fields:\n\nroots:  a  set  of  complex  roots  in  V,  given  as a list of lists        (vectors), on which W has a faithful permutation representation.\n\n   `coroots`: the  coroots for `gens(W)`.\n\nHere  we  describe  functions  available  for  finite reflection groups W represented  as permutation groups on a  set of roots. These functions make use  of the classification of W whenever it is known, but work even if it is not known.\n\nLet SV be the symmetric algebra of V. The invariants of W in SV are called  the  polynomial  invariants  of  W.  They  are  generated  as a polynomial   ring   by   dim   V  homogeneous  algebraically  independent polynomials  fâ‚,â€¦,f_{dim  V}.  The  polynomials  fáµ¢  are not uniquely determined  but  their  degrees  are.  The  fáµ¢  are  called  the  basic invariants  of W, and their degrees the reflection degrees of W. Let I be the ideal generated by the homogeneous invariants of positive degree in  SV. Then SV/I is isomorphic to the regular representation of W as a  W-module. It  is thus  a graded  (by the  degree of  elements of SV) version  of the regular  representation of W.  The polynomial which gives the  graded multiplicity  of a  character Ï†  of W  in the graded module SV/I is called the fake degree of Ï†.\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.PermRoot.reflection","page":"Gapjm Documentation","title":"Gapjm.PermRoot.reflection","text":"reflection(root, coroot)::Matrix the reflection of given root and coroot\n\nA  (complex) reflection in GL(V), the linear group of a vector space over a subfield of the complex numbers, is a map s of finite order whose fixed points  are  a  hyperplane  H  (the  reflecting  hyperplane of s); an eigenvector  r for  the non-trivial  eigenvalue Î¶  (a root of unity) is called  a root of s. If we choose a linear form ráµ› (called a coroot of s) defining H such that ráµ›(r)=1-Î¶ then the linear map s is given by xâ†¦x-ráµ›(x)r.\n\nA  way of specifying a  reflection is by giving  a root and a coroot, which are  uniquely determined by the reflection up to multiplication of the root by  a  scalar  and  of  the  coroot  by  the  inverse  scalar. The function reflection  gives  the  matrix  of  the  corresponding  reflection in the standard  basis of V, where the root and the coroot are vectors given in  the standard  bases of  V and  Váµ›, so  that ráµ›(r)  is obtained as permutedims(root)*coroot.\n\njulia> r=reflection([1,0,0],[2,-1,0])\n3Ã—3 Matrix{Int64}:\n -1  0  0\n  1  1  0\n  0  0  1\n\njulia> r==reflrep(coxgroup(:A,3),1)\ntrue\n\njulia> r*[2,-1,0]\n3-element Vector{Int64}:\n -2\n  1\n  0\n\njulia> [1 0 0]*r\n1Ã—3 Matrix{Int64}:\n -1  0  0\n\nAs  we see in the last lines, in our package the matrices operate an V as row vectors and on Váµ› as column vectors\n\n\n\n\n\nreflection(W,i)\n\nreflection for i-th root of W\n\n\n\n\n\nreflection(s::Matrix [,r::AbstractVector])\n\nHere  s is  a square  matrix, and  if given  r is  a vector of the same length  as size(s)[1]. The function determines if  s is the matrix of a reflection  (resp. if r is  given if it is  the matrix of a reflection of root  r; the point of  giving r is to  specify exactly the desired root and  coroot, which  otherwise are  determined only  up to  a scalar and its inverse).  The function  returns nothing  if s  if is  not a reflection (resp. not a reflection with root r), and otherwise returns a named tuple with four fields:\n\n.root:   the root of the reflection s (equal to r if given)\n\n.coroot:  the coroot of s\n\n.eigenvalue:  the non-trivial eigenvalue of s\n\n.isOrthogonal:   a  boolean  which is  true if  and  only if  s is   orthogonal  with respect to  the usual scalar  product (then the root and   eigenvalue are sufficient to determine s)\n\njulia> reflection([-1 0 0;1 1 0;0 0 1])\n(root = [2, 0, 0], coroot = Rational{Int64}[1//1, -1//2, 0//1], eig = -1, isOrthogonal = false)\n\njulia> reflection([-1 0 0;1 1 0;0 0 1],[1,0,0])\n(root = [1, 0, 0], coroot = Rational{Int64}[2//1, -1//1, 0//1], eig = -1, isOrthogonal = false)\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.PermRoot.cartan-Tuple{PermRootGroup}","page":"Gapjm Documentation","title":"Gapjm.PermRoot.cartan","text":"cartan(W::PermRootGroup)    Cartan matrix of W.\n\nLet  sâ‚,â€¦,sâ‚™ be reflections with associated  roots ráµ¢ and coroots cáµ¢. The  matrix C with  entries Cáµ¢,â±¼=cáµ¢(râ±¼) is  called a Cartan matrix of sâ‚,â€¦,sâ‚™.  It is uniquely  determined by sâ‚,â€¦,sâ‚™  up to conjugation by a diagonal matrix.\n\nIf sâ‚,â€¦,sâ‚™ generate a reflection group W, then C up to conjugation by a  diagonal matrix is an invariant of the reflection representation of W. If invertible C determines this representation since then the ráµ¢ form a basis  in which the matrix  for sáµ¢ differs from  the identity only on the i-th line, where the corresponding line of C has been subtracted.\n\njulia> W=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> cartan(W)\n3Ã—3 Matrix{Int64}:\n  2  -1   0\n -1   2  -1\n  0  -1   2\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.PermRoot.Diagram","page":"Gapjm Documentation","title":"Gapjm.PermRoot.Diagram","text":"diagram of finite Coxeter group\n\n\n\n\n\n","category":"type"},{"location":"#Gapjm.PermRoot.hyperplane_orbits","page":"Gapjm Documentation","title":"Gapjm.PermRoot.hyperplane_orbits","text":"hyperplane_orbits(W)\n\nreturns  a  list  of  named  tuples,  one  for each hyperplane orbit of the reflection  group W. If o is the named tuple for such an orbit, and s is  the first  element of  gens(W) whose  hyperplane is  in the orbit, it contains the following fields\n\no.s:     index of s in gens(W)\n\no.cl_s:  map(i->position_class(W,s^i),1:o.order-1)\n\no.order: order of s\n\n.N_s:    Size of orbit\n\n.det_s:  for i in 1:o.order-1, position in CharTable of (det_s)^i\n\njulia> W=coxgroup(:B,2)\nBâ‚‚\n\njulia> hyperplane_orbits(W)\n2-element Vector{NamedTuple{(:s, :cl_s, :order, :N_s, :det_s), Tuple{Int64, Vector{Int64}, Int64, Int64, Vector{Int64}}}}:\n (s = 1, cl_s = [2], order = 2, N_s = 2, det_s = [5])\n (s = 2, cl_s = [4], order = 2, N_s = 2, det_s = [1])\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.PermRoot.rank","page":"Gapjm Documentation","title":"Gapjm.PermRoot.rank","text":"rank(W::Group)\n\nThis  function  returns  the  rank  of  a  reflection group, which is the dimension of the space where it acts.\n\njulia> rank(ComplexReflectionGroup(31))\n4\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.PermRoot.semisimplerank","page":"Gapjm Documentation","title":"Gapjm.PermRoot.semisimplerank","text":"semisimpleRank(W)\n\nThis  function returns the  semisimple rank of  the reflection group W, which  is the dimension of the space  where it effectively acts. If Wis a reflection  group acting on V, and Vâ‚  is the subspace generated by the roots  of  the  reflections  of  W,  then  the  dimension  of Vâ‚ is the semisimple rank. W is called essential if Vâ‚=V.\n\njulia> W=reflection_subgroup(coxgroup(:A,3),[1,3])\nAâ‚ƒâ‚â‚â‚ƒâ‚Ž=Aâ‚Ã—Aâ‚Î¦â‚\n\njulia> semisimplerank(W)\n2\n\njulia> rank(W)\n3\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.degrees-Tuple{Group}","page":"Gapjm Documentation","title":"Gapjm.degrees","text":"degrees(W)\n\nreturns  a list  holding the  degrees of  W as  a reflection group on the vector  space V on which  it acts. These are  the degrees dâ‚,â€¦,dâ‚™ where n  is the dimension of  V of the basic  invariants of W in SV. They reflect various properties of W; in particular, their product is the size of W.\n\njulia> W=ComplexReflectionGroup(30)\nHâ‚„\n\njulia> degrees(W)\n4-element Vector{Int64}:\n  2\n 12\n 20\n 30\n\njulia> length(W)\n14400\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.ComplexR.codegrees","page":"Gapjm Documentation","title":"Gapjm.ComplexR.codegrees","text":"codegrees(W)\n\nreturns  the vector of codegrees of W  as a reflection group on the space V  of reflrep(W).  These are  one less  than the  degrees of  the basic derivations of W on SVâŠ— V^vee.\n\njulia> W=ComplexReflectionGroup(4)\nGâ‚„\n\njulia> codegrees(W)\n2-element Vector{Int64}:\n 0\n 2\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.PermRoot.bipartite_decomposition","page":"Gapjm Documentation","title":"Gapjm.PermRoot.bipartite_decomposition","text":"bipartite_decomposition(W)\n\nReturns  a bipartite decomposition [L,R] of the indices of the generators of  the  reflection  group  W,  such  that reflection_subgroup(W,L) and reflection_subgroup(W,R) are abelian subgroups, and W=reflection_subgroup(W,   vcat(L,R)).   Gives   an   error  if  no  such decomposition is possible.\n\njulia> bipartite_decomposition(coxgroup(:E,8))\n([1, 4, 6, 8], [3, 2, 5, 7])\n\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.PermRoot.catalan","page":"Gapjm Documentation","title":"Gapjm.PermRoot.catalan","text":"Catalan(n) n-th Catalan Number\n\njulia> catalan(8)\n1430\n\n\n\n\n\nCatalan(W)\n\nreturns the Catalan Number of the irreducible complex reflection group W. For well-generated groups, this number is equal to the number of simples in the  dual Braid  monoid. For  other groups  it was  defined by  Gordon and Griffeth2012.  For Weyl groups, it also counts the number of antichains of roots.\n\njulia> catalan(coxgroup(:A,7))\n1430\n\nCatalan(W,i)\n\nreturns   the  i-th  Fuss-Catalan  Number   of  the  irreducible  complex reflection  group W. For  well-generated groups, this  number is equal to the  number of chains  sâ‚,â€¦,sáµ¢ of simples  in the dual  monoid where sâ±¼ divides  sâ±¼â‚Šâ‚. For these groups, it is also equal to âˆâ±¼(ih+dâ±¼)/dâ±¼ where the  product runs over the reflection degrees  of W, and where h is the Coxeter  number of W. For non-well generated groups, the definition is in Gordon and Griffeth2012.\n\njulia> catalan(ComplexReflectionGroup(7),2)\n16\n\nCatalan(W,q), resp. Catalan(W,i,q)\n\nwhere  q  is  a  variable  (like  Pol(:q)  or  an  'Mvp')  returns  the q-Catalan number (resp. the i-th q-Fuss Catalan number) of W. Again the definitions in general are in Gordon and Griffeth2012.\n\njulia> catalan(ComplexReflectionGroup(7),2,q)\nPol{Int64}: qâ·Â²+2qâ¶â°+3qâ´â¸+4qÂ³â¶+3qÂ²â´+2qÂ¹Â²+1\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.PermRoot.reflrep-Tuple{PermRootGroup, Any}","page":"Gapjm Documentation","title":"Gapjm.PermRoot.reflrep","text":"reflrep(W,w)  Reflection representation\n\nLet  W be a  finite reflection group  on the space  V and let  w be a permutation  of the roots of W. The function reflrep returns the matrix of  w acting on V. This is  the linear transformation of V which acts trivially  on the orthogonal of  the coroots and has  same effect as w on the simple roots. The function makes sense more generally for an element of the normalizer of W in the whole permutation group of the roots.\n\njulia> W=reflection_subgroup(rootdatum(\"E7sc\"),1:6)\nEâ‚‡â‚â‚â‚‚â‚ƒâ‚„â‚…â‚†â‚Ž=Eâ‚†Î¦â‚\n\njulia> reflrep(W,longest(W))\n7Ã—7 Matrix{Int64}:\n  0   0   0   0   0  -1  2\n  0  -1   0   0   0   0  2\n  0   0   0   0  -1   0  3\n  0   0   0  -1   0   0  4\n  0   0  -1   0   0   0  3\n -1   0   0   0   0   0  2\n  0   0   0   0   0   0  1\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.PermRoot.PermX","page":"Gapjm Documentation","title":"Gapjm.PermRoot.PermX","text":"PermX(W,M::AbstractMatrix)\n\nLet  M be  a linear  transformation of  reflection representation  of W which  preserves the set  of roots of  parent(W), and normalizes W (for the  action of  matrices on  the right).  PermX returns the corresponding permutation  of the roots of parent(W);  it returns nothing if M does not normalize the set of roots.\n\njulia> W=reflection_subgroup(rootdatum(\"E7sc\"),1:6)\nEâ‚‡â‚â‚â‚‚â‚ƒâ‚„â‚…â‚†â‚Ž=Eâ‚†Î¦â‚\n\njulia> PermX(W,reflrep(W,longest(W)))==longest(W)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.PermRoot.reflections","page":"Gapjm Documentation","title":"Gapjm.PermRoot.reflections","text":"list of same length as W.roots giving corresponding reflections\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.PermRoot.refleigen","page":"Gapjm Documentation","title":"Gapjm.PermRoot.refleigen","text":"refleigen(W) Reflection eigenvalues\n\nLet  W  be  a  reflection  group  on the vector space V. refleigen(W) returns   for  each  conjugacy   class  representative  x   of  W  (see classreps) the eigenvalues of x on V, as a list of Root1.\n\njulia> refleigen(coxgroup(:B,2))\n5-element Vector{Vector{Root1}}:\n [1, 1]\n [1, -1]\n [-1, -1]\n [1, -1]\n [Î¶â‚„, Î¶â‚„Â³]\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.PermRoot.reflchar","page":"Gapjm Documentation","title":"Gapjm.PermRoot.reflchar","text":"reflchar(W,w) Reflection character\n\nReturns  the trace  of the  element w  of the  reflection group W as an endomorphism of the vector space V on which W acts. This is the same as trace(reflrep(W,w)).\n\njulia-repl``` julia> W=coxgroup(:B,3) Bâ‚ƒ\n\njulia> reflchar(W,longest(W)) -3 julia-repl```\n\n\n\n\n\nreflchar(W)\n\nReturns  the reflection character of the  reflection group W. This is the same  as map(c->reflchar(W,c),class-reps(W)). When W is irreducible, it is also CharTable(W).irr[charinfo(W)[:extRefl][2]].\n\njulia> reflchar(coxgroup(:A,3))\n5-element Vector{Int64}:\n  3\n  1\n -1\n  0\n -1\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.PermRoot.simple_conjugating","page":"Gapjm Documentation","title":"Gapjm.PermRoot.simple_conjugating","text":"element w such that simple_reps(W,i)^w==i\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.PermRoot.simple_reps","page":"Gapjm Documentation","title":"Gapjm.PermRoot.simple_reps","text":"return for each root the index of the first simple root conjugate to it\"\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.PermRoot.invariant_form","page":"Gapjm Documentation","title":"Gapjm.PermRoot.invariant_form","text":"invariant_form(W)\n\nThis  function returns the matrix F  of an Hermitian form invariant under the action of the reflection group W. That is, if M is the matrix of an element of W, then M*F*M'=F.\n\njulia> W=ComplexReflectionGroup(4)\nGâ‚„\n\njulia> invariant_form(W)\n2Ã—2 Matrix{Int64}:\n 1  0\n 0  2\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.PermRoot.invariants","page":"Gapjm Documentation","title":"Gapjm.PermRoot.invariants","text":"invariants(W)\n\nreturns  the fundamental invariants of W in its reflection representation V.  That is, returns  a set of  algebraically independent elements of the symmetric  algebra  of  the  dual  of  V which generate the W-invariant polynomial  functions on V. Each such invariant function is returned as a function:  if eâ‚,â€¦,eâ‚™ is a basis of V and f is the function, then the value  of the polynomial  function on aâ‚eâ‚+â€¦+aâ‚™eâ‚™  is obtained by calling f(aâ‚,â€¦,aâ‚™). This function depends on the classification, and is dependent on the exact reflection representation of W. So for the moment it is only implemented   when  the  reflection   representation  for  the  irreducible components has the same Cartan matrix as the one provided by Chevie for the corresponding  irreducible  group.  The  polynomials  are invariant for the natural   action  of   the  group   elements  as   matrices;  that  is,  if m==reflrep(W,w)  for some  w in  W, then  an invariant  f satisfies f(aâ‚,â€¦,aâ‚™)=f(vâ‚,â€¦,vâ‚™)   where  [vâ‚,â€¦,vâ‚™]=[aâ‚,â€¦,aâ‚™]Ã—m.  This  action  is implemented on Mvps by the function ^.\n\njulia> W=coxgroup(:A,2)\nAâ‚‚\n\njulia> @Mvp x,y,z\n\njulia> i=invariants(W);\n\njulia> i[1](x,y)\nMvp{Int64}: -2xÂ²+2xy-2yÂ²\n\njulia> i[2](x,y)\nMvp{Int64}: 6xÂ²y-6xyÂ²\n\njulia> W=ComplexReflectionGroup(24)\nGâ‚‚â‚„\n\njulia> i=invariants(W)[1];\n\njulia> p=i(x,y,z)\nMvp{Rational{Int64}}: (14//1)xâ´+(-12//1)xÂ²yÂ²+(-42//1)xÂ²yz+(21//2)xÂ²zÂ²+(18//7)yâ´+(-6//1)yÂ³z+(-9//2)yÂ²zÂ²+(-21//8)zâ´\n\njulia> p^reflrep(W,1)-p\nMvp{Cyc{Rational{Int64}}}: 0\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.PermRoot.generic_order","page":"Gapjm Documentation","title":"Gapjm.PermRoot.generic_order","text":"generic_order(W,q)\n\nreturns  the \"compact\" generic order of W as a polynomial in q. This is q^(Nâ‚•)Î áµ¢(q^(dáµ¢)-1)  where dáµ¢  are the  reflection degrees  and Nâ‚• the number  of reflecting hyperplanes. For a Weyl group, it is the order of the associated  semisimple  finite  reductive  group  over  the  field with q elements.\n\njulia> Pol(:q)\nPol{Int64}: q\n\njulia> PermRoot.generic_order(ComplexReflectionGroup(4),q)\nPol{Int64}: qÂ¹â´-qÂ¹â°-qâ¸+qâ´\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.PermRoot.torus_order","page":"Gapjm Documentation","title":"Gapjm.PermRoot.torus_order","text":"torus_order(W,i,q)\n\nreturns  as a  polynomial in  q the  toric order  of the i-th conjugacy class  of W. This is the characteristic  polynomial of an element of that class  on  the  reflection  representation  of  W.  It is the same as the generic  order of the reflection subcoset  of W determined by the trivial subgroup and a representative of the i-th conjugacy class.\n\njulia> W=ComplexReflectionGroup(4);Pol(:q);\n\njulia> torus_order.(Ref(W),1:HasType.NrConjugacyClasses(W),q)\n7-element Vector{Pol{Cyc{Int64}}}:\n qÂ²-2q+1\n qÂ²+2q+1\n qÂ²+1\n qÂ²-Î¶â‚ƒq+Î¶â‚ƒÂ²\n qÂ²+Î¶â‚ƒq+Î¶â‚ƒÂ²\n qÂ²+Î¶â‚ƒÂ²q+Î¶â‚ƒ\n qÂ²-Î¶â‚ƒÂ²q+Î¶â‚ƒ\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.PermRoot.parabolic_reps","page":"Gapjm Documentation","title":"Gapjm.PermRoot.parabolic_reps","text":"parabolic_reps(W)\n\nReturns  a list  of indices  of roots  of W describing representatives of orbits of parabolic subgroups under conjugation by W. For Coxeter groups, each   orbit  has   a  representative   whose  indices   is  a   subset  of eachindex(gens(W)). This may not be the case in general.\n\njulia> parabolic_reps(coxgroup(:A,4))\n7-element Vector{Vector{Int64}}:\n []\n [1]\n [1, 2]\n [1, 3]\n [1, 2, 3]\n [1, 2, 4]\n [1, 2, 3, 4]\n\ngap> ParabolicRepresentatives(ComplexReflectionGroup(3,3,3)); [ [  ], [ 1 ], [ 1, 2 ], [ 1, 3 ], [ 1, 20 ], [ 2, 3 ], [ 1, 2, 3 ] ]\n\nparabolic_reps(W,r)\n\nIf  a second  argument r  is given,  returns only  representatives of the parabolic subgroups of semisimple rank r.\n\njulia> parabolic_reps(coxgroup(:A,4),2)\n2-element Vector{Vector{Int64}}:\n [1, 2]\n [1, 3]\n\ngap> ParabolicRepresentatives(ComplexReflectionGroup(3,3,3),2); [ [ 1, 2 ], [ 1, 3 ], [ 1, 20 ], [ 2, 3 ] ]\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.PermRoot.parabolic_closure","page":"Gapjm Documentation","title":"Gapjm.PermRoot.parabolic_closure","text":"parabolic_closure(W,I)\n\nI  should be a  list of indices  of reflections of  W. Returns J such that  reflection_subgroup(W,J) is the smallest  parabolic subgroup of W containing reflection_subgroup(W,I).\n\njulia> W=ComplexReflectionGroup(7)\nGâ‚‡\n\njulia> parabolic_closure(W,[1])\n1-element Vector{Int64}:\n 1\n\njulia> parabolic_closure(W,[1,2])\n3-element Vector{Int64}:\n 1\n 2\n 3\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.PermRoot.is_parabolic","page":"Gapjm Documentation","title":"Gapjm.PermRoot.is_parabolic","text":"is_parabolic(W)\n\nwhether the reflection group W is a parabolic subgroup of parent(W).\n\njulia> W=ComplexReflectionGroup(7)\nGâ‚‡\n\njulia> is_parabolic(reflection_subgroup(W,[1,2]))\nfalse\n\njulia> is_parabolic(reflection_subgroup(W,[1]))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.ComplexR.ComplexReflectionGroup","page":"Gapjm Documentation","title":"Gapjm.ComplexR.ComplexReflectionGroup","text":"ComplexReflectionGroup(STnumber)\n\nComplexReflectionGroup(p,q,r)\n\nThe  first form of ComplexReflectionGroup  returns the complex reflection group which has Shephard-Todd number STnumber, see Shephard-Todd1954.   The   second   form   returns   the imprimitive complex reflection group G(p,q,r).\n\njulia> G=ComplexReflectionGroup(4)\nGâ‚„\n\njulia> degrees(G)\n2-element Vector{Int64}:\n 4\n 6\n\njulia> length(G)\n24\n\njulia> fakedegrees(G,Pol(:q))\n7-element Vector{Pol{Int64}}:\n 1       \n qâ´      \n qâ¸      \n qâ·+qâµ   \n qâµ+qÂ³   \n qÂ³+q    \n qâ¶+qâ´+qÂ²\n\njulia> ComplexReflectionGroup(2,1,6)\nBâ‚†\n\n\n\n\n\n","category":"function"},{"location":"#Hecke-algebras","page":"Gapjm Documentation","title":"Hecke algebras","text":"","category":"section"},{"location":"","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"HeckeAlgebras\nhecke\ncentral_monomials\nclass_polynomials\nchar_values\nalt\nÎ±(::HeckeTElt)\nschur_elements\nFactorizedSchurElement\nFactorizedSchurElements\nisrepresentation\nreflrep(::HeckeAlgebra)","category":"page"},{"location":"#Gapjm.HeckeAlgebras","page":"Gapjm Documentation","title":"Gapjm.HeckeAlgebras","text":"This   module  ports   Chevie  functionality   for  Iwahori-Hecke  algebras associated to Coxeter groups.\n\nLet  (W,S) be a Coxeter  system where mâ‚›â‚œ is  the order of st for s,tâˆˆ S. Let R be a commutative ring with 1 and for sâˆˆ S let uâ‚›â‚€,uâ‚›â‚âˆˆ R be elements which depend ony on the conjugacy class of s in W (this is the same  as requiring that uâ‚›áµ¢=uâ‚œáµ¢ whenever mâ‚›â‚œ is odd). The Iwahori-Hecke algebra of W over R with parameters uâ‚›áµ¢ is a deformation of the group algebra  of W over R defined as  follows: it is the unitary associative R-algebra generated by elements Tâ‚›, sâˆˆ S subject to the relations:\n\n(Tâ‚›-uâ‚›â‚€)(Tâ‚›-uâ‚›â‚)=0 for all sâˆˆ S (the quadratic relations)\n\nTâ‚›Tâ‚œTâ‚›= Tâ‚œTâ‚›Tâ‚œ with mâ‚›â‚œ factors on each side (the braid relations)\n\nIf  uâ‚›â‚€=1 and  uâ‚›â‚=-1 for  all s  then the quadratic relations become Tâ‚›Â²=1 and the deformation of the group algebra is trivial.\n\nSince  the generators Tâ‚› satisfy the  braid relations, the algebra H is in  fact a quotient of the group algebra of the braid group associated with W.  It follows that, if w=s_1â‹¯ s_m  is a reduced expression of w âˆˆ W then  the  product  Tâ‚›_1â‹¯ Tâ‚›_m  depends  only  on w. We will therefore denote by T_w. We have T_1=1.\n\nIf  one of uâ‚›â‚€ or uâ‚›â‚ is invertible  in R, for example uâ‚›â‚, then by changing  the generators  to Tâ€²â‚›=-Tâ‚›/uâ‚›â‚,  and setting qâ‚›=-uâ‚›â‚€/uâ‚›â‚, the braid  relations do no change  (since when mâ‚›â‚œ is  odd we have uâ‚›áµ¢=uâ‚œáµ¢) but  the quadratic relations become  (Tâ€²â‚›-qâ‚›)(Tâ€²â‚›+1)=0. This last form is the  most common  form considered  in the  literature. Another common form, considered  in  the  context  of  Kazhdan-Lusztig  theory, is uâ‚›â‚€=âˆšqâ‚› and uâ‚›â‚=-âˆšqâ‚›â»Â¹.  The general form of parameters provided is a special case of general cyclotomic Hecke algebras, and can be useful in many contexts.\n\nFor  some  algebras  the  character  table,  and in general Kazhdan-Lusztig bases,  require a square root of -uâ‚›â‚€uâ‚›â‚.  We provide a way to specify it with  the  field  .rootpara  which  can  be  given  when constructing the algebra. If not given a root is automatically extracted when needed (and we know  how to compute it) by the function RootParameter. Note however that sometimes  an  explicit  choice  of  root  is  necessary  which  cannot  be automatically determined.\n\nThere  is a universal choice  for R and uâ‚›áµ¢:  Let uâ‚›áµ¢:sâˆˆ S,iâˆˆ[0,1] be indeterminates   such  that  uâ‚›áµ¢=uâ‚œáµ¢  whenever  mâ‚›â‚œ  is  odd,  and  let A=â„¤[uâ‚›áµ¢] be the corresponding polynomial ring. Then the Hecke algebra H of  W over a  with parameters uâ‚›áµ¢  is called the generic Iwahori-Hecke algebra  of  with  W.  Any  other  algebra  with parameters vâ‚›áµ¢ can be obtained  by specialization from  H: There is  a unique ring homomorphism f:A  â†’ R such that f(uâ‚›áµ¢)=vâ‚›áµ¢  for all i. Then we  can view R as an A-module via f and we can identify the other algebra to R _A H.\n\nThe  elements {T_wâˆ£wâˆˆ W} actually form an  R-basis of H if one of the uâ‚›áµ¢  is invertible for all s. The  structure constants in that basis is obtained  as  follows.  To  multiply  T_v  by  T_w,  choose  a  reduced expression for v, say v=s_1 â‹¯ s_k and apply inductively the formula:\n\nT_sT_w=T_sw               if l(sw)=l(w)+1\n\nT_sT_w=-uâ‚›â‚€uâ‚›â‚T_sw+(uâ‚›â‚€+uâ‚›â‚)T_w if l(sw)=l(w)-1.\n\nIf all s we have uâ‚›â‚€=q, uâ‚›â‚=-1 then we call the corresponding algebra the one-parameter or Spetsial Iwahori-Hecke algebra associated with W; it can  be obtained with the  simplified call 'hecke(W,q)'. Certain invariants of  the irreducible characters of  this algebra play a  special role in the representation  theory of the underlying  finite Coxeter groups, namely the a- and A-invariants. For basic properties of Iwahori-Hecke algebras and their  relevance to the representation theory of finite groups of Lie type, see for example Curtis and Reiner 1987, Sections~67 and 68.\n\nIn  the  following  example,  we  compute  the multiplication table for the 0-Iwahoriâ€“Hecke algebra associated with the Coxeter group of type A_2.\n\njulia> W=coxgroup(:A,2)\nAâ‚‚\n\njulia> H=hecke(W,0)             # One-parameter algebra with `q=0`\nhecke(Aâ‚‚,0)\n\njulia> T=Tbasis(H);             # Create the `T` basis\n\njulia> el=words(W)\n6-element Vector{Vector{Int8}}:\n []       \n [2]      \n [1]      \n [2, 1]   \n [1, 2]   \n [1, 2, 1]\n\njulia> T.(el)*permutedims(T.(el))        # multiplication table\n6Ã—6 Matrix{HeckeTElt{Perm{Int16}, Int64, HeckeAlgebra{Int64, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:\n T.    Tâ‚‚     Tâ‚     Tâ‚‚â‚    Tâ‚â‚‚    Tâ‚â‚‚â‚ \n Tâ‚‚    -Tâ‚‚    Tâ‚‚â‚    -Tâ‚‚â‚   Tâ‚â‚‚â‚   -Tâ‚â‚‚â‚\n Tâ‚    Tâ‚â‚‚    -Tâ‚    Tâ‚â‚‚â‚   -Tâ‚â‚‚   -Tâ‚â‚‚â‚\n Tâ‚‚â‚   Tâ‚â‚‚â‚   -Tâ‚‚â‚   -Tâ‚â‚‚â‚  -Tâ‚â‚‚â‚  Tâ‚â‚‚â‚ \n Tâ‚â‚‚   -Tâ‚â‚‚   Tâ‚â‚‚â‚   -Tâ‚â‚‚â‚  -Tâ‚â‚‚â‚  Tâ‚â‚‚â‚ \n Tâ‚â‚‚â‚  -Tâ‚â‚‚â‚  -Tâ‚â‚‚â‚  Tâ‚â‚‚â‚   Tâ‚â‚‚â‚   -Tâ‚â‚‚â‚\n\n\nThus,  we work  with algebras  with arbitrary  parameters. We will see that this also works on the level of characters and representations.\n\nfinally, benchmarks on julia 1.0.2\n\njulia> function test_w0(n)\n         W=coxgroup(:A,n)\n         Tbasis(hecke(W,Pol()))(longest(W))^2\n       end\ntest_w0 (generic function with 1 method)\n\njulia> @btime test_w0(7);\n  132.737 ms (1788153 allocations: 157.37 MiB)\n\nCompare to GAP3 where the following function takes 0.92s\n\ntest_w0:=function(n)local W,T,H;\n  W:=CoxeterGroup(\"A\",n);H:=Hecke(W,X(Rationals));T:=Basis(H,\"T\");\n  T(LongestCoxeterWord(W))^2;\nend;\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.HeckeAlgebras.hecke","page":"Gapjm Documentation","title":"Gapjm.HeckeAlgebras.hecke","text":"hecke( W [, parameter][,rootpara=r]) return a Hecke algebra for W\n\nExample\n\njulia> W=coxgroup(:B,2)\nBâ‚‚\n\njulia> Pol(:q)\nPol{Int64}: q\n\njulia> H=hecke(W,q)\nhecke(Bâ‚‚,q)\n\njulia> H.para\n2-element Vector{Vector{Pol{Int64}}}:\n [q, -1]\n [q, -1]\n\njulia> H=hecke(W,q^2,rootpara=q)\nhecke(Bâ‚‚,qÂ²,rootpara=q)\n\njulia> H.para,rootpara(H)\n(Vector{Pol{Int64}}[[qÂ², -1], [qÂ², -1]], Pol{Int64}[q, q])\n\njulia> H=hecke(W,[q^2,q^4],rootpara=[q,q^2])\nhecke(Bâ‚‚,Pol{Int64}[qÂ², qâ´],rootpara=Pol{Int64}[q, qÂ²])\n\njulia> H.para,rootpara(H)\n(Vector{Pol{Int64}}[[qÂ², -1], [qâ´, -1]], Pol{Int64}[q, qÂ²])\n\njulia> H=hecke(W,9,rootpara=3)\nhecke(Bâ‚‚,9,rootpara=3)\n\njulia> H.para,rootpara(H)\n([[9, -1], [9, -1]], [3, 3])\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.HeckeAlgebras.central_monomials","page":"Gapjm Documentation","title":"Gapjm.HeckeAlgebras.central_monomials","text":"central_monomials(H)   Let  H be an Hecke  algebra for the reflection  group W. The function   returns  the  scalars  by  which  the  image  in  H  of  Ï€  acts on the   irreducible  representations of  the Iwahori-Hecke  algebra. When  W is   irreducible, Ï€ is the generator of the center of the pure braid group. In   general,  it  is  the  product  of  such  elements  for  each irreducible   component. When W is an irreducible Coxeter group, Ï€ is the lift to the   braid group of the square of the longest element of W.\n\njulia> H=hecke(coxgroup(:H,3),Pol(:q))\nhecke(Hâ‚ƒ,q)\n\njulia> central_monomials(H)\n10-element Vector{Pol{Cyc{Int64}}}:\n 1  \n qÂ³â°\n qÂ¹Â²\n qÂ¹â¸\n qÂ¹â°\n qÂ¹â°\n qÂ²â°\n qÂ²â°\n qÂ¹âµ\n qÂ¹âµ\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.HeckeAlgebras.class_polynomials","page":"Gapjm Documentation","title":"Gapjm.HeckeAlgebras.class_polynomials","text":"class_polynomials(h)\n\nreturns the class polynomials of the Hecke element h of the Hecke algebra H=h.H  with respect  to representatives  reps of  minimal length in the conjugacy  classes  of  the  Coxeter  group  W=H.W.  Such  minimal length representatives  are given by  the function classinfo(W)[:classtext]. The vector  p of these polynomials has the property that if X is the matrix of  the values of  the irreducible characters  of H on  T_w (for w in reps),  then the product X*p  is the list of  values of the irreducible characters on h.\n\njulia> W=CoxSym(4)\nð”– â‚„\n\njulia> H=hecke(W,Pol(:q))\nhecke(ð”– â‚„,q)\n\njulia> h=Tbasis(H)(longest(W))\nTâ‚â‚‚â‚â‚ƒâ‚‚â‚\n\njulia> p=class_polynomials(h)\n5-element Vector{Pol{Int64}}:\n 0        \n 0        \n qÂ²       \n qÂ³-2qÂ²+q \n qÂ³-qÂ²+q-1\n\nThe class polynomials were introduced in Geck-Pfeiffer1993.\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.HeckeAlgebras.char_values","page":"Gapjm Documentation","title":"Gapjm.HeckeAlgebras.char_values","text":"char_values(h)\n\nh  is an  element of  an Iwahori-Hecke  algebra H  (in any  basis). The function  returns the  values of  the irreducible  characters of H on h (the   method  used  is  to  convert  to   the  T  basis,  and  then  use class_polynomials).\n\njulia> W=coxgroup(:B,2)\nBâ‚‚\n\njulia> H=hecke(W,q^2;rootpara=q)\nhecke(Bâ‚‚,qÂ²,rootpara=q)\n\njulia> char_values(Cpbasis(H)(1,2,1))\n5-element Vector{Pol{Int64}}:\n -q-qâ»Â¹        \n q+qâ»Â¹         \n 0             \n qÂ³+2q+2qâ»Â¹+qâ»Â³\n 0             \n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.HeckeAlgebras.alt","page":"Gapjm Documentation","title":"Gapjm.HeckeAlgebras.alt","text":"alt(a::HeckeTElt)\n\nthe  involution on the Hecke algebra defined by xâ†¦ bar(x) on coefficients and Tâ‚›â†¦ uâ‚›,â‚€uâ‚›,â‚Tâ‚›. Essentially it corresponds to tensoring with the sign representation.\n\njulia> W=coxgroup(:G,2);Pol(:q);H=hecke(W,q)\nhecke(Gâ‚‚,q)\n\njulia> T=Tbasis(H);h=T(1,2)*T(2,1)\nqÂ²T.+(qÂ²-q)Tâ‚+(q-1)Tâ‚â‚‚â‚\n\njulia> alt(h)\nqâ»Â²T.+(qâ»Â²-qâ»Â³)Tâ‚+(qâ»Â³-qâ»â´)Tâ‚â‚‚â‚\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Garside.Î±-Tuple{HeckeTElt}","page":"Gapjm Documentation","title":"Gapjm.Garside.Î±","text":"Î±(a::HeckeTElt)\n\nthe anti-involution on the Hecke algebra defined by T_wâ†¦T_inv(w).\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.HeckeAlgebras.schur_elements","page":"Gapjm Documentation","title":"Gapjm.HeckeAlgebras.schur_elements","text":"schur_elements(H)\n\nreturns the list of Schur elements for the (cyclotomic) Hecke algebra H\n\njulia> H=hecke(ComplexReflectionGroup(4),Pol(:q))\nhecke(Gâ‚„,q)\n\njulia> s=schur_elements(H)\n7-element Vector{Pol{Cyc{Rational{Int64}}}}:\n qâ¸+2qâ·+3qâ¶+4qâµ+4qâ´+4qÂ³+3qÂ²+2q+1              \n 2âˆš-3+(6+4âˆš-3)qâ»Â¹+12qâ»Â²+(6-4âˆš-3)qâ»Â³-2âˆš-3qâ»â´\n -2âˆš-3+(6-4âˆš-3)qâ»Â¹+12qâ»Â²+(6+4âˆš-3)qâ»Â³+2âˆš-3qâ»â´\n 2+2qâ»Â¹+4qâ»Â²+2qâ»Â³+2qâ»â´\n Î¶â‚ƒÂ²âˆš-3qÂ³+(3-âˆš-3)qÂ²+3q+3+âˆš-3-Î¶â‚ƒâˆš-3qâ»Â¹\n -Î¶â‚ƒâˆš-3qÂ³+(3+âˆš-3)qÂ²+3q+3-âˆš-3+Î¶â‚ƒÂ²âˆš-3qâ»Â¹\n qÂ²+2q+2+2qâ»Â¹+qâ»Â²\n\njulia> CycPol.(s)\n7-element Vector{CycPol{Cyc{Rational{Int64}}}}:\n Î¦â‚‚Â²Î¦â‚ƒÎ¦â‚„Î¦â‚†\n 2âˆš-3qâ»â´Î¦â‚‚Â²Î¦â€²â‚ƒÎ¦â€²â‚†\n -2âˆš-3qâ»â´Î¦â‚‚Â²Î¦â€³â‚ƒÎ¦â€³â‚†\n 2qâ»â´Î¦â‚ƒÎ¦â‚„\n Î¶â‚ƒÂ²âˆš-3qâ»Â¹Î¦â‚‚Â²Î¦â€²â‚ƒÎ¦â€³â‚†\n -Î¶â‚ƒâˆš-3qâ»Â¹Î¦â‚‚Â²Î¦â€³â‚ƒÎ¦â€²â‚†\n qâ»Â²Î¦â‚‚Â²Î¦â‚„\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.HeckeAlgebras.FactorizedSchurElement","page":"Gapjm Documentation","title":"Gapjm.HeckeAlgebras.FactorizedSchurElement","text":"FactorizedSchurElement(H,phi)\n\nreturns  the factorized schur_element (see FactorizedSchurElements) of the Hecke  algebra  H  for  the  irreducible  character of H of parameter phi (see charinfo(W)[:charparams])\n\njulia> W=ComplexReflectionGroup(4)\nGâ‚„\n\njulia> @Mvp x,y; H=hecke(W,[[1,x,y]])\nhecke(Gâ‚„,Mvp{Int64, Int64}[1, x, y])\n\njulia> FactorizedSchurElement(H,[[2,5]])\n-xâ»Â¹yÎ¦â‚‚(xy)Î¦â‚(x)Î¦â‚†(xyâ»Â¹)Î¦â‚(y)\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.HeckeAlgebras.FactorizedSchurElements","page":"Gapjm Documentation","title":"Gapjm.HeckeAlgebras.FactorizedSchurElements","text":"FactorizedSchurElements(H)\n\nLet  H be  a Hecke  algebra for  the complex  reflection group W, whose parameters are all (Laurent) monomials in some variables xâ‚,â€¦,xâ‚™, and let K  be the field of definition of W. Then Maria Chlouveraki has shown that the  Schur elements  of H  then take  the particular  form M âˆ_Î¦ Î¦(M_Î¦) where  Î¦ runs over a list of  K-cyclotomic polynomials, and M and M_Î¦ are  (Laurent)  monomials  (in  possibly  some  fractional  powers)  of the variables  xáµ¢.  The  function  FactorizedSchurElements  returns  a data structure which shows this factorization.\n\njulia> W=ComplexReflectionGroup(4)\nGâ‚„\n\njulia> @Mvp x,y; H=hecke(W,[[1,x,y]])\nhecke(Gâ‚„,Mvp{Int64, Int64}[1, x, y])\n\njulia> FactorizedSchurElements(H)\n7-element Vector{Gapjm.HeckeAlgebras.FactSchur}:\n xâ»â´yâ»â´Î¦â‚‚(xy)Î¦â‚Î¦â‚†(x)Î¦â‚Î¦â‚†(y)\n Î¦â‚‚(xÂ²yâ»Â¹)Î¦â‚Î¦â‚†(x)Î¦â‚Î¦â‚†(xyâ»Â¹)\n -xâ»â´yâµÎ¦â‚Î¦â‚†(xyâ»Â¹)Î¦â‚‚(xyâ»Â²)Î¦â‚Î¦â‚†(y)\n -xâ»Â¹yÎ¦â‚‚(xy)Î¦â‚(x)Î¦â‚†(xyâ»Â¹)Î¦â‚(y)\n -xâ»â´yÎ¦â‚‚(xÂ²yâ»Â¹)Î¦â‚(x)Î¦â‚(xyâ»Â¹)Î¦â‚†(y)\n xâ»Â¹yâ»Â¹Î¦â‚†(x)Î¦â‚(xyâ»Â¹)Î¦â‚‚(xyâ»Â²)Î¦â‚(y)\n xâ»Â²yÎ¦â‚‚(xÂ²yâ»Â¹)Î¦â‚‚(xy)Î¦â‚‚(xyâ»Â²)\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.HeckeAlgebras.isrepresentation","page":"Gapjm Documentation","title":"Gapjm.HeckeAlgebras.isrepresentation","text":"isrepresentation(H::HeckeAlgebra,r)\n\nreturns true or false, according to whether a given set r of elements corresponding  to  the  standard  generators  of the reflection group H.W defines a representation of the Hecke algebra H or not.\n\njulia> H=hecke(coxgroup(:F,4))\nhecke(Fâ‚„,1)\n\njulia> isrepresentation(H,reflrep(H))\ntrue\n\njulia> isrepresentation(H,Tbasis(H).(1:4))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.PermRoot.reflrep-Tuple{HeckeAlgebra}","page":"Gapjm Documentation","title":"Gapjm.PermRoot.reflrep","text":"reflrep(H)\n\nreturns  a list of matrices which give the reflection representation of the Iwahori-Hecke algebra H.\n\njulia> Pol(:q);W=coxgroup(:B,2);H=hecke(W,q)\nhecke(Bâ‚‚,q)\n\njulia> reflrep(H)\n2-element Vector{Matrix{Pol{Int64}}}:\n [-1 0; -q q]\n [q -2; 0 -1]\n\njulia> H=hecke(coxgroup(:H,3))\nhecke(Hâ‚ƒ,1)\n\njulia> reflrep(H)\n3-element Vector{Matrix{Cyc{Int64}}}:\n [-1 0 0; -1 1 0; 0 0 1]\n [1 (-3-âˆš5)/2 0; 0 -1 0; 0 -1 1]\n [1 0 0; 0 1 -1; 0 0 -1]\n\n\n\n\n\n","category":"method"},{"location":"#Kazhdan-Lusztig-polynomials-and-bases","page":"Gapjm Documentation","title":"Kazhdan-Lusztig polynomials and bases","text":"","category":"section"},{"location":"","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"KL\nKLPol\nTbasis\nKL.getCp\nCbasis\nCpbasis\ncharacter\nrepresentation(::LeftCell,H)\nWgraph\nLeftCells\nLeftCell\nLusztigaw\nLusztigAw\nAsymptoticAlgebra","category":"page"},{"location":"#Gapjm.KL","page":"Gapjm Documentation","title":"Gapjm.KL","text":"This  module ports Chevie functionality for Kazhdan-Lusztig polynomials and bases.\n\nLet  â„‹ be  the Iwahori-Hecke algebra  of a Coxeter  system (W,S), with quadratic  relations (Tâ‚›-uâ‚›â‚€)(Tâ‚›-uâ‚›â‚)=0  for sâˆˆ  S. If  -uâ‚›â‚€uâ‚›â‚ has a square  root  wâ‚›,  we  can  scale  the  basis  Tâ‚›  to  get  a new basis tâ‚›=-Tâ‚›/wâ‚›    with   quadratic    relations   (tâ‚›-vâ‚›)(tâ‚›+vâ‚›â»Â¹)=0   where vâ‚›=wâ‚›/uâ‚›â‚.   The  most  general  case   when  Kazhdan-Lusztig  bases  and polynomials  can be defined is when the parameters vâ‚› belong to a totally ordered abelian group Î“ for multiplication, see Lusztig1983.  We set  Î“âº= {Î³âˆˆ  Î“âˆ£Î³>0} and Î“â»={Î³â»Â¹âˆ£Î³âˆˆ Î“âº}={Î³âˆˆ Î“âˆ£Î³<0}.\n\nThus  we assume â„‹ defined over the ring â„¤[Î“], the group algebra of Î“ over  â„¤, and the quadratic  relations of â„‹  associate to each sâˆˆ S a vâ‚›âˆˆ  Î“âº such that  (tâ‚›-vâ‚›)(tâ‚›+vâ‚›â»Â¹)=0. We also  set qâ‚›=vâ‚›Â² and define the  basis Tâ‚›=vâ‚›tâ‚› with quadratic relations (Tâ‚›-qâ‚›)(Tâ‚›+1)=0; for wâˆˆ W with reduced expression w=sâ‚â€¦sâ‚™ we define q_w Î“ by q_w^Â½=v_sâ‚v_sâ‚™ and let q_w=(q_w^Â½)Â².\n\nWe  define the bar involution on â„‹  by linearity: on â„¤[Î“] we define it by  overline_Î³ Î“a_Î³Î³= _Î³ Î“ a_Î³ Î³Â¹ and we extend it to â„‹ by  overline  Tâ‚›=Tâ‚›Â¹.  Then  the Kazhdan-Lusztig basis C_w is defined  as  the  only  basis  of  â„‹  stable  by the bar involution and congruent to t_w modulo _w WÎ“ t_w.\n\nThe  basis  C_w  can  be  computed  as  follows.  We  define  elements R_xy  of â„¤[Î“] by  T_yÂ¹=_x overlineR_xyÂ¹ q_xÂ¹T_x. We then  define inductively  the Kazhdan-Lusztig  polynomials (in this general context  we should say the Kazhdan-Lusztig elements of â„¤[Î“], which belong to the subalgebra of â„¤[Î“] generated by the qâ‚›) by P_xw=Ï„_(q_wq_x)^Â½  (_xywR_xyP_yw)  where  Ï„  is the truncation:  Ï„_nu _Î³  Î“ a_Î³Î³=  _Î³nua_Î³Î³; the  induction is thus on decreasing x for the Bruhat order and starts at P_ww=1. We have then C_w=_y q_w^-12 P_ywT_y.\n\nThe  Chevie code  for the  Kazhdan-Lusztig bases  C, D and their primed versions, has been initially written by Andrew Mathas around 1994, who also contributed  to  the  design  of  the programs dealing with Kazhdan-Lusztig bases. He also implemented some other bases, such as the Murphy basis which can  be  found  in  the  Chevie  contributions  directory. The code for the unequal  parameters  case  has  been  written  around  1999  by F.Digne and J.Michel. The other Kazhdan-Lusztig bases are computed in terms of the Câ€² basis.\n\nWhen  the â„¤[Î“] is a  Laurent polynomial ring the  bar operation is taking the  inverse of  the variables,  and truncation  is keeping terms of degree smaller or equal to that of Î½. It is possible to use arbitrary groups Î“ as   long   as   methods   bar:_Î³   Î“   a_Î³Î³  _Î³  Î“  a_Î³Î³Â¹, positive_part  : _Î³  Î“ a_Î³Î³  _Î³ 1  a_Î³Î³ and negative_part: _Î³  Î“  a_Î³Î³    _Î³  1  a_Î³Î³  have been defined on â„¤[Î“]. These operations   will   be   used   internally   by  the  programs  to  compute Kazhdan-Lusztig bases.\n\nfinally, benchmarks on julia 1.0.2\n\njulia> function test_kl(W)\n         q=Pol(); H=hecke(W,q^2,rootpara=q)\n         C=Cpbasis(H); T=Tbasis(H)\n         [T(C(w)) for w in elements(W)]\n       end\ntest_kl (generic function with 1 method)\n\njulia> @btime test_kl(coxgroup(:F,4));\n2.265 s (22516606 allocations: 1.81 GiB)\n\nCompare to GAP3 where the following function takes 11s for F4\n\ntest_kl:=function(W)local q,H,T,C;\n  q:=X(Rationals);H:=Hecke(W,q^2,q);\n  T:=Basis(H,\"T\");C:=Basis(H,\"C'\");\n  List(Elements(W),e->T(C(e)));\nend;\n\nAnother benchmark:\n\nfunction test_kl2(W)\n  el=elements(W)\n  [KLPol(W,x,y) for x in el, y in el]\nend\n\ntest_kl2 (generic function with 1 method)\n\njulia>@btime test_kl2(coxgroup(:F,4));\n  8s (97455915 allocations: 6.79 GiB)\n\nCompare to GAP3 where the following function takes 42s for F4\n\ntest_kl2:=function(W)local el;\n  el:=Elements(W);\n  List(el,x->List(el,y->KazhdanLusztigPolynomial(W,x,y)));\nend;\n\nWe provide also functionality to study the Kazhdan-Lusztig left cells (for the equal-parameter Hecke algebra).\n\njulia> W=coxgroup(:H,3)\nHâ‚ƒ\n\njulia> c=LeftCells(W)\n22-element Vector{LeftCell{FiniteCoxeterGroup{Perm{Int16},Cyc{Int64}}}}:\n LeftCell<Hâ‚ƒ: duflo= character=Ï†â‚â€šâ‚€>\n LeftCell<Hâ‚ƒ: duflo=123 character=Ï†â‚â€šâ‚â‚…>\n LeftCell<Hâ‚ƒ: duflo=(15) character=Ï†â‚…â€šâ‚…>\n LeftCell<Hâ‚ƒ: duflo=(10) character=Ï†â‚…â€šâ‚…>\n LeftCell<Hâ‚ƒ: duflo=(14) character=Ï†â‚…â€šâ‚…>\n LeftCell<Hâ‚ƒ: duflo=7 character=Ï†â‚…â€šâ‚…>\n LeftCell<Hâ‚ƒ: duflo=(12) character=Ï†â‚…â€šâ‚…>\n LeftCell<Hâ‚ƒ: duflo=(9,12) character=Ï†â‚…â€šâ‚‚>\n LeftCell<Hâ‚ƒ: duflo=(5,11) character=Ï†â‚…â€šâ‚‚>\n LeftCell<Hâ‚ƒ: duflo=13 character=Ï†â‚…â€šâ‚‚>\n â‹®\n LeftCell<Hâ‚ƒ: duflo=(8,13) character=Ï†â‚ƒâ€šâ‚†+Ï†â‚ƒâ€šâ‚ˆ>\n LeftCell<Hâ‚ƒ: duflo=(1,15) character=Ï†â‚ƒâ€šâ‚†+Ï†â‚ƒâ€šâ‚ˆ>\n LeftCell<Hâ‚ƒ: duflo=3 character=Ï†â‚ƒâ€šâ‚+Ï†â‚ƒâ€šâ‚ƒ>\n LeftCell<Hâ‚ƒ: duflo=2 character=Ï†â‚ƒâ€šâ‚+Ï†â‚ƒâ€šâ‚ƒ>\n LeftCell<Hâ‚ƒ: duflo=1 character=Ï†â‚ƒâ€šâ‚+Ï†â‚ƒâ€šâ‚ƒ>\n LeftCell<Hâ‚ƒ: duflo=6 character=Ï†â‚„â€šâ‚ƒ+Ï†â‚„â€šâ‚„>\n LeftCell<Hâ‚ƒ: duflo=(13) character=Ï†â‚„â€šâ‚ƒ+Ï†â‚„â€šâ‚„>\n LeftCell<Hâ‚ƒ: duflo=(11) character=Ï†â‚„â€šâ‚ƒ+Ï†â‚„â€šâ‚„>\n LeftCell<Hâ‚ƒ: duflo=9 character=Ï†â‚„â€šâ‚ƒ+Ï†â‚„â€šâ‚„>\n\nsee  also  the  functions  elements,  character,  representation  and Wgraph  for left  cells. The  operations length,  in (which  refer to elements)  and == (which  compares Duflo involutions)  are also defined for  left cells. When Character(c) has been computed, then c.a also has been  bound which holds the common  value of Lusztig's a-function for the elements of c and The irreducible constituents of character(c).\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.KL.KLPol","page":"Gapjm Documentation","title":"Gapjm.KL.KLPol","text":"KLPol(W,y,w) returns the Kazhdan-Lusztig polynomial P_{y,w} of W\n\nTo  compute Kazhdan-Lusztig polynomials in  the one-parameter case it seems that  the best  approach still  is by  using the  recursion formula  in the original  article KL79. One can first run  a number of standard checks on a given  pair  of  elements  to  see  if the computation of the corresponding polynomial  can be reduced to a similar computation for elements of smaller length. One such check involves the notion of critical pairs (cf. Alv87): a pair  of elements wâ‚,wâ‚‚âˆˆ  W such that  wâ‚â‰¤wâ‚‚ is critical  if â„’(wâ‚‚) âŠ† â„’(wâ‚)  and â„› (wâ‚‚)âŠ† â„› (wâ‚), where â„’  and â„› denote the left and right descent  set, respectively.  Now if  yâ‰¤w âˆˆ  W are arbitrary elements then there   always  exists  a  critical  pair   zâ‰¤w  with  yâ‰¤zâ‰¤w  and  then P_yw=P_zw.  Given two elements y and  w, such a critical pair is   found  by  the  function   'critical_pair'.  Whenever  the  polynomial corresponding  to  a  critical  pair  is  computed  then  this pair and the polynomial  are stored in  the property :klpol  of the underlying Coxeter group.\n\njulia> W=coxgroup(:B,3)\nBâ‚ƒ\n\njulia> map(i->map(x->KLPol(W,one(W),x),elements(W,i)),1:W.N)\n9-element Vector{Vector{Pol{Int64}}}:\n [1, 1, 1]\n [1, 1, 1, 1, 1]\n [1, 1, 1, 1, 1, 1, 1]\n [1, 1, 1, x+1, 1, 1, 1, 1]\n [x+1, 1, 1, x+1, x+1, 1, x+1, 1]\n [1, x+1, 1, x+1, x+1, xÂ²+1, 1]\n [x+1, x+1, xÂ²+x+1, 1, 1]\n [xÂ²+1, x+1, 1]\n [1]\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.HeckeAlgebras.Tbasis","page":"Gapjm Documentation","title":"Gapjm.HeckeAlgebras.Tbasis","text":"julia> W=coxgroup(:B,3)\nBâ‚ƒ\n\njulia> Pol(:v);H=hecke(W,v^2,rootpara=v)\nhecke(Bâ‚ƒ,vÂ²,rootpara=v)\n\njulia> C=Cpbasis(H);\n\njulia> T=Tbasis(H);\n\njulia> T(C(1,2))\nvâ»Â²T.+vâ»Â²Tâ‚‚+vâ»Â²Tâ‚+vâ»Â²Tâ‚â‚‚\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.KL.getCp","page":"Gapjm Documentation","title":"Gapjm.KL.getCp","text":"getCp(H,w)\n\nreturn C_w expressed in the basis T of the Hecke algebra H.\n\nImplementation JM and FD 1999. We use the formulae: C_w=Î£_ywP_yw(q)q^-l(w)2T_y and if sww then Câ‚› C_sw=Cw+Î£_yswÎ¼(ysw)Cy=Î£_vwÎ¼áµ¥ Táµ¥ where Î¼áµ¥=P_vw(q)q^-l(w)2+Î£_vyswÎ¼(ysw)P_vy(q)q^-l(y)2 It  follows that if deg(Î¼áµ¥)=-l(v)  then deg(Î¼áµ¥)=-l(v) with leading coefficient  Î¼(vsw) (this happens exactly for y=v in the sum which occurs in the formula for Î¼áµ¥).\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.KL.Cbasis","page":"Gapjm Documentation","title":"Gapjm.KL.Cbasis","text":"Cbasis(H::HeckeAlgebra)\n\nreturns  a function which gives the  C-basis of the Iwahori-Hecke algebra H. The algebra H should have the functon rootpara defined. This basis is  defined as follows (see e.g. (5.1)Lusztig1985). Let W  be the underlying Coxeter group. For  x,y âˆˆ W let P_xy be the corresponding  Kazhdanâ€“Lusztig polynomial. If T_w  w W denotes the usual T-basis, then C_x=sum_yle x(-1)^l(x)-l(y)P_yx(q^-1)q_x^12q_y^-1  T_y for x  âˆˆ W. For example,  we have Câ‚›=qâ‚›â»Â½Tâ‚›-qâ‚›Â½Tâ‚  for s âˆˆ  S. Thus, the transformation matrix between the T-basis and the C-basis is lower unitriangular, with monomials  in qâ‚› along the diagonal.  In the one-parameter case (all qâ‚› are equal to vÂ²) the multiplication rules for the C basis are given by:\n\nCâ‚›â‹…Câ‚“ =-(v+v^-1)Câ‚“, if sx<x, and Câ‚›â‚“+âˆ‘â‚œ Î¼(t,x)Câ‚œ if sx>x.\n\nwhere  the sum is over  all t such that  t<x, l(t)â‰¢l(x)~mod~2 and st<t. The  coefficient Î¼(t,x) is the coefficient of degree (l(x)-l(t)-1)/2 in the Kazhdanâ€“Lusztig polynomial P_xt.\n\njulia> W=coxgroup(:B,3);Pol(:v);H=hecke(W,v^2)\nhecke(Bâ‚ƒ,vÂ²)\n\njulia> T=Tbasis(H);C=Cbasis(H);T(C(1))\n-vT.+vâ»Â¹Tâ‚\n\njulia> C(T(1))\nvÂ²C.+vCâ‚\n\nWe  can  also  compute  character  values  on  elements in the C-basis as follows:\n\njulia> ref=reflrep(H)\n3-element Vector{Matrix{Pol{Int64}}}:\n [-1 0 0; -vÂ² vÂ² 0; 0 0 vÂ²]\n [vÂ² -2 0; 0 -1 0; 0 -vÂ² vÂ²]\n [vÂ² 0 0; 0 vÂ² -1; 0 0 -1]\n\njulia> c=CharTable(H).irr[charinfo(W)[:extRefl][[2]],:]\n1Ã—10 Matrix{Pol{Int64}}:\n 3  2vÂ²-1  vâ¸-2vâ´  -3vÂ¹Â²  2vÂ²-1  vâ´  vâ´-2vÂ²  -vâ¶  vâ´-vÂ²  0\n\njulia> hcat(char_values.(C.(classreps(W)),Ref(c))...)\n1Ã—10 Matrix{Pol{Int64}}:\n 3  -v-vâ»Â¹  0  0  -v-vâ»Â¹  2  0  0  1  0\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.KL.Cpbasis","page":"Gapjm Documentation","title":"Gapjm.KL.Cpbasis","text":"Cpbasis(H)\n\nreturns  a function which gives the C'-basis of the Iwahori-Hecke algebra H  (see (5.1)Lusztig1985).  This basis  is defined by C_x= _yxP_yxq_x^-12 T_y for x âˆˆ W. We have C_x=(-1)^l(x)alt(C_x) for all x âˆˆ W (see alt).\n\njulia> W=coxgroup(:B,2);Pol(:v);H=hecke(W,[v^4,v^2])\nhecke(Bâ‚‚,Pol{Int64}[vâ´, vÂ²])\n\njulia> Cp=Cpbasis(H);h=Cp(1)^2\n(vÂ²+vâ»Â²)Câ€²â‚\n\njulia> k=Tbasis(H)(h)\n(1+vâ»â´)T.+(1+vâ»â´)Tâ‚\n\njulia> Cp(k)\n(vÂ²+vâ»Â²)Câ€²â‚\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.KL.character","page":"Gapjm Documentation","title":"Gapjm.KL.character","text":"character(c)\n\nReturns  a list l  such that the  character of c.group  afforded by the left cell c is sum(CharTable(c.group).irr[l]).\n\njulia> c=LeftCells(coxgroup(:G,2))[3]\nLeftCell<Gâ‚‚: duflo=2 character=Ï†â‚‚â€šâ‚+Ï†â€²â‚â€šâ‚ƒ+Ï†â‚‚â€šâ‚‚>\n\njulia> character(c)\n3-element Vector{Int64}:\n 3\n 5\n 6\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Chars.representation-Tuple{LeftCell, Any}","page":"Gapjm Documentation","title":"Gapjm.Chars.representation","text":"representation(c::LeftCell,H)\n\nreturns matrices giving the representation of H on the left cell c.\n\njulia> W=coxgroup(:H,3)\nHâ‚ƒ\n\njulia> c=LeftCells(W)[3]\nLeftCell<Hâ‚ƒ: duflo=(15) character=Ï†â‚…â€šâ‚…>\n\njulia> @Mvp q;H=hecke(W,q)\nhecke(Hâ‚ƒ,q)\n\njulia> representation(c,H)\n3-element Vector{Matrix{Mvp{Int64, Rational{Int64}}}}:\n [-1 0 â€¦ 0 0; 0 -1 â€¦ 0 qÂ½; â€¦ ; 0 0 â€¦ q 0; 0 0 â€¦ 0 q]\n [-1 qÂ½ â€¦ 0 0; 0 q â€¦ 0 0; â€¦ ; 0 0 â€¦ -1 0; 0 qÂ½ â€¦ 0 -1]\n [q 0 â€¦ 0 0; qÂ½ -1 â€¦ 0 0; â€¦ ; 0 0 â€¦ q 0; 0 0 â€¦ 0 -1]\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.KL.Wgraph","page":"Gapjm Documentation","title":"Gapjm.KL.Wgraph","text":"Wgraph(c::LeftCell)\n\nreturn the W-graph for a left cell for the one-parameter Hecke algebra of a finite Coxeter group. \n\n\n\n\n\nWgraph(W::CoxeterGroup,i)\n\nreturn the W-graph for the i-th irreducible representation of W (or of the 1-parameter Hecke algebra of W).\n\nOnly implemented for irreducible groups of type E, F or H.\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.KL.LeftCells","page":"Gapjm Documentation","title":"Gapjm.KL.LeftCells","text":"LeftCells(W[,i]) left cells of W [in i-th 2-sided cell]   for the 1-parameter Hecke algebra hecke(W,q)\n\nThe  program uses precomputed  data(see Geck-Halls 2014) for  exceptional types and for type :A,  so is quite fast for these types (it  takes 13 seconds to compute the  101796 left cells for type Eâ‚ˆ). For other  types, left cells are computed from first principles, thus computing many  Kazhdan-Lusztig polynomials. It takes 60  seconds to compute the left cells of Dâ‚†, for example.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> LeftCells(W)\n4-element Vector{LeftCell{FiniteCoxeterGroup{Perm{Int16},Int64}}}:\n LeftCell<Gâ‚‚: duflo= character=Ï†â‚â€šâ‚€>\n LeftCell<Gâ‚‚: duflo=12 character=Ï†â‚â€šâ‚†>\n LeftCell<Gâ‚‚: duflo=2 character=Ï†â‚‚â€šâ‚+Ï†â€²â‚â€šâ‚ƒ+Ï†â‚‚â€šâ‚‚>\n LeftCell<Gâ‚‚: duflo=1 character=Ï†â‚‚â€šâ‚+Ï†â€³â‚â€šâ‚ƒ+Ï†â‚‚â€šâ‚‚>\n\nPrinting such a record displays the character afforded by the left cell and its  Duflo involution; the Duflo involution r  is printed as a subset I of    1:W.N   such    that   r=longest(reflection_subgroup(W,I)),   see describe_involution.\n\nIf  a second argument i is given, the program returns only the left cells which  are in the i-th two-sided cell,  that is whose character is in the i-th family of W (see \"Families of unipotent characters\").\n\njulia> W=coxgroup(:G,2);\njulia> LeftCells(W,1)\n2-element Vector{LeftCell{FiniteCoxeterGroup{Perm{Int16},Int64}}}:\n LeftCell<Gâ‚‚: duflo=2 character=Ï†â‚‚â€šâ‚+Ï†â€²â‚â€šâ‚ƒ+Ï†â‚‚â€šâ‚‚>\n LeftCell<Gâ‚‚: duflo=1 character=Ï†â‚‚â€šâ‚+Ï†â€³â‚â€šâ‚ƒ+Ï†â‚‚â€šâ‚‚>\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.KL.LeftCell","page":"Gapjm Documentation","title":"Gapjm.KL.LeftCell","text":"LeftCell(W,w)\n\nreturns  a  record  describing  the  left  cell  of  W  for  hecke(W,q) containing element w.\n\njulia> W=coxgroup(:E,8)\nEâ‚ˆ\n\njulia> LeftCell(W,W((1:8)...))\nLeftCell<Eâ‚ˆ: duflo=(42,43) character=Ï†â‚ƒâ‚…â€šâ‚‚>\n\n\n\n\n\n","category":"type"},{"location":"#Gapjm.KL.Lusztigaw","page":"Gapjm Documentation","title":"Gapjm.KL.Lusztigaw","text":"Lusztigaw(W,w)\n\nFor  w an element  of the Coxeter  groups W, this  function returns the coefficients  on the irreducible characters of the virtual Character ca_w defined  in 5.10.2 Lusztig1985.  This character has the property that the corresponding almost character is integral and positive.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> l=Lusztigaw(W,W(1))\n6-element Vector{Int64}:\n 0\n 0\n 1\n 0\n 1\n 1\n\njulia> sum(l.*map(i->almostChar(W,i),eachindex(l)))\n[Gâ‚‚]:<Ï†â€²â‚â€šâ‚ƒ>+<Ï†â‚‚â€šâ‚>+<Ï†â‚‚â€šâ‚‚>\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.KL.LusztigAw","page":"Gapjm Documentation","title":"Gapjm.KL.LusztigAw","text":"LusztigAw( <W>, <w>)\n\nFor  <w> an element  of the Coxeter  groups <W>, this  function returns the coefficients  on the irreducible  characters of the  virtual Character cA_w defined  in 5.11.6 Lusztig1985.  This character has the property that the corresponding almost character is integral and positive.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> l=LusztigAw(W,W(1))\n6-element Vector{Int64}:\n 0\n 0\n 0\n 1\n 1\n 1\n\njulia> sum(l.*map(i->almostChar(W,i),eachindex(l)))\n[Gâ‚‚]:<Ï†â€³â‚â€šâ‚ƒ>+<Ï†â‚‚â€šâ‚>+<Ï†â‚‚â€šâ‚‚>\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.KL.AsymptoticAlgebra","page":"Gapjm Documentation","title":"Gapjm.KL.AsymptoticAlgebra","text":"AsymptoticAlgebra(W,i)\n\nThe  asymptotic algebra A associated to  the algebra H=Hecke(W,q) is an algebra   with   basis   tâ‚“_x   W   and   structure  constants t_xt_y=sum_z  Î³_xyz  t_z  given  by:  let  h_xyz  be  the coefficient  of  C_x  C_y  on  C_z. Then h_xyz=Î³_xyz^-1 q^a(z)2+lower terms, where q^a(z)2 is the maximum over x,y of the degree of h_xyz.\n\nThe  algebra A  is the  direct product  of the subalgebras A_mathcal C  generated  by  the  elements  t_x_xmathcal  C, where mathcal C runs over the two-sided cells of W. If mathcal C is the  i-th  two-sided  cell  of  W, the command 'AsymptoticAlgebra(W,i)' returns  the algebra A_mathcal C. Note  that the function a(z) is constant  over  a  two-sided  cell,  equal  to  the  common value of the a-function   attached  to  the  characters   of  the  two-sided  cell  (see 'Character' for left cells).\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> A=AsymptoticAlgebra(W,1)\nAsymptotic Algebra dim.10\n\njulia> b=basis(A)\n10-element Vector{AlgebraElt{AsymptoticAlgebra, Int64}}:\n tâ‚‚\n tâ‚â‚‚\n tâ‚‚â‚â‚‚\n tâ‚â‚‚â‚â‚‚\n tâ‚‚â‚â‚‚â‚â‚‚\n tâ‚\n tâ‚‚â‚\n tâ‚â‚‚â‚\n tâ‚‚â‚â‚‚â‚\n tâ‚â‚‚â‚â‚‚â‚\n\njulia> b*permutedims(b)\n10Ã—10 Matrix{AlgebraElt{AsymptoticAlgebra, Int64}}:\n tâ‚‚      0            tâ‚‚â‚â‚‚            â€¦  0               tâ‚‚â‚â‚‚â‚        0\n tâ‚â‚‚     0            tâ‚â‚‚+tâ‚â‚‚â‚â‚‚          0               tâ‚â‚‚â‚+tâ‚â‚‚â‚â‚‚â‚  0\n tâ‚‚â‚â‚‚    0            tâ‚‚+tâ‚‚â‚â‚‚+tâ‚‚â‚â‚‚â‚â‚‚     0               tâ‚‚â‚+tâ‚‚â‚â‚‚â‚    0\n tâ‚â‚‚â‚â‚‚   0            tâ‚â‚‚+tâ‚â‚‚â‚â‚‚          0               tâ‚+tâ‚â‚‚â‚      0\n tâ‚‚â‚â‚‚â‚â‚‚  0            tâ‚‚â‚â‚‚               0               tâ‚‚â‚          0\n 0       tâ‚â‚‚          0               â€¦  tâ‚â‚‚â‚            0            tâ‚â‚‚â‚â‚‚â‚\n 0       tâ‚‚+tâ‚‚â‚â‚‚      0                  tâ‚‚â‚+tâ‚‚â‚â‚‚â‚       0            tâ‚‚â‚â‚‚â‚\n 0       tâ‚â‚‚+tâ‚â‚‚â‚â‚‚    0                  tâ‚+tâ‚â‚‚â‚+tâ‚â‚‚â‚â‚‚â‚  0            tâ‚â‚‚â‚\n 0       tâ‚‚â‚â‚‚+tâ‚‚â‚â‚‚â‚â‚‚  0                  tâ‚‚â‚+tâ‚‚â‚â‚‚â‚       0            tâ‚‚â‚\n 0       tâ‚â‚‚â‚â‚‚        0                  tâ‚â‚‚â‚            0            tâ‚\n\njulia> CharTable(A)\nCharTable(Asymptotic Algebra dim.10)\n     â”‚2 12 212 1212 21212 1 21 121 2121 12121\nâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nÏ†â€²â‚â€šâ‚ƒâ”‚.  .   .    .     . 1  .  -1    .     1\nÏ†â‚‚â€šâ‚ â”‚1  .   2    .     1 1  .   2    .     1\nÏ†â‚‚â€šâ‚‚ â”‚1  .   .    .    -1 1  .   .    .    -1\nÏ†â€³â‚â€šâ‚ƒâ”‚1  .  -1    .     1 .  .   .    .     .\n\n\n\n\n\n","category":"type"},{"location":"#Garside-monoids-and-groups,-braids.","page":"Gapjm Documentation","title":"Garside monoids and groups, braids.","text":"","category":"section"},{"location":"","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"Garside\nleft_divisors\nleftgcd\nrightgcd\nleftlcm\nrightlcm\nÎ±(::Garside.LocallyGarsideElm)\nÎ±(::GarsideElm,::AbstractVector)\nBrieskorn_normal_form\nDualBraidMonoid\nfraction\nword(::Garside.GarsideMonoid,w)\nword(::Garside.GarsideElm)\nelements(::Garside.LocallyGarsideMonoid,l)\nimage\nconjugating_elt\ncentralizer_gens\nconjcat\nendomorphisms\nPresentation\nshrink","category":"page"},{"location":"#Gapjm.Garside","page":"Gapjm Documentation","title":"Gapjm.Garside","text":"Garside  monoids  are  a  general  class  of monoids whose most famous examples  are the braid and dual braid monoids. The implementation of these last  monoids is  in the  framework of  a general implementation of Garside monoids.\n\nTo  define Garside monoids we first need to introduce some vocabulary about divisibility  in monoids. A left divisor of  x is a d such that there exists  y with x=dy (and then we say  that x is a right multiple of d).  We say that a monoid M  is left cancellable if an equality dx=dy implies  x=y. We define symmetrically  right divisors, left multiples and right cancellability. We say that x is an atom if it has no proper left divisor (that is a d such that x=dy with yâ‰ 1) apart from 1. A left gcd  of x and y is a common left  divisor d of x and y such that any  other common left divisor is a left divisor of d. Similarly a right lcm  of x and  y is a  common multiple which  is a left divisor of any other common multiple.\n\nWe  call Garside a monoid M which:\n\nis left and right cancellable.\nis generated by its atoms,  which are finite in number.\nadmits left and  right  gcds  and  lcms.\nis such that any element has only finitely many left (or right) divisors.\nadmits a Garside element, which is an element Î” whose set of left and right divisors coincide and generate M.\n\nGarside  elements are not  unique, but there  is a unique  minimal one (for divisibility);  we assume a  Garside element Î”  has been chosen. Then the divisors  of Î” are called  the simples of M.  A Garside monoid embeds into  its group of fractions, which is  called a Garside group (a Garside group  may have  several distinct  Garside structures,  as we  will see for Braid groups of finite Coxeter groups).\n\nWe  also implement locally Garside monoids,  which are monoids where lcms do  not always exist, but exist when any common multiple exists; the set of simples  is then not defined using a  Garside element, but by the condition that  they contain the atoms and are  closed under lcms and taking divisors (see  [BDM01]); since it is not ensured by the existence of Î”, one has to add  the condition that  any element is  divisible by finitely many simples (but  the number of simples can be infinite). The main example is the braid monoid of an infinite Coxeter group. It is not known if these monoids embed in  their group of fractions (though that has been proved for braid monoids of Coxeter groups by Paris [Paris01]) and thus computing in the monoid does not help for computing in the group (only the monoid is implemented here).\n\nWhat allows computing with Garside and locally Garside monoids, and Garside groups,  is the fact  that they admit  normal forms â€“-  these normal forms where exhibited for braid monoids of Coxeter groups by Deligne [Del72], who extended previous work of Brieskorn, Saito [BS72] and Garside [Gar69]:\n\n(i) Let  M be a locally Garside monoid and let bâˆˆ M. Then there is a unique maximal left simple divisor Î±(b) of b â€“- any other simple dividing b on the left divides Î±(b) on the left.\n\n(ii) Assume  M is a Garside monoid, Î” is  its Garside element and G is its group  of fractions. Then,  given any element  xâˆˆ G, there  is some power i such that Î”â± xâˆˆ M.\n\nA consequence of (i) is that any element has a canonical decomposition as a product of simples, called its left-greedy normal form. If we define Ï‰(x) by  x=Î±(x)Ï‰(x), then the normal form of x is Î±(x)Î±(Ï‰(x))Î±(Ï‰^2(x))â€¦ We use  the normal form to represent elements  of M, and when M is Garside (ii)  to represent elements  of G: given  xâˆˆ G we  compute the smallest power  i  such  that  Î”â±  xâˆˆ  M,  and  we  represent  x by the couple (i,Î”â»â±x).  We are thus reduced to the case where xâˆˆ M, not divisible by Î”,  where we represent  x by the  sequence of simples which constitutes its normal form. \n\nWe  now describe Artin-Tits braid monoids. Let (W,S) be a Coxeter system, that is W has presentation\n\nâŸ¨sâˆˆ Sâˆ£s^2=1, stsâ‹¯ =tstâ‹¯   (mâ‚›â‚œ factors on each side) for s,tâˆˆ SâŸ©\n\nfor  some Coxeter matrix mâ‚›â‚œ for s,tâˆˆ S. The braid group B associated to (W,S) is the group defined by the presentation\n\nâŸ¨ð¬âˆˆ ð’âˆ£ ð¬ð­ð¬â‹¯ =ð­ð¬ð­â‹¯  (mâ‚›â‚œ factors on each side) for ð¬,ð­âˆˆ ð’âŸ©\n\nThe positive braid monoid Bâº associated to W is the monoid defined by the  presentation above â€“- it identifies to the submonoid of B generated by  ð’ by  the result  of Paris  mentioned above.  This monoid  is locally Garside,  with set of simples  in bijection with elements  of W and atoms the elements of ð’; we will denote by ð– the set of simples, and by ð° â†¦ w  the bijection between simples and elements  of W. The group W has a length  defined  in  terms  of  reduced expressions. Similarly, having only homogeneous relations, Bâº has a natural length function. Then ð– can be characterized  as the subset of the elements  of Bâº of the same length as their image in W.\n\nIf  W is finite, then Bâº is Garside with Garside element the element of ð– whose image is the longest element  of W. A finite Coxeter group is also  a reflection group in  a real vector space,  thus in its complexified V,  and B has also a topological definition as the fundamental group of the  space VÊ³áµ‰áµ/W, where VÊ³áµ‰áµ  is the set of  elements of V which are fixed  by no  non-identity element  of S;  however, we  will not use this here.\n\nGiven a Coxeter group W,\n\nExamples\n\njulia> W=coxgroup(:A,4)\nAâ‚„\n\njulia> B=BraidMonoid(W)\nBraidMonoid(Aâ‚„)\n\nconstructs  the  associated  braid  monoid,  and  then  as  a  function 'B' constructs  elements of the braid monoid (or group when W is finite) from a list of generators.\n\njulia> w=B(1,2,3,4)\n1234\n\njulia> w^3\n121321432.343\n\njulia> word(Î±(w^3))\n9-element Vector{Int64}:\n 1\n 2\n 1\n 3\n 2\n 1\n 4\n 3\n 2\n\njulia> w^4\nÎ”.232432\n\njulia> inv(w)\n(1234)â»Â¹\n\nAs  seen in the fourth  line above, the function  'Î±(b)' returns the simple Î±(b)âˆˆ ð– as an element of W.\n\nHow  an element of  a Garside group  is printed is  controlled by IOcontext ':greedy'.  By default, elements are printed  as fractions aâ»Â¹b where a and  b have no left common divisor. Each  of a and b is printed using its left-greedy normal form, that is a maximal power of the Garside element followed  the rest.  One can  print the  entire element  in the left-greedy normal  from by setting the ':greedy' IOContext; with the same w as above we have:\n\njulia> repr(w^-1,context=IOContext(stdout,:greedy=>true,:limit=>true))\n\"Î”â»Â¹.232432\"\n\nFinally,  repr gives   w  back   in  a   form  which   after  assigning 'B=BraidMonoid(W)' can be input back into Julia:\n\njulia> repr(w)\n\"B(1,2,3,4)\"\n\njulia> repr(w^3)\n\"B(1,2,1,3,2,1,4,3,2,3,4,3)\"\n\njulia> repr(w^-1)\n\"B(-4,-3,-2,-1)\"\n\nIn  general elements of  a Garside monoid  are displayed thus  as a list of their constituting atoms.\n\nWe  now describe the dual braid monoid.  For that, we first give a possible approach  to construct Garside monoids. Given a  group W and a set S of generators  of W as a monoid, we  define the length l(w) as the minimum number of elements of S needed to write w. We then define left divisors of   x  as  the  d   such  that  there  exists   y  with  x=dy  and l(d)+l(y)=l(x).  We say that  wâˆˆ W is  balanced if its  set of left and right  divisors coincide,  is a  lattice (where  upper and lower bounds are lcms and gcds) and generates W. Then we have:\n\nsuppose w is balanced and let [1,w] be its set of divisors (an interval for  the partial order  defined by divisibility).  Then the monoid M with generators  [1,w] and relations  xy=z whenever xy=z  holds in W and l(x)+l(y)=l(z)  is Garside,  with simples  [1,w] and  atoms S.  It is called the interval monoid defined by the interval [1,w].\n\nThe  Artin-Tits braid monoid  is an interval  monoid by taking  for S the Coxeter generators, in which case l is the Coxeter length, and taking for w  the longest element of W. The dual monoid, constructed by Birman, Ko and  Lee  for  type  A  and  by  Bessis  for  all  well-generated complex reflection  groups, is obtained in  a similar way, by  taking this time for S  the set of all reflections, and for w a Coxeter element; then l is the  reflection length  'reflength' (for  well-generated complex reflection groups  whihc are not real S contains only those reflections which divide w  for the  reflection length);  for the  dual monoid  the simples are of cardinality  the  generalized  Catalan  numbers.  An  interval  monoid  has naturally  an inverse morphism from M  to W, called 'EltBraid' which is the  quotient map from the  interval monoid to W  which sends back simple braids to [1,w]. #A  last notable  notion is  reversible monoids.  Since in Chevie we store #only  left normal forms, it is easy to compute left lcms and gcds, but hard #to  compute right ones.  But this becomes  easy to do  if the monoid has an #operation  'reverse', which has the property that  'a' is a left divisor of #'b'  if and only if  'reverse(a)' is a right  divisor of 'reverse(b)'. This #holds  for Artin-Tits  and dual  braid monoids;  Artin-Tits monoids  have a #reverse  operation which consists of reversing a word, written as a list of #atoms.  The dual monoid  also has a  reverse operation defined  in the same #way,  but this operation changes  monoid: it goes from  the dual monoid for #the  Coxeter element w to the dual  monoid for the Coxeter element wâ»Â¹. #The  operations 'RightLcm' and  'RightGcd', as well  quite a few algorithms #have faster implementations if the monoid has a reverse operation.\n\nThis module implements functions to solve the conjugacy problem and compute centralizers  in Garside groups, following the work of Franco, Gebhardt and Gonzalez-Meneses.\n\nTwo  elements w and w' of a monoid  M are conjugate in M if there exists  xâˆˆ M such that wx=xw'; if  M satisfies the Ã–re conditions, it has  a  group  of  fractions  where  this  becomes  xâ»Â¹wx=w',  the  usual definition  of conjugacy. A special case  which is even closer to conjugacy in  the group is if there exists yâˆˆ  M such that w=xy and w'=yx. This relation  is not transitive in general,  but we call cyclic conjugacy the transitive closure of this relation, a restricted form of conjugacy.\n\nThe  next  observation  is  that  if  w,w'  are conjugate in the group of fractions  of the Garside monoid M then  they are conjugate in M, since if  wx=xw' then  there is  a power  Î”â± which  is central and such that xÎ”â±âˆˆ M. Then wxÎ”â±=xÎ”â± w' is a conjugation in M.\n\nThe  crucial observation for solving the  conjugacy problem is to introduce inf(w):=sup{i such  that  Î”â±   divides  w}  and sup(w):=inf{i such  that  w  divides Î”â±}, and to notice  that the number of  conjugates of w with  same inf and sup as w  is finite. Further, a  theorem of Birman shows  that the maximum inf and  minimum sup in a conjugacy class can be achieved simultaneously; the elements  achieving this are called the super summit set of w. Thus a way to  determine if two elements are conjugate  is to find a representative of both  of them in  their super summit  set, and then  solve conjugacy within that  set. This can also be used  to compute the centralizer of an element: if  we consider  the super  summit set  as the  objects of a category whose morphisms are the conjugations by simple elements, the centralizer is given by the endomorphisms of the given object.\n\nWe illustrate this on an example:\n\njulia> b=B(2,1,4,1,4)\n214.14\n\njulia> c=B(1,4,1,4,3)\n14.143\n\njulia> d=conjugating_elt(b,c)\n(1)â»Â¹21321432\n\njulia> b^d\n14.143\n\njulia> centralizer_gens(b)\n3-element Vector{GarsideElm{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:\n 321432.213243\n 21.1\n 4\n\njulia> C=conjcat(b;ss=:ss)\ncategory with 10 objects and 32 generating maps\n\njulia> C.obj\n10-element Vector{GarsideElm{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:\n 1214.4\n 214.14\n 124.24\n 1343.1\n 14.124\n 143.13\n 24.214\n 134.14\n 13.134\n 14.143\n\nThere  is a faster  solution to the  conjugacy problem given in [gebgon10]: for  each bâˆˆ M, they define a  particular simple left divisor of b, its preferred  prefix  such  that  the  operation  sliding which cyclically conjugates  b by  its preferred  prefix, is  eventually periodic, and the period  is contained in the super summit set  of x. We say that x is in its  sliding circuit if some  iterated sliding of x  is equal to x. The set  of sliding  circuits in  a given  conjugacy class  is smaller than the super  summit  set,  thus  allows  to  solve  the conjugacy problem faster. Continuing from the above example,\n\njulia> word(W,preferred_prefix(b))\n2-element Vector{Int64}:\n 2\n 1\n\njulia> b^B(preferred_prefix(b))\n1214.4\n\njulia> b1=b^B(preferred_prefix(b))\n1214.4\n\njulia> C=conjcat(b)\ncategory with 2 objects and 6 generating maps\n\njulia> C.obj\n2-element Vector{GarsideElm{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:\n 1214.4\n 1343.1\n\nFinally,  we have implemented  Hao Zheng's algorithm  to extract roots in a Garside monoid:\n\njulia> W=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> B=BraidMonoid(W)\nBraidMonoid(Aâ‚ƒ)\n\njulia> Pi=B(B.Î´)^2\nÎ”Â²\n\njulia> root(Pi,2)\nÎ”\n\njulia> root(Pi,3)\n1232\n\njulia> root(Pi,4)\n132\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.Garside.left_divisors","page":"Gapjm Documentation","title":"Gapjm.Garside.left_divisors","text":"left_divisors( M, s)\n\nall  the left divisors of the simple element s of the Garside monoid M, as  a vector  of vectors,  where the  i+1-th vector  holds the  divisors of length i in the atoms.\n\njulia> W=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> B=BraidMonoid(W)\nBraidMonoid(Aâ‚ƒ)\n\njulia> map(x->B.(x),Garside.left_divisors(B,W(1,3,2)))\n4-element Vector{Vector{GarsideElm{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}}:\n [.]   \n [1, 3]\n [13]  \n [132] \n\njulia> B=DualBraidMonoid(W)\nDualBraidMonoid(Aâ‚ƒ,c=[1, 3, 2])\n\njulia> map(x->B.(x),Garside.left_divisors(B,W(1,3,2)))\n4-element Vector{Vector{GarsideElm{Perm{Int16}, DualBraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}}:\n [.]                     \n [1, 2, 3, 4, 5, 6]      \n [12, 13, 15, 25, 34, 45]\n [Î´]                     \n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Garside.leftgcd","page":"Gapjm Documentation","title":"Gapjm.Garside.leftgcd","text":"leftgcd(M::LocallyGarsideMonoid,elts...;complements=false)\n\nelts  should be simples of  the monoid M. The  function return the left gcd  d of the elts;  if complements=true, followed by  a tuple of the complements d^-1*elts[1],â€¦\n\n\n\n\n\nleftgcd(aâ‚,â€¦,aâ‚™;complements=false) \n\naâ‚,â€¦,aâ‚™  should be  elements of  the same  (locally) Garside  monoid. The function returns the left gcd d of aâ‚,â€¦,aâ‚™. If complements is true it returns (d,(dâ»Â¹aâ‚,â€¦,dâ»Â¹aâ‚™)).\n\njulia> W=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> B=BraidMonoid(W)\nBraidMonoid(Aâ‚ƒ)\n\njulia> leftgcd(B(2,1,2)^2,B(3,2)^2;complements=true)\n(2, (121.21, 32.2))\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Garside.rightgcd","page":"Gapjm Documentation","title":"Gapjm.Garside.rightgcd","text":"rightgcd(M::LocallyGarsideMonoid,elts...)\n\nelts  should be simples of the monoid  M. The function return the right gcd  d of the elts;  if complements=true, followed by  a tuple of the complements elts[1]*d^-1,â€¦\n\n\n\n\n\nrightgcd(aâ‚,â€¦,aâ‚™;complements=false) \n\naâ‚,â€¦,aâ‚™  should be  elements of  the same  (locally) Garside  monoid. The function returns the right gcd d of aâ‚,â€¦,aâ‚™. If complements is true it returns (d,(aâ‚/d,â€¦,aâ‚™/d)).\n\njulia> W=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> B=BraidMonoid(W)\nBraidMonoid(Aâ‚ƒ)\n\njulia> rightgcd(B(2,1,2)^2,B(3,2)^2;complements=true)\n(2.2, (12.21, 23))\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Garside.leftlcm","page":"Gapjm Documentation","title":"Gapjm.Garside.leftlcm","text":"leftlcm(M::GarsideMonoid,elts...)\n\nelts  should be simples of the monoid  M. The function return the left lcm  m of the elts;  if complements=true, followed by  a tuple of the complements m/elts[1],â€¦\n\n\n\n\n\nleftlcm(aâ‚,â€¦,aâ‚™;complements=false)\n\naâ‚,â€¦,aâ‚™  should  be  elements  of  the  same Garside monoid. The function returns  the least common left multiple  m of aâ‚,â€¦,aâ‚™; if complements is true it returns '(m,(m/aâ‚,â€¦,m/aâ‚™))`.\n\njulia> B=BraidMonoid(coxgroup(:A,3))\nBraidMonoid(Aâ‚ƒ)\n\njulia> leftlcm(B(2,1,2)^2,B(3,2)^2;complements=true)\n(Î”.121, (123, 23.321))\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Garside.rightlcm","page":"Gapjm Documentation","title":"Gapjm.Garside.rightlcm","text":"rightlcm(M::GarsideMonoid,elts...;complements=false)\n\nelts  should be simples of the monoid  M. The function return the right lcm  m of the elts;  if complements=true, followed by  a tuple of the complements elts[1]^-1*m,â€¦\n\n\n\n\n\nrightlcm(aâ‚,â€¦,aâ‚™;complements=false)\n\naâ‚,â€¦,aâ‚™  should  be  elements  of  the  same Garside monoid. The function returns  the least common right multiple  m of aâ‚,â€¦,aâ‚™; if complements is true it returns '(m,(aâ‚â»Â¹m,â€¦,aâ‚™â»Â¹m))`.\n\njulia> B=BraidMonoid(coxgroup(:A,3))\nBraidMonoid(Aâ‚ƒ)\n\njulia> rightlcm(B(2,1,2)^2,B(3,2)^2;complements=true)\n(Î”Â², (321.123, 12321.321))\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Garside.Î±-Tuple{Gapjm.Garside.LocallyGarsideElm}","page":"Gapjm Documentation","title":"Gapjm.Garside.Î±","text":"Î±(b)\n\nFor  b is an element of a  locally Garside monoid, returns the first term in  the normal form of b. This is generalized to any element of a Garside group M, by returning the left gcd of M.Î´ and b.\n\njulia> W=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> b=BraidMonoid(W)(2,1,2,1,1)\n121.1.1\n\njulia> Î±(b)\n121\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.Garside.Î±-Tuple{GarsideElm, AbstractVector{T} where T}","page":"Gapjm Documentation","title":"Gapjm.Garside.Î±","text":"Î±(b,I) find the longest prefix of Garside element b which uses only  b.M.atoms[I]\n\njulia> W=coxgroup(:A,4);B=BraidMonoid(W)\nBraidMonoid(Aâ‚„)\n\njulia> w0=B(longest(W))\nÎ”\n\njulia> Î±(w0,[1,2,3])\n121321\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.Garside.Brieskorn_normal_form","page":"Gapjm Documentation","title":"Gapjm.Garside.Brieskorn_normal_form","text":"Brieskorn_normal_form(b)\n\nBrieskorn  citeBri71 has noticed that if L(b)  is the left descent set of b  (see \"leftdescents\"),  and if  b_(L(b)) is  the right lcm of L(b), then  b_(L(b)) left-divides b. We can  now divide b by b_(L(b)) and continue  this  process  with  the  quotient.  In  this  way,  we obtain an expression  b=b_(Lâ‚)â‹¯ b_(Láµ£)  where Láµ¢=L(b_(Láµ¢)â‹¯  b_(Láµ£)) for  all i, which   we  call  the   Brieskorn  normal  form   of  b.  The  function Brieskorn_normal_form  returns a  description of  this form, by returning the list of sets L(b) which describe the above decomposition.\n\njulia> W=coxgroup(:E,8);B=BraidMonoid(W)\nBraidMonoid(Eâ‚ˆ)\n\njulia> w=B(2,3,4,2,3,4,5,4,2,3,4,5,6,5,4,2,3,4,5,6,7,6,5,4,2,3,4,5,6,7,8)\n2342345423456542345676542345678\n\njulia> Brieskorn_normal_form(w)\n2-element Vector{Vector{Int64}}:\n [2, 3, 4, 5, 6, 7]\n [8]\n\njulia> Brieskorn_normal_form(w^2)\n2-element Vector{Vector{Int64}}:\n [2, 3, 4, 5, 6, 7, 8]\n [2, 3, 4, 5, 6]\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Garside.DualBraidMonoid","page":"Gapjm Documentation","title":"Gapjm.Garside.DualBraidMonoid","text":"Let  W be a well generated complex  reflection group and c be a Coxeter element  of W (if W is a Coxeter group and no c is given a particular one  is chosen  by making  the product  of elements  in a  partition of the Coxeter  diagram in two sets where  elements in each commute pairwise). The result  is the dual braid  monoid determined by W  and c: let w be an element  of W or a sequence  sâ‚,â€¦,sâ‚™ of integers indices of reflections of W.\n\njulia> W=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> B=DualBraidMonoid(W)\nDualBraidMonoid(Aâ‚ƒ,c=[1, 3, 2])\n\njulia> B(2,1,2,1,1)\n12.1.1.1\n\njulia> B(-1,-2,-3,1,1)\n(25.1)â»Â¹1.1\n\n\n\n\n\n","category":"type"},{"location":"#Gapjm.Garside.fraction","page":"Gapjm Documentation","title":"Gapjm.Garside.fraction","text":"fraction(b) returns a tuple (x,y)  of two  elements with  no non-trivial  common left divisor and such that b=inv(x)*y.\n\njulia> B=BraidMonoid(coxgroup(:A,3))\nBraidMonoid(Aâ‚ƒ)\n\njulia> b=B( 2, 1, -3, 1, 1)\n(23)â»Â¹321.1.1\n\njulia> fraction(b)\n(23, 321.1.1)\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Groups.word-Tuple{Gapjm.Garside.GarsideMonoid, Any}","page":"Gapjm Documentation","title":"Gapjm.Groups.word","text":"word(M::GarsideMonoid,w)\n\nreturns a word in the atoms of M representing the simple w\n\njulia> B=BraidMonoid(coxgroup(:A,3))\nBraidMonoid(Aâ‚ƒ)\n\njulia> word(B,B.Î´)\n6-element Vector{Int64}:\n 1\n 2\n 1\n 3\n 2\n 1\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.Groups.word-Tuple{GarsideElm}","page":"Gapjm Documentation","title":"Gapjm.Groups.word","text":"word(b::GarsideElm) returns  a description  of b  as a  list of  the atoms  of which  it is a product.  If b is in the Garside group  but not the Garside monoid, it is represented  in  fraction  normal  form  where  as a special convention the inverses  of  the  atoms  are  represented  by  negating  the corresponding integer.\n\njulia> B=BraidMonoid(coxgroup(:A,3))\nBraidMonoid(Aâ‚ƒ)\n\njulia> b=B(2,1,2,1,1)*inv(B(2,2))\n(21)â»Â¹1.12.21\n\njulia> word(b)\n7-element Vector{Int64}:\n -1\n -2\n  1\n  1\n  2\n  2\n  1\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.Groups.elements-Tuple{Gapjm.Garside.LocallyGarsideMonoid, Any}","page":"Gapjm Documentation","title":"Gapjm.Groups.elements","text":"elements(M,l)\n\nM  should  be  a  (locally)  Garside  monoid which has an additive length function  (that is, a product  of l atoms is  not equal to any product of less  than l atoms). GarsideWords(M,l) returns  the list of elements of length l in M.\n\njulia> M=BraidMonoid(coxgroup(:A,2))\nBraidMonoid(Aâ‚‚)\n\njulia> elements(M,4)\n12-element Vector{GarsideElm{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:\n 12.21\n 21.12\n 1.1.1.1\n 2.2.2.2\n 1.1.12\n 1.12.2\n 12.2.2\n 2.2.21\n 21.1.1\n 2.21.1\n Î”.1\n Î”.2\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.Garside.image","page":"Gapjm Documentation","title":"Gapjm.Garside.image","text":"image(b::GarsideElm)\n\nThis  function is defined only if b  is an element of an interval monoid, for instance a braid. It returns the image of b in the group of which the monoid  is an interval  monoid. For instance  it gives the  projection of a braid in an Artin monoid back to the Coxeter group.\n\njulia> W=CoxSym(4)\nð”– â‚„\n\njulia> b=BraidMonoid(W)(2,1,2,1,1)\n121.1.1\n\njulia> p=image(b)\nPerm{UInt8}: (1,3)\n\njulia> word(W,p)\n3-element Vector{Int64}:\n 1\n 2\n 1\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Garside.conjugating_elt","page":"Gapjm Documentation","title":"Gapjm.Garside.conjugating_elt","text":"conjugating_elt(b,b1[,F];ss=:sc)\n\nb  and b1 should  be elements of  the same Garside  group. The function returns  a such that b^a=b1 if such exists, and nothing otherwise. If an  argument ss  is given,  the computation  is done in the corresponding category  â€“- see \"conjcat\".  If an argument  F is given  it should be an automorphism  of the braid monoid, like the Frobenius of a reflection coset attached  to b.M.W;  the computation  is then  done in  the corresponding F-conjugacy category.\n\njulia> W=coxgroup(:D,4)\nDâ‚„\n\njulia> B=BraidMonoid(W)\nBraidMonoid(Dâ‚„)\n\njulia> b=B(2,3,1,2,4,3);b1=B(1,4,3,2,2,2)\n1432.2.2\n\njulia> conjugating_elt(b,b1)\n(134312.23)â»Â¹\n\njulia> c=conjugating_elt(b,b1;ss=:cyc)\n232.2\n\njulia> b^c\n1432.2.2\n\njulia> WF=spets(W,Perm(1,2,4))\nÂ³Dâ‚„\n\njulia> F=Frobenius(WF);\n\njulia> c=B(3,4,3,1,2,3)\n343123\n\njulia> conjugating_elt(b,c,F)\n124312\n\njulia> ^(b,B(1,2,4,3,1,2),F)\n343123\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Garside.centralizer_gens","page":"Gapjm Documentation","title":"Gapjm.Garside.centralizer_gens","text":"centralizer_gens(b[,F];ss=:sc)\n\na  list of generators of the centralizer of b. The computation is done by computing  the  endomorphisms  of  the  object  b  in the category of its sliding  circuits. If an argument ss is given, the computation is done in the corresponding category â€“- see conjcat.\n\nIf  an argument  F is  given it  should be  an automorphism  of the braid monoid,  like the Frobenius of a reflection coset attached to b.M.W; then the F-centralizer is computed.\n\njulia> W=coxgroup(:D,4)\nDâ‚„\n\njulia> B=BraidMonoid(W)\nBraidMonoid(Dâ‚„)\n\njulia> w=B(4,4,4)\n4.4.4\n\njulia> cc=centralizer_gens(w)\n8-element Vector{GarsideElm{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:\n 1\n (31432)â»Â¹231432\n (1)â»Â¹34.431\n (2)â»Â¹34.432\n (32431)â»Â¹132431\n 4\n 34.43\n 2\n\njulia> shrink(cc)\n5-element Vector{GarsideElm{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:\n 4            \n 2            \n 1            \n 34.43        \n (3243)â»Â¹13243\n\njulia> centralizer_gens(w;ss=:cyc)\nSet{GarsideElm{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}} with 1 element:\n  4\n\njulia> F=Frobenius(spets(W,Perm(1,2,4)));\n\njulia> centralizer_gens(w,F)\n2-element Vector{GarsideElm{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:\n 124      \n 312343123\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Garside.conjcat","page":"Gapjm Documentation","title":"Gapjm.Garside.conjcat","text":"'conjcat(b[,F];ss=:sc)'\n\nreturns  the conjugacy category  of the summit  set of b  of the required type.  By default,  computes the  category of  sliding circuits  of b. If ss==:ss,  computes  the  super  summit  set.  If ss==:cyc, computes the cyclic  conjugacy category. Finally, if ss==:inf computes the category of all conjugate elements with same Inf as b.\n\nIf  an argument  F is  given it  should be  the Frobenius of a Reflection coset attached to b.M.W. Then the F-conjugacy category is returned.\n\njulia> W=coxgroup(:A,4)\nAâ‚„\n\njulia> w=BraidMonoid(W)(4,3,3,2,1)\n43.321\n\njulia> conjcat(w)\ncategory with 2 objects and 4 generating maps\n\njulia> conjcat(w).obj\n2-element Vector{GarsideElm{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:\n 32143\n 21324\n\njulia> conjcat(w;ss=:ss).obj\n4-element Vector{GarsideElm{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:\n 32143\n 13243\n 21432\n 21324\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Garside.endomorphisms","page":"Gapjm Documentation","title":"Gapjm.Garside.endomorphisms","text":"endomorphisms(C,o)  for category C, returns generators of the endomorphisms of C.obj[o]\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Presentations.Presentation","page":"Gapjm Documentation","title":"Gapjm.Presentations.Presentation","text":"Presentation( G::FpGroup[, printlevel])\n\nPresentation returns a presentation containing a copy of the presentation of the given finitely presented group G on the same set of generators.\n\nThe  optional printlevel parameter  can be used  to restrict or to extend the  amount of output provided by Tietze transformation functions when being applied  to the created  presentation. The default  value 1 is designed for interactive  use and implies  explicit messages to  be displayed by most of these  functions. A  printlevel value  of 0  will suppress these messages, whereas a printlevel value of 2 will enforce some additional output.\n\n\n\n\n\nPresentation(M)\n\nM  should be a  Garside monoid. Presentation  returns a presentation of the  corresponding Garside group  (the presentation is  as given in theorem 4.1 of Dehornoy-Paris 1999.\n\njulia> M=DualBraidMonoid(coxgroup(:A,3))\nDualBraidMonoid(Aâ‚ƒ,c=[1, 3, 2])\n\njulia> p=Presentation(M)\n<< presentation with 6 gens and 15 rels of total length 62 >>\n\njulia> Presentations.DisplayPresentation(p)\n1: ab=da\n2: ac=ca\n3: ec=cb\n4: bd=da\n5: bd=ab\n6: cd=fc\n7: ae=fa\n8: be=cb\n9: be=ec\n10: de=ed\n11: ef=fa\n12: df=fc\n13: df=cd\n14: ef=ae\n15: def=acb\n\njulia> simplify(p)\n<< presentation with 3 generators, 4 relators of total length 26>>\n<< presentation with 3 generators, 3 relators of total length 16>>\n\njulia> Presentations.DisplayPresentation(p)\n1: ab=ba\n2: cac=aca\n3: cbc=bcb\n\n\n\n\n\n","category":"type"},{"location":"#Gapjm.Garside.shrink","page":"Gapjm Documentation","title":"Gapjm.Garside.shrink","text":"shrink(l)\n\nThe  list l is a  list of  elements of  the same Garside group G. This function  tries to find  another set of  generators of the  subgroup of G generated by the elements of l, of smaller total length (the length being counted  as returned by the function  word).\n\njulia> B=BraidMonoid(CoxSym(3))\nBraidMonoid(ð”– â‚ƒ)\n\njulia> b=[B(1)^3,B(2)^3,B(-2,-1,-1,2,2,2,2,1,1,2),B(1,1,1,2)]\n4-element Vector{GarsideElm{Perm{UInt8}, BraidMonoid{Perm{UInt8}, CoxSym{UInt8}}}}:\n 1.1.1              \n 2.2.2              \n (1.12)â»Â¹2.2.2.21.12\n 1.1.12             \n\njulia> shrink(b)\n2-element Vector{GarsideElm{Perm{UInt8}, BraidMonoid{Perm{UInt8}, CoxSym{UInt8}}}}:\n 2  \n 1  \n\n\n\n\n\n","category":"function"},{"location":"#Classes/characters-of-reflection-groups","page":"Gapjm Documentation","title":"Classes/characters of reflection groups","text":"","category":"section"},{"location":"","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"Chars\nCharTable\non_chars\ncharinfo\ncharnames\nclassinfo\nfakedegree\nfakedegrees\nrepresentation\nrepresentations\nInductionTable\njInductionTable\nJInductionTable\ndetPerm\nWGraphToRepresentation\npblocks","category":"page"},{"location":"#Gapjm.Chars","page":"Gapjm Documentation","title":"Gapjm.Chars","text":"The  CharTable of a finite complex reflection group W is computed using the  decomposition of W in irreducible  groups (see refltype). For each irreducible  group the character  table is either  computed using recursive formulas  for the infinite series,  or read into the  system from a library file  for the  exceptional types.  Thus, character  tables can  be obtained quickly  even for very large groups  (e.g., Eâ‚ˆ). Similar remarks apply for conjugacy classes.\n\nThe  conjugacy  classes  and  irreducible  characters of irreducible finite complex reflection groups have canonical labelings by certain combinatorial objects;  these labelings are used in the  tables we give. For the classes, these  are partitions or partition tuples  for the infinite series, or, for exceptional  Coxeter  groups,  Carter's  admissible  diagrams Carter1972; for other  primitive  complex  reflection  groups  we  just  use  words  in the generators  to specify  the classes.  For the  characters, these  are again partitions  or partition tuples for the infinite series, and for the others they  are pairs  of two  integers (d,e)  where d  is the  degree of the character  and  e  is  the  smallest  symmetric  power  of the reflection representation  containing  the  given  character  as  a  constituent  (the b-invariant  of the character). This information is obtained by using the functions classinfo and charinfo. When you display the character table, the canonical labelings for classes and characters are those displayed.\n\nA  typical example  is coxgroup(:A,n),  the symmetric  group ð”–â‚™â‚Šâ‚ where classes and characters are parameterized by partitions of n+1.\n\njulia> W=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> CharTable(W)\nCharTable(Aâ‚ƒ)\n    â”‚1111 211 22 31  4\nâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n1111â”‚   1  -1  1  1 -1\n211 â”‚   3  -1 -1  .  1\n22  â”‚   2   .  2 -1  .\n31  â”‚   3   1 -1  . -1\n4   â”‚   1   1  1  1  1\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> ct=CharTable(W)\nCharTable(Gâ‚‚)\n     â”‚Aâ‚€ AÌƒâ‚ Aâ‚ Gâ‚‚ Aâ‚‚ Aâ‚+AÌƒâ‚\nâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nÏ†â‚â€šâ‚€ â”‚ 1  1  1  1  1     1\nÏ†â‚â€šâ‚† â”‚ 1 -1 -1  1  1     1\nÏ†â€²â‚â€šâ‚ƒâ”‚ 1  1 -1 -1  1    -1\nÏ†â€³â‚â€šâ‚ƒâ”‚ 1 -1  1 -1  1    -1\nÏ†â‚‚â€šâ‚ â”‚ 2  .  .  1 -1    -2\nÏ†â‚‚â€šâ‚‚ â”‚ 2  .  . -1 -1     2\n\njulia> ct.charnames\n6-element Vector{String}:\n \"\\phi_{1,0}\"\n \"\\phi_{1,6}\"\n \"\\phi_{1,3}'\"\n \"\\phi_{1,3}''\"\n \"\\phi_{2,1}\"\n \"\\phi_{2,2}\"\n\njulia> ct.classnames\n6-element Vector{String}:\n \"A_0\"\n \"\\tilde A_1\"\n \"A_1\"\n \"G_2\"\n \"A_2\"\n \"A_1+\\tilde A_1\"\n\nRecall  that our groups acts a reflection group on the vector space V, so have  fake degrees  (see \"fakeDegree\").  The valuation  and degree of these give  two  integers  b,B  for  each  irreducible  character  of  W (see charinf(W)[:b]  and  charinfo(W)[:B]).  For  finite Coxeter groups, the valuation  and degree of  the generic degrees  of the one-parameter generic Hecke  algebra  give  two  more  integers  a,A (see charinfo(W)[:a] and charinfo(W)[:A],   and  Carter1985,  Ch.11. These will also be used in the operations of truncated inductions explained in the chapter \"Reflection subgroups\".\n\nIwahori-Hecke  algebras and  cyclotomic Hecke  algebras also have character tables, see the corresponding chapters.\n\nWe  now describe for each type our conventions for labeling the classes and characters.\n\nType  Aâ‚™ (nâ‰¥0). In this  case we have  W â‰… ð”–â‚™â‚Šâ‚. The classes and characters  are labeled by partitions of n+1. The partition corresponding to  a class describes  the cycle type  for the elements  in that class; the representative   in  '.classtext'   is  the   concatenation  of  the  words corresponding  to each part, and to a part i is associated the product of i-1  consecutive generators (starting one  higher that the last generator used  for the previous  parts). The partition  corresponding to a character describes  the type of  the Young subgroup  such that the trivial character induced  from this  subgroup contains  that character with multiplicity 1 and such that every other character occurring in this induced character has a  higher a-value. Thus, the sign  character corresponds to the partition (1â¿âºÂ¹)  and  the  trivial  character  to  the  partition  (n+1). The character of the reflection representation of W is labeled by (n,1).\n\nType  Bâ‚™  (nâ‰¥2).  In  this  case  W=W(Bâ‚™) is isomorphic to the wreath product  of the cyclic  group of order  2 with the  symmetric group ð”–â‚™. Hence  the classes and characters are  parameterized by pairs of partitions such  that the total sum of their  parts equals n. The pair corresponding to  a class describes the signed cycle type for the elements in that class, as in Carter1972. We use the convention that if (Î»,Î¼) is such a pair then Î» corresponds to the positive and Î¼ to the negative cycles.  Thus, (1â¿,-) and (-,1â¿) label  the trivial class and the class containing  the longest element, respectively. The pair corresponding to an irreducible character is determined via Clifford theory, as follows.\n\nWe  have a semidirect product decomposition W(Bâ‚™)=N â‹Š ð”–â‚™ where N is the standard  n-dimensional  ð”½â‚‚â¿-vector  space.  For  a,b  â‰¥  0 such that n=a+b let Î·_{a,b} be the irreducible character of N which takes value 1  on the first a standard basis vectors and value -1 on the next b standard  basis vectors of N. Then  the inertia subgroup of Î·_{a,b} has the  form T_{a,b}=N.(ð”–_a Ã— ð”–_b) and  we can extend Î·_{a,b} trivially to an  irreducible  character  Î·Ìƒ_{a,b}  of  T_{a,b}.  Let  Î± and Î² be partitions  of a and b, respectively. We take the tensor product of the corresponding  irreducible characters of ð”–_a and ð”–_b and regard this as an  irreducible  character  of  T_{a,b}.  Multiplying this character with Î·Ìƒ_{a,b}  and  inducing  to  W(Bâ‚™)  yields an irreducible character Ï‡= Ï‡_{(Î±,Î²)}  of W(Bâ‚™). This defines the correspondence between irreducible characters and pairs of partitions as above.\n\nFor example, the pair ((n),-) labels the trivial character and (-,(1â¿)) labels  the  sign  character.  The  character  of  the  natural  reflection representation is labeled by ((n-1),(1)).\n\nType  Dâ‚™ (nâ‰¥4). In this case W=W(Dâ‚™) can be embedded as a subgroup of index  2 into the Coxeter  group W(Bâ‚™). The intersection  of a class of W(Bâ‚™) with W(Dâ‚™) is either empty or a single class in W(Dâ‚™) or splits up  into two classes in  W(Dâ‚™). This also leads  to a parameterization of the  classes of W(Dâ‚™) by pairs of  partitions (Î»,Î¼) as before but where the  number of parts of Î¼ is even and where there are two classes of this type  if Î¼ is empty and all parts of  Î» are even. In the latter case we denote  the two classes in W(Dâ‚™) by (Î»,+) and (Î»,-), where we use the convention  that  the  class  labeled  by (Î»,+) contains a representative which  can be written  as a word  in {sâ‚,sâ‚ƒ,â€¦,sâ‚™} and  (Î»,-) contains a representative which can be written as a word in {sâ‚‚,sâ‚ƒ, â€¦,sâ‚™}.\n\nBy  Clifford theory the restriction of  an irreducible character of W(Bâ‚™) to  W(Dâ‚™)  is  either  irreducible  or  splits  up  into  two irreducible components.  Let (Î±,Î²) be  a pair of  partitions with total  sum of parts equal to n. If Î±!=Î² then the restrictions of the irreducible characters of  W(Bâ‚™) labeled  by (Î±,Î²)  and (Î²,Î±)  are irreducible and equal. If Î±=Î²  then the restriction of the character labeled by (Î±,Î±) splits into two  irreducible components  which we  denote by  (Î±,+) and (Î±,-). Note that  this can only happen if n is  even. In order to fix the notation we use  a  result  of  Stembridge1989  which describes the value  of the  difference of  these two  characters on  a class of the form (Î»,+)  in terms of the character values of the symmetric group ð”–_{n/2}. Recall  that it is implicit  in the notation (Î»,+)  that all parts of Î» are even. Let Î»' be the partition of n/2 obtained by dividing each part by  2. Then the value of Ï‡_{(Î±,-)}-Ï‡_{(Î±,+)} on an element in the class (Î»,+) is given by 2^{k(Î»)} times the value of the irreducible character of  ð”–_{n/2} labeled by Î± on the class of cycle type Î»'. (Here, k(Î») denotes the number of non-zero parts of Î».)\n\nThe  labels for the trivial, the  sign and the natural reflection character are the same as for W(Bâ‚™), since these characters are restrictions of the corresponding characters of W(Bâ‚™).\n\nThe groups G(d,1,n). They  are isomorphic to the wreath product of the cyclic group of order d with  the  symmetric  group  ð”–â‚™.  Hence  the  classes  and characters are parameterized  by d-tuples of partitions such that the total sum of their parts  equals n. The words chosen  as representatives of the classes are, when d>2, computed in a slightly different way than for Bâ‚™, in order to agree  with the words on which Ram  and Halverson compute the characters of the  Hecke algebra. First the parts of the d partitions are merged in one big  partition and sorted in  increasing order. Then, to  a part i coming from  the j-th partition is  associated the word (l+1â€¦1â€¦ l+1)Ê²â»Â¹l+2â€¦l+i where l is the highest generator used to express the previous part.\n\nThe  d-tuple corresponding to an  irreducible character is determined via Clifford  theory in  a similar  way than  for the  Bâ‚™ case.  The identity character  has the first  partition with one  part equal n  and the other ones  empty. The character of the  reflection representations has the first two  partitions with one part  equal respectively to n-1  and to 1, and the other partitions empty.\n\nThe groups G(de,e,n). They  are normal  subgroups of  index e  in G(de,1,n).  The quotient is cyclic,  generated by the image g  of the first generator of G(de,1,n). The  classes are parameterized as the  classes of G(de,e,n) with an extra information for a component of a class which splits.\n\nAccording  to  Hugues1985,  a  class  C of G(de,1,n) parameterized  by a de-partition (Sâ‚€S_de-1) is in G(de,e,n) if e  divides áµ¢ i _p Sáµ¢p. It  splits in d classes for the largest d  dividing e and all parts of all  Sáµ¢ and such that Sáµ¢ is empty if d  does not divide i. If w is in C then 'gâ± w gâ»â±' for 'i in 0:d-1' are  representatives of the classes of G(de,e,n) which meet C. They are described by appending the integer i to the label for C.\n\nThe  characters are described by Clifford theory. We make g act on labels for  characters of G(de,1,n)  . The action  of g permutes circularly by d  the partitions in the de-tuple.  A character has same restriction to G(de,e,n)  as its transform by g.  The number of irreducible components of its restriction is equal to the order k of its stabilizer under powers of  g.  We  encode  a  character  of  G(de,e,n)  by first, choosing the smallest  for lexicographical order label  of a character whose restriction contains  it; then this label is periodic with a motive repeated k times; we  represent the  character by  one of  these motives,  to which we append E(k)â± for 'i in 0:k-1' to describe which component of the restriction we choose.\n\nTypes Gâ‚‚ and Fâ‚„. The matrices of character values and the orderings and labelings  of  the  irreducible  characters  are  exactly  the  same  as in Carter1985,  p.412/413:  in  type  Gâ‚‚  the  character Ï†â‚,â‚ƒ'  takes the value -1 on the reflection associated to the long simple root;  in type Fâ‚„, the characters Ï†â‚,â‚â‚‚', Ï†â‚‚,â‚„', Ï†â‚„,â‚‡', Ï†â‚ˆ,â‚‰' and Ï†â‚‰,â‚†' occur in the induced of the identity from the Aâ‚‚ corresponding to the  short  simple  roots;  the  pairs  (Ï†â‚‚,â‚â‚†',  Ï†â‚‚,â‚„â€³)  and (Ï†â‚ˆ,â‚ƒ', Ï†â‚ˆ,â‚‰â€³)  are  related  by  tensoring  by  sign; and finally Ï†â‚†,â‚†â€³ is the exterior  square of the  reflection representation. Note,  however, that we put  the long root at  the left of the  Dynkin diagrams to be in accordance with the conventions in Lusztig1985, (4.8) and (4.10).\n\nThe classes are labeled by Carter's admissible diagrams Carter1972.  A character  is labeled  by a pair (d,b) where  d denotes the  degree and b  the corresponding b-invariant. If there  are several characters with the same  pair (d,b) we attach a prime to them, as in Carter1985.\n\nTypes  Eâ‚†,Eâ‚‡,Eâ‚ˆ. The character  tables are obtained  by specialization of those  of the Hecke algebra. The classes are labeled by Carter's admissible diagrams Carter1972. A character is labeled by the pair (d,b)  where  d  denotes  the  degree  and  b  is  the  corresponding b-invariant.  For  these  types,  this  gives  a  unique  labeling of the characters.\n\nNon-crystallographic  types Iâ‚‚(m), Hâ‚ƒ, Hâ‚„. In these cases we do not have  canonical  labelings  for  the  classes.  We  label  them  by reduced expressions.\n\nEach  character for  type Hâ‚ƒ  is uniquely  determined by the pair (d,b) where  d is the degree and  b the corresponding b-invariant. For type Hâ‚„  there are just  two characters (those  of degree 30)  for which the corresponding  pairs are  the same.  These two  characters are nevertheless distinguished  by  their  fake  degrees:  the  character Ï†â‚ƒâ‚€,â‚â‚€' has fake degree  qÂ¹â°+qÂ¹Â²+ higher terms, while Ï†â‚ƒâ‚€,â‚â‚€â€³ has fake degree qÂ¹â°+qÂ¹â´+ higher  terms. The characters in the table for type Hâ‚„ are ordered in the same way as in Alvis and Lusztig1982.\n\nFinally,  the characters  of degree 2  for type  Iâ‚‚(m) are  ordered as follows.  The matrix representations affording the characters of degree 2 are given by: Ï_j  sâ‚sâ‚‚  beginpmatrixE(m)^j00E(m)^-jendpmatrix  sâ‚beginpmatrix0110endpmatrix where  1 â‰¤ j â‰¤  âŒŠ(m-1)/2âŒ‹. The reflection representation is  Ïâ‚. The  characters in  the table  are ordered by listing first the characters of degree 1 and then Ïâ‚,Ïâ‚‚,â€¦.\n\nPrimitive complex reflection groups Gâ‚„ to Gâ‚ƒâ‚„. The  groups Gâ‚‚â‚ƒ=Hâ‚ƒ, Gâ‚‚â‚ˆ=Fâ‚„, Gâ‚ƒâ‚€=Hâ‚„ are exceptional Coxeter groups and have  been  explained  above.  Similarly  for  the  other groups labels for characters  consist primarily  of the  pair (d,b)  where d  denotes the degree  and b is the corresponding  b-invariant. This is sufficient for Gâ‚„,  Gâ‚â‚‚, Gâ‚‚â‚‚ and Gâ‚‚â‚„. For other  groups there are pairs or triples of  characters which  have the  same (d,b)  value. We  disambiguate these according  to  the  conventions  of Malle2000 for Gâ‚‚â‚‡, Gâ‚‚â‚‰, Gâ‚ƒâ‚, Gâ‚ƒâ‚ƒ and Gâ‚ƒâ‚„:\n\nFor Gâ‚‚â‚‡:\n\nThe  fake degree  of Ï†â‚ƒ,â‚…'  (resp. Ï†â‚ƒ,â‚‚â‚€',  Ï†â‚ˆ,â‚‰â€³) has smaller degree that  of  Ï†â‚ƒ,â‚…â€³  (resp.  Ï†â‚ƒ,â‚‚â‚€â€³,  Ï†â‚ˆ,â‚‰'). The characters Ï†â‚…,â‚â‚…' and Ï†â‚…,â‚†' occur with multiplicity 1 in the induced from the trivial character of  the parabolic subgroup  of type Aâ‚‚  generated by the  first and third generator  (it is asserted mistakenly in Malle2000 that Ï†â‚…,â‚†â€³ does not occur in this induced; it occurs with multiplicity 2).\n\nFor Gâ‚‚â‚‰:\n\nThe  character  Ï†â‚†,â‚â‚€â€´  is  the  exterior  square  of Ï†â‚„,â‚; its complex conjugate  is Ï†â‚†,â‚â‚€â—. The  character Ï†â‚â‚…,â‚„â€³ occurs  in Ï†â‚„,â‚âŠ—Ï†â‚„,â‚ƒ; the character  Ï†â‚â‚…,â‚â‚‚â€³  is  tensored  by  the  sign  character from Ï†â‚â‚…,â‚„â€³. Finally  Ï†â‚†,â‚â‚€' occurs in  the induced from  the trivial character of the standard parabolic subgroup of type Aâ‚ƒ generated by the first, second and fourth generators.\n\nFor Gâ‚ƒâ‚:\n\nThe  characters Ï†â‚â‚…,â‚ˆ', Ï†â‚â‚…,â‚‚â‚€' and Ï†â‚„â‚…,â‚ˆâ€³ occur in Ï†â‚„,â‚âŠ—Ï†â‚‚â‚€,â‚‡; the character   Ï†â‚‚â‚€,â‚â‚ƒ'  is  complex  conjugate  of  Ï†â‚‚â‚€,â‚‡;  the  character Ï†â‚„â‚…,â‚â‚‚'  is tensored by sign of Ï†â‚„â‚…,â‚ˆ'. The two terms of maximal degree of  the fakedegree of Ï†â‚ƒâ‚€,â‚â‚€' are  qâµâ°+qâ´â¶ while for Ï†â‚ƒâ‚€,â‚â‚€â€³ they are qâµâ°+2qâ´â¶.\n\nFor Gâ‚ƒâ‚ƒ:\n\nThe  terms of  maximal degree  of the  fakedegree of Ï†â‚â‚€,â‚ˆ' are qÂ²â¸+qÂ²â¶ while  for Ï†â‚â‚€,â‚ˆ' they are qÂ²â¸+qÂ²â´. The  terms of maximal degree of the fakedegree   of  Ï†â‚„â‚€,â‚…'  are  qÂ³Â¹+qÂ²â¹   while  for  Ï†â‚„â‚€,â‚…â€³  they  are qÂ³Â¹+2qÂ²â¹.  The character  Ï†â‚â‚€,â‚â‚‡' is  tensored by  sign of Ï†â‚â‚€,â‚ˆ' and Ï†â‚„â‚€,â‚â‚„' is tensored by sign of Ï†â‚„â‚€,â‚…'.\n\nFor Gâ‚ƒâ‚„:\n\nThe  character Ï†â‚‚â‚€,â‚ƒâ‚ƒ' occurs in Ï†â‚†,â‚âŠ—Ï†â‚â‚…,â‚â‚„. The character Ï†â‚‡â‚€,â‚‰' is rational.  The character  Ï†â‚‡â‚€,â‚‰â€³ occurs  in Ï†â‚†,â‚âŠ—Ï†â‚â‚…,â‚â‚„.  The character Ï†â‚‡â‚€,â‚„â‚…'   is  rational.The   character  Ï†â‚‡â‚€,â‚„â‚…â€³   is  tensored  by  the determinant  character of  Ï†â‚‡â‚€,â‚‰â€³. The  character Ï†â‚…â‚†â‚€,â‚â‚ˆ' is rational. The character Ï†â‚…â‚†â‚€,â‚â‚ˆâ€´ occurs in Ï†â‚†,â‚âŠ—Ï†â‚ƒâ‚ƒâ‚†,â‚â‚‡. The character Ï†â‚‚â‚ˆâ‚€,â‚â‚‚' occurs    in   Ï†â‚†,â‚âŠ—Ï†â‚ƒâ‚ƒâ‚†,â‚â‚‡.   The   character   Ï†â‚‚â‚ˆâ‚€,â‚ƒâ‚€â€³   occurs   in Ï†â‚†,â‚âŠ—Ï†â‚ƒâ‚ƒâ‚†,â‚â‚‡.  The  character  Ï†â‚…â‚„â‚€,â‚‚â‚'  occurs  in Ï†â‚†,â‚âŠ—Ï†â‚â‚€â‚…,â‚‚â‚€. The character  Ï†â‚â‚€â‚…,â‚ˆ' is  complex conjugate  of Ï†â‚â‚€â‚…,â‚„,  and Ï†â‚ˆâ‚„â‚€,â‚â‚ƒ' is complex  conjugate  of  Ï†â‚ˆâ‚„â‚€,â‚â‚.  The  character  Ï†â‚ˆâ‚„â‚€,â‚‚â‚ƒ'  is  complex conjugate  of  Ï†â‚ˆâ‚„â‚€,â‚â‚‰.  Finally  Ï†â‚â‚‚â‚€,â‚‚â‚'  occurs  in induced from the trivial character of the standard parabolic subgroup of type Aâ‚… generated by the generators of Gâ‚ƒâ‚„ with the third one omitted.\n\nFor  the groups Gâ‚… and Gâ‚‡ we  adopt the following conventions. For Gâ‚… they are compatible with those of MalleRouquier2003 and BroueMalleMichel2014.\n\nFor Gâ‚…:\n\nWe  let W=ComplexReflectionGroup(5),  so the  generators are  W(1) and W(2).\n\nThe  character Ï†â‚,â‚„' (resp. Ï†â‚,â‚â‚‚', Ï†â‚‚,â‚ƒ') takes the value 1 (resp. Î¶â‚ƒ,  -Î¶â‚ƒ)  on  W(1).  The  character  Ï†â‚,â‚ˆâ€³ is complex conjugate to Ï†â‚,â‚â‚†,  and the character  Ï†â‚,â‚ˆ' is complex  conjugate to Ï†â‚,â‚„' . The character  Ï†â‚‚,â‚…â€³ is complex  conjugate to Ï†â‚‚,â‚;  Ï†â‚‚,â‚…' take the value -1 on W(1). The character Ï†â‚‚,â‚‡' is complex conjugate to Ï†â‚‚,â‚…'.\n\nFor Gâ‚‡:\n\nWe  let W=ComplexReflectionGroup(7),  so the  generators are W(1), W(2) and W(3).\n\nThe  characters  Ï†â‚,â‚„'  and  Ï†â‚,â‚â‚€'  take  the value 1 on W(2). The character  Ï†â‚,â‚ˆâ€³ is complex  conjugate to Ï†â‚,â‚â‚†  and Ï†â‚,â‚ˆ' is complex conjugate  to Ï†â‚,â‚„'. The characters Ï†â‚,â‚â‚‚'  and Ï†â‚,â‚â‚ˆ' take the value Î¶â‚ƒ  on W(2). The character Ï†â‚,â‚â‚„â€³ is complex conjugate to Ï†â‚,â‚‚â‚‚ and Ï†â‚,â‚â‚„'  is complex conjugate to Ï†â‚,â‚â‚€'. The character Ï†â‚‚,â‚ƒ' takes the value  -Î¶â‚ƒ on  W(2) and  Ï†â‚‚,â‚â‚ƒ' takes  the value  -1 on W(2). The characters  Ï†â‚‚,â‚â‚â€³, Ï†â‚‚,â‚…â€³, Ï†â‚‚,â‚‡â€´ and  Ï†â‚‚,â‚ are Galois conjugate, as well  as  the  characters  Ï†â‚‚,â‚‡',  Ï†â‚‚,â‚â‚ƒ',  Ï†â‚‚,â‚â‚'  and  Ï†â‚‚,â‚…'. The character  Ï†â‚‚,â‚‰' is complex  conjugate to Ï†â‚‚,â‚â‚…  and Ï†â‚‚,â‚‰â€´ is complex conjugate to Ï†â‚‚,â‚ƒ'.\n\nFinally,  for the remaining groups Gâ‚†, Gâ‚ˆ  to Gâ‚â‚, Gâ‚â‚ƒ to Gâ‚‚â‚, Gâ‚‚â‚…, Gâ‚‚â‚†,  Gâ‚ƒâ‚‚ and Gâ‚ƒâ‚ƒ there are only  pairs of characters with same value (d,b).  We give labels uniformly to these characters by applying in order the following rules :\n\nIf the two characters have  different fake degrees, label Ï†_{d,b}' the  one  whose  fake  degree  is  minimal  for  the  lexicographic  order of  polynomials (starting with the highest term).\nFor the not yet labeled pairs, if only one of the two characters has the  property   that  in  its   Galois  orbit  at   least  one  character  is  distinguished by its (d,b)-invariant, label it Ï†_{d,b}'.\nFor the not yet labeled pairs,  if the minimum of the (d,b)-value (for  the  lexicographic  order  (d,b))  in  the  Galois  orbits  of the two  character  is different, label Ï†_{d,b}' the character with the minimal  minimum.\nWe define now a new invariant  for characters: consider all the pairs of  irreducible   characters  Ï‡  and  Ïˆ  uniquely  determined  by  their  (d,b)-invariant such that Ï† occurs with non-zero multiplicity m in  Ï‡âŠ—Ïˆ.  We define  t(Ï†) to  be the  minimal (for  lexicographic order)  possible list (d(Ï‡),b(Ï‡),d(Ïˆ),b(Ïˆ),m).\n\nFor  the not  yet labeled  pairs, if  the t-invariants are different, label Ï†_{d,b}' the character with the minimal t-invariant.\n\nAfter  applying  the  last  rule  all  the  pairs  will be labelled for the considered  groups. The labelling obtained  is compatible for Gâ‚‚â‚…, Gâ‚‚â‚†, Gâ‚ƒâ‚‚  and Gâ‚ƒâ‚ƒ  with that  of Malle2000  and for Gâ‚ˆ with that described in MalleRouquier2003.\n\nWe  should  emphasize  that  for  all  groups  with  a  few exceptions, the parameters  for characters do  not depend on  any non-canonical choice. The exceptions  are G(de,e,n) with e>1, and Gâ‚…, Gâ‚‡, Gâ‚‚â‚‡, Gâ‚‚â‚ˆ, Gâ‚‚â‚‰ and  Gâ‚ƒâ‚„, groups  which admit  outer automorphisms  preserving the set of reflections,  so choices  of a  particular value  on a particular generator must be made for characters which are not invariant by these automorphisms.\n\nLabels  for the classes. For the exceptional complex reflection groups, the labels  for the classes represent the  decomposition of a representative of the  class as a product of generators, with the additional conventions that 'z'  represents the generator  of the center  and for well-generated groups 'c'  represents a Coxeter element  (a product of the  generators which is a regular element for the highest reflection degree).\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.Chars.CharTable","page":"Gapjm Documentation","title":"Gapjm.Chars.CharTable","text":"CharTable is a structure to hold character tables of groups and Hecke  algebras\n\n\n\n\n\n","category":"type"},{"location":"#Gapjm.Chars.on_chars","page":"Gapjm Documentation","title":"Gapjm.Chars.on_chars","text":"on_chars(G,aut)\n\naut  is an automorphism of  the group G (for  a permutation group, this could  be  given  as  a  permutation  normalizing  G).  The result is the permutation  1:nconjugacy_classes(G) (representing indices of irreducible characters) induced by aut.\n\njulia> WF=rootdatum(\"3D4\")\nÂ³Dâ‚„\n\njulia> on_chars(Group(WF),WF.phi)\n(1,2,7)(8,9,12)\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Chars.charinfo","page":"Gapjm Documentation","title":"Gapjm.Chars.charinfo","text":"charinfo(W)\n\nreturns   information  about  the  irreducible  characters  of  the  finite reflection group W. The result is a Dict with the following entries:\n\n:charparams:  contains  parameters  for  the  irreducible  characters  as described in the introduction. The parameters are tuples with one component for  each irreducible  component of  W (as  given by  refltype). For an irreducible   component  which  is  an  imprimitive  reflection  group  the component  of the charparam is a tuple of partitions (partitions for type :A,  double partitions  for type  :B), and  for a primitive irreducible group it is a pair (d,e) where d is the degree of the character and e is  the  smallest  symmetric  power  of  the  character  of  the reflection representation  which  contains  the  given  character  as  a component. In addition,  there is an ordinal number if more than one character shares the first two invariants.\n\njulia> charinfo(coxgroup(:G,2))[:charparams]\n6-element Vector{Vector{Vector{Int64}}}:\n [[1, 0]]\n [[1, 6]]\n [[1, 3, 1]]\n [[1, 3, 2]]\n [[2, 1]]\n [[2, 2]]\n\n:charnames:  strings describing the  irreducible characters, computed from the charparams. This is the same as charnames(W).\n\n:positionId:  the position of the trivial character in the character table of W.\n\njulia> charinfo(coxgroup(:D,4))[:positionId]\n13\n\n:positionDet:  Contains the position  of the determinant  character in the character   table  of  W. For Coxeter groups this is the sign character.\n\njulia> charinfo(coxgroup(:D,4))[:positionDet]\n4\n\n:extRefl: Only present if W is irreducible, in which case the reflection representation  of W and all its exterior powers are irreducible. It then contains   the  position   of  the   exterior  powers   of  the  reflection representation in the character table.\n\njulia> charinfo(coxgroup(:D,4))[:extRefl]\n5-element Vector{Int64}:\n 13\n 11\n  5\n  3\n  4\n\n:b:   contains  a  list  holding  the  b-function  for  all  irreducible characters  of W, that is,  for each character Ï‡,  the valuation of the fake  degree of Ï‡. The ordering of the result corresponds to the ordering of  the  characters  in  CharTable(W).  The  advantage  of  this function compared  to calling fakeDegrees is that one  does not have to provide an indeterminate,  and that  it may  be much  faster to  compute than the fake degrees.\n\njulia> charinfo(coxgroup(:D,4))[:b]\n13-element Vector{Int64}:\n  6\n  6\n  7\n 12\n  4\n  3\n  6\n  2\n  2\n  4\n  1\n  2\n  0\n\n:B:   contains  a  list  holding  the  B-function  for  all  irreducible characters  of W, that is, for each character Ï‡, the degree of the fake degree  of Ï‡. The ordering  of the result corresponds  to the ordering of the  characters in CharTable(W). The  advantage of this function compared to  calling  fakeDegrees  is  that  one  does  not  have  to  provide  an indeterminate,  and that  it may  be much  faster to  compute than the fake degrees.\n\njulia> charinfo(coxgroup(:D,4))[:B]\n13-element Vector{Int64}:\n 10\n 10\n 11\n 12\n  8\n  9\n 10\n  6\n  6\n  8\n  5\n  6\n  0\n\n:a:  Only  filled  for  Spetsial  groups.  Contains  a  list  holding  the a-function  for  all  irreducible  characters  of  the  Coxeter  group or Spetsial  reflection  group  W,  that  is,  for  each  character Ï‡, the valuation  of the generic degree of Ï‡ (in the one-parameter Hecke algebra hecke(W,Pol(:q))  corresponding  to  W).  The  ordering  of  the result corresponds to the ordering of the characters in CharTable(W).\n\njulia> charinfo(coxgroup(:D,4))[:a]\n13-element Vector{Int64}:\n  6\n  6\n  7\n 12\n  3\n  3\n  6\n  2\n  2\n  3\n  1\n  2\n  0\n\n:A:  Only  filled  for  Spetsial  groups.  Contains  a  list  holding  the A-function  for  all  irreducible  characters  of  the  Coxeter  group or Spetsial  reflection group W, that is, for each character Ï‡, the degree of   the  generic  degree  of  Ï‡  (in  the  one-parameter  Hecke  algebra hecke(W,Pol(:q))  corresponding  to  W).  The  ordering  of  the result corresponds to the ordering of the characters in CharTable(W).\n\njulia> charinfo(coxgroup(:D,4))[:A]\n13-element Vector{Int64}:\n 10\n 10\n 11\n 12\n  9\n  9\n 10\n  6\n  6\n  9\n  5\n  6\n  0\n\n:opdam:  Contains the permutation of  the characters obtained by composing the  Opdam  involution  with  complex  conjugation. This permutation has an interpretation as a Galois action on the characters of H=hecke(W,Pol(:x)):  if H splits  by taking v  an e-th root of x, .opdam records the permutation effected by the Galois action v->E(e)*v.\n\njulia> charinfo(ComplexReflectionGroup(22))[:opdam]\n(3,5)(4,6)(11,13)(12,14)(17,18)\n\njulia> charinfo(coxgroup(:A,2))\nDict{Symbol, Any} with 9 entries:\n  :a           => [3, 1, 0]\n  :b           => [3, 1, 0]\n  :positionId  => 3\n  :charnames   => [\"111\", \"21\", \"3\"]\n  :A           => [3, 2, 0]\n  :B           => [3, 2, 0]\n  :extRefl     => [3, 2, 1]\n  :charparams  => [[[1, 1, 1]], [[2, 1]], [[3]]]\n  :positionDet => 1\n\nFor  irreducible groups, the returned  record contains sometimes additional information:\n\nfor  Fâ‚„: the entry :kondo gives the labeling of the characters given by Kondo, also used in Lusztig1985, (4.10).\n\nfor  Eâ‚†, Eâ‚‡, Eâ‚ˆ: the entry :frame  gives the labeling of the characters given   by  Frame,   also  used   in  Lusztig1985,   (4.11),  (4.12),  and (4.13).\n\nfor  Gâ‚‚: the  entry :spaltenstein  gives the  labeling of the characters given by Spaltenstein.\n\njulia> charinfo(coxgroup(:G,2))[:spaltenstein]\n6-element Vector{String}:\n \"1\"\n \"\\varepsilon\"\n \"\\varepsilon_l\"\n \"\\varepsilon_c\"\n \"\\theta'\"\n \"\\theta''\"\n\nfor  G(de,e,2)  even  e  and  d>1:  the  entry  :malle  gives  the parameters for the characters used by Malle in Malle1996.\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Chars.charnames","page":"Gapjm Documentation","title":"Gapjm.Chars.charnames","text":"charnames(W;options...) charnames(io::IO,W)\n\nreturns  the  list  of  character  names  for the reflection group W. The optional  options are IOContext attributes which can give alternative names in  certain cases, or a different formatting  of names in general. They can be specified by giving an IO as argument.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> charnames(W;limit=true)\n6-element Vector{String}:\n \"Ï†â‚â€šâ‚€\"\n \"Ï†â‚â€šâ‚†\"\n \"Ï†â€²â‚â€šâ‚ƒ\"\n \"Ï†â€³â‚â€šâ‚ƒ\"\n \"Ï†â‚‚â€šâ‚\"\n \"Ï†â‚‚â€šâ‚‚\"\n\njulia> charnames(W;TeX=true)\n6-element Vector{String}:\n \"\\phi_{1,0}\"\n \"\\phi_{1,6}\"\n \"\\phi_{1,3}'\"\n \"\\phi_{1,3}''\"\n \"\\phi_{2,1}\"\n \"\\phi_{2,2}\"\n\njulia> charnames(W;spaltenstein=true,limit=true)\n6-element Vector{String}:\n \"1\"\n \"Îµ\"\n \"Îµâ‚—\"\n \"Îµ_c\"\n \"Î¸â€²\"\n \"Î¸â€³\"\n\njulia> charnames(W;spaltenstein=true,TeX=true)\n6-element Vector{String}:\n \"1\"\n \"\\varepsilon\"\n \"\\varepsilon_l\"\n \"\\varepsilon_c\"\n \"\\theta'\"\n \"\\theta''\"\n\nThe  last two  commands show  the character  names used by Spaltenstein and Lusztig when describing the Springer correspondence.\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Chars.classinfo","page":"Gapjm Documentation","title":"Gapjm.Chars.classinfo","text":"classinfo(W)\n\nreturns  information about the  conjugacy classes of  the finite reflection group W. The result is a Dict with three entries:\n\n:classtext:  contains words in  the generators describing representatives of  each  conjugacy  class.  Each  word  is  a  list  of integers where the generator  sáµ¢  is  represented  by  the  integer  i. For finite Coxeter groups, it is the same as map(x->word(W,representative(x)),conjugacyclasses(W)),   and   each  such representative  is of minimal length in its  conjugacy class and is a \"very good\" element in the sense of GeckMichel1997.\n\n:classparams:  The  elements  of  this  list  are  tuples  which have one component  for each irreducible component of  W. These components for the infinite  series,  contain  partitions  or  partition tuples describing the class  (see  the  introduction).  For  the  exceptional Coxeter groups they contain  Carter's admissible  diagrams, see Carter1972. For  exceptional complex reflection groups they contain in general the same information as in classtext.\n\n:classnames:  Contains strings describing the conjugacy classes, made out of the information in :classparams.\n\njulia> classinfo(coxgroup(:A,2))\nDict{Symbol, Any} with 5 entries:\n  :classes     => [1, 3, 2]\n  :orders      => [1, 2, 3]\n  :classtext   => [Int64[], [1], [1, 2]]\n  :classnames  => [\"111\", \"21\", \"3\"]\n  :classparams => [[1, 1, 1], [2, 1], [3]]\n\nSee also the introduction of this section.\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Chars.fakedegree","page":"Gapjm Documentation","title":"Gapjm.Chars.fakedegree","text":"fakedegree(W, Ï†, q)\n\nreturns  the  fake degree  of  the  character  of parameter  Ï†  (see :CharParams)  of  the  reflection  group W,  evaluated  at  q  (see \"fakeDegrees\" for a definition of the fake degrees).\n\njulia> Chars.fakedegree(coxgroup(:A,2),[[2,1]],Pol(:q))\nPol{Cyc{Int64}}: qÂ²+q\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Chars.fakedegrees","page":"Gapjm Documentation","title":"Gapjm.Chars.fakedegrees","text":"fakedegrees(W , q)\n\nreturns  a list holding the fake degrees of the reflection group W on the vector  space V, evaluated at q. These are the graded multiplicities of the  irreducible characters of W in the quotient SV/I where SV is the symmetric  algebra of V and I is the ideal generated by the homogeneous invariants  of  positive  degree  in  SV.  The  ordering  of  the  result corresponds to the ordering of the characters in 'CharTable(W)'.\n\njulia> fakedegrees(coxgroup(:A,2),Pol(:q))\n3-element Vector{Pol{Int64}}:\n qÂ³\n qÂ²+q\n 1\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Chars.representation","page":"Gapjm Documentation","title":"Gapjm.Chars.representation","text":"representation(c::LeftCell,H)\n\nreturns matrices giving the representation of H on the left cell c.\n\njulia> W=coxgroup(:H,3)\nHâ‚ƒ\n\njulia> c=LeftCells(W)[3]\nLeftCell<Hâ‚ƒ: duflo=(15) character=Ï†â‚…â€šâ‚…>\n\njulia> @Mvp q;H=hecke(W,q)\nhecke(Hâ‚ƒ,q)\n\njulia> representation(c,H)\n3-element Vector{Matrix{Mvp{Int64, Rational{Int64}}}}:\n [-1 0 â€¦ 0 0; 0 -1 â€¦ 0 qÂ½; â€¦ ; 0 0 â€¦ q 0; 0 0 â€¦ 0 q]\n [-1 qÂ½ â€¦ 0 0; 0 q â€¦ 0 0; â€¦ ; 0 0 â€¦ -1 0; 0 qÂ½ â€¦ 0 -1]\n [q 0 â€¦ 0 0; qÂ½ -1 â€¦ 0 0; â€¦ ; 0 0 â€¦ q 0; 0 0 â€¦ 0 -1]\n\n\n\n\n\nrepresentation(W,i)\n\nreturns a list holding, for the i-th irreducible character of the complex reflection  group  W,  a  list  of  matrices  images  of  the  generating reflections  of W  in a  model of  the corresponding representation. This function  is based on the classification,  and is not yet fully implemented for   Gâ‚ƒâ‚„;  78  representations   are  missing  out   of  169,  that  is, representations  of dimension â‰¥140, except half of those of dimensions 315, 420 and 840.\n\njulia> representation(ComplexReflectionGroup(24),3)\n3-element Vector{Matrix{Cyc{Int64}}}:\n [1 0 0; -1 -1 0; -1 0 -1]\n [-1 0 -1; 0 -1 (1-âˆš-7)/2; 0 0 1]\n [-1 -1 0; 0 1 0; 0 (1+âˆš-7)/2 -1]\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Chars.representations","page":"Gapjm Documentation","title":"Gapjm.Chars.representations","text":"representations(W)\n\nreturns the representations of W (see representation).\n\njulia> representations(coxgroup(:B,2))\n5-element Vector{Vector{Matrix{Int64}}}:\n [[1], [-1]]\n [[1 0; -1 -1], [1 2; 0 -1]]\n [[-1], [-1]]\n [[1], [1]]\n [[-1], [1]]\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Chars.InductionTable","page":"Gapjm Documentation","title":"Gapjm.Chars.InductionTable","text":"InductionTable(u,g)\n\nreturns   an  object  describing  the   decomposition  of  the  irreducible characters  of the subgroup  u induced to  the group g.  In the default show method, the rows correspond to the characters of the parent group, and the  columns  to  those  of  the  subgroup.  The  return object has a field scalar  which is a Matrix{Int} containing  the induction table, and the other  fields contain labeling information  taken from the character tables of u and g when it exists.\n\njulia> g=Group([Perm(1,2),Perm(2,3),Perm(3,4)])\nGroup([(1,2),(2,3),(3,4)])\n\njulia> u=Group( [ Perm(1,2), Perm(3,4) ])\nGroup([(1,2),(3,4)])\n\njulia> InductionTable(u,g)\nInduction Table from Group([perm\"(1,2)\",perm\"(3,4)\"]) to Group([perm\"(1,2)\",perm\"(2,3)\",perm\"(3,4)\"])\n   â”‚X.1 X.2 X.3 X.4\nâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nX.1â”‚  .   1   .   .\nX.2â”‚  .   1   1   1\nX.3â”‚  1   1   .   .\nX.4â”‚  1   .   1   1\nX.5â”‚  1   .   .   .\n\njulia> g=coxgroup(:G,2)\nGâ‚‚\n\njulia> u=reflection_subgroup(g,[1,6])\nGâ‚‚â‚â‚â‚…â‚Ž=Aâ‚‚\n\njulia> t=InductionTable(u,g)\nInduction Table from Gâ‚‚â‚â‚â‚…â‚Ž=Aâ‚‚ to Gâ‚‚\n     â”‚111 21 3\nâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€\nÏ†â‚â€šâ‚€ â”‚  .  . 1\nÏ†â‚â€šâ‚† â”‚  1  . .\nÏ†â€²â‚â€šâ‚ƒâ”‚  1  . .\nÏ†â€³â‚â€šâ‚ƒâ”‚  .  . 1\nÏ†â‚‚â€šâ‚ â”‚  .  1 .\nÏ†â‚‚â€šâ‚‚ â”‚  .  1 .\n\nusing an IOContext allows to transmit attributes to the table format method\n\njulia> xprint(t;rows=[5],cols=[3,2])\nInduction Table\n    â”‚3 21\nâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€\nÏ†â‚‚â€šâ‚â”‚.  1\n\nIt is also possible to TeX induction tables\n\nThis function also works for Spets (Reflection Cosets)\n\n\n\n\n\n","category":"type"},{"location":"#Gapjm.Chars.jInductionTable","page":"Gapjm Documentation","title":"Gapjm.Chars.jInductionTable","text":"jInductionTable(H, W)\n\ncomputes  the decomposition  into irreducible  characters of the reflection group  W  of  the  j-induced  of  the  irreducible  characters  of  the reflection  subgroup  H.  The  j-induced  of  Ï†  is  the  sum  of the irreducible  components of the induced of  Ï† which have same b-function (see charinfo) as Ï†. What is returned is an InductionTable struct.\n\njulia> W=coxgroup(:D,4)\nDâ‚„\n\njulia> H=reflection_subgroup(W,[1,3])\nDâ‚„â‚â‚â‚ƒâ‚Ž=Aâ‚‚Î¦â‚Â²\n\njulia> jInductionTable(H,W)\nj-Induction Table from Dâ‚„â‚â‚â‚ƒâ‚Ž=Aâ‚‚Î¦â‚Â² to Dâ‚„\n     â”‚111 21 3\nâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€\n11+  â”‚  .  . .\n11-  â”‚  .  . .\n1.111â”‚  .  . .\n.1111â”‚  .  . .\n11.2 â”‚  .  . .\n1.21 â”‚  1  . .\n.211 â”‚  .  . .\n2+   â”‚  .  . .\n2-   â”‚  .  . .\n.22  â”‚  .  . .\n1.3  â”‚  .  1 .\n.31  â”‚  .  . .\n.4   â”‚  .  . 1\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Chars.JInductionTable","page":"Gapjm Documentation","title":"Gapjm.Chars.JInductionTable","text":"JInductionTable(H, W)\n\ncomputes  the decomposition  into irreducible  characters of the reflection group  W  of  the  J-induced  of  the  irreducible  characters  of  the reflection  subgroup  H.  The  J-induced  of  Ï†  is  the  sum  of the irreducible  components of the induced of  Ï† which have same a-function (see charinfo) as Ï†. What is returned is an InductionTable struct.\n\njulia> W=coxgroup(:D,4)\nDâ‚„\n\njulia> H=reflection_subgroup(W,[1,3])\nDâ‚„â‚â‚â‚ƒâ‚Ž=Aâ‚‚Î¦â‚Â²\n\njulia> JInductionTable(H,W)\nJ-Induction Table from Dâ‚„â‚â‚â‚ƒâ‚Ž=Aâ‚‚Î¦â‚Â² to Dâ‚„\n     â”‚111 21 3\nâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€\n11+  â”‚  .  . .\n11-  â”‚  .  . .\n1.111â”‚  .  . .\n.1111â”‚  .  . .\n11.2 â”‚  1  . .\n1.21 â”‚  1  . .\n.211 â”‚  .  . .\n2+   â”‚  .  . .\n2-   â”‚  .  . .\n.22  â”‚  .  . .\n1.3  â”‚  .  1 .\n.31  â”‚  .  . .\n.4   â”‚  .  . 1\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Chars.detPerm","page":"Gapjm Documentation","title":"Gapjm.Chars.detPerm","text":"detPerm(W)\n\nreturn  the permutation of the characters of the reflection group W which is effected when tensoring by the determinant character (for Coxeter groups this is the sign character).\n\njulia> W=coxgroup(:D,4)\nDâ‚„\n\njulia> detPerm(W)\n(1,8)(2,9)(3,11)(4,13)(7,12)\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Chars.WGraphToRepresentation","page":"Gapjm Documentation","title":"Gapjm.Chars.WGraphToRepresentation","text":"WGraphToRepresentation(coxrank::Integer,graph,v)\n\n(Jean Michel june/december 2003 from  code/data of Geck, Marin, Alvis, Naruse, Howlett,Yin) We  store  some  representations  of  some  Hecke  algebras  with  only one parameter  v as W-graphs. For a  Coxeter system (W,S) where coxrank is  the length of S, a W-graph is  defined by a set of vertices C; to xâˆˆ  C is  attached I(x)âŠ‚  S and  to (x,y)âˆˆ  C^2 is attached an \"edge\" Î¼(x,y)  in the field of definition  of W; this defines a representation of  the Hecke algebra with  single rootparameter v on  a space with basis e_y_y C by:\n\n``Ts(ey)=\\begin{cases}-ey& if sâˆˆ I(y)\\\n       v^2 ey+âˆ‘{xâˆ£sâˆˆ I(x)} vÎ¼(x,y)ex&otherwise\\end{cases}``\n\nThe  W-graphs are  stored in  a compact  format to  save space.  They are represented as a pair.\n\nThe  first element is a list describing C.\n\nIts  elements are  either a  set I(x),  or an  integer n  specifying to repeat the previous element n more times.\n\nThe  second element is a list which  specifies Î¼. \n\nWe   first   describe   the   Î¼-list   for   symmetric  W-graphs  (when Î¼(x,y)=Î¼(y,x)).  There is one  element of the  Î¼-list for each non-zero value m taken by Î¼, which consists of a pair whose first element is m and  whose second element is a list of  lists; if l is one of these lists each  pair [l[1],l[i]]  represents an  edge (x=l[1],y=l[i]) such that Î¼(x,y)=Î¼(y,x)=m.  For non-symmetric W-graphs, the first element of each pair  in the Î¼-list  is a pair  [m1,m2] and each  edge [x,y] obtained from  the lists in the second element  has to be interpreted as Î¼(x,y)=m1 and Î¼(y,x)=m2.\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.pblocks","page":"Gapjm Documentation","title":"Gapjm.pblocks","text":"pblocks(G,p)\n\nLet  p be a prime. This function returns the partition of the irreducible characters  of G  in p-blocks,  represented by  the list  of indices of irreducibles characters in each block.\n\njulia> W=CoxSym(5)\nð”– â‚…\n\njulia> pblocks(W,2)\n2-element Vector{Vector{Int64}}:\n [1, 3, 4, 5, 7]\n [2, 6]\n\njulia> pblocks(W,3)\n3-element Vector{Vector{Int64}}:\n [1, 5, 6]\n [2, 3, 7]\n [4]\n\njulia> pblocks(W,7)\n7-element Vector{Vector{Int64}}:\n [1]\n [2]\n [3]\n [4]\n [5]\n [6]\n [7]\n\n\n\n\n\n","category":"function"},{"location":"#Reductive-groups,-semisimple-elements","page":"Gapjm Documentation","title":"Reductive groups, semisimple elements","text":"","category":"section"},{"location":"","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"Semisimple\nfundamental_group\nQuasiIsolatedRepresentatives(::FiniteCoxeterGroup)\nis_isolated\ntorsion_subgroup\nalgebraic_centre\ncentralizer(::FiniteCoxeterGroup,::SemisimpleElement)\nSScentralizer_reps\nStructureRationalPointsConnectedCentre","category":"page"},{"location":"#Gapjm.Semisimple","page":"Gapjm Documentation","title":"Gapjm.Semisimple","text":"Algebraic groups and semi-simple elements\n\nLet  us fix an  algebraically closed field  K and let  ð† be a connected reductive  algebraic group over K. Let ð“ be a maximal torus of ð†, let X(ð“)  be the  character group  of ð“  (resp. Y(ð“)  the dual lattice of one-parameter  subgroups  of  ð“)  and  Î¦  (resp  Î¦^) the roots (resp. coroots) of ð† with respect to ð“.\n\nThen  ð† is  determined up  to isomorphism  by the  root datum (X(ð“),Î¦, Y(ð“),Î¦^).  In algebraic terms, this consists  in giving a free â„¤-lattice X=X(ð“) of dimension the rank of ð“ (which is also called the rank of ð†),  and a root system Î¦ âŠ‚ X,  and giving similarly the dual roots Î¦^âŠ‚ Y=Y(ð“).\n\nThis  is obtained  by a  slight generalization  of our  setup for a Coxeter group  W. This time we assume the canonical basis of the vector space V on  which W acts is a â„¤-basis of  X, and Î¦ is specified by a matrix 'simpleroots(W)'  whose lines are the simple  roots expressed in this basis of  X. Similarly Î¦^  is described by  a matrix 'simplecoroots(W)' whose lines  are the simple coroots in the basis  of Y dual to the chosen basis of  X. The duality pairing between X and Y is the canonical one, that is  the pairing between vectors xâˆˆ X  and yâˆˆ Y is given by sum(x.*y). Thus, we must have the relation simpleroots(W)*permutedims(simplecoroots(W))=cartan(W).\n\nWe  get that  by a  the function  rootdatum, whose  arguments are the two matrices simpleroots(W) and simplecoroots(W) described above. The roots need  not generate V, so  the matrices need not  be square. For instance, the root datum of the linear group of rank 3 can be specified as:\n\njulia> W=rootdatum([-1 1 0;0 -1 1],[-1 1 0;0 -1 1])\nAâ‚‚Î¦â‚\n\njulia> reflrep(W,W(1))\n3Ã—3 Matrix{Int64}:\n 0  1  0\n 1  0  0\n 0  0  1\n\nhere  the symmetric group on 3 letters  acts by permutation of the basis of X.  The dimension of X (the  length of the vectors in simpleroots(W)) is the rank and the dimension of the subspace generated by the roots (the length  of  simpleroots(W))  is  called  the  semi-simple  rank. In the example the rank is 3 and the semisimple rank is 2.\n\nThe  default form  'W=coxgroup(:A,2)' defines  the adjoint  algebraic group (the  group with a trivial center). In that  case Î¦ is a basis of X, so 'simpleroots(W)'  is  the  identity  matrix  and  'simplecoroots(W)' is the Cartan  matrix 'cartan(W)' of the root system. \n\n|The  form 'coxgroup(:A,2,sc)'  constructs the  semisimple simply connected |algebraic  group, where 'simpleroots(W)' is  the transposed of 'cartan(W)' |and 'simplecoroots(W)' is the identity matrix.\n\nThere  is an extreme form  of root data which  requires another function to specify:  when W is the trivial coxgroup()  and there are thus no roots (in  this case ð† is a torus), the root datum cannot be determined by the roots,  but is entirely determined by the rank r. The function torus(r) constructs such a root datum.\n\nFinally,  the function rootdatum also understands some familiar names for the algebraic groups and gives the results that could be obtained by giving the appropriate matrices 'simpleroots(W)' and 'simplecoroots(W)':\n\njulia> rootdatum(:gl,3)   # same as the previous example\nAâ‚‚Î¦â‚\n\nSemisimple elements\n\nIt  is also possible  to compute with  semi-simple elements. The first type are  finite order elements of ð“, which over an algebraically closed field K  are in bijection with elements of YâŠ— â„š /â„¤ whose denominator is prime to  the  characteristic  of  K.  These  are  represented  as  a vector of Rationals r such that 0â‰¤r<1, or, more to the point, a Vector{Root1}. The  function  SS  constructs  a  semisimple  element  from  a  vector of Rational,  while  the  more  general  function  can  construct semisimple elements from arbitrary ring elements (like elements of K, Mvps,â€¦\n\njulia> G=rootdatum(:sl,4)\nAâ‚ƒ\n\njulia> L=reflection_subgroup(G,[1,3])\nAâ‚ƒâ‚â‚â‚ƒâ‚Ž=Aâ‚Ã—Aâ‚Î¦â‚\n\njulia> C=algebraic_centre(L)\nDict{Symbol, Any} with 3 entries:\n  :descAZ => [[1, 2]]\n  :AZ     => SSGroup(SemisimpleElement{Root1}[<1,1,-1>])\n  :Z0     => SubTorus(Aâ‚ƒâ‚â‚â‚ƒâ‚Ž=Aâ‚Ã—Aâ‚Î¦â‚,[[1, 2, 1]])\n\njulia> T=torsion_subgroup(C[:Z0],3)\nSSGroup(SemisimpleElement{Root1}[<Î¶â‚ƒ,Î¶â‚ƒÂ²,Î¶â‚ƒ>])\n\njulia> e=sort(elements(T))\n3-element Vector{SemisimpleElement{Root1}}:\n <1,1,1>\n <Î¶â‚ƒ,Î¶â‚ƒÂ²,Î¶â‚ƒ>\n <Î¶â‚ƒÂ²,Î¶â‚ƒ,Î¶â‚ƒÂ²>\n\nFirst,  the  group  ð†  =SLâ‚„  is  constructed,  then the Levi subgroup L consisting   of  block-diagonal  matrices  of  shape  2Ã—2.  The  function algebraic_centre returns a record with : the neutral component Zâ° of the centre Z of L, represented by a basis of Y(Zâ°), a complement subtorus S  of  ð“  to  Zâ°  represented  similarly  by  a  basis of Y(S), and semi-simple  elements representing the classes of  Z modulo Zâ° , chosen in S. The classes Z/Zâ° also biject to the fundamental group as given by the  field '.descAZ', see \"AlgebraicCentre\" for an explanation. Finally the semi-simple elements of order 3 in Zâ° are computed.\n\njulia> e[3]^G(2)\nSemisimpleElement{Root1}: <Î¶â‚ƒÂ²,1,Î¶â‚ƒÂ²>\n\njulia> orbit(G,e[3])\n6-element Vector{SemisimpleElement{Root1}}:\n <Î¶â‚ƒÂ²,Î¶â‚ƒ,Î¶â‚ƒÂ²>\n <Î¶â‚ƒÂ²,1,Î¶â‚ƒÂ²>\n <Î¶â‚ƒ,1,Î¶â‚ƒÂ²>\n <Î¶â‚ƒÂ²,1,Î¶â‚ƒ>\n <Î¶â‚ƒ,1,Î¶â‚ƒ>\n <Î¶â‚ƒ,Î¶â‚ƒÂ²,Î¶â‚ƒ>\n\nHere  is the same  computation as above  performed with semisimple elements whose coefficients are in the finite field FF(4):\n\njulia> G=rootdatum(:sl,4)\nAâ‚ƒ\n\njulia> s=SemisimpleElement(G,Z(4).^[1,2,1])\nSemisimpleElement{FFE{2}}: <Zâ‚„,Zâ‚„Â²,Zâ‚„>\n\njulia> s^G(2)\nSemisimpleElement{FFE{2}}: <Zâ‚„,1â‚‚,Zâ‚„>\n\njulia> orbit(G,s)\n6-element Vector{SemisimpleElement{FFE{2}}}:\n <Zâ‚„,Zâ‚„Â²,Zâ‚„>\n <Zâ‚„,1â‚‚,Zâ‚„>\n <Zâ‚„Â²,1â‚‚,Zâ‚„>\n <Zâ‚„,1â‚‚,Zâ‚„Â²>\n <Zâ‚„Â²,1â‚‚,Zâ‚„Â²>\n <Zâ‚„Â²,Zâ‚„,Zâ‚„Â²>\n\nWe  can  compute  the  centralizer  C_ð† (s)  of  a semisimple element in ð†:\n\njulia> G=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> s=SS(G,[0,1//2,0])\nSemisimpleElement{Root1}: <1,-1,1>\n\njulia> centralizer(G,s)\nAâ‚ƒâ‚â‚â‚ƒâ‚Ž=(Aâ‚Aâ‚)Î¦â‚‚\n\nThe  result is an  extended reflection group;  the reflection group part is the Weyl group of C_ð† â°(s) and the extended part are representatives of C_ð†  (s)  modulo  C_ð†â°(s)  taken  as  diagram  automorphisms of the reflection  part.  Here  it  is  printed  as  a  coset  C_ð† â°(s)Ï• which generates C_ð† (s).\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.Semisimple.fundamental_group","page":"Gapjm Documentation","title":"Gapjm.Semisimple.fundamental_group","text":"fundamental_group(W)\n\nThis  function returns the fundamental group of the algebraic group defined by  the Coxeter  group struct  W. This  group is  returned as  a group of diagram  automorphisms of the corresponding affine Weyl group, that is as a group  of permutations of  the set of  simple roots enriched  by the lowest root  of  each  irreducible  component.  The  definition  we  take  of  the fundamental  group of a (not necessarily semisimple) reductive group is (Pâˆ© Y(ð“))/Q where P is the coweight lattice (the dual lattice in Y(ð“)âŠ— â„š of the root lattice) and Q is the coroot latice. The bijection between elements of P/Q   and   diagram   automorphisms   is   explained   in  the  context  of non-irreducible groups for example in Â§3.B BonnafÃ©2005.\n\njulia> W=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> fundamental_group(W)\nGroup([(1,2,3,12)])\n\njulia> W=rootdatum(:sl,4)\nAâ‚ƒ\n\njulia> fundamental_group(W)\nGroup([])\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Semisimple.QuasiIsolatedRepresentatives-Tuple{FiniteCoxeterGroup}","page":"Gapjm Documentation","title":"Gapjm.Semisimple.QuasiIsolatedRepresentatives","text":"QuasiIsolatedRepresentatives(W,p=0)\n\nW  should be a Weyl  group corresponding to an  algebraic group ð† over an algebraically  closed field  of characteristic  0. This  function returns a list  of  semisimple  elements  for  ð†,  which  are  representatives of the ð†-orbits  of quasi-isolated  semisimple elements.  It follows the algorithm given  in  Bonnafe2005.  If  a  second  argument p is given,  it  gives  representatives  of  those quasi-isolated elements which exist in characteristic p.\n\njulia> W=coxgroup(:E,6);l=Semisimple.QuasiIsolatedRepresentatives(W)\n5-element Vector{SemisimpleElement{Root1}}:\n <1,1,1,1,1,1>\n <1,1,1,Î¶â‚ƒ,1,1>\n <1,-1,1,1,1,1>\n <1,Î¶â‚†,Î¶â‚†,1,Î¶â‚†,1>\n <Î¶â‚ƒ,1,1,1,1,Î¶â‚ƒ>\n\njulia> map(s->is_isolated(W,s),l)\n5-element Vector{Bool}:\n 1\n 1\n 1\n 0\n 0\n\njulia> W=rootdatum(:E6sc);l=Semisimple.QuasiIsolatedRepresentatives(W)\n7-element Vector{SemisimpleElement{Root1}}:\n <1,1,1,1,1,1>\n <-1,1,1,-1,1,-1>\n <Î¶â‚ƒ,1,Î¶â‚ƒÂ²,1,Î¶â‚ƒ,Î¶â‚ƒÂ²>\n <Î¶â‚ƒÂ²,1,Î¶â‚ƒ,1,Î¶â‚ƒ,Î¶â‚ƒÂ²>\n <Î¶â‚ƒÂ²,1,Î¶â‚ƒ,1,Î¶â‚ƒÂ²,Î¶â‚ƒ>\n <Î¶â‚ƒÂ²,1,Î¶â‚ƒ,1,Î¶â‚ƒÂ²,Î¶â‚†âµ>\n <Î¶â‚†âµ,1,Î¶â‚ƒÂ²,1,Î¶â‚ƒ,Î¶â‚ƒÂ²>\n\njulia> map(s->is_isolated(W,s),l)\n7-element Vector{Bool}:\n 1\n 1\n 1\n 1\n 1\n 1\n 1\n\njulia> Semisimple.QuasiIsolatedRepresentatives(W,3)\n2-element Vector{SemisimpleElement{Root1}}:\n <1,1,1,1,1,1>\n <-1,1,1,-1,1,-1>\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.Semisimple.is_isolated","page":"Gapjm Documentation","title":"Gapjm.Semisimple.is_isolated","text":"is_isolated(WF::Spets,t::SemisimpleElement{Root1})\n\nWF  should be  a Coxeter  coset representing  an algebraic  coset ð† â‹…Ïƒ, where  ð† is a connected  reductive group (represented by W=Group(WF)), and  Ïƒ  is  a  quasi-central  automorphism  of  ð† defined by WF. The element  t should be a semisimple element of ð†. The function returns a boolean describing whether tÏƒ is isolated, that is whether the Weyl group of C_ð† (tÏƒ)â° is not in any proper parabolic subgroup of W^Ïƒ.\n\njulia> WF=rootdatum(:u,6)\nÂ²Aâ‚…Î¦â‚‚\n\njulia> l=QuasiIsolatedRepresentatives(WF)\n4-element Vector{SemisimpleElement{Root1}}:\n <1,1,1,1,1,1>\n <Î¶â‚„,1,1,1,1,Î¶â‚„Â³>\n <Î¶â‚„,Î¶â‚„,1,1,Î¶â‚„Â³,Î¶â‚„Â³>\n <Î¶â‚„,Î¶â‚„,Î¶â‚„,Î¶â‚„Â³,Î¶â‚„Â³,Î¶â‚„Â³>\n\njulia> is_isolated.(Ref(WF),l)\n4-element BitVector:\n 1\n 0\n 1\n 1\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Semisimple.torsion_subgroup","page":"Gapjm Documentation","title":"Gapjm.Semisimple.torsion_subgroup","text":"torsion_subgroup(S::SubTorus,n)\n\nThis  function  returns  the  subgroup  of  semi-simple  elements  of order dividing n in the subtorus S.\n\njulia> G=rootdatum(:sl,4)\nAâ‚ƒ\n\njulia> L=reflection_subgroup(G,[1,3])\nAâ‚ƒâ‚â‚â‚ƒâ‚Ž=Aâ‚Ã—Aâ‚Î¦â‚\n\njulia> C=algebraic_centre(L)\nDict{Symbol, Any} with 3 entries:\n  :descAZ => [[1, 2]]\n  :AZ     => SSGroup(SemisimpleElement{Root1}[<1,1,-1>])\n  :Z0     => SubTorus(Aâ‚ƒâ‚â‚â‚ƒâ‚Ž=Aâ‚Ã—Aâ‚Î¦â‚,[[1, 2, 1]])\n\njulia> T=torsion_subgroup(C[:Z0],3)\nSSGroup(SemisimpleElement{Root1}[<Î¶â‚ƒ,Î¶â‚ƒÂ²,Î¶â‚ƒ>])\n\njulia> sort(elements(T))\n3-element Vector{SemisimpleElement{Root1}}:\n <1,1,1>\n <Î¶â‚ƒ,Î¶â‚ƒÂ²,Î¶â‚ƒ>\n <Î¶â‚ƒÂ²,Î¶â‚ƒ,Î¶â‚ƒÂ²>\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Semisimple.algebraic_centre","page":"Gapjm Documentation","title":"Gapjm.Semisimple.algebraic_centre","text":"algebraic_centre(W)\n\nW  should  be  a  Weyl  group,  or  an extended Weyl group. This function returns  a description  of the  centre Zð† of  the algebraic  group ð† defined by <W> as a Dict with the following fields:\n\n:Z0: the neutral component Z^0 of Zð† as a subtorus of ð“.\n\n:AZ:  representatives in  Zð† of  A(Z)=Zð†(Zð†)^0 given  as a group of semisimple elements.\n\n:ZD:  center of the derived subgroup of  ð† given as a group of semisimple elements.\n\n:descAZ:  if  W  is  not  an  extended  Weyl group, describes A(Z) as a quotient  of the center  pi of the  simply connected covering  of ð†. It contains  a list of elements given as words in the generators of pi which generate the kernel of the quotient map.\n\njulia> G=rootdatum(:sl,4)\nAâ‚ƒ\n\njulia> L=reflection_subgroup(G,[1,3])\nAâ‚ƒâ‚â‚â‚ƒâ‚Ž=Aâ‚Ã—Aâ‚\n\njulia> algebraic_centre(L)\nDict{Symbol,Any} with 3 entries:\n  :descAZ => [[1, 2]]\n  :AZ     => SSGroup(SemisimpleElement{Root1}[<1,1,-1>])\n  :Z0     => SubTorus(Aâ‚ƒâ‚â‚â‚ƒâ‚Ž=Aâ‚Ã—Aâ‚,[[1, 2, 1]])\n\njulia> G=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> s=SS(G,[0,1//2,0])\nSemisimpleElement{Root1}: <1,-1,1>\n\njulia> C=centralizer(G,s)\nAâ‚ƒâ‚â‚â‚ƒâ‚Ž=(Aâ‚Aâ‚)Î¦â‚‚\n\njulia> algebraic_centre(C)\nDict{Symbol,Any} with 3 entries:\n  :descAZ => [[1], [2]]\n  :AZ     => SSGroup(SemisimpleElement{Root1}[])\n  :Z0     => SubTorus(Aâ‚ƒâ‚â‚â‚ƒâ‚Ž=Aâ‚Ã—Aâ‚,[[0, 1, 0]])\n\ngap> AlgebraicCentre(C); rec( Z0 := SubTorus(ReflectionSubgroup(CoxeterGroup(\"A\",3), [ 1, 3 ]),), AZ := Group( <0,1/2,0> ) )\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Groups.centralizer-Tuple{FiniteCoxeterGroup, SemisimpleElement}","page":"Gapjm Documentation","title":"Gapjm.Groups.centralizer","text":"Centralizer(W,s)\n\nW  should  be  a  Weyl  group  or  an extended reflection group and s a semisimple  element of the  algebraic group G  corresponding to W. This function  returns the  Weyl group  of C_G(s),  which describes  it. The stabilizer  is an extended reflection group, with the reflection group part equal to the Weyl group of C_Gâ°(s), and the diagram automorphism part being those induced by C_G(s).\n\njulia> G=coxgroup(:A,3)\nAâ‚ƒ\njulia> s=SS(G,[0,1//2,0])\nSemisimpleElement{Root1}: <1,-1,1>\njulia> centralizer(G,s)\nAâ‚ƒâ‚â‚â‚ƒâ‚Ž=(Aâ‚Aâ‚)Î¦â‚‚\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.Semisimple.SScentralizer_reps","page":"Gapjm Documentation","title":"Gapjm.Semisimple.SScentralizer_reps","text":"SScentralizer_reps(W [,p])\n\nW  should be a Weyl group corresponding  to an algebraic group ð†. This function  returns a list describing representatives  ð‡ of ð†-orbits of reductive  subgroups  of  ð†  which  are  the  identity component of the centralizer of a semisimple element. Each group ð‡ is specified by a list h   of  reflection  indices  in  W   such  that  ð‡  corresponds  to reflection_subgroup(W,h).  If a  second argument  p is  given, only the list of the centralizers which occur in characteristic p is returned.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> SScentralizer_reps(W)\n6-element Vector{Vector{Int64}}:\n []\n [1]\n [2]\n [1, 2]\n [1, 5]\n [2, 6]\n\njulia> reflection_subgroup.(Ref(W),SScentralizer_reps(W))\n6-element Vector{FiniteCoxeterSubGroup{Perm{Int16},Int64}}:\n Gâ‚‚â‚â‚Ž=Î¦â‚Â²\n Gâ‚‚â‚â‚â‚Ž=Aâ‚Î¦â‚\n Gâ‚‚â‚â‚‚â‚Ž=AÌƒâ‚Î¦â‚\n Gâ‚‚\n Gâ‚‚â‚â‚â‚…â‚Ž=Aâ‚‚\n Gâ‚‚â‚â‚‚â‚†â‚Ž=AÌƒâ‚Ã—Aâ‚\n\njulia> SScentralizer_reps(W,2)\n5-element Vector{Vector{Int64}}:\n []\n [1]\n [2]\n [1, 2]\n [1, 5]\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Semisimple.StructureRationalPointsConnectedCentre","page":"Gapjm Documentation","title":"Gapjm.Semisimple.StructureRationalPointsConnectedCentre","text":"StructureRationalPointsConnectedCentre(W,q)\n\nW  should be  a Coxeter  group or  a Coxeter  coset representing a finite reductive  group ð† ^F, and q should  be the prime power associated to the  isogeny F. The function returns the abelian invariants of the finite abelian group Zâ°ð† ^F where Zâ°ð† is the connected center of ð†.\n\nIn  the following example one determines the structure of ð“(ð”½â‚ƒ) where ð“ runs over all the maximal tori of SLâ‚„.\n\njulia> l=twistings(rootdatum(:sl,4),Int[])\n5-element Vector{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}}:\n Aâ‚ƒâ‚â‚Ž=Î¦â‚Â³\n Aâ‚ƒâ‚â‚Ž=Î¦â‚Â²Î¦â‚‚\n Aâ‚ƒâ‚â‚Ž=Î¦â‚Î¦â‚‚Â²\n Aâ‚ƒâ‚â‚Ž=Î¦â‚Î¦â‚ƒ\n Aâ‚ƒâ‚â‚Ž=Î¦â‚‚Î¦â‚„\n\njulia> StructureRationalPointsConnectedCentre.(l,3)\n5-element Vector{Vector{Int64}}:\n [2, 2, 2]\n [2, 8]\n [4, 8]\n [26]\n [40]\n\njulia-repl\n\n\n\n\n\n","category":"function"},{"location":"#Reflection-cosets","page":"Gapjm Documentation","title":"Reflection cosets","text":"","category":"section"},{"location":"","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"Cosets\ndegrees(::Spets)\nspets\ntwistings\ngraph_automorphisms\nsubspets","category":"page"},{"location":"#Gapjm.Cosets","page":"Gapjm Documentation","title":"Gapjm.Cosets","text":"Let  R be a  root system in  the real vector  space V. We say that Fâ‚€âˆˆ GL(V)  is an  automorphism of  R if  it permutes  R and is of finite order  (finite  order  is  automatic  if  R generates V). It follows by chap.  VI,  Â§1.1,  lemme  1  Bourbaki1968 that the dual Fâ‚€*âˆˆ  GL(V*)  permutes  the  coroots  R*âŠ‚  V*; thus Fâ‚€ normalizes the reflection  group  W  associated  to  R,  that  is  wâ†¦  Fâ‚€wFâ‚€â»Â¹ is an automorphism  of W. Thus we get a reflection coset WFâ‚€, which we call a Coxeter coset.\n\nThe  motivation for introducing Coxeter  cosets comes from automorphisms of algebraic  reductive groups, giving rise to non-split reductive groups over finite fields. Let ð† be a connected reductive algebraic group ð† over an algebraic  closure ð”½Ì„_q of a finite field ð”½_q, defined over ð”½_q; this corresponds  to a  Frobenius endomorphism  F so  that the finite group of rational  points ð†(ð”½_q) identifies to the  subgroup ð†^F of fixed points under F.\n\nLet ð“ be a maximal torus of ð†, and Î¦ (resp. Î¦*) be the roots (resp. coroots)  of ð† with respect  to ð“ in the  character group X(ð“) (resp. the  group of one-parameter subgroups Y(ð“)). Then ð† is determined up to isomorphism  by (X(ð“),Î¦,Y(ð“),Î¦*); this corresponds  to give a root system in   the  vector  space  V=â„š âŠ— X(ð“)   and  a  rational  reflection  group W=N_ð†(ð“)/ð“ acting on it.\n\nIf  ð“ is F-stable the Frobenius endomorphism F acts also naturally on X(T)  and defines thus  an endomorphism of  V, which is  of the form q Fâ‚€, where Fâ‚€âˆˆ GL(V) is of finite order and normalizes W. We get thus a Coxeter  coset WFâ‚€âŠ‚GL(V).  The data  (X(ð“), Î¦,  Y(ð“), Î¦*,  Fâ‚€), and the integer   q  completely  determine  up   to  isomorphism  the  associated reductive finite group ð†^F. Thus these data is a way of representing in the  essential  information  which  determines  a  finite  reductive group. Indeed, all properties of Chevalley groups can be computed from that datum: symbols  representing characters, conjugacy classes,  and finally the whole character table of ð†^F.\n\nIt  turns out that  many interesting objects  attached to this datum depend only on (V,W, Fâ‚€): the order of the maximal tori, the fake degrees, the order  of ð†^F, symbols representing unipotent characters, Deligne-Lusztig induction  in  terms  of  almost  characters, the Fourier matrix relating characters and almost characters, etcâ€¦ (see, e.g., Broue-Malle-Michel1993).  It is thus possible to extend their  construction to non-crystallographic groups (or even to more general complex  reflection groups, see \"Spets\"); this is  why we did not include a root  system in  the definition  of a  reflection coset. However, unipotent conjugacy classes for instance depend on the root system.\n\nWe assume now that ð“ is contained in an F-stable Borel subgroup of ð†. This  defines an order  on the roots,  and there is  a unique element Ï•âˆˆ W Fâ‚€,  the  reduced  element  of  the  coset,  which  preserves the set of positive  roots.  It  thus  defines  a  diagram  automorphism, that is an automorphism  of the Coxeter system (W,S).  This element is stored in the component  '.phi' of the coset record. It may be defined without mentioning the  roots,  as  follows:  (W,Fâ‚€(S))  is  another  Coxeter  system,  thus conjugate to S by a unique element of W, thus there is a unique element Ï•âˆˆ  WFâ‚€ which stabilizes S (a proof  follows from Theoreme 1, chap. V, Â§3  Bourbaki1968). We  consider thus  cosets of the form WÏ• where Ï• stabilizes S. The coset W Ï• is completely defined by the permutation  '.phi'  when  ð†  is  semi-simple  â€“-  equivalently when Î¦ generates  V; in this  case we just  need to specify  'phi' to define the coset.\n\nThere is a slight generalisation of the above setup, covering in particular the  case of the Ree  and Suzuki groups. We  consider ð†^F where F not a Frobenius  endomorphism, but  an isogeny  such that  some power  F^n is a Frobenius endomorphism. Then F still defines an endomorphism of V which normalizes  W; we define a real number q such that F^n is attached to an  ð”½_{qâ¿}-structure. Then we still have F=q Fâ‚€ where Fâ‚€ is of finite order  but q is no more an integer.  Thus Fâ‚€âˆˆ GL(VâŠ— â„) but Fâ‚€âˆ‰ GL(V). For  instance, for the  Ree and Suzuki  groups, Fâ‚€ is  an automorphism of order  2 of W, which is of type Gâ‚‚, Bâ‚‚ or Fâ‚„, and q=âˆš2 for Bâ‚‚ and  Fâ‚„ and q=âˆš3  for Gâ‚‚ This  can be constructed  starting from root systems  for Gâ‚‚, Bâ‚‚ or  Fâ‚„ where all the  roots have the same length. This kind of root system is not crystallographic. Such non-crystallographic  root systems exist for all finite Coxeter groups such as  the dihedral groups, Hâ‚ƒ and Hâ‚„. We will call here Weyl cosets the cosets  corresponding to rational forms  of algebraic groups, which include thus some non-rational roots systems for Bâ‚‚, Gâ‚‚ and Fâ‚„.\n\nSpets\n\nWe  now extend the above notions  to general complex reflection groups. Let WâŠ‚  GL(V) be a complex reflection group  on the vector space V. Let Ï• be  an element  of GL(V)  which normalizes  W. Then  the coset  WÏ• is called a reflection coset.\n\nA reference for these cosets is Broue-Malle-Michel 1999 When W is a so-called Spetsial group, they are the basic object for the construction  of  a  Spetses,  which  is  an object attached to a complex reflection  group from which one can derive combinatorially some attributes shared with finite reductive groups, like unipotent degrees, etcâ€¦.\n\nWe  say that  a reflection  coset is  irreducible if  W is irreducible. A general  coset is a direct  product of descents of  scalars, which is the case  where Ï•  is transitive  on the  irreducible components  of W. The irreducible    cosets   have   been   classified   in   Broue-Malle-Michel 1999:  up to multiplication of Ï• by a scalar, there is usually only one or two possible cosets for a given irreducible group.\n\nWe  deal only  with finite  order cosets,  that is,  we assume there is a (minimal) integer Î´ such that (WÏ•)^Î´=W. Then the group generated by W and Ï• is finite, of order Î´|W|.\n\nA  subset C  of a  WÏ• is  called a  conjugacy class  if one of the following equivalent conditions is fulfilled:\n\nC is the orbit of an element in WÏ• under the conjugation action of W.\nC is a conjugacy class of âŸ¨W,Ï•âŸ© contained in WÏ•.\nThe set {wâˆˆ W|wÏ•âˆˆ C} is  a Ï•-conjugacy  class of W (two elements\n\nv,wâˆˆ  W are called Ï•-conjugate, if and only if there exists xâˆˆ W with v=xwÏ•(xâ»Â¹)).\n\nAn irreducible character of âŸ¨W,Ï•âŸ© has some non-zero values on WÏ• if and only if its restriction to W is irreducible. Further, two characters Ï‡â‚ and  Ï‡â‚‚  which  have  same  irreducible  restriction  to  W differ by a character  of  the  cyclic  group  âŸ¨Ï•âŸ©  (which identifies to the quotient âŸ¨W,Ï•âŸ©/W). A set containing one extension to âŸ¨W,Ï•âŸ© of each Ï•-invariant character  of W is called a set  of irreducible characters of WÏ•. Two such  characters  are  orthogonal  for  the  scalar  product  on  the class functions on WÏ• given by Ï‡Ïˆ=WÂ¹_w WÏ‡(wÏ•)overlineÏˆ(wÏ•) For rational groups (Weyl groups), Lusztig has defined a choice of a set of irreducible  characters for  WÏ• (called  the preferred extensions), but for  more  general  reflection  cosets  we  have made some rather arbitrary choices,  which  however  have  the  property  that their values lie in the smallest possible field.\n\nThe  character  table  of  WÏ•  is  the  table  of  values  of  a set of irreducible characters on the conjugacy classes.\n\nA subcoset LwÏ• of WÏ• is given by a reflection subgroup L of W and an element w of W such that wÏ• normalizes L.\n\nWe  then have a natural notion of  restriction of class functions on WÏ• to  class  functions  on  LwÏ•  as  well  as  of  induction in the other direction.  These  maps  are  adjoint  with  respect  to the scalar product defined above (see Broue-Malle-Michel 1999).\n\nIn  this package the most general construction  of a reflection coset is by starting  from a reflection datum, and giving in addition the matrix 'F' of the  map Ï•:Vâ†’ V  (see the command  'spets'). However, at present, general cosets are only implemented for groups represented as permutation groups on a  set of roots, and  it is required that  the automorphism given preserves this  set up to  a scalar (it  is allowed that  these scalars depend on the pair  of an  irreducible component  and its  image). It  is also allowed to specify  Ï• by the permutation it induces on the roots; in this case it is assumed  that Ï• acts  trivially on the  orthogonal of the  roots, but the roots  could be those of a parent group, generating a larger space. Thus in any  case we have  a permutation representation  of âŸ¨W,Ï•âŸ© and we consider the coset to be a set of permutations.\n\nReflection  cosets  are  implemented  in  by  a  struct which points to a reflection  group  record  and  has  additional  fields holding 'F' and the corresponding  permutation 'phi'. In the general case, on each component of W  which is  a descent  of scalars,  'F' will  permute the components and differ  by a scalar on each  component from an automorphism which preserves the  roots. In this case, we have  a permutation 'phi' and a 'scalar' which is stored for that component.\n\nThe  most common situation where cosets  with non-trivial 'phi' arise is as sub-cosets  of reflection groups. Here is an \"exotic\" example, see the next chapter for more classical examples involving Coxeter groups.\n\njulia> W=ComplexReflectionGroup(14)\nGâ‚â‚„\n\njulia> R=reflection_subgroup(W,[2,4])\nGâ‚â‚„â‚â‚‚â‚„â‚Ž=Gâ‚…\n\njulia> RF=spets(R,W(1)) # should be Â²Gâ‚…(âˆš6)\nGâ‚â‚„â‚â‚‚â‚„â‚Ž=Â²Gâ‚…\n\njulia> Diagram(RF)\nÏ• acts as (1,2) on the component below\nG5 1(3)==2(3)\n\njulia> degrees(RF)\n2-element Vector{Tuple{Int64, Cyc}}:\n (6, 1)\n (12, -1)\n\nThe  last line shows for each  reflection degree the corresponding factor of  the coset, which is  the scalar by which  Ï• acts on the corresponding fundamental reflection invariant. The factors characterize the coset.\n\nA  spets by default is  printed in an abbreviated  form which describes its type,  as above ('Gâ‚…' twisted by 2, with a Cartan matrix which differs from the  standard one by  a factor of  âˆš6). The function  repr gives a form which could be input back in Julia. With the same data as above we have:\n\njulia> print(RF)\nspets(reflection_subgroup(ComplexReflectionGroup(14),[2, 4]),perm\"(1,3)(2,4)(5,9)(6,10)(7,11)(8,12)(13,21)(14,22)(15,23)(16,24)(17,25)(18,26)(19,27)(20,28)(29,41)(30,42)(31,43)(32,44)(33,45)(34,46)(35,47)(36,48)(37,49)(38,50)(39,51)(40,52)(53,71)(54,72)(55,73)(56,74)(57,75)(58,76)(59,77)(60,78)(62,79)(64,80)(65,81)(66,82)(67,69)(68,70)(83,100)(84,101)(85,102)(87,103)(89,99)(90,97)(91,98)(92,96)(93,104)(94,95)(105,113)(106,114)(109,111)(110,112)(115,118)(116,117)(119,120)\")\n\nConjugacy  classes and irreducible characters of Coxeter cosets are defined as  for  general  reflection  cosets.  For  irreducible  characters of Weyl cosets,  we choose (following Lusztig) for each Ï•-stable character of W a  particular extension to a character of  Wâ‹Š âŸ¨Ï•âŸ©, which we will call the preferred extension. The character table of the coset WÏ• is the table of  the restrictions to  WÏ• of the  preferred extensions. The question of finding the conjugacy classes and character table of a Coxeter coset can be reduced to the case of irreducible root systems R.\n\nThe automorphism Ï• permutes the irreducible components of W, and WÏ•  is a direct  product of cosets  where Ï• permutes cyclically the irreducible components of W. The preferred extension is defined to be the  direct  product  of  the  preferred  extension  in  each  of these situations.\nAssume now that WÏ• is a descent of scalars, that is the decomposition in irreducible components W=Wâ‚Ã— â‹¯ Ã— Wâ‚– is cyclically permuted by Ï•. Then there are natural bijections from the Ï•-conjugacy classes of W to  the Ï•áµ-conjugacy classes  of Wâ‚ as  well as from the Ï•-stable characters  of W to the Ï•áµ-stable  characters of Wâ‚, which reduce the  definition of preferred  extensions on WÏ•  to the definition for Wâ‚Ï•áµ.\nAssume now  that W  is the  Coxeter group  of an  irreducible root system.   Ï•  permutes  the  simple   roots,  hence  induces  a  graph automorphism  on  the  corresponding  Dynkin  diagram.  If  Ï•=1  then conjugacy  classes and  characters coincide  with those  of the Coxeter group W.\n\nThe  nontrivial cases for crystallographic roots  systems are (the order of Ï•  is written as left exponent to  the type): Â²Aâ‚™, Â²Dâ‚™, Â³Dâ‚„, Â²Eâ‚†. For  non-crystallographic root  systems where  all the  roots have the same length the additional cases Â²Bâ‚‚, Â²Gâ‚‚, Â²Fâ‚„ and Â²Iâ‚‚(k) arise.\n\nIn  case  Â³Dâ‚„  the  group  Wâ‹Š âŸ¨Ï•âŸ©  can be embedded into the Coxeter  group of type Fâ‚„, which induces a labeling for the conjugacy classes of the coset. The preferred extension is chosen as the (single) extension with rational values.\nIn case  Â²Dâ‚™ the  group Wâ‹Š âŸ¨Ï•âŸ©  is isomorphic  to a Coxeter group of type Bâ‚™. This induces a canonical labeling for the conjugacy classes  of the coset and allows to define the preferred extension in a combinatorial  way  using  the  labels  (pairs  of  partitions) for the characters of the Coxeter group of type Bâ‚™.\nIn the remaining crystallographic cases Ï• identifies to -wâ‚€ where wâ‚€  is the longest element of W.  So, there is a canonical labeling of  the conjugacy classes and characters of  the coset by those of W. The  preferred extensions  are defined  by describing  the signs of the character values on -wâ‚€.\n\nThe  most general  construction of  a Coxeter  coset is  by starting from a Coxeter   datum   specified   by   the   matrices   of   'simpleRoots'  and 'simpleCoroots',  and  giving  in  addition  the  matrix 'F0Mat' of the map Fâ‚€:Vâ†’ V (see the commands  'CoxeterCoset' and 'CoxeterSubCoset'). As for Coxeter  groups,  the  elements  of  WÏ•  are  uniquely  determined by the permutation  they  induce  on  the  set  of  roots  R.  We consider these permutations as 'Elements' of the Coxeter coset.\n\nCoxeter  cosets are implemented by a struct which points to a Coxeter datum record  and  has  additional  fields  holding 'F0Mat' and the corresponding element  'phi'. Functions on the coset (for example, 'classinfo') are about properties  of  the  group  coset  W  Ï•  ;  however, most definitions for elements of untwisted Coxeter groups apply without change to elements in W Ï•:  e.g., if we define the length of  an element wÏ•âˆˆ WÏ• as the number of positive  roots it sends to negative ones, it  is the same as the length of w,  i.e., Ï• is of length 0, since Ï• has been chosen to preserve the set of positive roots. Similarly, the 'Coxeter word' describing wÏ• is the same as the one for w, etcâ€¦\n\nWe associate to a Coxeter coset WÏ• a twisted Dynkin diagram, consisting of  the Dynkin diagram of W and  the graph automorphism induced by Ï• on this  diagram (this specifies the  group Wâ‹Š âŸ¨FâŸ©, mentioned above, up to  isomorphism). See the  functions 'ReflectionType', 'ReflectionName' and 'Diagram' for Coxeter cosets.\n\nBelow  is an example showing first how to not define, then how to define, the Weyl coset for a Suzuki group:\n\njulia> W=coxgroup(:B,2)\nBâ‚‚\n\njulia> spets(W,Perm(1,2))\nERROR: matrix F must preserve the roots\nStacktrace:\n [1] error(::String) at ./error.jl:33\n [2] spets(::Gapjm.Weyl.FCG{Int16,Int64,PRG{Int64,Int16}}, ::Matrix{Int64}) at /home/jmichel/julia/Gapjm/src/Cosets.jl:241 (repeats 2 times)\n [3] top-level scope at REPL[19]:1\n\njulia> W=coxgroup(:Bsym,2)\nBsymâ‚‚\n\njulia> WF=spets(W,Perm(1,2))\nÂ²Bsymâ‚‚\n\njulia> CharTable(WF)\nCharTable(Â²Bsymâ‚‚)\n   â”‚    1 121\nâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n2. â”‚1   1   1\n.11â”‚1  -1  -1\n1.1â”‚. -âˆš2  âˆš2\n\nA subcoset HwÏ• of WÏ• is given by a reflection subgroup H of W and an  element w of W  such that wÏ• induces  an automorphism of the root system of H. For algebraic groups, this corresponds to a rational form of a  reductive subgroup of maximal rank.  For example, if WÏ• corresponds to the  algebraic group ð† and  H is the trivial  subgroup, the coset HwÏ• corresponds to a maximal torus ð“_w of type w.\n\njulia> W=coxgroup(:Bsym,2)\nBsymâ‚‚\n\njulia> WF=spets(W,Perm(1,2))\nÂ²Bsymâ‚‚\n\njulia> subspets(WF,Int[],W(1))\nBsymâ‚‚â‚â‚Ž=Î¦â€´â‚ˆ\n\nA subgroup H which is a parabolic subgroup corresponds to a rational form of  a Levi  subgroup of  ð†. The  command 'twistings'  gives all rational forms of such a Levi.\n\njulia> W=coxgroup(:B,2)\nBâ‚‚\n\njulia> twistings(W,[1])\n2-element Vector{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}}:\n Bâ‚‚â‚â‚â‚Ž=AÌƒâ‚Î¦â‚\n Bâ‚‚â‚â‚â‚Ž=AÌƒâ‚Î¦â‚‚\n\njulia> twistings(W,[2])\n2-element Vector{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}}:\n Bâ‚‚â‚â‚‚â‚Ž=Aâ‚Î¦â‚\n Bâ‚‚â‚â‚‚â‚Ž=Aâ‚Î¦â‚‚\n\nNotice how we distinguish between subgroups generated by short roots and by long  roots. A general  H corresponds to  a reductive subgroup of maximal rank.  Here we consider the subgroup generated  by the long roots in Bâ‚‚, which  corresponds to a  subgroup of type  SLâ‚‚Ã— SLâ‚‚ in SPâ‚„, and show its possible rational forms.\n\njulia> W=coxgroup(:B,2)\nBâ‚‚\n\njulia> twistings(W,[2,4])\n2-element Vector{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}}:\n Bâ‚‚â‚â‚‚â‚„â‚Ž=Aâ‚Ã—Aâ‚\n Bâ‚‚â‚â‚‚â‚„â‚Ž=(Aâ‚Aâ‚)\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.degrees-Tuple{Spets}","page":"Gapjm Documentation","title":"Gapjm.degrees","text":"degrees(WF::Spets)\n\nLet  W be  the group  of the  reflection coset  WF, and  let V be the vector  space  of  dimension  'rank(W)'  on  which W acts as a reflection group.  Let  fâ‚,â€¦,fâ‚™  be  the  basic  invariants  of W on the symmetric algebra  SV of V;  they can be  chosen so they  are eigenvectors of the matrix  WF.F. The corresponding  eigenvalues are called  the factors of F acting on V; they characterize the coset â€“- they are equal to 1 only for  the trivial  coset. The  generalized degrees  of WF  are the pairs formed of the reflection degrees and the corresponding factor.\n\njulia> W=coxgroup(:E,6)\nEâ‚†\n\njulia> WF=spets(W)\nEâ‚†\n\njulia> phi=W(6,5,4,2,3,1,4,3,5,4,2,6,5,4,3,1);\n\njulia> HF=subspets(WF,2:5,phi)\nEâ‚†â‚â‚‚â‚ƒâ‚„â‚…â‚Ž=Â³Dâ‚„Î¦â‚ƒ\n\njulia> Diagram(HF)\nÏ• acts as (1,2,4) on the component below\n  O 2\n  ï¿¨\nOâ€”Oâ€”O\n1 3 4\n\njulia> degrees(HF)\n6-element Vector{Tuple{Int64, Cyc{Int64}}}:\n (1, Î¶â‚ƒ) \n (1, Î¶â‚ƒÂ²)\n (2, 1)  \n (4, Î¶â‚ƒ) \n (6, 1)  \n (4, Î¶â‚ƒÂ²)\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.Cosets.spets","page":"Gapjm Documentation","title":"Gapjm.Cosets.spets","text":"spets(W::FiniteCoxeterGroup,F::Matrix=I(rank(W)))\n\nThis  function returns a  Coxeter coset. F  must be an invertible matrix, representing  an  automorphism  of  the  vector  space  V of dimension of dimension  rank(W) which  induces an  automorphism of  the root system of parent(W).\n\nThe returned struct has in particular the following fields:\n\n.W: the Coxeter group W\n\n.F: the matrix acting on V which represents the unique element phi in WF which preserves the positive roots.\n\n'.phi': the permutation of the roots of W induced by .F (also the element of smallest length in the Coset  W .phi).\n\nIn the first example we create a Coxeter coset corresponding to the general unitary group GU_3(q) over the finite field FF(q).\n\njulia> W=rootdatum(:gl,3)\nAâ‚‚Î¦â‚\n\njulia> gu3=spets(W,-reflrep(W,W()))\nÂ²Aâ‚‚Î¦â‚‚\n\njulia> F4=coxgroup(:F,4);D4=reflection_subgroup(F4,[1,2,16,48])\nFâ‚„â‚â‚‰â€šâ‚‚â€šâ‚â€šâ‚â‚†â‚Ž=Dâ‚„â‚â‚ƒâ‚‚â‚â‚„â‚Ž\n\njulia> spets(D4,[1 0 0 0;0 1 2 0;0 0 0 1;0 0 -1 -1])\nFâ‚„â‚â‚‰â€šâ‚â‚†â€šâ‚â€šâ‚‚â‚Ž=Â³Dâ‚„â‚â‚ƒâ‚„â‚â‚‚â‚Ž\n\nspets(W::FiniteCoxeterGroup,p::Perm)\n\nIn  this version F is  defined by the permutation  of the simple roots it does.\n\njulia> W=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> spets(W,Perm(1,3))\nÂ²Aâ‚ƒ\n\n\n\n\n\nspets(s::String) builds a few of the exceptional spets\n\njulia> spets(\"3G422\")\nÂ³Gâ‚„â€šâ‚‚â€šâ‚‚\n\njulia> spets(\"2G5\")\nÂ²Gâ‚…\n\njulia> spets(\"3G333\")\nGâ‚ƒâ€šâ‚ƒâ€šâ‚ƒâ‚â‚â€šâ‚‚â€šâ‚ƒâ€šâ‚„â‚„â‚Ž=Â³Gâ‚ƒâ€šâ‚ƒâ€šâ‚ƒâ‚â‚â€šâ‚‚â€šâ‚ƒâ€šâ‚„â‚„â‚Ž\n\njulia> spets(\"3pG333\")\nGâ‚ƒâ€šâ‚ƒâ€šâ‚ƒâ‚â‚â€šâ‚‚â€šâ‚ƒâ€šâ‚„â‚„â‚Ž=Â³Gâ‚ƒâ€šâ‚ƒâ€šâ‚ƒâ‚â‚â€šâ‚‚â€šâ‚ƒâ€šâ‚„â‚„â‚Ž\n\njulia> spets(\"4G333\")\nGâ‚ƒâ€šâ‚ƒâ€šâ‚ƒâ‚â‚â€šâ‚‚â€šâ‚ƒâ€šâ‚â‚‚â‚Ž=â´Gâ‚ƒâ€šâ‚ƒâ€šâ‚ƒâ‚â‚â€šâ‚‚â€šâ‚ƒâ€šâ‚â‚‚â‚Ž\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Cosets.twistings","page":"Gapjm Documentation","title":"Gapjm.Cosets.twistings","text":"twistings(W,I)\n\nW  should be a  Coxeter group.\n\nThe  function returns the list, up  to W-conjugacy, of Coxeter sub-cosets of  W whose  Coxeter group  is reflection_subgroup(W,I)  â€“- In term of algebraic groups, it corresponds to representatives of the possible twisted forms of the corresponding reductive subgroup of maximal rank L.\n\nW  could also be a coset WÏ•; then the subgroup L must be conjugate to Ï•(L)  for  a  rational  form  to  exist.  If Ï• normalizes L, then the rational forms are classified by the the Ï•-classes of N_W(L)/L.\n\njulia> W=coxgroup(:E,6)\nEâ‚†\n\njulia> WF=spets(W,Perm(1,6)*Perm(3,5))\nÂ²Eâ‚†\n\njulia> twistings(W,2:5)\n3-element Vector{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}}:\n Eâ‚†â‚â‚‚â‚ƒâ‚„â‚…â‚Ž=Dâ‚„Î¦â‚Â²\n Eâ‚†â‚â‚‚â‚ƒâ‚„â‚…â‚Ž=Â³Dâ‚„Î¦â‚ƒ\n Eâ‚†â‚â‚‚â‚ƒâ‚„â‚…â‚Ž=Â²Dâ‚„Î¦â‚Î¦â‚‚\n\n\njulia> twistings(WF,2:5)\n3-element Vector{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}}:\n Eâ‚†â‚â‚‚â‚…â‚„â‚ƒâ‚Ž=Â²Dâ‚„â‚â‚â‚„â‚ƒâ‚‚â‚ŽÎ¦â‚Î¦â‚‚\n Eâ‚†â‚â‚‚â‚…â‚„â‚ƒâ‚Ž=Â³Dâ‚„â‚â‚â‚„â‚ƒâ‚‚â‚ŽÎ¦â‚†\n Eâ‚†â‚â‚‚â‚ƒâ‚„â‚…â‚Ž=Dâ‚„Î¦â‚‚Â²\n\n\n\n\n\ntwistings(W)\n\nW  should be a Coxeter group which is not a proper reflection subgroup of another reflection group (so that inclusion(W)==eachindex(roots(W))). The function returns all 'spets' representing twisted forms of algebraic groups of type W.\n\njulia> twistings(coxgroup(:A,3)*coxgroup(:A,3))\n8-element Vector{Spets{FiniteCoxeterGroup{Perm{Int16},Int64}}}:\n Aâ‚ƒÃ—Aâ‚ƒ\n Aâ‚ƒÃ—Â²Aâ‚ƒ\n Â²Aâ‚ƒÃ—Aâ‚ƒ\n Â²Aâ‚ƒÃ—Â²Aâ‚ƒ\n (Aâ‚ƒAâ‚ƒ)\n Â²(Aâ‚ƒAâ‚ƒ)\n Â²(Aâ‚ƒAâ‚ƒ)â‚â‚â‚‚â‚ƒâ‚†â‚…â‚„â‚Ž\n (Aâ‚ƒAâ‚ƒ)â‚â‚â‚‚â‚ƒâ‚†â‚…â‚„â‚Ž\n\njulia> twistings(coxgroup(:D,4))\n6-element Vector{Spets{FiniteCoxeterGroup{Perm{Int16},Int64}}}:\n Dâ‚„\n Â²Dâ‚„â‚â‚‚â‚„â‚ƒâ‚â‚Ž\n Â²Dâ‚„\n Â³Dâ‚„\n Â²Dâ‚„â‚â‚â‚„â‚ƒâ‚‚â‚Ž\n Â³Dâ‚„â‚â‚â‚„â‚ƒâ‚‚â‚Ž\n\njulia> W=rootdatum(:so,8)\nDâ‚„\n\njulia> twistings(W)\n2-element Vector{Spets{FiniteCoxeterGroup{Perm{Int16},Int64}}}:\n Dâ‚„\n Â²Dâ‚„\n\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Cosets.graph_automorphisms","page":"Gapjm Documentation","title":"Gapjm.Cosets.graph_automorphisms","text":"graph_automorphisms(t::Vector{TypeIrred})\n\nGiven  the refltype of a  finite Coxeter group, returns  the group of all Graph automorphisms of t.\n\njulia> W=coxgroup(:D,4)\nDâ‚„\n\njulia> Cosets.graph_automorphisms(refltype(W*W))\nGroup([(1,5)(2,6)(3,7)(4,8),(1,2),(1,4)])\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Cosets.subspets","page":"Gapjm Documentation","title":"Gapjm.Cosets.subspets","text":"subspets(WF,I,w=one(Group(WF)))\n\nReturns   the   reflection   subcoset   of   the   coset  WF  with  group reflection_subgroup(Group(WF),I)  and torsion w*WF.phi.  w must be an element  of Group(WF) such that  'w*WF.phi' normalizes the subroot system generated by I.\n\njulia> WF=spets(coxgroup(:F,4))\nFâ‚„\n\njulia> w=transporting_elt(Group(WF),[1,2,9,16],[1,9,16,2],action=(s,g)->s.^g);\n\njulia> LF=subspets(WF,[1,2,9,16],w)\nFâ‚„â‚â‚‰â€šâ‚â‚†â€šâ‚â€šâ‚‚â‚Ž=Â³Dâ‚„â‚â‚ƒâ‚„â‚â‚‚â‚Ž\n\njulia> Diagram(LF)\nÏ• acts as (2,3,4) on the component below\n  O 4\n  ï¿¨\nOâ€”Oâ€”O\n3 1 2\n\n\n\n\n\n","category":"function"},{"location":"#Non-connected-reductive-groups","page":"Gapjm Documentation","title":"Non-connected reductive groups","text":"","category":"section"},{"location":"","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"Sscoset\ncentralizer(::Spets,::SemisimpleElement{Root1})\nQuasiIsolatedRepresentatives(::Spets)\nis_isolated(::Spets,::SemisimpleElement{Root1})","category":"page"},{"location":"#Gapjm.Sscoset","page":"Gapjm Documentation","title":"Gapjm.Sscoset","text":"Section{Quasi-Semisimple elements of non-connected reductive groups}\n\nWe also use Coxeter cosets to represented non-connected reductive groups of the  form ð† â‹Š Ïƒ where  ð† is a connected  reductive group and Ïƒ is an algebraic automorphism of ð†; more specifically to represent the coset ð† .Ïƒ.  We may always  choose Ïƒâˆˆ ð†  â‹…Ïƒ quasi-semisimple, which means that Ïƒ  preserves a pair ð“ âŠ‚ ð of a maximal torus and a Borel subgroup of ð†,  and further  quasi-central, which  means that  the Weyl group of C_ð† (Ïƒ)  is W^Ïƒ. Then  Ïƒ defines an  automorphism F_0 of  the root datum (X(ð“ ), Î¦, Y(ð“ ), Î¦^âˆ¨), thus a Coxeter coset. We refer to Digne-Michel2018 for details.\n\nWe  have  extended  the  functions  for  semi-simple  elements to work with quasi-semisimple elements tÏƒâˆˆ ð“ â‹…Ïƒ. Here, as in Digne-Michel2018,  Ïƒ  is  a  quasi-central  automorphism uniquely   defined  by  a  diagram  automorphism  of  (W,S),  taking  Ïƒ symplectic in type Aâ‚‚â‚™.\n\nHere are some examples:\n\njulia> WF=rootdatum(:u,6)\nÂ²Aâ‚…Î¦â‚‚\n\nWe  can  see  WF  as  the  coset  GLâ‚†â‹…Ïƒ  where  Ïƒ  is the composed of transpose, inverse and the longest element of W.\n\njulia> l=QuasiIsolatedRepresentatives(WF)\n4-element Vector{SemisimpleElement{Root1}}:\n <1,1,1,1,1,1>\n <Î¶â‚„,1,1,1,1,Î¶â‚„Â³>\n <Î¶â‚„,Î¶â‚„,1,1,Î¶â‚„Â³,Î¶â‚„Â³>\n <Î¶â‚„,Î¶â‚„,Î¶â‚„,Î¶â‚„Â³,Î¶â‚„Â³,Î¶â‚„Â³>\n\nwe  define an element tÏƒâˆˆ ð“ â‹…Ïƒ to  be quasi-isolated if the Weyl group of C_ð†  (tÏƒ)  is  not  in  any  proper  parabolic  subgroup  of  W^Ïƒ. This generalizes  the  definition  for  connected  groups.  The  above shows the elements  t  where  tÏƒ  runs  over  representatives  of  quasi-isolated quasi-semisimple  classes of  ð† â‹…Ïƒ.  The given  representatives have been chosen Ïƒ-stable.\n\njulia> centralizer.(Ref(WF),l)\n4-element Vector{ExtendedCox{FiniteCoxeterGroup{Perm{Int16},Rational{Int64}}}}:\n Extended(Câ‚ƒâ‚â‚ƒâ‚‚â‚â‚Ž)\n Bâ‚‚Î¦â‚\n (Aâ‚Aâ‚)â‚â‚â‚ƒâ‚ŽÃ—Aâ‚â‚â‚‚â‚Ž\n Â²Aâ‚ƒâ‚â‚ƒâ‚â‚‚â‚Ž\n\nin  the above example, the groups C_ð†  (tÏƒ) are computed and displayed as extended  Coxeter groups (following the same convention as for centralisers in connected reductive groups).\n\nWe  define an element tÏƒâˆˆ ð“  â‹…Ïƒ to be isolated if  the Weyl group of C_ð† (tÏƒ)â°  is not in any proper  parabolic subgroup of W^Ïƒ. This generalizes the definition for connected groups.\n\njulia> is_isolated.(Ref(WF),l)\n4-element BitVector:\n 1\n 0\n 1\n 1\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.Groups.centralizer-Tuple{Spets, SemisimpleElement{Root1}}","page":"Gapjm Documentation","title":"Gapjm.Groups.centralizer","text":"centralizer(WF::Spets,t::SemisimpleElement{Root1})  \n\nWF  should be  a Coxeter  coset representing  an algebraic coset ð† â‹…Ïƒ, where ð† is a connected reductive group (represented by 'W:=Group(WF)'), and  Ïƒ  is  a  quasi-central  automorphism  of ð† defined by WF. The element  t should be a semisimple  element of ð†. The function returns an  extended reflection  group describing  C_ð† (tÏƒ), with the reflection group  part representing  C_ð† â°(tÏƒ), and  the diagram  automorphism part being those induced by C_ð† (tÏƒ)/C_ð† (tÏƒ)â° on C_ð† (tÏƒ)â°.\n\njulia> WF=rootdatum(:u,6)\nÂ²Aâ‚…Î¦â‚‚\n\njulia> s=SS(Group(WF),[1//4,0,0,0,0,3//4])\nSemisimpleElement{Root1}: <Î¶â‚„,1,1,1,1,Î¶â‚„Â³>\n\njulia> centralizer(WF,s)\nBâ‚‚Î¦â‚\n\njulia> centralizer(WF,one(s))\nExtended(Câ‚ƒâ‚â‚ƒâ‚‚â‚â‚Ž)\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.Semisimple.QuasiIsolatedRepresentatives-Tuple{Spets}","page":"Gapjm Documentation","title":"Gapjm.Semisimple.QuasiIsolatedRepresentatives","text":"QuasiIsolatedRepresentatives(WF::Spets,p=0)\n\nWF  should be  a Coxeter  coset representing  an algebraic  coset ð† â‹…Ïƒ, where  ð† is a connected  reductive group (represented by W=Group(WF)), and  Ïƒ  is  a  quasi-central  automorphism  of  ð† defined by WF. The function returns a list of semisimple elements of ð† such that tÏƒ, when t  runs over this  list, are representatives  of the conjugacy classes of quasi-isolated quasisemisimple elements of ð† â‹…Ïƒ (an element tÏƒâˆˆ ð“ â‹…Ïƒ is quasi-isolated  if  the  Weyl  group  of  C_ð†  (tÏƒ)  is not in any proper parabolic  subgroup of W^Ïƒ). If a second  argument p is given, it lists only those representatives which exist in characteristic p.\n\njulia> WF=rootdatum(Symbol(\"2E6sc\"))\nÂ²Eâ‚†\n\njulia> QuasiIsolatedRepresentatives(WF)\n5-element Vector{SemisimpleElement{Root1}}:\n <1,1,1,1,1,1>\n <1,1,1,-1,1,1>\n <1,-1,Î¶â‚„,1,Î¶â‚„,1>\n <1,Î¶â‚ƒÂ²,1,Î¶â‚ƒ,1,1>\n <1,Î¶â‚„Â³,1,-1,1,1>\n\njulia> QuasiIsolatedRepresentatives(WF,2)\n2-element Vector{SemisimpleElement{Root1}}:\n <1,1,1,1,1,1>\n <1,Î¶â‚ƒÂ²,1,Î¶â‚ƒ,1,1>\n\njulia> QuasiIsolatedRepresentatives(WF,3)\n4-element Vector{SemisimpleElement{Root1}}:\n <1,1,1,1,1,1>\n <1,1,1,-1,1,1>\n <1,-1,Î¶â‚„,1,Î¶â‚„,1>\n <1,Î¶â‚„Â³,1,-1,1,1>\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.Semisimple.is_isolated-Tuple{Spets, SemisimpleElement{Root1}}","page":"Gapjm Documentation","title":"Gapjm.Semisimple.is_isolated","text":"is_isolated(WF::Spets,t::SemisimpleElement{Root1})\n\nWF  should be  a Coxeter  coset representing  an algebraic  coset ð† â‹…Ïƒ, where  ð† is a connected  reductive group (represented by W=Group(WF)), and  Ïƒ  is  a  quasi-central  automorphism  of  ð† defined by WF. The element  t should be a semisimple element of ð†. The function returns a boolean describing whether tÏƒ is isolated, that is whether the Weyl group of C_ð† (tÏƒ)â° is not in any proper parabolic subgroup of W^Ïƒ.\n\njulia> WF=rootdatum(:u,6)\nÂ²Aâ‚…Î¦â‚‚\n\njulia> l=QuasiIsolatedRepresentatives(WF)\n4-element Vector{SemisimpleElement{Root1}}:\n <1,1,1,1,1,1>\n <Î¶â‚„,1,1,1,1,Î¶â‚„Â³>\n <Î¶â‚„,Î¶â‚„,1,1,Î¶â‚„Â³,Î¶â‚„Â³>\n <Î¶â‚„,Î¶â‚„,Î¶â‚„,Î¶â‚„Â³,Î¶â‚„Â³,Î¶â‚„Â³>\n\njulia> is_isolated.(Ref(WF),l)\n4-element BitVector:\n 1\n 0\n 1\n 1\n\n\n\n\n\n","category":"method"},{"location":"#Unipotent-characters","page":"Gapjm Documentation","title":"Unipotent characters","text":"","category":"section"},{"location":"","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"Uch\nUnipotentCharacters\ndegrees(::UnipotentCharacters,q)\nUch.CycPolUnipotentDegrees\nUniChar\nDLChar\nalmostChar\non_unipotents\nDLLefschetz\nLusztigInduce\nLusztigRestrict\nLusztigInductionTable\nFamilies\nFamily\nfourier\ndrinfeld_double\nndrinfeld_double\nfamily_imprimitive\nFamiliesClassical\n*(f::Family, g::Family)\nfusion_algebra","category":"page"},{"location":"#Gapjm.Uch","page":"Gapjm Documentation","title":"Gapjm.Uch","text":"Let  ð† be a connected reductive group defined over the algebraic closure of  a finite field ð”½_q,  with corresponding Frobenius automorphism F, or  more generally let  F be an  isogeny of ð† such that  a power is a Frobenius (this covers the Suzuki and Ree groups).\n\nIf  ð“  is  an  F-stable  maximal  torus  of  ð†,  and  ð is a (not necessarily  F-stable)  Borel  subgroup  containing  ð“,  we  define the Deligne-Lusztig  variety X_ð=gð  ð†  ð  gð   F(gð ) . This variety  has a natural action of ð† ^F on the left, so the corresponding Deligne-Lusztig  virtual module  áµ¢ (-1)â±  Hâ±_c(X_ðâ„š _â„“)  also. The character  of this virtual module  is the Deligne-Lusztig character R_ð“ ^ð†  (1); the  notation reflects  the fact  that one  can prove  that this character does not depend on the choice of ð. Actually, this character is parameterized by an F-conjugacy class of W: if ð“â‚€âŠ‚ðâ‚€ is an F-stable pair,  there  is  an  unique  w  W=N_ð†  (ð“â‚€)ð“â‚€  such  that the triple (ð“,ð,F) is ð†-conjugate to (ð“â‚€,ðâ‚€,wF). In this case we denote R_w for R_ð“^ð† (1); it depends only on the F-class of w.\n\nThe  unipotent characters of ð† ^F are the irreducible constituents of the  R_w. In a  similar way that  the unipotent classes  are a building block  for  describing  the  conjugacy  classes  of  a reductive group, the unipotent characters are a building block for the irreducible characters of a  reductive group.  They can  be parameterized  by combinatorial data that Lusztig  has attached just to the coset WÏ†, where Ï† is the finite order automorphism  of  X(ð“â‚€)  such  that  F=qÏ†.  Thus, from the viewpoint of Chevie, they are objects combinatorially attached to a Coxeter coset.\n\nA  subset  of  the  unipotent  characters, the principal series unipotent characters,   can  be  described  in  an   elementary  way.  They  are  the constituents  of Râ‚, or equivalently the characters of the virtual module defined  by the  cohomology of  X_ð â‚€,  which is the discrete variety (ð†  ðâ‚€)^F; the virtual module reduces  to the actual module â„š _â„“(ð† ðâ‚€)  ^F. Thus the  Deligne-Lusztig induction R_ð“â‚€^ð† (1) reduces to Harish-Chandra  induction,  defined  as  follows:  let  ð  =ð”  â‹Š ð‹ be an F-stable  Levi decomposition of an F-stable parabolic subgroup of ð†. Then  the Harish-Chandra induced R_ð‹^ð† of a character Ï‡ of ð‹^F is  the character Ind_ð^F^ð† ^FÏ‡, where Ï‡Ìƒ is the lift to ð^F of  Ï‡ via  the quotient  ð^Fð” ^F=ð‹^F;  Harish-Chandra induction is a particular  case of Lusztig  induction, which is  defined when ð is not F-stable  using the variety X_ð” = gð” ð† ð”  gð”  F(gð” ), and gives  for  an  ð‹^F-module  a  virtual  ð†  ^F-module. Like ordinary induction,  these functors have adjoint functors going from representations of  ð† ^F to representations  (resp. virtual representations) of ð‹^F called Harish-Chandra restriction (resp. Lusztig restriction).\n\nThe  commuting algebra  of ð†^F-endomorphisms  of R_ð“â‚€^ð†(1)  is an Iwahori-Hecke algebra for W^Ï†, with parameters which are some powers of q;  they  are  all  equal  to  q  when W^Ï†=W. Thus principal series unipotent characters correspond to characters of W^Ï†.\n\nTo  understand the  decomposition of  Deligne-Lusztig characters,  and thus unipotent  characters,  is  is  useful  to  introduce  another set of class functions  which are parameterized  by irreducible characters  of the coset WÏ†.  If  Ï‡  is  such  a  character,  we  define  the associated almost character  by: Ráµª=WÂ¹_w  WÏ‡(wÏ†) R_w.  The reason  to the name is that these class function are close to irreducible characters: they satisfy Ráµª  R_Ïˆ_ð†^F=Î´_Ï‡Ïˆ;  for  the  linear  and unitary group they are actually  unipotent characters (up to sign in the latter case). They are in general  sum (with  rational coefficients)  of a  small number of unipotent characters  in  the  same  Lusztig  family  (see  \"Families  of unipotent characters\").  The degree of Ráµª is a  polynomial in q equal to the fake degree  of  the  character  Ï‡  of  WÏ†  (see  \"Functions  for Reflection cosets\").\n\nWe  now describe the parameterization of unipotent characters when W^Ï†=W, thus  when the coset WÏ† identifies with W (the situation is similar but a  bit more difficult to describe  in general). The (rectangular) matrix of scalar  products Ï Ráµª_ð†  ^F, when characters  of W and unipotent characters  are arranged in the right  order, is block-diagonal with rather small blocks which are called Lusztig families.\n\nFor  the characters of W a family ð“• corresponds to a block of the Hecke algebra  over a ring called the Rouquier  ring. To ð“• Lusztig associates a small group Î“ (not bigger than (â„¤/2)â¿, or ð”–áµ¢ for iâ‰¤5) such that the unipotent  characters in the family are  parameterized by the pairs (x,Î¸) taken  up to Î“-conjugacy, where xâˆˆÎ“ and Î¸ is an irreducible character of C_Î“(x). Further, the elements of ð“• themselves are parameterized by a  subset of such pairs,  and Lusztig defines a  pairing between such pairs which  computes the scalar product Ï  Ráµª_ð†^F. For more details see \"DrinfeldDouble\".\n\nA  second parameterization  of unipotent  character is  via Harish-Chandra series.  A character is called cuspidal if all its proper Harish-Chandra restrictions  vanish. There are few  cuspidal unipotent characters (none in linear   groups,  and  at   most  one  in   other  classical  groups).  The ð†^F-endomorphism algebra of an Harish-Chandra induced R_ð‹^F^ð†^FÎ»,  where Î» is a  cuspidal unipotent character turns out to be a Hecke algebra associated to the group W_ð†^F(ð‹^F)=N_ð†^F(ð‹)ð‹, which turns out to be a Coxeter group. Thus another  parameterization is by triples (ð‹,Î»,Ï†),  where Î» is a cuspidal unipotent  character of ð‹^F and Ï†  is an irreducible character of the relative  group W_ð†^F(ð‹^F). Such  characters are said  to belong to the Harish-Chandra series determined by (ð‹,Î»).\n\nA  final  piece  of  information  attached  to  unipotent characters is the eigenvalues  of Frobenius. Let FáµŸ be  the smallest power of the isogeny F  which is a split Frobenius (that  is, FáµŸ is a Frobenius and Ï†áµŸ=1). Then  FáµŸ  acts  naturally  on  Deligne-Lusztig  varieties and thus on the corresponding  virtual modules, and commutes to the action of ð†^F; thus for  a given  unipotent character  Ï, a  submodule of  the virtual module which  affords  Ï  affords  a  single  eigenvalue Î¼ of FáµŸ. Results of Lusztig  and Digne-Michel show that this  eigenvalue is of the form qáµƒáµŸÎ»áµ¨ where  2aâˆˆâ„¤ and Î»áµ¨ is a root of unity which depends only on Ï and not the  considered module.  This Î»áµ¨  is called  the eigenvalue  of Frobenius attached  to Ï.  Unipotent characters  in the  Harish-Chandra series of a pair (ð‹,Î») have the same eigenvalue of Frobenius as Î».\n\nChevie   contains  tables  of  all   this  information,   and  can  compute Harish-Chandra  and Lusztig  induction of  unipotent characters  and almost characters. We illustrate the information on some examples:\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> uc=UnipotentCharacters(W)\nUnipotentCharacters(Gâ‚‚)\n      Î³â”‚   Deg(Î³)  Feg Fr(Î³)    label\nâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nÏ†â‚â€šâ‚€   â”‚        1    1     1         \nÏ†â‚â€šâ‚†   â”‚       qâ¶   qâ¶     1         \nÏ†â€²â‚â€šâ‚ƒ  â”‚  qÎ¦â‚ƒÎ¦â‚†/3   qÂ³     1    (1,Ï)\nÏ†â€³â‚â€šâ‚ƒ  â”‚  qÎ¦â‚ƒÎ¦â‚†/3   qÂ³     1   (gâ‚ƒ,1)\nÏ†â‚‚â€šâ‚   â”‚ qÎ¦â‚‚Â²Î¦â‚ƒ/6  qÎ¦â‚ˆ     1    (1,1)\nÏ†â‚‚â€šâ‚‚   â”‚ qÎ¦â‚‚Â²Î¦â‚†/2 qÂ²Î¦â‚„     1   (gâ‚‚,1)\nGâ‚‚[-1] â”‚ qÎ¦â‚Â²Î¦â‚ƒ/2    0    -1   (gâ‚‚,Îµ)\nGâ‚‚[1]  â”‚ qÎ¦â‚Â²Î¦â‚†/6    0     1    (1,Îµ)\nGâ‚‚[Î¶â‚ƒ] â”‚qÎ¦â‚Â²Î¦â‚‚Â²/3    0    Î¶â‚ƒ  (gâ‚ƒ,Î¶â‚ƒ)\nGâ‚‚[Î¶â‚ƒÂ²]â”‚qÎ¦â‚Â²Î¦â‚‚Â²/3    0   Î¶â‚ƒÂ² (gâ‚ƒ,Î¶â‚ƒÂ²)\n\nThe first column gives the name of the unipotent character; the first 6 are in  the  principal  series  so  are  named  according  to the corresponding characters  of W. The last 4 are cuspidal, and named by the corresponding eigenvalue  of  Frobenius,  which  is  displayed  in  the fourth column. In general   the   names   of   the   unipotent  characters  come  from  their parameterization  by  Harish-Chandra  series;  in  addition,  for classical groups, they are associated to symbols.\n\nThe first two characters are each in a family by themselves. The last eight are  in a family associated to the  group Î“=ð”–â‚ƒ: the last column shows the parameters  (x,Î¸). The  second column  shows the  degree of the unipotent characters, which is transformed by the Lusztig Fourier matrix of the third column,  which gives the  degree of the  corresponding almost character, or equivalently the fake degree of the corresponding character of W.\n\nOne  can get  more information  on the  Lusztig Fourier  matrix of  the big family by asking\n\njulia> uc.families[1]\nFamily(D(ð”– â‚ƒ),[5, 6, 4, 3, 8, 7, 9, 10])\nDrinfeld double of ð”– â‚ƒ, Lusztigâ€²s version\n   labelâ”‚eigen                                               \nâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n(1,1)   â”‚    1 1//6  1//2  1//3  1//3  1//6  1//2  1//3  1//3\n(gâ‚‚,1)  â”‚    1 1//2  1//2  0//1  0//1 -1//2 -1//2  0//1  0//1\n(gâ‚ƒ,1)  â”‚    1 1//3  0//1  2//3 -1//3  1//3  0//1 -1//3 -1//3\n(1,Ï)   â”‚    1 1//3  0//1 -1//3  2//3  1//3  0//1 -1//3 -1//3\n(1,Îµ)   â”‚    1 1//6 -1//2  1//3  1//3  1//6 -1//2  1//3  1//3\n(gâ‚‚,Îµ)  â”‚   -1 1//2 -1//2  0//1  0//1 -1//2  1//2  0//1  0//1\n(gâ‚ƒ,Î¶â‚ƒ) â”‚   Î¶â‚ƒ 1//3  0//1 -1//3 -1//3  1//3  0//1  2//3 -1//3\n(gâ‚ƒ,Î¶â‚ƒÂ²)â”‚  Î¶â‚ƒÂ² 1//3  0//1 -1//3 -1//3  1//3  0//1 -1//3  2//3\n\nOne  can  do  computations  with  individual  unipotent characters. Here we construct  the Coxeter torus, and then the identity character of this torus as a unipotent character.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> T=spets(reflection_subgroup(W,Int[]),W(1,2))\nGâ‚‚â‚â‚Ž=Î¦â‚†\n\njulia> u=UniChar(T,1)\n[Gâ‚‚â‚â‚Ž=Î¦â‚†]:<.>\n\nThen  here  are  two  ways  to  construct  the  Deligne-Lusztig  character associated to the Coxeter torus:\n\njulia> LusztigInduce(W,u)\n[Gâ‚‚]:<Ï†â‚â€šâ‚€>+<Ï†â‚â€šâ‚†>-<Ï†â‚‚â€šâ‚>+<Gâ‚‚[-1]>+<Gâ‚‚[Î¶â‚ƒ]>+<Gâ‚‚[Î¶â‚ƒÂ²]>\n\njulia> v=DLChar(W,[1,2])\n[Gâ‚‚]:<Ï†â‚â€šâ‚€>+<Ï†â‚â€šâ‚†>-<Ï†â‚‚â€šâ‚>+<Gâ‚‚[-1]>+<Gâ‚‚[Î¶â‚ƒ]>+<Gâ‚‚[Î¶â‚ƒÂ²]>\n\njulia> degree(v)\nPol{Int64}: qâ¶+qâµ-qâ´-2qÂ³-qÂ²+q+1\n\njulia> v*v\n6\n\nThe  last two lines ask for the degree  of v, then for the scalar product of v with itself.\n\nFinally  we mention  that Chevie  can also  provide unipotent characters of Spetses, as defined in BroueMalleMichel2014. An example:\n\njulia> UnipotentCharacters(ComplexReflectionGroup(4))\nUnipotentCharacters(Gâ‚„)\n    Î³â”‚           Deg(Î³)    Feg Fr(Î³)   label\nâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nÏ†â‚â€šâ‚€ â”‚                1      1     1        \nÏ†â‚â€šâ‚„ â”‚ -âˆš-3qâ´Î¦â€³â‚ƒÎ¦â‚„Î¦â€³â‚†/6     qâ´     1  1âˆ§-Î¶â‚ƒÂ²\nÏ†â‚â€šâ‚ˆ â”‚  âˆš-3qâ´Î¦â€²â‚ƒÎ¦â‚„Î¦â€²â‚†/6     qâ¸     1  -1âˆ§Î¶â‚ƒÂ²\nÏ†â‚‚â€šâ‚… â”‚        qâ´Î¦â‚‚Â²Î¦â‚†/2   qâµÎ¦â‚„     1   1âˆ§Î¶â‚ƒÂ²\nÏ†â‚‚â€šâ‚ƒ â”‚-Î¶â‚ƒâˆš-3qÎ¦â€³â‚ƒÎ¦â‚„Î¦â€²â‚†/3   qÂ³Î¦â‚„     1   1âˆ§Î¶â‚ƒÂ²\nÏ†â‚‚â€šâ‚ â”‚Î¶â‚ƒÂ²âˆš-3qÎ¦â€²â‚ƒÎ¦â‚„Î¦â€³â‚†/3    qÎ¦â‚„     1    1âˆ§Î¶â‚ƒ\nÏ†â‚ƒâ€šâ‚‚ â”‚           qÂ²Î¦â‚ƒÎ¦â‚† qÂ²Î¦â‚ƒÎ¦â‚†     1        \nZâ‚ƒ:2 â”‚    -âˆš-3qÎ¦â‚Î¦â‚‚Î¦â‚„/3      0   Î¶â‚ƒÂ²  Î¶â‚ƒâˆ§Î¶â‚ƒÂ²\nZâ‚ƒ:11â”‚   -âˆš-3qâ´Î¦â‚Î¦â‚‚Î¦â‚„/3      0   Î¶â‚ƒÂ²  Î¶â‚ƒâˆ§-Î¶â‚ƒ\nGâ‚„   â”‚       -qâ´Î¦â‚Â²Î¦â‚ƒ/2      0    -1 -Î¶â‚ƒÂ²âˆ§-1\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.Uch.UnipotentCharacters","page":"Gapjm Documentation","title":"Gapjm.Uch.UnipotentCharacters","text":"UnipotentCharacters(W)\n\nW  should be a Coxeter group, a  Coxeter Coset or a Spetses. The function gives  back a record containing  information about the unipotent characters of the associated algebraic group (or Spetses). This contains the following fields:\n\n.harishChandra:  information  about  Harish-Chandra  series  of  unipotent characters.  This is itself a list of records, one for each pair (ð‹,Î») of a  Levi  of  an  F-stable  parabolic  subgroup  and  a cuspidal unipotent character of ð‹^F. These records themselves have the following fields:\n\n:levi: a list 'l' such that ð‹ corresponds to 'ReflectionSubgroup(W,l)'.\n\n:cuspidalName: the name of the unipotent cuspidal character lambda.\n\n:eigenvalue: the eigenvalue of Frobenius for Î».\n\n:relativeType: the reflection type of W_ð† (ð‹);\n\n:parameterExponents:  the ð† ^F-endomorphism  algebra of R_ð‹^ð† (Î») is  a  Hecke  algebra  for  W_ð†  (ð‹)  with  some parameters of the form q^a_s. This holds the list of exponents a_s.\n\n:charNumbers:  the  indices  of  the  unipotent  characters indexed by the irreducible characters of W_ð† (ð‹).\n\n.almostHarishChandra:   information   about   Harish-Chandra   series  of unipotent  character sheaves.  This is  identical to  Ì€harishChandra` for a split  reductive group,  and reflects  the situation  for the corresponding split group for a nonsplit group.\n\n.families:  information  about  Lusztig  families of unipotent characters. This  is itself a list  of records, one for  each family. These records are described in the section about families below.\n\nthe following information is computed on demand from uc=UnipotentCharacters(W):\n\nspets(uc): the reductive group W.\n\njulia> W=coxgroup(:Bsym,2)\nBsymâ‚‚\n\njulia> WF=spets(W,Perm(1,2))\nÂ²Bsymâ‚‚\n\njulia> uc=UnipotentCharacters(WF)\nUnipotentCharacters(Â²Bsymâ‚‚)\n       Î³â”‚   Deg(Î³)   Feg Fr(Î³) label\nâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n2       â”‚        1     1     1      \n11      â”‚       qâ´    qâ´     1      \nÂ²Bâ‚‚[1,3]â”‚âˆš2qÎ¦â‚Î¦â‚‚/2 qÎ¦â‚Î¦â‚‚   Î¶â‚ˆÂ³     1\nÂ²Bâ‚‚[1,5]â”‚âˆš2qÎ¦â‚Î¦â‚‚/2     0   Î¶â‚ˆâµ     2\n\njulia> uc.families\n3-element Vector{Family}:\n Family(Câ‚,[1]) \n Family(Câ‚,[2]) \n Family(?4,3:4)\n\njulia> uc.families[3]\nFamily(?4,3:4)\nlabelâ”‚eigen    1     2\nâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n1    â”‚  Î¶â‚ˆÂ³ âˆš2/2 -âˆš2/2\n2    â”‚  -Î¶â‚ˆ âˆš2/2  âˆš2/2\n\ncharnames(uc):  the list of names of the unipotent characters.  Using    appropriate keywords, one can control the display in various ways.\n\njulia> uc=UnipotentCharacters(coxgroup(:G,2));\n\njulia> charnames(uc;limit=true)\n10-element Vector{String}:\n \"Ï†â‚â€šâ‚€\"   \n \"Ï†â‚â€šâ‚†\"   \n \"Ï†â€²â‚â€šâ‚ƒ\"  \n \"Ï†â€³â‚â€šâ‚ƒ\"  \n \"Ï†â‚‚â€šâ‚\"   \n \"Ï†â‚‚â€šâ‚‚\"   \n \"Gâ‚‚[-1]\" \n \"Gâ‚‚[1]\"  \n \"Gâ‚‚[Î¶â‚ƒ]\" \n \"Gâ‚‚[Î¶â‚ƒÂ²]\"\n\njulia> charnames(uc;TeX=true)\n10-element Vector{String}:\n \"\\phi_{1,0}\"    \n \"\\phi_{1,6}\"    \n \"\\phi_{1,3}'\"   \n \"\\phi_{1,3}''\"  \n \"\\phi_{2,1}\"    \n \"\\phi_{2,2}\"    \n \"G_2[-1]\"        \n \"G_2[1]\"         \n \"G_2[\\zeta_3]\"  \n \"G_2[\\zeta_3^2]\"\n\nOne  can control  the display  of unipotent  characters in  various ways by IOContext  properties. In the display, the row labels are the nems of the unipotent characters. Then the following column numbers display:\n\n1: The index of the character in the list of unipotent characters.\n2: The degree of the unipotent character.\n3: The degree of the corresponding almost character.\n4: for classical groups, the symbol attached to the unipotent character.\n5: The eigenvalue of Frobenius attached to the unipotent character.\n6: The parameter the character has in its Lusztig family.\n7: The sign attached to the character in the Fourier transform.\n\nWhich  columns  are  displayed  can  be  controlled by the property :cols (default [2,3,5,6]).\n\nIn  addition if  ':byfamily=true', the  characters are  displayed family by family  instead  of  in  index  order.  Finally,  the properties rows and columnrepartition  of  format  can  be  set,  giving more tuning of the table.\n\njulia> W=coxgroup(:B,2)\nBâ‚‚\n\njulia> uc=UnipotentCharacters(W)\nUnipotentCharacters(Bâ‚‚)\n  Î³â”‚Deg(Î³) Feg Fr(Î³) label\nâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n11.â”‚ qÎ¦â‚„/2  qÂ²     1   +,-\n1.1â”‚qÎ¦â‚‚Â²/2 qÎ¦â‚„     1   +,+\n.11â”‚    qâ´  qâ´     1      \n2. â”‚     1   1     1      \n.2 â”‚ qÎ¦â‚„/2  qÂ²     1   -,+\nBâ‚‚ â”‚qÎ¦â‚Â²/2   0    -1   -,-\n\njulia> xdisplay(uc;byfamily=true)\nUnipotentCharacters(Bâ‚‚)\n   Î³â”‚Deg(Î³) Feg Fr(Î³) label\nâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n2.Ë¢ â”‚     1   1     1      \nâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n11. â”‚ qÎ¦â‚„/2  qÂ²     1   +,-\n1.1Ë¢â”‚qÎ¦â‚‚Â²/2 qÎ¦â‚„     1   +,+\n.2  â”‚ qÎ¦â‚„/2  qÂ²     1   -,+\nBâ‚‚  â”‚qÎ¦â‚Â²/2   0    -1   -,-\nâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n.11Ë¢â”‚    qâ´  qâ´     1      \nâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\njulia> xdisplay(uc;cols=[1,4])\nUnipotentCharacters(Bâ‚‚)\n  Î³â”‚nâ‚€   Symbol\nâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n11.â”‚ 1   (12,0)\n1.1â”‚ 2   (02,1)\n.11â”‚ 3 (012,12)\n2. â”‚ 4     (2,)\n.2 â”‚ 5   (01,2)\nBâ‚‚ â”‚ 6   (012,)\n\n\n\n\n\n","category":"type"},{"location":"#Gapjm.degrees-Tuple{UnipotentCharacters, Any}","page":"Gapjm Documentation","title":"Gapjm.degrees","text":"degrees(uc::UnipotentCharacters,q=Pol())\n\nReturns  the  list  of  degrees  of  the unipotent characters of the finite reductive group (or Spetses) with Weyl group (or Spetsial reflection group) W, evaluated at q.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> uc=UnipotentCharacters(W);\n\njulia> degrees(uc)\n10-element Vector{Pol{Rational{Int64}}}:\n 1//1                                         \n (1//1)qâ¶                                     \n (1//3)qâµ+(1//3)qÂ³+(1//3)q                    \n (1//3)qâµ+(1//3)qÂ³+(1//3)q                    \n (1//6)qâµ+(1//2)qâ´+(2//3)qÂ³+(1//2)qÂ²+(1//6)q  \n (1//2)qâµ+(1//2)qâ´+(1//2)qÂ²+(1//2)q           \n (1//2)qâµ+(-1//2)qâ´+(-1//2)qÂ²+(1//2)q         \n (1//6)qâµ+(-1//2)qâ´+(2//3)qÂ³+(-1//2)qÂ²+(1//6)q\n (1//3)qâµ+(-2//3)qÂ³+(1//3)q                   \n (1//3)qâµ+(-2//3)qÂ³+(1//3)q                   \n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.Uch.CycPolUnipotentDegrees","page":"Gapjm Documentation","title":"Gapjm.Uch.CycPolUnipotentDegrees","text":"CycPolUnipotentDegrees(W)\n\nTaking  advantage that  the degrees  of unipotent  characters of the finite reductive group (or Spetses) with Weyl group (or Spetsial reflection group) W  are products  of cyclotomic  polynomials, this  function returns these degrees as a list of CycPols.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> CycPolUnipotentDegrees(W)\n10-element Vector{CycPol{Rational{Int64}}}:\n 1     \n qâ¶       \n qÎ¦â‚ƒÎ¦â‚†/3  \n qÎ¦â‚ƒÎ¦â‚†/3  \n qÎ¦â‚‚Â²Î¦â‚ƒ/6 \n qÎ¦â‚‚Â²Î¦â‚†/2 \n qÎ¦â‚Â²Î¦â‚ƒ/2 \n qÎ¦â‚Â²Î¦â‚†/6 \n qÎ¦â‚Â²Î¦â‚‚Â²/3\n qÎ¦â‚Â²Î¦â‚‚Â²/3\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Uch.UniChar","page":"Gapjm Documentation","title":"Gapjm.Uch.UniChar","text":"UniChar(W,l)\n\nConstructs  an object representing the unipotent character specified by l of  the algebraic  group associated  to the  Coxeter group or Coxeter coset specified  by W. There are 3 possibilities  for l: if it is an integer, the  l-th unipotent character of W is  returned. If it is a string, the unipotent  character of W whose name is l is returned. Finally, l can be  a  list  of  length  the  number  of unipotent characters of W, which specifies the coefficient to give to each.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> u=UniChar(W,7)\n[Gâ‚‚]:<Gâ‚‚[-1]>\n\njulia> v=UniChar(W,\"G2[E3]\")\n[Gâ‚‚]:<Gâ‚‚[Î¶â‚ƒ]>\n\njulia> w=UniChar(W,[1,0,0,-1,0,0,2,0,0,1])\n[Gâ‚‚]:<Ï†â‚â€šâ‚€>-<Ï†â€³â‚â€šâ‚ƒ>+2<Gâ‚‚[-1]>+<Gâ‚‚[Î¶â‚ƒÂ²]>\n\nsome limited arithmetic is available on unipotent characters:\n\njulia> w-2u\n[Gâ‚‚]:<Ï†â‚â€šâ‚€>-<Ï†â€³â‚â€šâ‚ƒ>+<Gâ‚‚[Î¶â‚ƒÂ²]>\n\njulia> w*w  # scalar product\n7\n\njulia> degree(w)\nPol{Int64}: qâµ-qâ´-qÂ³-qÂ²+q+1\n\n\n\n\n\n","category":"type"},{"location":"#Gapjm.Uch.DLChar","page":"Gapjm Documentation","title":"Gapjm.Uch.DLChar","text":"DLChar(W,w)\n\nThis  function returns the Deligne-Lusztig character  R_ð“ ^ð† (1) of the algebraic  group ð† associated to the Coxeter group or Coxeter coset W. The  torus  ð“  can  be  specified  in  3  ways:  if w is an integer, it represents the w-th conjugacy class (or phi-conjugacy class for a coset WÏ•)  of W. Otherwise  w can be  a word or  an element of  W, and it represents the class (or Ï•-class) of w.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> DLChar(W,3)\n[Gâ‚‚]:<Ï†â‚â€šâ‚€>-<Ï†â‚â€šâ‚†>-<Ï†â€²â‚â€šâ‚ƒ>+<Ï†â€³â‚â€šâ‚ƒ>\n\njulia> DLChar(W,W(1))\n[Gâ‚‚]:<Ï†â‚â€šâ‚€>-<Ï†â‚â€šâ‚†>-<Ï†â€²â‚â€šâ‚ƒ>+<Ï†â€³â‚â€šâ‚ƒ>\n\njulia> DLChar(W,[1])\n[Gâ‚‚]:<Ï†â‚â€šâ‚€>-<Ï†â‚â€šâ‚†>-<Ï†â€²â‚â€šâ‚ƒ>+<Ï†â€³â‚â€šâ‚ƒ>\n\njulia> DLChar(W,[1,2])\n[Gâ‚‚]:<Ï†â‚â€šâ‚€>+<Ï†â‚â€šâ‚†>-<Ï†â‚‚â€šâ‚>+<Gâ‚‚[-1]>+<Gâ‚‚[Î¶â‚ƒ]>+<Gâ‚‚[Î¶â‚ƒÂ²]>\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Uch.almostChar","page":"Gapjm Documentation","title":"Gapjm.Uch.almostChar","text":"almostChar(W,i)\n\nThis  function  returns  the  i-th  almost  unipotent  character  of  the algebraic  group ð† associated to the Coxeter group or Coxeter coset W. If Ï† is the i-th irreducible character of W, the i-th almost character is  R_Ï†=WÂ¹_w W  Ï†(w) R_ð“_w^ð†  (1) where  ð“_w is  the maximal torus  associated  to  the  conjugacy  class  (or Ï•-conjugacy class for a coset) of w.\n\njulia> W=coxgroup(:B,2)\nBâ‚‚\n\njulia> almostChar(W,3)\n[Bâ‚‚]:<.11>\n\njulia> almostChar(W,1)\n[Bâ‚‚]:1//2<11.>+1//2<1.1>-1//2<.2>-1//2<Bâ‚‚>\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Uch.on_unipotents","page":"Gapjm Documentation","title":"Gapjm.Uch.on_unipotents","text":"on_unipotents(W,aut)\n\nW  is  a  reflection  group  or  reflection  coset  representing a finite reductive group ð† ^F, and aut is an automorphism of ð† ^F (for W a  permutation group, this can be given as a permutation of the roots). The function  returns the permutation  of the unipotent  characters of ð† ^F induced  by aut. This makes sense  for Spetsial complex reflection groups and is implemented for them.\n\njulia> WF=rootdatum(\"3D4\")\nÂ³Dâ‚„\n\njulia> on_unipotents(Group(WF),WF.phi)\n(1,7,2)(8,12,9)\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Uch.DLLefschetz","page":"Gapjm Documentation","title":"Gapjm.Uch.DLLefschetz","text":"DLLefschetz(h)\n\nHere h is an element of a Hecke algebra associated to a Coxeter group W which  itself  is  associated  to  an  algebraic  group ð†. By results of Digne-Michel,  for g ð† ^F,  the number of fixed  points of Fáµ on the Deligne-Lusztig variety associated to the element wÏ• of the Coxeter coset WÏ•, have for m sufficiently divisible, the form _Ï† Ï†_(qáµ)(T_wÏ•)R_Ï†(g)  where Ï†  runs over  the irreducible characters of WÏ•,  where  R_Ï†  is  the  corresponding  almost  character, and where Ï†_(qáµ)  is a character value of the Hecke algebra â„‹ (WÏ•,qáµ) of WÏ• with parameter qáµ. This expression is called the Lefschetz character of the  Deligne-Lusztig variety. If we consider  qáµ as an indeterminate x, it can be seen as a sum of unipotent characters with coefficients character values of the generic Hecke algebra â„‹ (WÏ•,x).\n\nThe  function 'DLLefschetz' takes  as argument a  Hecke element and returns the  corresponding Lefschetz character. This is defined on the whole of the Hecke  algebra by linearity.  The Lefschetz character  of various varieties related   to   Deligne-Lusztig   varieties,   like   their  completions  or desingularisation,  can be  obtained by  taking the  Lefschetz character at various elements of the Hecke algebra.\n\njulia> W=coxgroup(:A,2)\nAâ‚‚\n\njulia> H=hecke(W,Pol(:q))\nhecke(Aâ‚‚,q)\n\njulia> T=Tbasis(H);\n\njulia> DLLefschetz(T(1,2))\n[Aâ‚‚]:<111>-q<21>+qÂ²<3>\n\njulia> DLLefschetz((T(1)+T())*(T(2)+T()))\n[Aâ‚‚]:q<21>+(qÂ²+2q+1)<3>\n\nThe   last  line  shows  the   Lefschetz  character  of  the  Samelson-Bott desingularisation of the Coxeter element Deligne-Lusztig variety.\n\nWe now show an example with a coset (corresponding to the unitary group).\n\njulia> H=hecke(spets(W,Perm(1,2)),Pol(:q)^2)\nhecke(Â²Aâ‚‚,qÂ²)\n\njulia> T=Tbasis(H);DLLefschetz(T(1))\n[Â²Aâ‚‚]:-<11>-q<Â²Aâ‚‚>+qÂ²<2>\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Uch.LusztigInduce","page":"Gapjm Documentation","title":"Gapjm.Uch.LusztigInduce","text":"LusztigInduce(W,u)\n\nu  should be a unipotent character of a parabolic subcoset of the Coxeter coset  W. It represents  a unipotent character  Î» of a  Levi ð‹ of the algebraic  group  ð†  attached  to  W.  The  program returns the Lusztig induced R_ð‹^ð†(Î»).\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> WF=spets(W)\nGâ‚‚\n\njulia> T=subspets(WF,Int[],W(1))\nGâ‚‚â‚â‚Ž=Î¦â‚Î¦â‚‚\n\njulia> u=UniChar(T,1)\n[Gâ‚‚â‚â‚Ž=Î¦â‚Î¦â‚‚]:<.>\n\njulia> LusztigInduce(WF,u)\n[Gâ‚‚]:<Ï†â‚â€šâ‚€>-<Ï†â‚â€šâ‚†>-<Ï†â€²â‚â€šâ‚ƒ>+<Ï†â€³â‚â€šâ‚ƒ>\n\njulia> DLChar(W,W(1))\n[Gâ‚‚]:<Ï†â‚â€šâ‚€>-<Ï†â‚â€šâ‚†>-<Ï†â€²â‚â€šâ‚ƒ>+<Ï†â€³â‚â€šâ‚ƒ>\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Uch.LusztigRestrict","page":"Gapjm Documentation","title":"Gapjm.Uch.LusztigRestrict","text":"LusztigRestrict(R,u)\n\nu  should be a unipotent character of a parent Coxeter coset W of which R is a parabolic subcoset. It represents a unipotent character Î³ of the algebraic  group ð† attached to W,  while R represents a Levi subgroup L. The program returns the Lusztig restriction *R_ð‹^ð†(Î³).\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> WF=spets(W)\nGâ‚‚\n\njulia> T=subspets(WF,Int[],W(1))\nGâ‚‚â‚â‚Ž=Î¦â‚Î¦â‚‚\n\njulia> u=DLChar(W,W(1))\n[Gâ‚‚]:<Ï†â‚â€šâ‚€>-<Ï†â‚â€šâ‚†>-<Ï†â€²â‚â€šâ‚ƒ>+<Ï†â€³â‚â€šâ‚ƒ>\n\njulia> LusztigRestrict(T,u)\n[Gâ‚‚â‚â‚Ž=Î¦â‚Î¦â‚‚]:4<.>\n\njulia> T=subspets(WF,Int[],W(2))\nGâ‚‚â‚â‚Ž=Î¦â‚Î¦â‚‚\n\njulia> LusztigRestrict(T,u)\n[Gâ‚‚â‚â‚Ž=Î¦â‚Î¦â‚‚]:0\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Lusztig.LusztigInductionTable","page":"Gapjm Documentation","title":"Gapjm.Lusztig.LusztigInductionTable","text":"LusztigInductionTable(R,W)\n\nR  should be a parabolic subgroup of the Coxeter group W or a parabolic subcoset  of  the  Coxeter  coset  W,  in  each  case representing a Levi subgroup  ð‹ of  the algebraic  group ð†  associated to W. The function returns  an InductionTable  representing the  Lusztig induction R_ð‹^ð† between unipotent characters.\n\njulia> W=coxgroup(:B,3)\nBâ‚ƒ\n\njulia> t=twistings(W,[1,3])\n2-element Vector{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}}:\n Bâ‚ƒâ‚â‚â‚ƒâ‚Ž=AÌƒâ‚Ã—Aâ‚Î¦â‚\n Bâ‚ƒâ‚â‚â‚ƒâ‚Ž=AÌƒâ‚Ã—Aâ‚Î¦â‚‚\n\njulia> LusztigInductionTable(t[2],W)\nLusztig Induction from Bâ‚ƒâ‚â‚â‚ƒâ‚Ž=AÌƒâ‚Ã—Aâ‚Î¦â‚‚ to Bâ‚ƒ\n     â”‚11âŠ— 11 11âŠ— 2 2âŠ— 11 2âŠ— 2\nâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n111. â”‚     1    -1    -1    .\n11.1 â”‚    -1     .     1   -1\n1.11 â”‚     .     .    -1    .\n.111 â”‚    -1     .     .    .\n21.  â”‚     .     .     .    .\n1.2  â”‚     1    -1     .    1\n2.1  â”‚     .     1     .    .\n.21  â”‚     .     .     .    .\n3.   â”‚     .     .     .    1\n.3   â”‚     .     1     1   -1\nBâ‚‚:2 â”‚     .     .     1   -1\nBâ‚‚:11â”‚     1    -1     .    .\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Families","page":"Gapjm Documentation","title":"Gapjm.Families","text":"Families of unipotent characters\n\nThe blocks of the (rectangular) matrix RáµªÏ_ð† ^F when Ï‡ runs over Irr(W)  and  Ï  runs  over  the  unipotent  characters,  are called the Lusztig  families. When  ð†  is split  and W  is a Coxeter group they correspond  on the Irr(W) side to two-sided Kazhdan-Lusztig cells â€“- for split  Spetses they  correspond to  Rouquier blocks  of the  Spetsial Hecke algebra.  The matrix of scalar products  RáµªÏ_ð† ^F can be completed to   a  square  matrix  A_ÏÏ_ð†  ^F  where  A_Ï  are  the characteristic  functions of character  sheaves on ð†  ^F; this square matrix is called the Fourier matrix of the family.\n\nThe  'UnipotentCharacters' record in Chevie contains a field '.families', a list of family records containing information on each family, including the Fourier matrix. Here is an example.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> uc=UnipotentCharacters(W);\n\njulia> uc.families\n3-element Vector{Family}:\n Family(D(ð”– â‚ƒ),[5, 6, 4, 3, 8, 7, 9, 10])\n Family(Câ‚,[1])                         \n Family(Câ‚,[2])                         \n\njulia> uc.families[1]\nFamily(D(ð”– â‚ƒ),[5, 6, 4, 3, 8, 7, 9, 10])\nDrinfeld double of ð”– â‚ƒ, Lusztigâ€²s version\n   labelâ”‚eigen                                               \nâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n(1,1)   â”‚    1 1//6  1//2  1//3  1//3  1//6  1//2  1//3  1//3\n(gâ‚‚,1)  â”‚    1 1//2  1//2  0//1  0//1 -1//2 -1//2  0//1  0//1\n(gâ‚ƒ,1)  â”‚    1 1//3  0//1  2//3 -1//3  1//3  0//1 -1//3 -1//3\n(1,Ï)   â”‚    1 1//3  0//1 -1//3  2//3  1//3  0//1 -1//3 -1//3\n(1,Îµ)   â”‚    1 1//6 -1//2  1//3  1//3  1//6 -1//2  1//3  1//3\n(gâ‚‚,Îµ)  â”‚   -1 1//2 -1//2  0//1  0//1 -1//2  1//2  0//1  0//1\n(gâ‚ƒ,Î¶â‚ƒ) â”‚   Î¶â‚ƒ 1//3  0//1 -1//3 -1//3  1//3  0//1  2//3 -1//3\n(gâ‚ƒ,Î¶â‚ƒÂ²)â”‚  Î¶â‚ƒÂ² 1//3  0//1 -1//3 -1//3  1//3  0//1 -1//3  2//3\n\njulia> charnames(uc)[uc.families[1].charNumbers]\n8-element Vector{String}:\n \"phi2,1\"  \n \"phi2,2\"  \n \"phi1,3''\"\n \"phi1,3'\" \n \"G2[1]\"   \n \"G2[-1]\"  \n \"G2[E3]\"  \n \"G2[E3^2]\"\n\nThe  Fourier matrix is obtained  by 'fourier(f)'; the field 'f.charNumbers' holds  the indices of the unipotent characters  which are in the family. We obtain  the list of eigenvalues of Frobenius for these unipotent characters by  'Eigenvalues(f)'. The Fourier matrix  and vector of eigenvalues satisfy the  properties of  fusion data,  see below.  The field 'f.charLabels' is what  is displayed  in the  column 'labels'  when displaying the family. It contains  labels naturally attached to lines  of the Fourier matrix. In the case   of  reductive  groups,   the  family  is   always  attached  to  the \"drinfeld_double\"  of a small finite group  and the '.charLabels' come from this construction.\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.Families.Family","page":"Gapjm Documentation","title":"Gapjm.Families.Family","text":"Family(f [, charNumbers [, opt]])\n\nThis function creates a new family in two possible ways.\n\nIn  the first case f is a string which denotes a family known to  Chevie. Examples are \"S3\",   \"S4\",   \"S5\"   which denote the family obtained as the Drinfeld  double of the symmetric group  on 3,4,5 elements, or \"C2\"   which denotes the Drinfeld double of the cyclic group of order 2.\n\nIn the second case f is already a struct Family.\n\nThe other (optional) arguments add information to the family defined by the first argument. If given, the second argument becomes f.charNumbers. If given,  the third argument  opt is a  Dict whose keys  are added to the resulting family.\n\nIf opt has a key signs, this should be a list of '1' and '-1', and then the  Fourier matrix  is conjugated  by the  diagonal matrix of those signs. This  is used  in Spetses  to adjust  the matrix  to the choice of signs of unipotent degrees.\n\njulia> Family(\"C2\")\nFamily(Câ‚‚,4)\nDrinfeldDouble(Z/2)\n labelâ”‚eigen                       \nâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n(1,1) â”‚    1 1//2  1//2  1//2  1//2\n(gâ‚‚,1)â”‚    1 1//2  1//2 -1//2 -1//2\n(1,Îµ) â”‚    1 1//2 -1//2  1//2 -1//2\n(gâ‚‚,Îµ)â”‚   -1 1//2 -1//2 -1//2  1//2\n\njulia> Family(\"C2\",4:7,Dict(:signs=>[1,-1,1,-1]))\nFamily(Câ‚‚,4:7)\nDrinfeldDouble(Z/2)\n labelâ”‚eigen signs                       \nâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n(1,1) â”‚    1     1  1//2 -1//2 1//2 -1//2\n(gâ‚‚,1)â”‚    1    -1 -1//2  1//2 1//2 -1//2\n(1,Îµ) â”‚    1     1  1//2  1//2 1//2  1//2\n(gâ‚‚,Îµ)â”‚   -1    -1 -1//2 -1//2 1//2  1//2\n\n\n\n\n\n","category":"type"},{"location":"#Gapjm.Families.fourier","page":"Gapjm Documentation","title":"Gapjm.Families.fourier","text":"fourier(f::Family: returns the Fourier matrix for the family f.\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Families.drinfeld_double","page":"Gapjm Documentation","title":"Gapjm.Families.drinfeld_double","text":"drinfeld_double(g[,opt])\n\nGiven  a (usually small) finite group  Î“, Lusztig has associated a family (a  Fourier matrix, a list of eigenvalues of Frobenius) which describes the representation ring of the Drinfeld double of the group algebra of Î“, and for   some  appropriate  small  groups  describes  a  family  of  unipotent characters. We do not explain the details of this construction, but explain how its final result building Lusztig's Fourier matrix, and a variant of it that we use in Spetses, from Î“.\n\nThe  elements of the family are in bijection  with the set ð“œ (Î“) of pairs (x,Ï‡)  taken up to  Î“-conjugacy, where xâˆˆÎ“  and Ï‡ is an irreducible complex-valued   character  of  C_Î“(x).  To  such  a  pair  Ï=(x,Ï‡)  is associated  an  eigenvalue  of  Frobenius  defined  by  Ï‰_Ï=Ï‡(x)Ï‡(1). Lusztig  then defines a Fourier matrix Sâ‚€ whose coefficient is given, for Ï=(x,Ï‡) and Ï'=(x', Ï‡'), by:\n\nSâ‚€_ÏÏ=C_Î“(x)Â¹_Ïâ‚=(xâ‚Ï‡â‚)Ï‡â‚(x)Ï‡(yâ‚)\n\nwhere  the sum is over all pairs Ïâ‚âˆˆð“œ (Î“) which are Î“-conjugate to Ï' and  such that yâ‚ C_Î“(x). This  coefficient also represents the scalar product ÏÏ_ð†^F of the corresponding unipotent characters.\n\nA  way to  understand the  formula for  Sâ‚€_ÏÏ better is to consider another  basis of the complex  vector space with basis  ð“œ (Î“), indexed by the  pairs  (x,y)  taken  up  to  Î“-conjugacy,  where  x  and y are commuting  elements  of  Î“.  This  basis  is  called  the basis of Mellin transforms, and given by:\n\n(xy)=_Ï‡ Irr(C_Î“(x))Ï‡(y)(xÏ‡)\n\nIn  the  basis  of  Mellin  transforms,  the  linear  map  Sâ‚€ is given by (x,y)â†¦(xâ»Â¹,yâ»Â¹)  and  the  linear  transformation  T which sends Ï to Ï‰_ÏÏ   becomes  (x,y)â†¦(x,xy).   These  are   particular  cases  of  the permutation  representation of GLâ‚‚(â„¤)  on the basis  of Mellin transforms where beginpmatrixabcr cdendpmatrix acts by (x,y)â†¦(xáµƒyáµ‡,xá¶œyáµˆ).\n\nFourier  matrices in finite reductive groups  are given by the above matrix Sâ‚€.  But for non-rational Spetses, we use a different matrix S which in the  basis of Mellin transforms  is given by (x,y)â†¦(yâ»Â¹,x). Equivalently, the formula S_ÏÏ differs from the formula for Sâ‚€_ÏÏ in that there  is no complex conjugation  of Ï‡â‚; thus the  matrix S is equal to Sâ‚€ multiplied on the right by the permutation matrix which corresponds to (x,Ï‡)â†¦(x,Ï‡Ì„).  The advantage of the matrix S over Sâ‚€ is that the pair S,T  satisfies directly the axioms for a fusion algebra (see below); also the matrix S is symmetric, while Sâ‚€ is Hermitian.\n\nThus there are two variants of 'drinfeld_double`:\n\ndrinfeld_double(g,lu=true)\n\nreturns  a family  containing Lusztig's  Fourier matrix  Sâ‚€, and an extra field  '.perm'  containing  the  permutation  of  the  indices  induced  by (x,Ï‡)â†¦(x,Ï‡Ì„),  which allows  to recover  S, as  well as  an extra field `:lusztig', set to 'true'.\n\ndrinfeld_double(g)\n\nreturns a family with the matrix S, which does not have fields '.lusztig' or '.perm'.\n\nThe family record 'f' returned also has the fields:\n\n:group: the group Î“.\n\n:charLabels: a list of labels describing the pairs (x,Ï‡), and thus also specifying in which order they are taken.\n\n:fourierMat: the Fourier matrix (the matrix S or Sâ‚€ depending on the call).\n\n:eigenvalues: the eigenvalues of Frobenius.\n\n:xy: a list of pairs '[x,y]' which are representatives of the Î“-orbits of pairs of commuting elements.\n\n:mellinLabels: a list of labels describing the pairs '[x,y]'.\n\n:mellin:  the base change matrix between  the basis (x,Ï‡) and the basis of   Mellin  transforms,   so  that   |f.fourierMat^(f.mellin^-1)|  is  the permutation  matrix (for (x,y)â†¦(yâ»Â¹,x)  or (x,y)â†¦(yâ»Â¹,xâ»Â¹) depending on the call).\n\n:special: the index of the special element, which is (x,Ï‡)=(1,1).\n\njulia> drinfeld_double(CoxSym(3))\nFamily(D(CoxSym(3)):8)\n   labelâ”‚eigen                                       \nâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n(1,X.1) â”‚    1  1/6  1/3 1/6 -3/2 -3/2  1/3  1/3  1/3\n(1,X.2) â”‚    1  1/3  2/3 1/3    0    0 -1/3 -1/3 -1/3\n(1,1)   â”‚    1  1/6  1/3 1/6  3/2  3/2  1/3  1/3  1/3\n(2a,X.1)â”‚   -1 -1/6    0 1/6  1/2 -1/2    0    0    0\n(2a,1)  â”‚    1 -1/6    0 1/6 -1/2  1/2    0    0    0\n(3a,1)  â”‚    1  1/3 -1/3 1/3    0    0  2/3 -1/3 -1/3\n(3a,X.2)â”‚  Î¶â‚ƒÂ²  1/3 -1/3 1/3    0    0 -1/3 -1/3  2/3\n(3a,X.3)â”‚   Î¶â‚ƒ  1/3 -1/3 1/3    0    0 -1/3  2/3 -1/3\n\njulia> drinfeld_double(CoxSym(3);lu=true)\nFamily(LD(CoxSym(3)):8)\n   labelâ”‚eigen                                       \nâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n(1,X.1) â”‚    1  1/6  1/3 1/6 -3/2 -3/2  1/3  1/3  1/3\n(1,X.2) â”‚    1  1/3  2/3 1/3    0    0 -1/3 -1/3 -1/3\n(1,1)   â”‚    1  1/6  1/3 1/6  3/2  3/2  1/3  1/3  1/3\n(2a,X.1)â”‚   -1 -1/6    0 1/6  1/2 -1/2    0    0    0\n(2a,1)  â”‚    1 -1/6    0 1/6 -1/2  1/2    0    0    0\n(3a,1)  â”‚    1  1/3 -1/3 1/3    0    0  2/3 -1/3 -1/3\n(3a,X.2)â”‚  Î¶â‚ƒÂ²  1/3 -1/3 1/3    0    0 -1/3  2/3 -1/3\n(3a,X.3)â”‚   Î¶â‚ƒ  1/3 -1/3 1/3    0    0 -1/3 -1/3  2/3\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Families.ndrinfeld_double","page":"Gapjm Documentation","title":"Gapjm.Families.ndrinfeld_double","text":"ndrinfeld_double(g)\n\nThis  function returns the number of elements that the family associated to the  Drinfeld double of the group g would have, without computing it. The evident advantage is the speed.\n\njulia> Families.ndrinfeld_double(ComplexReflectionGroup(5))\n378\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Families.family_imprimitive","page":"Gapjm Documentation","title":"Gapjm.Families.family_imprimitive","text":"family_imprimitive(S)\n\nS should be a symbol for a unipotent characters of an imprimitive complex reflection  group 'G(e,1,n)' or 'G(e,e,n)'. The function returns the family\n\njulia> Family(family_imprimitive([[0,1],[1],[0]]))\nFamily(0011,3)\nclassical family\nlabelâ”‚eigen      1        2        3\nâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n1    â”‚  Î¶â‚ƒÂ²  âˆš-3/3   -âˆš-3/3    âˆš-3/3\n2    â”‚    1 -âˆš-3/3 Î¶â‚ƒÂ²âˆš-3/3 -Î¶â‚ƒâˆš-3/3\n3    â”‚    1  âˆš-3/3 -Î¶â‚ƒâˆš-3/3 Î¶â‚ƒÂ²âˆš-3/3\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Families.FamiliesClassical","page":"Gapjm Documentation","title":"Gapjm.Families.FamiliesClassical","text":"FamiliesClassical(l)\n\nThe  list  l  should  be  a  list  of symbols as returned by the function symbols,  which classify the unipotent characters of groups of type :B, :C  or :D. FamiliesClassical returns  the list of families determined by these symbols.\n\njulia> FamiliesClassical(symbols(2,3,1))\n6-element Vector{Family}:\n Family(0112233,[4])\n Family(3,[9])\n Family(013,[5, 7, 10, 12])\n Family(112,[2])\n Family(022,[6])\n Family(01123,[1, 3, 8, 11])\n\nThe  above example shows the families of unipotent characters for the group B_3.\n\n\n\n\n\n","category":"function"},{"location":"#Base.:*-Tuple{Family, Family}","page":"Gapjm Documentation","title":"Base.:*","text":"<f>*<g>:  returns the  tensor product  of two  families <f> and <g>; the Fourier  matrix is the Kronecker  product of the matrices  for <f> and <g>, and the eigenvalues of Frobenius are the pairwise products.\n\n\n\n\n\n","category":"method"},{"location":"#Gapjm.Families.fusion_algebra","page":"Gapjm Documentation","title":"Gapjm.Families.fusion_algebra","text":"`FusionAlgebra(f::Family)`\n`FusionAlgebra(S,special=1)`\n\nAll  the Fourier matrices S in Chevie are unitary, that is Sâ»Â¹=conj(S), and  have a  special line  s (the  line of  index s=special(f)  for a family  f) such that no entry Sâ‚›,áµ¢  is equal to 0. Further, they have the  property that  the sums  Cáµ¢,â±¼,â‚–=sumâ‚— Sáµ¢,â‚—  Sâ±¼,â‚— conj(Sâ‚–,â‚—)/Sâ‚›,â‚— take integral  values. Finally,  S has  the property  that complex conjugation does a permutation with signs Ïƒ of the lines of S.\n\nIt  follows that we can define a Z-algebra A as follows: it has a basis báµ¢  indexed by the lines of S,  and has a multiplication defined by the fact that the coefficient of báµ¢bâ±¼ on bâ‚– is equal to Cáµ¢,â±¼,â‚–.\n\nA  is commutative, and has as unit  the element bâ‚›; the basis Ïƒ(báµ¢)isdual to báµ¢ for the linear form (báµ¢,bâ±¼)=Cáµ¢,â±¼,Ïƒâ‚â‚›â‚Ž`.\n\njulia> W=ComplexReflectionGroup(4)\nGâ‚„\n\njulia> uc=UnipotentCharacters(W);f=uc.families[4];\n\njulia> A=fusion_algebra(fourier(f),1)\nFusion Algebra dim.5\n\njulia> b=basis(A)\n5-element Vector{AlgebraElt{Gapjm.Families.FusionAlgebra, Int64}}:\n Bâ‚\n Bâ‚‚\n Bâ‚ƒ\n Bâ‚„\n Bâ‚…\n\njulia> b*permutedims(b)\n5Ã—5 Matrix{AlgebraElt{Gapjm.Families.FusionAlgebra, Int64}}:\n Bâ‚  Bâ‚‚      Bâ‚ƒ      Bâ‚„        Bâ‚…\n Bâ‚‚  -Bâ‚„+Bâ‚…  Bâ‚+Bâ‚„   Bâ‚‚-Bâ‚ƒ     Bâ‚ƒ\n Bâ‚ƒ  Bâ‚+Bâ‚„   -Bâ‚„+Bâ‚…  -Bâ‚‚+Bâ‚ƒ    Bâ‚‚\n Bâ‚„  Bâ‚‚-Bâ‚ƒ   -Bâ‚‚+Bâ‚ƒ  Bâ‚+Bâ‚„-Bâ‚…  -Bâ‚„\n Bâ‚…  Bâ‚ƒ      Bâ‚‚      -Bâ‚„       Bâ‚\n\njulia> CharTable(A)\nCharTable(Fusion Algebra dim.5)\n â”‚1    2    3  4  5\nâ”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n1â”‚1  âˆš-3 -âˆš-3  2 -1\n2â”‚1    1    1  .  1\n3â”‚1   -1   -1  .  1\n4â”‚1    .    . -1 -1\n5â”‚1 -âˆš-3  âˆš-3  2 -1\n\n\n\n\n\n","category":"function"},{"location":"#d-Harish-Chandra-series","page":"Gapjm Documentation","title":"d-Harish-Chandra series","text":"","category":"section"},{"location":"","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"dSeries\ncuspidal_pairs\nSeries\nennola","category":"page"},{"location":"#Gapjm.dSeries","page":"Gapjm Documentation","title":"Gapjm.dSeries","text":"d-Harish-Chandra   series  describe  unipotent  l-blocks  of  a  finite reductive  group ð†(ð”½_q) for lÎ¦_d(q) (at least, when l is not too small which means mostly not a bad prime for ð†). Some of the facts stated below  are still partly conjectural, we do not try to distinguish precisely what has been established and what is still conjectural.\n\nIf  (ð‹,Î») is  a d-cuspidal  pair then  the constituents  of the Lusztig induced  R_ð‹^ð†(Î») are called a d-Harish-Chandra series; they form the unipotent part of an l-block of ð†^F. It is conjectured (and proven in some   cases)  that  the  ð†^F-endomorphism   algebra  of  the  l-adic cohomology  of the  variety ð—  which defines  the Lusztig  induction is a d-cyclotomic Hecke algebra H_ð†(ð‹Î») for the group W_ð†(ð‹Î»)=N_ð†(ð‹Î»)ð‹,  which  is  a  complex  reflection group â€“- here d-cyclotomic  means that the parameters  of H_ð†(ð‹Î») are monomials in q  and that H_ð†(ð‹Î»)  specializes to the  algebra of W_ð†(ð‹Î») for qÎ¶_d.\n\nIt  follows that the decomposition of the  Lusztig induction is of the form R_ð‹^ð†(Î»)=_Ï•Irr(W_ð†(ð‹Î»))(-1)^náµ© Ï•(1)Î³áµ© where Î³áµ© is a unipotent character   of  ð†^F  attached  to  Ï•  and  where  náµ©  is  the  degree H^náµ©_c(ð—)  where  Î³áµ©  occurss;  and  further  for  any  Ï• we have R_ð‹^ð†(Î»)(1)=  (-1)^náµ© Î³áµ©(1)Sáµ© where Sáµ© is  the Schur element of the character  of  H_ð†(ð‹Î»)  which  deforms  to  Ï•. The function |Series| allows to explore a d-Harish-Chandra series.\n\njulia> W=rootdatum(\"3D4\")\nÂ³Dâ‚„\n\njulia> l=cuspidal_pairs(W,3)\n2-element Vector{NamedTuple{(:levi, :cuspidal), Tuple{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}, Int64}}}:\n (levi = Â³Dâ‚„, cuspidal = 8)\n (levi = Dâ‚„â‚â‚Ž=Î¦â‚ƒÂ², cuspidal = 1)\n\njulia> Series(W,l[2]...,3)\nÎ¶â‚ƒ-series R^{Â³Dâ‚„}_{Dâ‚„â‚â‚Ž=Î¦â‚ƒÂ²}(Î»==.)  H_G(L,Î»)==hecke(Gâ‚„,Mvp{Cyc{Int64}, Int64}[Î¶â‚ƒqÂ², Î¶â‚ƒ, Î¶â‚ƒq])\n â”‚    Î³áµ©    Ï†  Îµ family #\nâ”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n1â”‚  Ï†â‚â€šâ‚€ Ï†â‚â€šâ‚€  1        1\n2â”‚  Ï†â‚â€šâ‚† Ï†â‚â€šâ‚„  1        2\n3â”‚  Ï†â‚‚â€šâ‚‚ Ï†â‚â€šâ‚ˆ -1        5\n6â”‚ Ï†â€²â‚â€šâ‚ƒ Ï†â‚‚â€šâ‚…  1        4\n5â”‚ Ï†â€³â‚â€šâ‚ƒ Ï†â‚‚â€šâ‚ƒ -1        3\n7â”‚  Ï†â‚‚â€šâ‚ Ï†â‚‚â€šâ‚ -1        5\n4â”‚Â³Dâ‚„[1] Ï†â‚ƒâ€šâ‚‚  1        5\n\nAbove  we explore the 3-series corresponding  to R_ð“^ð†(Id) where ð† is the  triality group  and ð“  is the  torus of  type (qÂ²+q+1)Â². The group W_ð†(ð“)  is the complex reflection group Gâ‚„. The displays shows in the column   'Î³áµ©'  the  name  of   the  unipotent  characters  constituents  of R_ð“^ð†(Id),  and in the  first column the  number of these characters in the  list  of  unipotent  characters.  In  the  column  'Ï†' the name of the character  of W_ð†(ð“) corresponding  to the unipotent  character Î³áµ© is shown;  in the column  'Îµ' we show  the sign (-1)^náµ©.  Finally in the last column we show in which family of unipotent characters is Î³áµ©.\n\nThe theory of d-Harish-Chandra series can be generalized to spetsial complex reflection groups using some axioms. We show below an example.\n\njulia> W=ComplexReflectionGroup(4)\nGâ‚„\n\njulia> l=cuspidal_pairs(W,3)\n5-element Vector{NamedTuple{(:levi, :cuspidal), Tuple{Spets{PRSG{Cyc{Rational{Int64}}, Int16}}, Int64}}}:\n (levi = Gâ‚„, cuspidal = 3)\n (levi = Gâ‚„, cuspidal = 6)\n (levi = Gâ‚„, cuspidal = 7)\n (levi = Gâ‚„, cuspidal = 10)\n (levi = Gâ‚„â‚â‚Ž=Î¦â‚Î¦â€²â‚ƒ, cuspidal = 1)\n\njulia> Series(W,l[5]...,3)\nÎ¶â‚ƒ-series R^{Gâ‚„}_{Gâ‚„â‚â‚Ž=Î¦â‚Î¦â€²â‚ƒ}(Î»==.)  W_G(L,Î»)==Zâ‚†\n â”‚   Î³áµ© Ï†(mod 3)  Îµ parameter family #\nâ”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n1â”‚ Ï†â‚â€šâ‚€        1  1      Î¶â‚ƒqÂ²        1\n5â”‚ Ï†â‚‚â€šâ‚ƒ     -Î¶â‚ƒÂ²  1      -Î¶â‚ƒq        2\n2â”‚ Ï†â‚â€šâ‚„       Î¶â‚ƒ -1        Î¶â‚ƒ        4\n8â”‚ Zâ‚ƒ:2       -1 -1     -Î¶â‚ƒÂ²q        2\n9â”‚Zâ‚ƒ:11      Î¶â‚ƒÂ² -1       Î¶â‚ƒÂ²        4\n4â”‚ Ï†â‚‚â€šâ‚…      -Î¶â‚ƒ -1       -Î¶â‚ƒ        4\n\nAbove  we explore the 3-series corresponding  to the trivial character of the  torus of type (q-1)(q-Î¶â‚ƒ). For cyclic groups W_ð†(ð‹Î») we display the  parameters in  the table  since they  are associated  to characters of W_ð†(ð‹Î»). Finally the mention '(mod 3)' which appears in the 'Ï†' column means that in this case the axioms leave an ambiguity in the correspondence between  unipotent  characters  Î³áµ©  and  characters  Ï• (as well as with parameters):  the correspondence is known only up to a translation by 3 (in this case, the same as a global multiplication of all Ï• by -1).\n\nFinally,  we should note that  if the reflection group  or coset W is not defined  over the integers,  what counts is  not cyclotomic polynomials but factors  of them  over the  field of  definition of  W. In this case, one should not give as argument an integer d representing Î¶_d but specify a  root of unity. For instance, in the above case we get a different answer with:\n\njulia> cuspidal_pairs(W,Root1(;r=2//3))\n5-element Vector{NamedTuple{(:levi, :cuspidal), Tuple{Spets{PRSG{Cyc{Rational{Int64}}, Int16}}, Int64}}}:\n (levi = Gâ‚„, cuspidal = 2)\n (levi = Gâ‚„, cuspidal = 5)\n (levi = Gâ‚„, cuspidal = 7)\n (levi = Gâ‚„, cuspidal = 10)\n (levi = Gâ‚„â‚â‚Ž=Î¦â‚Î¦â€³â‚ƒ, cuspidal = 1)\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.Uch.cuspidal_pairs","page":"Gapjm Documentation","title":"Gapjm.Uch.cuspidal_pairs","text":"cuspidal_pairs(W[,d[,ad]])\n\nreturns  the pairs (LF,Î») where LF is a d-split Levi (with d-center of  dimension ad if ad is given) and Î» is a d-cuspidal character of LF.  If d  is omitted  it is  assumed to  be 1,  which means ordinary cuspidal  pairs.  The  character  Î»  is  returned  as  its  index amongst unipotent characters.\n\njulia> cuspidal_pairs(coxgroup(:F,4))\n9-element Vector{NamedTuple{(:levi, :cuspidal), Tuple{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}, Int64}}}:\n (levi = Fâ‚„, cuspidal = 31)\n (levi = Fâ‚„, cuspidal = 32)\n (levi = Fâ‚„, cuspidal = 33)\n (levi = Fâ‚„, cuspidal = 34)\n (levi = Fâ‚„, cuspidal = 35)\n (levi = Fâ‚„, cuspidal = 36)\n (levi = Fâ‚„, cuspidal = 37)\n (levi = Fâ‚„â‚â‚ƒâ‚‚â‚Ž=Bâ‚‚â‚â‚‚â‚â‚ŽÎ¦â‚Â², cuspidal = 6)\n (levi = Fâ‚„â‚â‚Ž=Î¦â‚â´, cuspidal = 1)\n\njulia> cuspidal_pairs(ComplexReflectionGroup(4),3)\n5-element Vector{NamedTuple{(:levi, :cuspidal), Tuple{Spets{PRSG{Cyc{Rational{Int64}}, Int16}}, Int64}}}:\n (levi = Gâ‚„, cuspidal = 3)\n (levi = Gâ‚„, cuspidal = 6)\n (levi = Gâ‚„, cuspidal = 7)\n (levi = Gâ‚„, cuspidal = 10)\n (levi = Gâ‚„â‚â‚Ž=Î¦â‚Î¦â€²â‚ƒ, cuspidal = 1)\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.dSeries.Series","page":"Gapjm Documentation","title":"Gapjm.dSeries.Series","text":"Series(W, L, cuspidal, d)\n\nIf the reflection coset or group W corresponds to the algebraic group ð† and  cuspidal  to  the  d-cuspidal  unipotent  character  Î»  of  ð‹, constructs  the  d-series  corresponding  to  R_ð‹^ð†(Î»). If s is the result, it is a record with the following fields and functions:\n\ns.spets: the reflection group or coset W.\n\ns.levi: the subcoset L.\n\ns.cuspidal: the index of Î» in UnipotentCharacters(L).\n\ns.d: the value of d (a Root1).\n\nrelative_group(s): the group W_ð†(ð‹Î»).\n\ndSeries.RLG(s): the UnipotentCharacter given by R_ð‹^ð†(Î»).\n\ndSeries.eps(s):  for each  character Ï†  of relative_group(s) the sign (-1)^n_Ï†  in the cohomology  of the variety  defining RLG(s) of the corresponding constituent Î³áµ© of RLG(s).\n\ndegree(s): the generic degree of RLG(s), as a CycPol.\n\ndSeries.char_numbers(s):  the indices in  UnipotentCharacters(W) of the constituents of RLG(s).\n\nhecke(s): the hecke algebra H_ð†(ð‹Î»).\n\nThe function Series has another form:\n\nSeries(<W> [,<d> [,<ad>]])\n\nreturns  all the  d-series of  W corresponding  to a  d-eigenspace of dimension   ad  (default  d=1,  and  if  ad  not  given  returns  all d-series).\n\njulia> W=ComplexReflectionGroup(4)\nGâ‚„\n\njulia> s=Series(W,3,1)[1]\nÎ¶â‚ƒ-series R^{Gâ‚„}_{Gâ‚„â‚â‚Ž=Î¦â‚Î¦â€²â‚ƒ}(Î»==.)  W_G(L,Î»)==Zâ‚†\n â”‚   Î³áµ© Ï†(mod 3)  Îµ parameter family #\nâ”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n1â”‚ Ï†â‚â€šâ‚€        1  1      Î¶â‚ƒqÂ²        1\n5â”‚ Ï†â‚‚â€šâ‚ƒ     -Î¶â‚ƒÂ²  1      -Î¶â‚ƒq        2\n2â”‚ Ï†â‚â€šâ‚„       Î¶â‚ƒ -1        Î¶â‚ƒ        4\n8â”‚ Zâ‚ƒ:2       -1 -1     -Î¶â‚ƒÂ²q        2\n9â”‚Zâ‚ƒ:11      Î¶â‚ƒÂ² -1       Î¶â‚ƒÂ²        4\n4â”‚ Ï†â‚‚â€šâ‚…      -Î¶â‚ƒ -1       -Î¶â‚ƒ        4\n\n\njulia> s.spets\nGâ‚„\n\njulia> s.levi\nGâ‚„â‚â‚Ž=Î¦â‚Î¦â€²â‚ƒ\n\njulia> s.cuspidal\n1\n\njulia> s.d\nRoot1: Î¶â‚ƒ\n\njulia> hecke(s)\nhecke(Gâ‚†â€šâ‚â€šâ‚,Mvp{Cyc{Int64}, Int64}[Î¶â‚ƒqÂ², -Î¶â‚ƒq, Î¶â‚ƒ, -Î¶â‚ƒÂ²q, Î¶â‚ƒÂ², -Î¶â‚ƒ])\n\njulia> degree(s)\nÎ¶â‚ƒÎ¦â‚Î¦â‚‚Â²Î¦â€³â‚ƒÎ¦â‚„Î¦â‚†\n\njulia> dSeries.RLG(s)\n[Gâ‚„]:<Ï†â‚â€šâ‚€>-<Ï†â‚â€šâ‚„>-<Ï†â‚‚â€šâ‚…>+<Ï†â‚‚â€šâ‚ƒ>-<Zâ‚ƒ:2>-<Zâ‚ƒ:11>\n\njulia> dSeries.char_numbers(s)\n6-element Vector{Int64}:\n 1\n 5\n 2\n 8\n 9\n 4\n\njulia> dSeries.eps(s)\n6-element Vector{Int64}:\n  1\n  1\n -1\n -1\n -1\n -1\n\njulia> relative_group(s)\nGâ‚†â€šâ‚â€šâ‚\n\njulia-repl\n\n\n\n\n\n","category":"type"},{"location":"#Gapjm.dSeries.ennola","page":"Gapjm Documentation","title":"Gapjm.dSeries.ennola","text":"ennola(W)\n\nLet  W be an irreducible spetsial reflection  group or coset, and z the generator  of the  center of  W, viewed  as a  root of  unity. A property checked case-by case is that, for a unipotent character Î³ with polynomial generic  degree deg Î³(q)  of the spets  attached to W  (this spets is a finite  reductive group, for W a Weyl group, in which case z=-1 if -1 is  in W),  deg Î³(zq)  is equal  to Â±deg  Î³'(q) for another unipotent character  Î³'; Â±Î³' is called the  Ennola transform of Î³. The function returns  the  permutation-with-signs  done  by  ennola  on  the unipotent degrees (as a permutation-with signs of 1:length(UnipotentCharacters(W))). The argument W must be irreducible.\n\nThe  permutation-with-signs is not uniquely determined by the degrees since two  of them may  be equal, but  is uniquely determined  by some additional axioms that we do not recall here.\n\njulia> dSeries.ennola(rootdatum(\"3D4\"))\nSPerm{Int64}: (3,-4)(5,-5)(6,-6)(7,-8)\n\njulia> dSeries.ennola(ComplexReflectionGroup(14))\nSPerm{Int64}: (2,43,-14,16,41,34)(3,35,40,18,-11,42)(4,-37,25,-17,-26,-36)(5,-6,-79)(7,-7)(8,-74)(9,-73)(10,-52,13,31,-50,29)(12,53,15,32,-51,-30)(19,71,70,21,67,68,20,69,72)(22,-39,27,-33,-28,-38)(23,24,-66,-23,-24,66)(44,46,49,-44,-46,-49)(45,48,47,-45,-48,-47)(54,-63,-55,-57,62,-56)(58,-65,-59,-61,64,-60)(75,-77)(76,-76)(78,-78)\n\n\nThe  last example  shows that  it may  happen that  the order of z-Ennola (here 18) is greater than the order of z (here 6); this is related to the presence  of irrationalities in  the character table  of the spetsial Hecke algebra of W.\n\n\n\n\n\n","category":"function"},{"location":"#Unipotent-classes-of-reductive-groups","page":"Gapjm Documentation","title":"Unipotent classes of reductive groups","text":"","category":"section"},{"location":"","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"Ucl\nUnipotentClasses\nICCTable\ninduced_linear_form\nspecial_pieces","category":"page"},{"location":"#Gapjm.Ucl","page":"Gapjm Documentation","title":"Gapjm.Ucl","text":"This  module gives information  about the unipotent  conjugacy classes of a connected  reductive  group  over  an  algebraically  closed field k, and various  invariants attached to  them. The unipotent  classes depend on the characteristic of k; their classification differs when the characteristic is  not good  (that is,  when it  divides one  of the coefficients of the highest  root).  In  good  characteristic,  the  unipotent  classes  are in bijection with nilpotent orbits on the Lie algebra.\n\nWe  give  the  following  information  for  a unipotent element u of each class:\n\nthe centralizer C_ð† (u), that we describe by the reductive part of C_ð†  (u)^0, by the  group of components  A(u)=C_ð† (u)C_ð† (u)^0, and by the dimension of its radical.\nin good characteristic, the  Dynkin-Richardson  diagram.\nthe Springer correspondence,  attaching characters of  the Weyl group or relative Weyl groups to each character of A(u).\n\nThe  Dynkin-Richarson diagram is attached to a nilpotent element e of the Lie  algebra ð”¤.  By the  Jacobson-Morozov theorem  there exists an ð”°ð”©â‚‚ subalgebra of ð”¤ containing e as the element beginpmatrix1001 endpmatrix. Let ð’ be the torus beginpmatrixh00h^-1 endpmatrix of SLâ‚‚ and let ð“ be a maximal  torus containing ð’, so that ð’  is the image of a one-parameter subgroup  Ïƒâˆˆ Y(ð“). Consider the root decomposition ð”¤=_Î±Î£ð”¤_Î± given by  ð“; then  Î±â†¦âŸ¨Ïƒ,Î±âŸ© defines  a linear  form on  Î£, determined by its value  on simple roots. It  is possible to choose  a system of simple roots Î   so that âŸ¨Ïƒ,Î±âŸ©â‰¥ 0 for Î±âˆˆÎ ,  and then âŸ¨Ïƒ,Î±âŸ©âˆˆ{0,1,2} for any Î±âˆˆÎ . The  Dynkin diagram of Î  decorated by  these values 0,1,2 is called the Dynkin-Richardson  diagram of e, and in good characteristic is a complete invariant of its ð”¤-orbit.\n\nLet  ð“‘  be  the  variety  of  all  Borel  subgroups  and  let ð“‘áµ¤ be the subvariety  of Borel subgroups  containing the unipotent  element u. Then dim C_ð†(u)=rank ð† + 2 dim ð“‘_u and in good characteristic this dimension can  be computed from  the Dynkin-Richardson diagram:  the dimension of the class of u is the number of roots Î± such that âŸ¨Ïƒ,Î±âŸ©âˆ‰{0,1}.\n\nWe   describe  now  the  Springer  correspondence.  Indecomposable  locally constant  ð†-equivariant  sheaves  on  C,  called  local  systems, are parameterized  by irreducible characters of A(u). The ordinary Springer correspondence  is a bijection  between irreducible characters  of the Weyl group  and a large subset  of the local systems  which contains all trivial local  systems (those parameterized by the  trivial character of A(u) for each  u).  More  generally,  the  generalized  Springer  correspondence associates  to each local  system a (unique  up to ð†-conjugacy) cuspidal pair  of a Levi  subgroup ð‹ of  ð† and a  cuspidal local system on an unipotent  class of ð‹, such that the set of local systems associated to a given cuspidal pair is parameterized by the characters of the relative Weyl group W_ð† (ð‹)=N_ð† (ð‹)ð‹. There are only few cuspidal pairs.\n\nThe  Springer correspondence gives information on the character values of a finite  reductive  groups  as  follows:  assume  that  k is the algebraic closure of a finite field ð”½_q and that F is the Frobenius attached to an  ð”½_q-structure of ð†. Let C  be an F-stable unipotent class and let  u C^F;  we  call  C  the  geometric  class  of  u  and the ð†^F-classes  inside  C^F  are  parameterized  by  the F-conjugacy classes  of A(u), denoted HÂ¹(F,A(u)) (most of  the time we can find u such  that F acts trivially  on A(u) and HÂ¹(F,A(u))  is then just the conjugacy  classes). To an F-stable character  Ï† of A(u) we associate the  characteristic function of the  corresponding local system (actually associated to an extension Ï†Ìƒ of Ï† to A(u).F); it is a class function Y_uÏ† on ð†^F which can be normalized so that: Y_uÏ†(uâ‚)=Ï†(cF)  if uâ‚ is  geometrically conjugate to  u and its ð†^F-class  is parameterized by the  F-conjugacy class cF of A(u), otherwise Y_uÏ†(uâ‚)=0. If the pair u,Ï† corresponds via the Springer correspondence to the character Ï‡ of W_ð†(ð‹), then Y_uÏ† is also denoted  Yáµª. There  is another  important class  of functions  indexed by local  systems: to a local system on  class C is attached an intersection cohomology  complex, which is a complex of sheaves supported on the closure CÌ„.  To  such  a  complex  of  sheaves  is associated its characteristic function,  a class function of ð†^F  obtained by taking the alternating trace  of the Frobenius acting on the  stalks of the cohomology sheaves. If Y_Ïˆ   is   the   characteristic   function   of  a  local  system,  the characteristic   function  of  the  corresponding  intersection  cohomology complex  is denoted  by X_Ïˆ.  This function  is supported  on CÌ„, and Lusztig  has shown that X_Ïˆ=áµ© P_ÏˆÏ‡ Yáµª where P_ÏˆÏ‡ are integer polynomials  in q and Yáµª are attached to local systems on classes lying in CÌ„.\n\nLusztig   and  Shoji  have  given  an   algorithm  to  compute  the  matrix P_ÏˆÏ‡,   which  is  implemented  in  Chevie.  The  relationship  with characters   of  ð†(ð”½_q),  taking  to  simplify  the  ordinary  Springer correspondence,  is that the  restriction to the  unipotent elements of the almost  character R_Ï‡ is equal to q^báµª Xáµª, where báµª is dim ð“‘áµ¤ for  an element u of the class C  such that the support of Ï‡ is CÌ„. The restriction of the Deligne-Lusztig characters R_w to the unipotents are  called the Green functions  and can also be  computed by Chevie. The values  of  all  unipotent  characters  on  unipotent  elements can also be computed  in principle by applying  Lusztig's Fourier transform matrix (see the  section on the Fourier  matrix) but there is  a difficulty in that the Xáµª must be first multiplied by some roots of unity which are not known in all  cases (and when known may depend on the congruence class of q modulo some small primes).\n\nWe illustrate these computations on some examples:\n\njulia> UnipotentClasses(rootdatum(:sl,4))\nUnipotentClasses(Aâ‚ƒ)\n1111<211<22<31<4\n   uâ”‚D-R dBu B-C          C(u) Aâ‚ƒ(Aâ‚ƒâ‚â‚Ž=Î¦â‚Â³) Aâ‚(Aâ‚ƒâ‚â‚â‚ƒâ‚Ž=Aâ‚Ã—Aâ‚Î¦â‚)/-1 .(Aâ‚ƒ)/Î¶â‚„\nâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n4   â”‚222   0 222         qÂ³.Zâ‚„          1:4                  -1:2    Î¶â‚„:Id\n31  â”‚202   1 22.    qâ´.Aâ‚â‚â‚Ž=Î¦â‚        Id:31                               \n22  â”‚020   2 2.2      qâ´.Aâ‚.Zâ‚‚         2:22                 11:11         \n211 â”‚101   3 2.. qâµ.Aâ‚‚â‚â‚â‚Ž=Aâ‚Î¦â‚       Id:211                               \n1111â”‚000   6 ...            Aâ‚ƒ      Id:1111\n\n   uâ”‚.(Aâ‚ƒ)/-Î¶â‚„\nâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n4   â”‚   -Î¶â‚„:Id\n31  â”‚\n22  â”‚\n211 â”‚\n1111â”‚\n\nThe  first column in the table gives the name of the unipotent class, which here  is  a  partition  describing  the  Jordan  form. The partial order on unipotent  classes given by Zariski closure  is given before the table. The column   'D-R',   displayed   only   in   good  characteristic,  gives  the Dynkin-Richardson  diagram  for  each  class;  the  column  'dBu' gives the dimension  of  the  variety  ð“‘áµ¤.  The  column 'B-C' gives the Bala-Carter classification  of u, that is  in the case of  slâ‚„ it displays u as a regular  unipotent  in  a  Levi  subgroup  by  giving the Dynkin-Richardson diagram  of a regular  unipotent (all 2's)  at entries corresponding to the Levi  and '.' at  entries which do  not correspond to  the Levi. The column 'C(u)'  describes the  group C_ð†(u):  a power  qáµˆ describes  that the unipotent  radical  of  C_ð†(u)  has  dimension  d (thus qáµˆ rational points);  then follows a  description of the  reductive part of the neutral component  of C_ð†(u),  given by  the name  of its  root datum.  Then if C_ð†(u)  is  not  connected,  the  description  of A(u) is given using another  vocabulary: a  cyclic group  of order  4 is  given as  'Z4', and a symmetric group on 3 points would be given as 'S3'.\n\nFor  instance, the first class '4'  has C_ð†(u)^0 unipotent of dimension 3  and A(u) equal to 'Z4', the cyclic  group of order 4. The class '22' has  C_G(u) with unipotent radical of  dimension 4, reductive part of type  'A1' and  A(u) is  'Z2', that  is the  cyclic group of order 2. The other  classes have C_ð†(u) connected. For  the class '31' the reductive part of C_G(u) is a torus of rank 1.\n\nThen  there is one column for each Springer series, giving for each class the pairs 'a:b' where 'a' is the name of the character of A(u) describing the  local system  involved and  'b' is  the name  of the  character of the (relative)  Weyl group corresponding by the Springer correspondence. At the top  of the column is  written the name of  the relative Weyl group, and in brackets  the name  of the  Levi affording  a cuspidal  local system; next, separated  by a / is a description of the central character associated to the  Springer series  (omitted if  this central  character is trivial): all local  systems  in  a  given  Springer  series have same restriction to the center of ð†. To find what the picture becomes for another algebraic group in  the  same  isogeny  class,  for  instance the adjoint group, one simply discards the Springer series whose central character becomes trivial on the center  of ð†; and  each group A(u)  has to be  quotiented by the common kernel  of  the  remaining  characters.  Here  is the table for the adjoint group:\n\njulia> UnipotentClasses(coxgroup(:A,3))\nUnipotentClasses(Aâ‚ƒ)\n1111<211<22<31<4\n   uâ”‚D-R dBu B-C          C(u) Aâ‚ƒ(Aâ‚ƒâ‚â‚Ž=Î¦â‚Â³)\nâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n4   â”‚222   0 222            qÂ³         Id:4\n31  â”‚202   1 22.    qâ´.Aâ‚â‚â‚Ž=Î¦â‚        Id:31\n22  â”‚020   2 2.2         qâ´.Aâ‚        Id:22\n211 â”‚101   3 2.. qâµ.Aâ‚‚â‚â‚â‚Ž=Aâ‚Î¦â‚       Id:211\n1111â”‚000   6 ...            Aâ‚ƒ      Id:1111\n\nHere is another example:\n\njulia> UnipotentClasses(coxgroup(:G,2))\nUnipotentClasses(Gâ‚‚)\n1<Aâ‚<AÌƒâ‚<Gâ‚‚(aâ‚)<Gâ‚‚\n     uâ”‚D-R dBu B-C  C(u)    Gâ‚‚(Gâ‚‚â‚â‚Ž=Î¦â‚Â²)  .(Gâ‚‚)\nâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nGâ‚‚    â”‚ 22   0  22    qÂ²         Id:Ï†â‚â€šâ‚€       \nGâ‚‚(aâ‚)â”‚ 20   1  20 qâ´.Sâ‚ƒ 21:Ï†â€²â‚â€šâ‚ƒ 3:Ï†â‚‚â€šâ‚ 111:Id\nAÌƒâ‚    â”‚ 01   2  .2 qÂ³.Aâ‚         Id:Ï†â‚‚â€šâ‚‚       \nAâ‚    â”‚ 10   3  2. qâµ.Aâ‚        Id:Ï†â€³â‚â€šâ‚ƒ       \n1     â”‚ 00   6  ..    Gâ‚‚         Id:Ï†â‚â€šâ‚†       \n\nwhich illustrates that on class Gâ‚‚(aâ‚) there are two local systems in the principal  series of  the Springer  correspondence, and  a further cuspidal local system. Also, from the 'B-C' column, we see that that class is not in a  proper Levi,  in which  case the  Bala-Carter diagram coincides with the Dynkin-Richardson diagram.\n\nThe  characteristics 2 and  3 are not  good for 'G2'.  To get the unipotent classes  and the Springer correspondence in bad characteristic, one gives a second argument to the function 'UnipotentClasses':\n\njulia> UnipotentClasses(coxgroup(:G,2),3)\nUnipotentClasses(Gâ‚‚)\n1<Aâ‚,(AÌƒâ‚)â‚ƒ<AÌƒâ‚<Gâ‚‚(aâ‚)<Gâ‚‚\n     uâ”‚dBu B-C  C(u) Gâ‚‚(Gâ‚‚â‚â‚Ž=Î¦â‚Â²) .(Gâ‚‚) .(Gâ‚‚)  .(Gâ‚‚)\nâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nGâ‚‚    â”‚  0  22 qÂ².Zâ‚ƒ       1:Ï†â‚â€šâ‚€       Î¶â‚ƒ:Id Î¶â‚ƒÂ²:Id\nGâ‚‚(aâ‚)â”‚  1  20 qâ´.Zâ‚‚       2:Ï†â‚‚â€šâ‚ 11:Id             \nAÌƒâ‚    â”‚  2  .2    qâ¶      Id:Ï†â‚‚â€šâ‚‚                   \nAâ‚    â”‚  3  2. qâµ.Aâ‚     Id:Ï†â€³â‚â€šâ‚ƒ                   \n(AÌƒâ‚)â‚ƒ â”‚  3  ?? qâµ.Aâ‚     Id:Ï†â€²â‚â€šâ‚ƒ                   \n1     â”‚  6  ..    Gâ‚‚      Id:Ï†â‚â€šâ‚†\n\nThe  function 'ICCTable' gives the  transition matrix between the functions Xáµª  and Y_Ïˆ.\n\njulia> uc=UnipotentClasses(coxgroup(:G,2));\njulia> t=ICCTable(uc)\nCoefficients of Xáµª on Yáµ© for Gâ‚‚\n      â”‚Gâ‚‚ Gâ‚‚(aâ‚)â½Â²Â¹â¾ Gâ‚‚(aâ‚) AÌƒâ‚ Aâ‚  1\nâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nXÏ†â‚â€šâ‚€ â”‚ 1          0      1  1  1  1\nXÏ†â€²â‚â€šâ‚ƒâ”‚ 0          1      0  1  0 qÂ²\nXÏ†â‚‚â€šâ‚ â”‚ 0          0      1  1  1 Î¦â‚ˆ\nXÏ†â‚‚â€šâ‚‚ â”‚ 0          0      0  1  1 Î¦â‚„\nXÏ†â€³â‚â€šâ‚ƒâ”‚ 0          0      0  0  1  1\nXÏ†â‚â€šâ‚† â”‚ 0          0      0  0  0  1\n\nHere  the row labels  and the column  labels show the  two ways of indexing local  systems: the  row labels  give the  character of the relative Weyl group and the column labels give the class and the name of the local system as  a character  of A(u):  for instance,  'G2(a1)' is the trivial local system  of the  class 'G2(a1)',  while 'G2(a1)(21)'  is the local system on that class corresponding to the 2-dimensional character of A(u)=Aâ‚‚.\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.Ucl.UnipotentClasses","page":"Gapjm Documentation","title":"Gapjm.Ucl.UnipotentClasses","text":"UnipotentClasses(W[,p])\n\nW  should  be  a  CoxeterGroup  record  for a Weyl group or RootDatum describing a reductive algebraic group ð†. The function returns a record containing   information   about   the   unipotent   classes  of  ð†  in characteristic   p  (if   omitted,  p   is  assumed   to  be  any  good characteristic for ð†). This contains the following fields:\n\ngroup: a pointer to W\n\np: the characteristic of the field for which the unipotent classes were computed. It is 0 for any good characteristic.\n\norderClasses:  a list describing the Hasse diagram of the partial order induced   on   unipotent   classes   by   the  closure  relation.  That  is .orderclasses[i]  is the list of j such that CÌ„â±¼âŠ‹ CÌ„áµ¢  and  there  is no  class  Câ‚–  such  that CÌ„â±¼âŠ‹ CÌ„â‚–âŠ‹ CÌ„áµ¢.\n\nclasses:  a  list  of  records  holding information for each unipotent class (see below).\n\nspringerSeries:  a list of records, each  of which describes a Springer series  of ð†.\n\nThe  records  describing  individual  unipotent  classes have the following fields:\n\nname: the name of the unipotent class.\n\nparameter:  a parameter  describing the  class (for  example, a partition describing the Jordan form, for classical groups).\n\nAu: the group A(u).\n\ndynkin:  present in good characteristic; contains the Dynkin-Richardson diagram,  given  as  a  list  of  0,1,2  describing  the coefficient on the corresponding simple root.\n\nred:  the reductive part of C_ð†(u).\n\ndimBu:  the dimension of the variety ð“‘áµ¤.\n\nThe  records for classes contain additional  fields for certain groups: for instance,  the names given to classes by Mizuno in Eâ‚†, Eâ‚‡, Eâ‚ˆ or by Shoji in Fâ‚„.\n\nThe  records  describing  individual  Springer  series  have  the following fields:\n\nlevi:the  indices of the  reflections corresponding to  the Levi subgroup ð‹  where  lives  the  cuspidal  local  system Î¹ from which the Springer series is induced.\n\nrelgroup: The relative Weyl group N_ð†(ð‹Î¹)ð‹. The first series is the principal series for which .levi=[] and .relgroup=W.\n\nlocsys:  a  list  of  length  NrConjugacyClasses(.relgroup), holding in i-th  position a  pair describing  which local  system corresponds to the i-th  character of  N_ð†(ð‹Î¹). The  first element  of the  pair is the index  of the concerned unipotent class u, and the second is the index of the corresponding character of A(u).\n\nZ:  the central character associated  to the Springer series, specified by its value on the generators of the centre.\n\njulia> W=rootdatum(:sl,4)\nAâ‚ƒ\n\njulia> uc=UnipotentClasses(W);\n\njulia> uc.classes\n5-element Vector{Gapjm.Ucl.UnipotentClass}:\n UnipotentClass(1111)\n UnipotentClass(211)\n UnipotentClass(22)\n UnipotentClass(31)\n UnipotentClass(4)\n\nThe  show  function  for  unipotent  classes  accepts  all the options of formatTable  and  of  charnames.  Giving  the  option  mizuno  (resp. shoji)  uses  the  names  given  by  Mizuno  (resp.  Shoji) for unipotent classes.  Moreover,  there  is  also  an  option  fourier which gives the correspondence  tensored  with  the  sign  character  of each relative Weyl group, which is the correspondence obtained via a Fourier-Deligne transform (here  we assume that  p is very  good, so that  there is a nondegenerate invariant  bilinear  form  on  the  Lie  algebra, and also one can identify nilpotent orbits with unipotent classes).\n\nHere is how to display the non-cuspidal part of the Springer correspondence of  the unipotent  classes of  Eâ‚† using  the notations  of Mizuno for the classes  and those  of Frame  for the  characters of  the Weyl group and of Spaltenstein  for the characters  of Gâ‚‚ (this  is convenient for checking our data with the original paper of Spaltenstein):\n\njulia> uc=UnipotentClasses(rootdatum(:E6sc));\n\njulia> xdisplay(uc;cols=[5,6,7],spaltenstein=true,frame=true,mizuno=true,\n      order=false)\nUnipotentClasses(Eâ‚†)\n     uâ”‚            Eâ‚†(Eâ‚†â‚â‚Ž) Gâ‚‚(Eâ‚†â‚â‚â‚ƒâ‚…â‚†â‚Ž=Aâ‚‚Ã—Aâ‚‚)/Î¶â‚ƒ Gâ‚‚(Eâ‚†â‚â‚â‚ƒâ‚…â‚†â‚Ž=Aâ‚‚Ã—Aâ‚‚)/Î¶â‚ƒÂ²\nâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nEâ‚†    â”‚                1:1â‚š                  Î¶â‚ƒ:1                  Î¶â‚ƒÂ²:1\nEâ‚†(aâ‚)â”‚                1:6â‚š                Î¶â‚ƒ:Îµ_c                Î¶â‚ƒÂ²:Îµ_c\nDâ‚…    â”‚              Id:20â‚š\nAâ‚…+Aâ‚ â”‚        -1:15â‚š 1:30â‚š                 Î¶â‚ƒ:Î¸â€²                 Î¶â‚ƒÂ²:Î¸â€²\nAâ‚…    â”‚              1:15_q                 Î¶â‚ƒ:Î¸â€³                 Î¶â‚ƒÂ²:Î¸â€³\nDâ‚…(aâ‚)â”‚              Id:64â‚š\nAâ‚„+Aâ‚ â”‚              Id:60â‚š\nDâ‚„    â”‚              Id:24â‚š\nAâ‚„    â”‚              Id:81â‚š\nDâ‚„(aâ‚)â”‚111:20â‚› 3:80â‚› 21:90â‚›\nAâ‚ƒ+Aâ‚ â”‚              Id:60â‚›\n2Aâ‚‚+Aâ‚â”‚               1:10â‚›                 Î¶â‚ƒ:Îµâ‚—                 Î¶â‚ƒÂ²:Îµâ‚—\nAâ‚ƒ    â”‚             Id:81â‚šâ€²\nAâ‚‚+2Aâ‚â”‚             Id:60â‚šâ€²\n2Aâ‚‚   â”‚              1:24â‚šâ€²                  Î¶â‚ƒ:Îµ                  Î¶â‚ƒÂ²:Îµ\nAâ‚‚+Aâ‚ â”‚             Id:64â‚šâ€²\nAâ‚‚    â”‚      11:15â‚šâ€² 2:30â‚šâ€²\n3Aâ‚   â”‚            Id:15_qâ€²\n2Aâ‚   â”‚             Id:20â‚šâ€²\nAâ‚    â”‚              Id:6â‚šâ€²\n1     â”‚              Id:1â‚šâ€²\n\n\n\n\n\n","category":"type"},{"location":"#Gapjm.Ucl.ICCTable","page":"Gapjm Documentation","title":"Gapjm.Ucl.ICCTable","text":"ICCTable(uc,seriesNo=1;q=Pol())\n\nThis function gives the table of decompositions of the functions X_Î¹ in terms  of the functions Y_Î¹. Here Î¹ is a ð†-equivariant local system on  the  class  C  of  a  unipotent  element  u. Such a local system is parametrized  by the pair  (u,Ï•) of u  and a character  of the group of components   A(u)   of   C_ð†   (u).   The  function  Y_Î¹  is  the characteristic   function  of  this   local  system  and   X_Î¹  is  the characteristic   function  of  the  corresponding  intersection  cohomology complex  on CÌ„. The  Springer correspondence says  that the local systems can  also be  indexed by  characters of  a relative  Weyl group.  Since the coefficient of Xáµª on Yáµ© is 0 if Ï‡ and Ï† are not characters of the same  relative Weyl group (are not in  the same Springer series), the table is  for one  Springer series,  specified by  the argument  'seriesNo' (this defaults  to 'seriesNo=1' which is the principal series). The decomposition multiplicities  are graded,  and are  given as  polynomials in one variable (specified by the argument q; if not given Pol() is assumed).\n\njulia> t=ICCTable(uc)\nCoefficients of Xáµª on Yáµ© for Aâ‚ƒ\n     â”‚4 31 22 211 1111\nâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nX4   â”‚1  1  1   1    1\nX31  â”‚0  1  1  Î¦â‚‚   Î¦â‚ƒ\nX22  â”‚0  0  1   1   Î¦â‚„\nX211 â”‚0  0  0   1   Î¦â‚ƒ\nX1111â”‚0  0  0   0    1\n\nIn  the  above  the  multiplicities  are  given  as  products of cyclotomic polynomials  to display them  more compactly. However  the format of such a table can be controlled more precisely.\n\nFor  instance,  one  can  ask  to  not  display  the entries as products of cyclotomic polynomials:\n\njulia> xdisplay(t;cycpol=false)\nCoefficients of Xáµª on Yáµ© for A3\n     â”‚4 31 22 211   1111\nâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nX4   â”‚1  1  1   1      1\nX31  â”‚0  1  1 q+1 qÂ²+q+1\nX22  â”‚0  0  1   1   qÂ²+1\nX211 â”‚0  0  0   1 qÂ²+q+1\nX1111â”‚0  0  0   0      1\n\nSince show uses the function format for tables, all the options of this function  are  also  available.  We  can  use  this to restrict the entries displayed  to a  given sublist  of the  rows and  columns (here the indices correspond  to the number  in Chevie of  the corresponding character of the relative Weyl group of the given Springer series):\n\njulia> uc=UnipotentClasses(coxgroup(:F,4));\njulia> t=ICCTable(uc);\njulia> sh=[13,24,22,18,14,9,11,19];\njulia> show(IOContext(stdout,:rows=>sh,:cols=>sh,:limit=>true),t);\nCoefficients of Xáµª on Yáµ© for Fâ‚„\n      â”‚Aâ‚+AÌƒâ‚ Aâ‚‚ AÌƒâ‚‚ Aâ‚‚+AÌƒâ‚ AÌƒâ‚‚+Aâ‚ Bâ‚‚â½Â¹Â¹â¾ Bâ‚‚ Câ‚ƒ(aâ‚)â½Â¹Â¹â¾\nâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nXÏ†â‚‰â€šâ‚â‚€â”‚    1  0  0     0     0      0  0          0\nXÏ†â€³â‚ˆâ€šâ‚‰â”‚    1  1  0     0     0      0  0          0\nXÏ†â€²â‚ˆâ€šâ‚‰â”‚    1  0  1     0     0      0  0          0\nXÏ†â€³â‚„â€šâ‚‡â”‚    1  1  0     1     0      0  0          0\nXÏ†â€²â‚†â€šâ‚†â”‚   Î¦â‚„  1  1     1     1      0  0          0\nXÏ†â‚„â€šâ‚ˆ â”‚   qÂ²  0  0     0     0      1  0          0\nXÏ†â€³â‚‰â€šâ‚†â”‚   Î¦â‚„ Î¦â‚„  0     1     0      0  1          0\nXÏ†â€²â‚„â€šâ‚‡â”‚   qÂ²  0 Î¦â‚„     0     1      0  0          1\n\nThe   function  'ICCTable'  returns  an   object  with  various  pieces  of information which can help further computations.\n\n.scalar:  this contains the table of  multiplicities Páµªáµ© of the Xáµª on the  Yáµ©.  One  should  pay  attention  that  by default, the table is not displayed  in the same order as the  stored |.scalar|, which is in order in Chevie  of  the  characters  in  the  relative  Weyl  group;  the  table is transposed,  then lines  and rows  are sorted  by dimBu,class  no,index of character in A(u) while displayed.\n\n.group: The group W.\n\n.relgroup: The relative Weyl group for the Springer series.\n\n.series: The index of the Springer series given for W.\n\n.dimBu: The list of dimð“‘áµ¤ for each local system (u,Ï†) in the series.\n\n:L:  The matrix of  (unnormalized) scalar products  of the functions Yáµ© with themselves, that is the (Ï†,Ï‡) entry is _gð†(ð”½_q) Yáµ©(g) Yáµª(g). This  is thus a symmetric, block-diagonal  matrix where the diagonal blocks correspond  to  geometric  unipotent  conjugacy  classes.  This  matrix  is obtained as a by-product of Lusztig's algorithm to compute Páµ©áµª.\n\n\n\n\n\n","category":"type"},{"location":"#Gapjm.Ucl.induced_linear_form","page":"Gapjm Documentation","title":"Gapjm.Ucl.induced_linear_form","text":"induced_linear_form(W, K, h)\n\nThis routine can be used to find the Richardson-Dynkin diagram of the class in  the algebraic group ð†  which contains a given  unipotent class of a reductive subgroup of maximum rank ð’ of ð†.\n\nIt  takes a linear  form on the  roots of K,  defined by its value on the simple  roots (these values  can define a  Dynkin-Richardson diagram); then extends  this linear form to the roots of ð† by 0 on the orthogonal of the  roots of K; and finally conjugates  the resulting form by an element of the Weyl group so that it takes positive values on the simple roots.\n\njulia> W=coxgroup(:F,4)\nFâ‚„\n\njulia> H=reflection_subgroup(W,[1,3])\nFâ‚„â‚â‚â‚ƒâ‚Ž=Aâ‚Ã—AÌƒâ‚Î¦â‚Â²\n\njulia> Ucl.induced_linear_form(W,H,[2,2])\n4-element Vector{Int64}:\n 0\n 1\n 0\n 0\n\njulia> uc=UnipotentClasses(W);\n\njulia> uc.classes[4].prop\nDict{Symbol, Any} with 7 entries:\n  :dynkin     => [0, 1, 0, 0]\n  :dimred     => 6\n  :red        => Aâ‚Ã—Aâ‚\n  :Au         => .\n  :balacarter => [1, 3]\n  :dimunip    => 18\n  :AuAction   => Aâ‚Ã—Aâ‚\n\njulia> uc.classes[4]\nUnipotentClass(Aâ‚+AÌƒâ‚)\n\nThe  example above shows that the class containing the regular class of the Levi subgroup of type Aâ‚Ã— AÌƒâ‚ is the class |A1+~A1|.\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Ucl.special_pieces","page":"Gapjm Documentation","title":"Gapjm.Ucl.special_pieces","text":"'special_pieces(<uc>)'\n\nThe  special  pieces  forme  a  partition  of  the  unipotent  variety of a reductive  group ð† which was defined  the first time in Spaltenstein1982 chap.  III  as  the  fibers  of  d^2, where d is a \"duality  map\". Another definition is as the  set of classes in the Zariski closure  of a special class  and not in the  Zariski closure of any smaller special  class, where  a special  class in  the support  of the  image of a special character by the Springer correspondence.\n\nEach  piece is a union of unipotent  conjugacy classes so is represented in Chevie  as a  list of  class numbers.  Thus the  list of  special pieces is returned  as  a  list  of  lists  of  class  numbers. The list is sorted by increasing  piece dimension, while each piece is sorted by decreasing class dimension, so the special class is listed first.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> special_pieces(UnipotentClasses(W))\n3-element Vector{Vector{Int64}}:\n [1]\n [4, 3, 2]\n [5]\n\njulia> special_pieces(UnipotentClasses(W,3))\n3-element Vector{Vector{Int64}}:\n [1]\n [4, 3, 2, 6]\n [5]\n\nThe   example  above  shows  that  the  special  pieces  are  different  in characteristic 3.\n\n\n\n\n\n","category":"function"},{"location":"#Symbols","page":"Gapjm Documentation","title":"Symbols","text":"","category":"section"},{"location":"","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"Symbols\nshiftÎ²\nÎ²set\npartÎ²\nranksymbol\ndefectsymbol\nsymbol_partition_tuple\nfegsymbol\ngendeg_symbol\ndegree_fegsymbol\ndegree_gendeg_symbol\nvaluation_fegsymbol\nvaluation_gendeg_symbol\ntableaux\nsymbols\nXSP","category":"page"},{"location":"#Gapjm.Symbols","page":"Gapjm Documentation","title":"Gapjm.Symbols","text":"The  combinatorial  objects  in  the  module  Symbols  are  partitions, Î²-sets and symbols.\n\nA  partition is a  non-increasing list of  positive integers pâ‚â‰¥pâ‚‚â‰¥â€¦pâ‚™>0, represented as a Vector{Int}.\n\nA  Î²-set  is  a  strictly  increasing  Vector{Int},  up  to the shift equivalence   relation,  the  transitive  closure  of  the  equivalence  of [bâ‚,â€¦,bâ‚™]  and  its  elementary  shift  [0,1+bâ‚,â€¦,1+bâ‚™]. An equivalence class  has exactly one member which does  not contain 0: it is called the normalized Î²-set.\n\nTo  a  partition  pâ‚â‰¥pâ‚‚â‰¥â€¦pâ‚™>0  is  associated  a  Î²-set, whose normalized representative   is   pâ‚™,pâ‚™â‚‹â‚+1,â€¦,pâ‚+n-1.   Conversely,   to  each  Î²-set bâ‚<bâ‚‚<â€¦<bâ‚™ is associated the partition bâ‚™-n+1â‰¥â€¦â‰¥bâ‚‚-1â‰¥bâ‚ (which may have some trailing zeros if starting from a non-normalized representative).\n\n2-symbols  where introduced by [Lusztig1977] and more general e-symbols by  Malle1995. An e-symbol  is a vector S=[Sâ‚,â€¦,Sâ‚‘] of   Î²-sets,  taken  modulo  the  equivalence  relation  generated  by  the simultaneous  elementary shift of all Î²-sets, and the cyclic permutation of the vector (in the particular case where e=2 it is thus an unordered pair of  Î²-sets). This  time there  is a  cyclic permutation class of normalized symbols  where 0 is not in the intersection of the Sáµ¢. The content of S  is mod(sum(length(S)),e); it is an  invariant of the symbol, as well as the rank, defined for an e-symbol as sum(sum,S)-div((c-1)*(c-e+1),2*e)   where   c=sum(length(S))   and  the shape s-minimum(s) where s=map(length,S).\n\nWhen  e=2  up  to  cyclic  permutation  we  choose representatives of the symbols [Sâ‚,Sâ‚‚] such that length(Sâ‚)â‰¥length(Sâ‚‚) so the shape is [d,0] where  d is called  the defect of  the symbol (the  content is equal to mod(d,2)).  For symbols [Sâ‚,Sâ‚‚] with length(Sâ‚)==length(Sâ‚‚) we choose representatives  such that Pâ‚â‰¤Pâ‚‚ lexicographically  where Pâ‚,Pâ‚‚ are the partitions associated to Sâ‚,Sâ‚‚.\n\nPartitions  and pairs  of partitions  are parameters  for characters of the Weyl groups of classical types, and tuples of partitions are parameters for characters   of  imprimitive  complex   reflection  groups.  2-Symbols  are parameters  for the unipotent characters of classical Chevalley groups, and more  general e-symbols  are parameters  for the  unipotent characters of Spetses  associated to spetsial imprimitive  complex reflection groups. The rank  of a  symbol is  the semi-simple  rank of the corresponding Chevalley group or Spets.\n\nSymbols  of rank  n and  defect 0  parameterize characters  of the Weyl group  of type Dâ‚™,  and symbols of  rank n and  defect divisible by 4 parameterize  unipotent characters of split  orthogonal groups of dimension 2n.  Symbols of  rank n  and defectâ‰¡2  (mod 4) parameterize unipotent characters  of non-split  orthogonal groups  of dimension  2n. Symbols of rank  n and defect 1 parameterize characters  of the Weyl group of type Bâ‚™,  and  symbols  of  rank  n  and  odd  defect parameterize unipotent characters  of symplectic groups of dimension  2n or orthogonal groups of dimension 2n+1.\n\ne-symbols  of rank n and  content 1 parameterize unipotent characters of  G(e,1,n). Those of  content 0 parameterize  unipotent characters of G(e,e,n).  The principal series  (characters of the  reflection group) is parametrized  by symbols of shape  [1,0,â€¦,0] for G(e,1,n) and [0,â€¦,0] for G(e,e,n).\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.Symbols.shiftÎ²","page":"Gapjm Documentation","title":"Gapjm.Symbols.shiftÎ²","text":"shiftÎ²( Î², n) shift Î²-set Î² by n\n\njulia> shiftÎ²([2,3],2)\n4-element Vector{Int64}:\n 0\n 1\n 4\n 5\n\njulia> shiftÎ²([0,1,4,5],-2)\n2-element Vector{Int64}:\n 2\n 3\n\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Symbols.Î²set","page":"Gapjm Documentation","title":"Gapjm.Symbols.Î²set","text":"Î²set(p) normalized Î²-set of a partition\n\njulia> Î²set([3,3,1])\n3-element Vector{Int64}:\n 1\n 4\n 5\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Symbols.partÎ²","page":"Gapjm Documentation","title":"Gapjm.Symbols.partÎ²","text":"'partÎ²(Î²)' partition defined by Î²-set Î²\n\njulia> partÎ²([0,4,5])\n2-element Vector{Int64}:\n 3\n 3\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Symbols.ranksymbol","page":"Gapjm Documentation","title":"Gapjm.Symbols.ranksymbol","text":"ranksymbol(S) rank of symbol S.\n\njulia> ranksymbol([[1,5,6],[1,2]])\n11\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Symbols.defectsymbol","page":"Gapjm Documentation","title":"Gapjm.Symbols.defectsymbol","text":"`defectsymbol(s)'\n\nFor an e-symbol [Sâ‚,Sâ‚‚,â€¦,Sâ‚‘] returns length(Sâ‚)-length(Sâ‚‚).\n\njulia> defectsymbol([[1,5,6],[1,2]])\n1\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Symbols.symbol_partition_tuple","page":"Gapjm Documentation","title":"Gapjm.Symbols.symbol_partition_tuple","text":"symbol_partition_tuple(p, s) symbol of shape s for partition tuple p.\n\nIn  the general case, s is a Vector{Int}  of same length as p and the i-th  element of the result is the Î²-set for páµ¢ shifted to be of length sáµ¢ (the minimal integer which makes this possible is added to s).\n\nWhen  s is  a positive  integer it  is interpreted  as [s,0,0,â€¦]  and a negative  integer is interpreted  as [0,-s,-s,â€¦] so  when p is a double partition  one gets the  symbol of defect  s associated to  p; as other uses  the  unipotent  symbol  for  a  character  of the principal series of G(e,1,r)   parameterized   by   an   e-tuple   p   of  partitions  is symbol_partition_tuple(p,1) and for G(e,e,r) the similar computation is symbol_partition_tuple(p,0)  (the function handles coded periodic p for G(e,e,r)).\n\njulia> symbol_partition_tuple([[1,2],[1]],1)\n2-element Vector{Vector{Int64}}:\n [2, 2]\n [1]\n\njulia> symbol_partition_tuple([[1,2],[1]],0)\n2-element Vector{Vector{Int64}}:\n [2, 2]\n [0, 2]\n\njulia> symbol_partition_tuple([[1,2],[1]],-1)\n2-element Vector{Vector{Int64}}:\n [2, 2]\n [0, 1, 3]\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Symbols.fegsymbol","page":"Gapjm Documentation","title":"Gapjm.Symbols.fegsymbol","text":"fegsymbol(S,p=0)\n\nLet  s=[Sâ‚,â€¦,Sâ‚‘] be an e-symbol  given as a Vector{Vector{Int}}. This function  returns as a CycPol the fake  degree of the character of symbol S.\n\njulia> fegsymbol([[1,5,6],[1,2]])\nqÂ¹â¶Î¦â‚…Î¦â‚‡Î¦â‚ˆÎ¦â‚‰Î¦â‚â‚€Î¦â‚â‚Î¦â‚â‚„Î¦â‚â‚†Î¦â‚â‚ˆÎ¦â‚‚â‚€Î¦â‚‚â‚‚\n\nWhen  given a  second argument  p dividing  e, and  a first argument of shape  (0,â€¦,0) representing the restriction  to G(e,e,r), works for the coset G(e,e,r).sâ‚áµ–.\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Symbols.gendeg_symbol","page":"Gapjm Documentation","title":"Gapjm.Symbols.gendeg_symbol","text":"gendeg_symbol(s)\n\nLet  s=[Sâ‚,â€¦,Sâ‚‘] be an e-symbol  given as a Vector{Vector{Int}}. This function  returns  as  a  CycPol  the  generic  degree  of  the unipotent character parameterized by s.\n\njulia> Symbols.gendeg_symbol([[1,2],[1,5,6]])\nqÂ¹Â³Î¦â‚…Î¦â‚†Î¦â‚‡Î¦â‚ˆÂ²Î¦â‚‰Î¦â‚â‚€Î¦â‚â‚Î¦â‚â‚„Î¦â‚â‚†Î¦â‚â‚ˆÎ¦â‚‚â‚€Î¦â‚‚â‚‚/2\n\nWorks for symbols for:\n\nG(e,1,r) (c==1, d==0)\nG(e,e,r) (c==0, d==0)\n\nÂ²G(e,e,r) (c==0, d==1) (e,r even. This includes Â²Dâ‚™, Â²Bâ‚‚, Â²Gâ‚‚)\n\nhere  c is the content  of the symbol and  d the Malle-defect, see 3.9 and 6.4 Malle1995.\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Symbols.degree_fegsymbol","page":"Gapjm Documentation","title":"Gapjm.Symbols.degree_fegsymbol","text":"degree_fegsymbol(s)\n\nthe  degree  of  the  fake  degree  of  the  character parameterized by the e-symbol s.\n\njulia> degree_fegsymbol([[1,5,6],[1,2]])\n88\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Symbols.degree_gendeg_symbol","page":"Gapjm Documentation","title":"Gapjm.Symbols.degree_gendeg_symbol","text":"degree_gendeg_symbol(s)\n\nthe  degree of the generic degree  of the unipotent character parameterized by the e-symbol s.\n\njulia> degree_gendeg_symbol([[1,5,6],[1,2]])\n91\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Symbols.valuation_fegsymbol","page":"Gapjm Documentation","title":"Gapjm.Symbols.valuation_fegsymbol","text":"valuation_fegsymbol(s)\n\nthe  valuation of  the fake  degree of  the character  parameterized by the e-symbol s.\n\njulia> valuation_fegsymbol([[1,5,6],[1,2]])\n16\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Symbols.valuation_gendeg_symbol","page":"Gapjm Documentation","title":"Gapjm.Symbols.valuation_gendeg_symbol","text":"valuation_gendeg_symbol(s)\n\nthe   valuation  of   the  generic   degree  of   the  unipotent  character parameterized by the e-symbol s.\n\njulia> valuation_gendeg_symbol([[1,5,6],[1,2]])\n13\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Symbols.tableaux","page":"Gapjm Documentation","title":"Gapjm.Symbols.tableaux","text":"tableaux(S)\n\nS  is a  partition tuple  or a  partition. returns  the list  of standard tableaux  associated to the partition  tuple S, that is  a filling of the associated  young diagrams  with the  numbers 1:sum(sum,S)  such that the numbers  increase across the rows  and down the columns.  If the imput is a single partition, the standard tableaux for that partition are returned.\n\njulia> tableaux([[2,1],[1]])\n8-element Vector{Vector{Vector{Vector{Int64}}}}:\n [[[1, 2], [3]], [[4]]]\n [[[1, 2], [4]], [[3]]]\n [[[1, 3], [2]], [[4]]]\n [[[1, 3], [4]], [[2]]]\n [[[1, 4], [2]], [[3]]]\n [[[1, 4], [3]], [[2]]]\n [[[2, 3], [4]], [[1]]]\n [[[2, 4], [3]], [[1]]]\n\njulia> tableaux([2,2])\n2-element Vector{Vector{Vector{Int64}}}:\n [[1, 2], [3, 4]]\n [[1, 3], [2, 4]]\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Symbols.symbols","page":"Gapjm Documentation","title":"Gapjm.Symbols.symbols","text":"symbols(e,r,c=1,def=0) e-symbols of rank r, content c and Malle-defect def\n\nAn e-symbol is a symbol of length e. The content of an e-symbol S is sum(length,S)%e. The symbols for unipotent  characters of:\n\nG(d,1,r) are symbols(d,r)\nG(e,e,r) are symbols(e,r,0).\nG(e,e,r).sâ‚áµ— where sâ‚ is the first generator of G(e,1,r) and t|e are symbols(e,r,0,t)\n\njulia> stringsymbol.(symbols(3,2,1))\n14-element Vector{String}:\n \"(12,0,0)\"\n \"(02,1,0)\"\n \"(02,0,1)\"\n \"(012,12,01)\"\n \"(01,1,1)\"\n \"(012,01,12)\"\n \"(2,,)\"\n \"(01,2,0)\"\n \"(01,0,2)\"\n \"(1,012,012)\"\n \"(,02,01)\"\n \"(,01,02)\"\n \"(0,,012)\"\n \"(0,012,)\"\n\njulia> stringsymbol.(symbols(3,3,0))\n12-element Vector{String}:\n \"(1+)\"\n \"(1E(3))\"\n \"(1E(3,2))\"\n \"(01,12,02)\"\n \"(01,02,12)\"\n \"(012,012,123)\"\n \"(0,1,2)\"\n \"(0,2,1)\"\n \"(01,01,13)\"\n \"(0,0,3)\"\n \"(012,,)\"\n \"(012,012,)\"\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Symbols.XSP","page":"Gapjm Documentation","title":"Gapjm.Symbols.XSP","text":"XSP(Ï,s,n,even=false)\n\nreturns the union of the Lusztig-Spaltenstein X^Ï-ss_nd for all d even when even=true, all d odd otherwise. In \"Character sheaves on disconnected groups II, 13.2\" the notation is ^Ï X^s_nd. The result is a list of lists, each one corresponding to a similarity class. If s==0, only positive defects are considered.\n\nXSP(2,1,n) gives L-S symbols for Spâ‚‚â‚™\nXSP(4,2,n) gives L-S symbols for Spâ‚‚â‚™ in char.2\nXSP(2,0,n) gives L-S symbols for SOâ‚‚â‚™â‚Šâ‚ [defect odd]\nXSP(2,0,n,true) gives L-S symbols for SOâ‚‚â‚™ [defect even]\nXSP(4,0,n,true) gives L-S symbols for SOâ‚‚â‚™ in char 2\n\nreturns named tuples with fields:\n\nsymbol\ndimBu\nAu  describes a character of A(u) as a list: true->sgn, false->Id  representing the local system of the Springer correspondent\nsp  parameter (double partition) of the generalized Springer  correspondent (character of the relative Weyl group)\n\n\n\n\n\n","category":"function"},{"location":"#Eigenspaces","page":"Gapjm Documentation","title":"Eigenspaces","text":"","category":"section"},{"location":"","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"Eigenspaces\nrelative_degrees\nregular_eigenvalues\neigenspace_projector\nposition_regular_class\nsplit_levis\ncuspidal","category":"page"},{"location":"#Gapjm.Eigenspaces","page":"Gapjm Documentation","title":"Gapjm.Eigenspaces","text":"Eigenspaces and d-Harish-Chandra series\n\nLet WÏ• be a reflection coset on a vector space V and LwÏ• a reflection subcoset  where L is a  parabolic subgroup (the fixator  of a subspace of V).  There  are  several  interesting  cases  where  the relative group N_W(LwÏ•)L,  or a subgroup of it normalizing some further data attached to L, is itself a reflection group.\n\nA first example is the case where Ï•=1 and w=1, W is the Weyl group of a   finite  reductive   group  ð†^F   and  the   Levi  subgroup  ð‹^F corresponding  to L has a cuspidal unipotent character. Then N_W(L)L is  a  Coxeter  group  acting  on  the  space  X(Zð‹)âŠ—â„.  A  combinatorial characterization of such parabolic subgroups of Coxeter groups is that they are  normalized by the  longest element of  larger parabolic subgroups (see 5.7.1 Lusztig1976).\n\nA  second  example  is  when  L  is  trivial  and  wÏ• is a Î¶-regular element,  that is  the Î¶-eigenspace  V_Î¶ of  wÏ• contains  a vector outside  all the reflecting hyperplanes of W. Then N_W(LwÏ•)L=C_W(wÏ•) is a reflection group in its action on V_Î¶.\n\nA similar but more general example is when V_Î¶ is the Î¶-eigenspace of some  element of  the reflection  coset WÏ•,  and is  of maximal dimension among such possible Î¶-eigenspaces. Then the set of elements of WÏ• which act  by Î¶ on V_Î¶ is a certain subcoset LwÏ•, and N_W(LwÏ•)L is a reflection group in its action on V_Î¶ (see 2.5 Lehrer-Springer1999).\n\nFinally,  a  still  more  general  example,  but which only occurs for Weyl groups  or  Spetsial  reflection  groups,  is  when ð‹ is a Î¶-split Levi subgroup  (which means that  the corresponding subcoset  LwÏ• is formed of all the elements which act by Î¶ on some subspace V_Î¶ of V), and Î» is  a  d-cuspidal  unipotent  character  of  ð‹  (which  means  that the multiplicity  of Î¶  as a  root of  the degree  of Î»  is the same as the multiplicity  of Î¶ as a root of the generic order of the semi-simple part of  ð†); then N_W(LwÏ•Î»)L is a complex reflection group in its action on V_Î¶.\n\nFurther,  in the above cases the relative group describes the decomposition of a Lusztig induction.\n\nWhen  ð†^F is  a finite  reductive group,  and Î»  a cuspidal unipotent character  of  the  Levi  subgroup  ð‹^F,  then the ð†^F-endomorphism algebra  of  the  Harish-Chandra  induced  representation R_ð‹^ð†(Î») is a Hecke algebra attached to the group N_W(L)L, thus the dimension of the characters  of this group describe the multiplicities in the Harish-Chandra induced.\n\nSimilarly, when ð‹ is a Î¶-split Levi subgroup, and Î» is a d-cuspidal unipotent  character of  ð‹ then  (conjecturally) the ð†^F-endomorphism algebra  of the Lusztig induced R_ð‹^ð†(Î»)  is a cyclotomic Hecke algebra for  to the  group N_W(LwÏ•Î»)L.  The constituents  of R_ð‹^ð†(Î») are called  a  Î¶-Harish-Chandra  series.  In  the  case of rational groups or cosets,  corresponding to finite  reductive groups, the  conjugacy class of LwÏ•  depends  only  on  the  order  d  of  Î¶,  so  one  also talks of d-Harish-Chandra  series. These series correspond to â„“-blocks where l is  a prime divisor of Î¦_d(q) which  does not divide any other cyclotomic factor of the order of ð†^F.\n\nThe functions described in this module allow to explore these situations.\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.Eigenspaces.relative_degrees","page":"Gapjm Documentation","title":"Gapjm.Eigenspaces.relative_degrees","text":"relative_degrees(WF,d)\n\nLet  WF be a reflection group or a reflection coset. Here d specifies a root  of unity Î¶: either d is an integer and specifies Î¶=E(d) or is a fraction  smaller a/b with 0<a<b  and specifies Î¶=E(b,a). If omitted, d  is  taken  to  be  1,  specifying  Î¶=1.  Then  if  V_Î¶  is the Î¶-eigenspace  of some element of WF,  and is of maximal dimension among such   possible  Î¶-eigenspaces,  and  W  is  the  group  of  WF  then N_W(V_Î¶)C_W(V_Î¶)  is a reflection group in  its action on V_Î¶. The function  relative_degrees returns the reflection degrees of this complex reflection group, which are a subset of those of W.\n\nThese   degrees  are   computed  by   an  invariant-theoretic  formula:  if (dâ‚,Îµâ‚),â€¦,(dâ‚™,Îµâ‚™)  are the generalized degrees of  WF they are the dáµ¢ such that Î¶^{dáµ¢}=Îµáµ¢.\n\njulia> W=coxgroup(:E,8)\nEâ‚ˆ\n\njulia> relative_degrees(W,4)\n4-element Vector{Int64}:\n  8\n 12\n 20\n 24\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Eigenspaces.regular_eigenvalues","page":"Gapjm Documentation","title":"Gapjm.Eigenspaces.regular_eigenvalues","text":"regular_eigenvalues(W)\n\nLet W be a reflection group or a reflection coset. A root of unity Î¶ is a regular eigenvalue for W if some element of W has a Î¶-eigenvector which   lies   outside   of   the   reflecting  hyperplanes.  The  function regular_eigenvalues returns the list of regular eigenvalues for W.\n\njulia> regular_eigenvalues(coxgroup(:G,2))\n6-element Vector{Root1}:\n   1\n  -1\n  Î¶â‚ƒ\n Î¶â‚ƒÂ²\n  Î¶â‚†\n Î¶â‚†âµ\n\njulia> W=ComplexReflectionGroup(6)\nGâ‚†\n\njulia> L=twistings(W,[2])[2]\nGâ‚†â‚â‚‚â‚Ž=Gâ‚ƒâ€šâ‚â€šâ‚[Î¶â‚„]Î¦â€²â‚„\n\njulia> regular_eigenvalues(L)\n3-element Vector{Root1}:\n    Î¶â‚„\n  Î¶â‚â‚‚â·\n Î¶â‚â‚‚Â¹Â¹\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Eigenspaces.eigenspace_projector","page":"Gapjm Documentation","title":"Gapjm.Eigenspaces.eigenspace_projector","text":"eigenspace_projector(WF,w[,d=1])\n\nLet  WF be a reflection group or a reflection coset. Here d specifies a root  of unity Î¶: either d is an integer and specifies Î¶=E(d)' or is a fraction  smallera/bwith0<a<band  specifiesÎ¶=E(b,a)', or is a Root1.  The function  returns the  unique w-invariant  projector on the Î¶-eigenspace of w.\n\njulia> W=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> w=W(1:3...)\n(1,12,3,2)(4,11,10,5)(6,9,8,7)\n\njulia> p=eigenspace_projector(W,w,1//4)\n3Ã—3 Matrix{Cyc{Rational{Int64}}}:\n  (1+Î¶â‚„)/4   Î¶â‚„/2  (-1+Î¶â‚„)/4\n  (1-Î¶â‚„)/4    1/2   (1+Î¶â‚„)/4\n (-1-Î¶â‚„)/4  -Î¶â‚„/2   (1-Î¶â‚„)/4\n\njulia> GLinearAlgebra.rank(p)\n1\n\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Eigenspaces.position_regular_class","page":"Gapjm Documentation","title":"Gapjm.Eigenspaces.position_regular_class","text":"position_regular_class(WF,d=0)\n\nLet  WF be a reflection group or a reflection coset. Here d specifies a root  of unity Î¶:  either d is  a Root1, or  an integer and specifies Î¶=E(d)  or is a fraction a//b with 0<a<b and specifies Î¶=E(b,a). If omitted, d is taken to be 0, specifying Î¶=1. The root Î¶ should be a regular  eigenvalue  for  WF  (see  \"regular_eigenvalues\").  The function returns  the index of the  conjugacy class of WF  which has a Î¶-regular eigenvector.\n\njulia> W=coxgroup(:E,8)\nEâ‚ˆ\n\njulia> position_regular_class(W,30)\n65\n\njulia> W=ComplexReflectionGroup(6)\nGâ‚†\n\njulia> L=twistings(W,[2])[2]\nGâ‚†â‚â‚‚â‚Ž=Gâ‚ƒâ€šâ‚â€šâ‚[Î¶â‚„]Î¦â€²â‚„\n\njulia> position_regular_class(L,7//12)\n2\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Eigenspaces.split_levis","page":"Gapjm Documentation","title":"Gapjm.Eigenspaces.split_levis","text":"split_levis(WF,d=0,ad=-1)\n\nLet  WF  be  a  reflection  group  or  a  reflection  coset.  If W is a reflection group it is treated as the trivial coset 'Spets(W)'.\n\nHere  d  specifies  a  root  of  unity  Î¶: either d is an integer and specifies  Î¶=E(d)  or  is  a  fraction  a/b  with 0<a<b and specifies Î¶=E(b,a). If omitted, d is taken to be 0, specifying Î¶=1.\n\nA  Levi  is  a  subcoset  of  the  form Wâ‚Fâ‚ where Wâ‚ is a parabolic subgroup of W, that is the centralizer of some subspace of V.\n\nThe  function returns  a list  of representatives  of conjugacy  classes of d-split  Levis of W. A  d-split Levi is a  subcoset of WF formed of all  the elements  which act  by Î¶  on a  given subspace  V_Î¶. If the additional  argument ad  is given,  it returns  only those subcosets such that  the common  Î¶-eigenspace of  their elements  is of  dimension ad. These  notions  make  sense  and  thus  are  implemented  for  any  complex reflection group.\n\nIn  terms of algebraic groups, an F-stable Levi subgroup of the reductive group  ð†  is  d-split  if  and  only  if it is the centralizer of the Î¦_d-part  of its center. When d=1, we get the notion of a split Levi, which  is the same as a Levi sugroup of an F-stable parabolic subgroup of ð†.\n\njulia> W=coxgroup(:A,3)\nAâ‚ƒ\n\njulia> split_levis(W,4)\n2-element Vector{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}}:\n Aâ‚ƒ\n Aâ‚ƒâ‚â‚Ž=Î¦â‚‚Î¦â‚„\n\njulia> W=spets(coxgroup(:D,4),Perm(1,2,4))\nÂ³Dâ‚„\n\njulia> split_levis(W,3)\n3-element Vector{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}}:\n Â³Dâ‚„\n Dâ‚„â‚â‚â‚ƒâ‚Ž=Aâ‚‚Î¦â‚ƒ\n Dâ‚„â‚â‚Ž=Î¦â‚ƒÂ²\n\njulia> W=coxgroup(:E,8)\nEâ‚ˆ\n\njulia> split_levis(W,4,2)\n3-element Vector{Spets{FiniteCoxeterSubGroup{Perm{Int16},Int64}}}:\n Eâ‚ˆâ‚â‚ƒâ‚‚â‚„â‚…â‚Ž=Dâ‚„â‚â‚â‚ƒâ‚‚â‚„â‚ŽÎ¦â‚„Â²\n Eâ‚ˆâ‚â‚…â‚‡â‚‚â‚ƒâ‚Ž=(Aâ‚Aâ‚)Ã—(Aâ‚Aâ‚)Î¦â‚„Â²\n Eâ‚ˆâ‚â‚ƒâ‚â‚…â‚†â‚Ž=Â²(Aâ‚‚Aâ‚‚)â‚â‚â‚„â‚‚â‚ƒâ‚ŽÎ¦â‚„Â²\n\njulia> split_levis(ComplexReflectionGroup(5))\n4-element Vector{Spets{PRSG{Cyc{Rational{Int64}}, Int16}}}:\n Gâ‚…\n Gâ‚…â‚â‚â‚Ž=Gâ‚ƒâ€šâ‚â€šâ‚Î¦â‚\n Gâ‚…â‚â‚‚â‚Ž=Gâ‚ƒâ€šâ‚â€šâ‚Î¦â‚\n Gâ‚…â‚â‚Ž=Î¦â‚Â²\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Uch.cuspidal","page":"Gapjm Documentation","title":"Gapjm.Uch.cuspidal","text":"cuspidal(uc::UnipotentCharacters[,e])\n\nA  unipotent character Î³ of a  finite reductive group ð† is e-cuspidal if  its  Lusztig  restriction  to  any  proper e-split Levi is zero. When e==1  (the default when  e is omitted)  we recover the  usual notion of cuspidal character. Equivalently the Î¦â‚‘-part of the generic degree of Î³ is equal to the Î¦â‚‘-part of the generic order of the adjoint group of ð†. This  makes  sense  for  any  Spetsial  complex  reflection  group  and  is implemented for them.\n\nThe  function returns the list of indices of unipotent characters which are e-cuspidal.\n\njulia> W=coxgroup(:D,4)\nDâ‚„\n\njulia> cuspidal(UnipotentCharacters(W))\n1-element Vector{Int64}:\n 14\n\njulia> cuspidal(UnipotentCharacters(W),6)\n8-element Vector{Int64}:\n  1\n  2\n  6\n  7\n  8\n  9\n 10\n 12\n\njulia> cuspidal(UnipotentCharacters(ComplexReflectionGroup(4)),3)\n4-element Vector{Int64}:\n  3\n  6\n  7\n 10\n\n\n\n\n\n","category":"function"},{"location":"#Classtypes","page":"Gapjm Documentation","title":"Classtypes","text":"","category":"section"},{"location":"","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"ClassTypes","category":"page"},{"location":"#Gapjm.Gt.ClassTypes","page":"Gapjm Documentation","title":"Gapjm.Gt.ClassTypes","text":"ClassTypes(G[,p])\n\nG  should be a root  datum or a twisted  root datum representing a finite reductive  group ð† ^F and  p should be a  prime. The function returns the class types of G in characteristic p (in good characteristic if p is  omitted). Two elements  of ð† ^F  have the same  class type if their centralizers  are  conjugate.  If  su  is  the Jordan decomposition of an element  x, the class type of x is  determined by the class type of its semisimple part s and the unipotent class of u in C_ð† (s).\n\nThe   function  ClassTypes  is  presently  only  implemented  for  simply connected  groups, where  C_ð† (s)  is connected.  This section is a bit experimental and may change in the future.\n\nClassTypes  returns a  struct which  contains a  list of classtypes for semisimple  elements,  which  are  represented  by  subspets  and contain additionnaly information on the unipotent classes of C_ð† (s).\n\nLet us give some examples:\n\njulia> t=ClassTypes(rootdatum(:sl,3))\nClassTypes(Aâ‚‚,good characteristic)\n    C_G(s)â”‚ |C_G(s)|\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nAâ‚‚â‚â‚Ž=Î¦â‚Â²  â”‚      Î¦â‚Â²\nAâ‚‚â‚â‚Ž=Î¦â‚Î¦â‚‚ â”‚     Î¦â‚Î¦â‚‚\nAâ‚‚â‚â‚Ž=Î¦â‚ƒ   â”‚       Î¦â‚ƒ\nAâ‚‚â‚â‚â‚Ž=Aâ‚Î¦â‚â”‚   qÎ¦â‚Â²Î¦â‚‚\nAâ‚‚        â”‚qÂ³Î¦â‚Â²Î¦â‚‚Î¦â‚ƒ\n\nBy   default,  only  information  about  semisimple  centralizer  types  is returned:   the type, and its generic order.\n\njulia> xdisplay(t;unip=true)\nClassTypes(Aâ‚‚,good characteristic)\n    C_G(s)â”‚      u |C_G(su)|\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nAâ‚‚â‚â‚Ž=.Î¦â‚Â² â”‚              Î¦â‚Â²\nAâ‚‚â‚â‚Ž=.Î¦â‚Î¦â‚‚â”‚             Î¦â‚Î¦â‚‚\nAâ‚‚â‚â‚Ž=.Î¦â‚ƒ  â”‚               Î¦â‚ƒ\nAâ‚‚â‚â‚â‚Ž=Aâ‚Î¦â‚â”‚     11    qÎ¦â‚Â²Î¦â‚‚\n          â”‚      2       qÎ¦â‚\nAâ‚‚        â”‚    111 qÂ³Î¦â‚Â²Î¦â‚‚Î¦â‚ƒ\n          â”‚     21      qÂ³Î¦â‚\n          â”‚      3       3qÂ²\n          â”‚ 3_{Î¶â‚ƒ}       3qÂ²\n          â”‚3_{Î¶â‚ƒÂ²}       3qÂ²\n\nHere  we  have  displayed  information  on  unipotent  classes,  with their centralizer.\n\njulia> xdisplay(t;nClasses=true)\nClassTypes(Aâ‚‚,good characteristic)\n    C_G(s)â”‚       nClasses  |C_G(s)|\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nAâ‚‚â‚â‚Ž=.Î¦â‚Â² â”‚(qÂ²-5q+2qâ‚ƒ+4)/6       Î¦â‚Â²\nAâ‚‚â‚â‚Ž=.Î¦â‚Î¦â‚‚â”‚       (qÂ²-q)/2      Î¦â‚Î¦â‚‚\nAâ‚‚â‚â‚Ž=.Î¦â‚ƒ  â”‚  (qÂ²+q-qâ‚ƒ+1)/3        Î¦â‚ƒ\nAâ‚‚â‚â‚â‚Ž=Aâ‚Î¦â‚â”‚       (q-qâ‚ƒ-1)    qÎ¦â‚Â²Î¦â‚‚\nAâ‚‚        â”‚             qâ‚ƒ qÂ³Î¦â‚Â²Î¦â‚‚Î¦â‚ƒ\n\nHere  we have added information on how many semisimple conjugacy classes of ð†  ^F have a given type. The  answer in general involves variables of the form qâ‚ which represent gcd(q-1,a).\n\nFinally an example in bad characteristic:\n\njulia> t=ClassTypes(coxgroup(:G,2),2);xdisplay(t;nClasses=true)\nClassTypes(Gâ‚‚,char. 2)\n    C_G(s)â”‚         nClasses     |C_G(s)|\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nGâ‚‚â‚â‚Ž=.Î¦â‚Â² â”‚(qÂ²-8q+2qâ‚ƒ+10)/12          Î¦â‚Â²\nGâ‚‚â‚â‚Ž=.Î¦â‚Î¦â‚‚â”‚        (qÂ²-2q)/4         Î¦â‚Î¦â‚‚\nGâ‚‚â‚â‚Ž=.Î¦â‚Î¦â‚‚â”‚        (qÂ²-2q)/4         Î¦â‚Î¦â‚‚\nGâ‚‚â‚â‚Ž=.Î¦â‚†  â”‚    (qÂ²-q-qâ‚ƒ+1)/6           Î¦â‚†\nGâ‚‚â‚â‚Ž=.Î¦â‚ƒ  â”‚    (qÂ²+q-qâ‚ƒ+1)/6           Î¦â‚ƒ\nGâ‚‚â‚â‚Ž=.Î¦â‚‚Â² â”‚ (qÂ²-4q+2qâ‚ƒ-2)/12          Î¦â‚‚Â²\nGâ‚‚â‚â‚â‚Ž=Aâ‚Î¦â‚‚â”‚       (q-qâ‚ƒ+1)/2       qÎ¦â‚Î¦â‚‚Â²\nGâ‚‚â‚â‚â‚Ž=Aâ‚Î¦â‚â”‚       (q-qâ‚ƒ-1)/2       qÎ¦â‚Â²Î¦â‚‚\nGâ‚‚â‚â‚‚â‚Ž=AÌƒâ‚Î¦â‚‚â”‚              q/2       qÎ¦â‚Î¦â‚‚Â²\nGâ‚‚â‚â‚‚â‚Ž=AÌƒâ‚Î¦â‚â”‚          (q-2)/2       qÎ¦â‚Â²Î¦â‚‚\nGâ‚‚        â”‚                1 qâ¶Î¦â‚Â²Î¦â‚‚Â²Î¦â‚ƒÎ¦â‚†\nGâ‚‚â‚â‚â‚…â‚Ž=Â²Aâ‚‚â”‚         (qâ‚ƒ-1)/2    qÂ³Î¦â‚Î¦â‚‚Â²Î¦â‚†\nGâ‚‚â‚â‚â‚…â‚Ž=Aâ‚‚ â”‚         (qâ‚ƒ-1)/2    qÂ³Î¦â‚Â²Î¦â‚‚Î¦â‚ƒ\n\nWe  notice that if q is  a power of 2 such  that qâ‰¡2 (mod 3), so that qâ‚ƒ=1,  some class types do not exist. We can see what happens by giving a specific value to qâ‚ƒ:\n\njulia> xdisplay(t(;q_3=1);nClasses=true)\nClassTypes(Gâ‚‚,char. 2) q_3=1\n    C_G(s)â”‚     nClasses     |C_G(s)|\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nGâ‚‚â‚â‚Ž=.Î¦â‚Â² â”‚(qÂ²-8q+12)/12          Î¦â‚Â²\nGâ‚‚â‚â‚Ž=.Î¦â‚Î¦â‚‚â”‚    (qÂ²-2q)/4         Î¦â‚Î¦â‚‚\nGâ‚‚â‚â‚Ž=.Î¦â‚Î¦â‚‚â”‚    (qÂ²-2q)/4         Î¦â‚Î¦â‚‚\nGâ‚‚â‚â‚Ž=.Î¦â‚†  â”‚     (qÂ²-q)/6           Î¦â‚†\nGâ‚‚â‚â‚Ž=.Î¦â‚ƒ  â”‚     (qÂ²+q)/6           Î¦â‚ƒ\nGâ‚‚â‚â‚Ž=.Î¦â‚‚Â² â”‚   (qÂ²-4q)/12          Î¦â‚‚Â²\nGâ‚‚â‚â‚â‚Ž=Aâ‚Î¦â‚‚â”‚          q/2       qÎ¦â‚Î¦â‚‚Â²\nGâ‚‚â‚â‚â‚Ž=Aâ‚Î¦â‚â”‚      (q-2)/2       qÎ¦â‚Â²Î¦â‚‚\nGâ‚‚â‚â‚‚â‚Ž=AÌƒâ‚Î¦â‚‚â”‚          q/2       qÎ¦â‚Î¦â‚‚Â²\nGâ‚‚â‚â‚‚â‚Ž=AÌƒâ‚Î¦â‚â”‚      (q-2)/2       qÎ¦â‚Â²Î¦â‚‚\nGâ‚‚        â”‚            1 qâ¶Î¦â‚Â²Î¦â‚‚Â²Î¦â‚ƒÎ¦â‚†\n\n\n\n\n\n","category":"type"},{"location":"#Unipotent-Elements","page":"Gapjm Documentation","title":"Unipotent Elements","text":"","category":"section"},{"location":"","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"Urad\nUnipotentGroup\nUrad.norm\nUrad.abelianpart\nUrad.decompose","category":"page"},{"location":"#Gapjm.Urad","page":"Gapjm Documentation","title":"Gapjm.Urad","text":"This  module contains  functions for  computing with  unipotent elements of reductive  groups;  specifically  to  compute  with  elements  of unipotent radical  of a Borel subgroup of  a connected algebraic reductive group; the implementation of these functions was initially written by Olivier Dudas in GAP3.\n\nThe  unipotent radical of a  Borel subgroup is the  product in any order of root  subgroups associated  to the  positive roots.  We fix an order, which gives a canonical form to display elements and to compare them.\n\nThe  computations use the Steinberg relations between root subgroups, which come from the choice of a Chevalley basis of the Lie algebra. The reference we  follow is Carter1972, chapters 4 to 6.\n\nWe  start with  a root  datum specified  by a  Weyl group  W and  build a struct which contains information about the maximal unipotent subgroup of the  corresponding reductive  group, that  is the  unipotent radical of the Borel subgroup determined by the positive roots.\n\njulia> W=coxgroup(:E,6)\nEâ‚†\n\njulia> U=UnipotentGroup(W)\nUnipotentGroup(Eâ‚†)\n\nNow, if Î±=roots(W,2), we construct the element u_Î±(4) of the root subgroup u_Î±:\n\njulia> U(2=>4)\nu2(4)\n\nIf we do not specify the coefficient we make by default u_Î±(1), so we have also:\n\njulia> U(2)^4\nu2(4)\n\nWe can make more complicated elements:\n\njulia> U(2=>4)*U(4=>5)\nu2(4)u4(5)\n\njulia> U(2=>4,4=>5)\nu2(4)u4(5)\n\nIf the roots are not in order the element is normalized:\n\njulia> U(4=>5,2=>4)\nu2(4)u4(5)u8(-20)\n\nIt is possible to display the decomposition of the roots in simple roots instead of their index:\n\njulia> xdisplay(U(4=>5,2=>4);root=true)\nuâ‚€â‚â‚€â‚€â‚€â‚€(4)uâ‚€â‚€â‚€â‚â‚€â‚€(5)uâ‚€â‚â‚€â‚â‚€â‚€(-20)\n\nThe coefficients in the root subgroups can be elements of arbitrary rings. Here is an example using Mvp's:\n\njulia> W=coxgroup(:E,8);U=UnipotentGroup(W)\nUnipotentGroup(Eâ‚ˆ)\n\njulia> u=U(map(i->i=>Z(2)*Mvp(Symbol(\"x_\",i)),1:8)...)\nu1(1â‚‚xâ‚)u2(1â‚‚xâ‚‚)u3(1â‚‚xâ‚ƒ)u4(1â‚‚xâ‚„)u5(1â‚‚xâ‚…)u6(1â‚‚xâ‚†)u7(1â‚‚xâ‚‡)u8(1â‚‚xâ‚ˆ)\n\njulia> cut(repr(u^16;context=rio(root=true)),before=\"u\",width=60)\nuâ‚‚â‚‚â‚ƒâ‚„â‚ƒâ‚‚â‚â‚€(1â‚‚xâ‚Â²xâ‚‚Â²xâ‚ƒÂ³xâ‚„â´xâ‚…Â³xâ‚†Â²xâ‚‡)\nuâ‚â‚‚â‚ƒâ‚„â‚ƒâ‚‚â‚â‚(1â‚‚xâ‚xâ‚‚Â²xâ‚ƒÂ³xâ‚„â´xâ‚…Â³xâ‚†Â²xâ‚‡xâ‚ˆ)\nuâ‚â‚‚â‚‚â‚„â‚ƒâ‚‚â‚‚â‚(1â‚‚xâ‚xâ‚‚Â²xâ‚ƒÂ²xâ‚„â´xâ‚…Â³xâ‚†Â²xâ‚‡Â²xâ‚ˆ)\nuâ‚â‚‚â‚‚â‚ƒâ‚ƒâ‚ƒâ‚‚â‚(1â‚‚xâ‚xâ‚‚Â²xâ‚ƒÂ²xâ‚„Â³xâ‚…Â³xâ‚†Â³xâ‚‡Â²xâ‚ˆ)\nuâ‚‚â‚‚â‚ƒâ‚„â‚ƒâ‚‚â‚â‚(1â‚‚xâ‚Â²xâ‚‚Â²xâ‚ƒÂ³xâ‚„â´xâ‚…Â³xâ‚†Â²xâ‚‡xâ‚ˆ)\nuâ‚â‚‚â‚‚â‚„â‚ƒâ‚ƒâ‚‚â‚(1â‚‚xâ‚xâ‚‚Â²xâ‚ƒÂ²xâ‚„â´xâ‚…Â³xâ‚†Â³xâ‚‡Â²xâ‚ˆ)\nuâ‚â‚‚â‚‚â‚„â‚„â‚ƒâ‚‚â‚(1â‚‚xâ‚xâ‚‚Â²xâ‚ƒÂ²xâ‚„â´xâ‚…â´xâ‚†Â³xâ‚‡Â²xâ‚ˆ)\nuâ‚‚â‚‚â‚ƒâ‚„â‚ƒâ‚ƒâ‚‚â‚(1â‚‚xâ‚Â²xâ‚‚Â²xâ‚ƒÂ³xâ‚„â´xâ‚…Â³xâ‚†Â³xâ‚‡Â²xâ‚ˆ)\nuâ‚â‚‚â‚ƒâ‚„â‚„â‚ƒâ‚‚â‚(1â‚‚xâ‚xâ‚‚Â²xâ‚ƒÂ³xâ‚„â´xâ‚…â´xâ‚†Â³xâ‚‡Â²xâ‚ˆ)\nuâ‚‚â‚‚â‚ƒâ‚„â‚„â‚ƒâ‚‚â‚(1â‚‚xâ‚Â²xâ‚‚Â²xâ‚ƒÂ³xâ‚„â´xâ‚…â´xâ‚†Â³xâ‚‡Â²xâ‚ˆ)\nuâ‚‚â‚ƒâ‚ƒâ‚…â‚„â‚ƒâ‚‚â‚(1â‚‚xâ‚Â²xâ‚‚Â³xâ‚ƒÂ³xâ‚„âµxâ‚…â´xâ‚†Â³xâ‚‡Â²xâ‚ˆ)\nuâ‚‚â‚‚â‚„â‚…â‚„â‚ƒâ‚‚â‚(1â‚‚xâ‚Â²xâ‚‚Â²xâ‚ƒâ´xâ‚„âµxâ‚…â´xâ‚†Â³xâ‚‡Â²xâ‚ˆ)\nuâ‚‚â‚ƒâ‚„â‚†â‚…â‚„â‚ƒâ‚‚(1â‚‚xâ‚Â²xâ‚‚Â³xâ‚ƒâ´xâ‚„â¶xâ‚…âµxâ‚†â´xâ‚‡Â³xâ‚ˆÂ²)\n\njulia> u^32\n()\n\nThe  above computation shows  that in characteristic  2 the exponent of the unipotent  group of Eâ‚ˆ is 32. More precisely, squaring doubles the height of  the involved roots, so in the above uÂ¹â¶ involves only roots of height 16 or more.\n\nVarious  actions are  defined on  unipotent elements.  Elements of the Weyl group  act (through certain representatives) as long as no root subgroup is in their inversion set:\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> U=UnipotentGroup(W);@Mvp x,y\n\njulia> u=U(1=>x,3=>y)\nu1(x)u3(y)\n\njulia> u^W(2,1)\nu4(y)u5(x)\n\njulia> u^W(1)\nERROR: u1(x)u3(y) should have no coefficient on root 1\n\nSemisimple elements act by conjugation:\n\njulia> s=SemisimpleElement(W,[E(3),2])\nSemisimpleElement{Cyc{Int64}}: <Î¶â‚ƒ,2>\n\njulia> u^s\nu1(Î¶â‚ƒx)u3(2Î¶â‚ƒy)\n\nAs well as unipotent elements:\n\njulia> u^U(2)\nu1(x)u3(x+y)u4(-x-2y)u5(x+3y)u6(xÂ²+3xy+3yÂ²)\n\n\n\n\n\n","category":"module"},{"location":"#Gapjm.Urad.UnipotentGroup","page":"Gapjm Documentation","title":"Gapjm.Urad.UnipotentGroup","text":"A  struct UnipotentGroup  U represents  the unipotent  radical ð” of a Borel subgroup of the reductive group with Weyl group U.W.\n\nSee   Carter1972,  section  4.2  for  details  on  the following.  A Chevalley basis  of the Lie  algebra of ð”  is a basis eáµ£, where   each  eáµ£  is  in  the  corresponding  root  subspace,  such  that [eáµ£,eâ‚›]=Náµ£â‚› e_{r+s} for some integer constants Náµ£â‚›.\n\nTo  build such  a basis,  let <  be a  total order  on the positive roots induced  by a total order on the ambient vector space (the default order of roots  of W in this package  is an example; we use  it in this module). A pair (r,s) of roots is special if 0<r<s and r+s is a root.\n\nConstants  Cáµ£â‚›áµ¢â±¼ are defined, see Carter1972, 5.2.3, by\n\nu_s(u)u_r(t)=u_r(t)u_s(u)prod_ij0u_ir+js(C_rsij(-t)^iu^j)\n\nWhere  ir+js runs over the positive  integral combinations of r and s which are roots, taken in lexicographic order.\n\nThe fields of struct Unipotent Group are:\n\nW:         the underlying Weyl group\nspecialPairs:   triples of indices of the roots (r,s,r+s)               where (r,s) is special, ordered by (r+s,r), followed               by the triples (s,r,r+s) for the same list.\nns:         The number of Â Â specialPairs where r<s.\nN:          the constants Náµ£â‚› for specialPairs\norder:      the order on positive roots used to normalize products\ncommutatorConstants: stores the Cáµ£â‚›áµ¢â±¼ by storing for each special pair                  (r,s) the list of quadruples [i,j,ir+js,Cáµ£â‚›áµ¢â±¼].\n\n\n\n\n\n","category":"type"},{"location":"#Gapjm.Urad.norm","page":"Gapjm Documentation","title":"Gapjm.Urad.norm","text":"'norm(U,l[,order])'\n\nThis  function  takes  a  list  of  pairs  'r=>c'  representing a unipotent element,  where 'r'  is a  root and  'c' the corresponding coefficient, and puts  it in  canonical form,  reordering the  terms to agree with 'U.order' using  the commutation  relations. If  a second  argument is given, this is used instead of 'U.order'.\n\njulia> U=UnipotentGroup(coxgroup(:G,2))\nUnipotentGroup(Gâ‚‚)\n\njulia> l=norm(U,[2=>4,1=>2])\n6-element Vector{Pair{Int64, Int64}}:\n 1 => 2\n 2 => 4\n 3 => -8\n 4 => 32\n 5 => -128\n 6 => 512\n\njulia> norm(U,l,6:-1:1)\n2-element Vector{Pair{Int64, Int64}}:\n 2 => 4\n 1 => 2\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Urad.abelianpart","page":"Gapjm Documentation","title":"Gapjm.Urad.abelianpart","text":"'abelianpart(u::UnipotentElement)'\n\nIf  ð” is the unipotent subgroup and D(ð”) its derived subgroup, this function   returns  the  projection   of  the  unipotent   element  'u'  on ð”/D(ð”), that is its coefficients on the simple roots.\n\njulia> U=UnipotentGroup(coxgroup(:G,2));@Mvp x,y\n\njulia> u=U(2=>y,1=>x)\nu1(x)u2(y)u3(-xy)u4(xyÂ²)u5(-xyÂ³)u6(2xÂ²yÂ³)\n\njulia> abelianpart(u)\nu1(x)u2(y)\n\n\n\n\n\n","category":"function"},{"location":"#Gapjm.Chars.decompose","page":"Gapjm Documentation","title":"Gapjm.Chars.decompose","text":"decompose(ct::CharTable,c::Vector) \n\ndecompose character c (given by its values on conjugacy classes)  on irreducible characters as given by CharTable ct\n\n\n\n\n\ndecompose(w,u)\n\nu  should be a unipotent element and  w an element of the corresponding Weyl  group.  If  ð”  is  the  unipotent  radical  of  the  Borel subgroup determined  by the  positive roots,  and ð”â»  the unipotent radical of the opposite  Borel, this  function decomposes  u into  its component in ð” âˆ© Ê·ð”â» and its component in ð” âˆ© Ê·ð”.\n\njulia> W=coxgroup(:G,2)\nGâ‚‚\n\njulia> U=UnipotentGroup(W);@Mvp x,y\n\njulia> u=U(2=>y,1=>x)\nu1(x)u2(y)u3(-xy)u4(xyÂ²)u5(-xyÂ³)u6(2xÂ²yÂ³)\n\njulia> decompose(W(1),u)\n2-element Vector{UnipotentElement{Mvp{Int64, Int64}}}:\n u1(x)\n u2(y)u3(-xy)u4(xyÂ²)u5(-xyÂ³)u6(2xÂ²yÂ³)\n\njulia> decompose(W(2),u)\n2-element Vector{UnipotentElement{Mvp{Int64, Int64}}}:\n u2(y)\n u1(x)\n\n\n\n\n\n","category":"function"},{"location":"#Dictionary-from-GAP3/Chevie","page":"Gapjm Documentation","title":"Dictionary from GAP3/Chevie","text":"","category":"section"},{"location":"","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"The dictionary from GAP3/Chevie is as follows:","category":"page"},{"location":"","page":"Gapjm Documentation","title":"Gapjm Documentation","text":"AbelianGenerators                           abelian_gens\nAlgebraicCentre                             algebraic_centre\nAlmostCharacter                             AlmostChar\nArrangements                                arrangements\nAsFraction                                  fraction\nAsReflection                                reflection\nAsRootOfUnity                               Root1\nAsWord                                      word\nAssociatedPartition                         conjugate_partition\nAsymptoticAlgebra                           AsymptoticAlgebra\nBadPrimes                                   badprimes\nBetaSet                                     Î²set\nBigCellDecomposition                        bigcell_decomposition\nBinomial                                    binomial\nBipartiteDecomposition                      bipartite_decomposition\nBlocksMat                                   blocks\nBraid                                       BraidMonoid\nBraidMonoid                                 BraidMonoid\nBraidRelations                              braid_relations\nBruhat                                      bruhatless\nBruhatPoset                                 Poset\nBruhatSmaller                               bruhatless\nCartanMat(\"A\",5)                            cartan(:A,5)\nCartanMatFromCoxeterMatrix                  cartan\nCartesian                                   cartesian\nCatalan                                     catalan\nCentralizerGenerators                       centralizer_gens\nCharFFE(x)                                  field(x).p\nCharNames                                   charnames\nCharParams(W)                               charinfo(W)[:charparams]\nCharRepresentationWords                     traces_words_mats\nCharTable                                   CharTable\nCheckHeckeDefiningRelations                 isrepresentation\nChevieCharInfo                              charinfo\nChevieClassInfo                             classinfo\nClassTypes                                  ClassTypes\nCoefficient(p,i)                            p[i]\nCollectBy(l,f)                              collectby(f,l)\nCollected                                   tally\nCombinations                                combinations\nComplexConjugate                            conj\nComplexReflectionGroup                      ComplexReflectionGroup\nCompositions                                compositions\nConcatenation(s::Vector...)                 vcat(s...)\nConcatenationString(s...)                   prod(s)\nConjugacySet(b[,F][,type])                  conjcat(b[,F],ss=type).obj\nConjugatePartition                          conjugate_partition\nCoxeterCoset                                spets\nCoxeterElements(W[,l])                      elements(W[,l])\nCoxeterGroup(\"A\",5)                         coxgroup(:A,5)\nCoxeterGroupByCartanMatrix(C)               gencox(C)\nCoxeterGroupByCoxeterMatrix(C)              gencox(cartan(C))\nCoxeterGroupHyperoctaedralGroup(n)          CoxHyperoctaedral(n)\nCoxeterGroupSymmetricGroup(n)               CoxSym(n)\nCoxeterLength(W,w)                          length(W,w)\nCoxeterMatrix                               coxmat\nCoxeterMatrixFromCartanMat                  coxmat\nCoxeterSubCoset                             subspets\nCoxeterWord(W,w)                            word(W,w)\nCoxeterWords(W[,l])                         word.(Ref(W),elements(W[,l]))\nCuspidalUnipotentCharacters(W)              cuspidal(UnipotentCharacters(W))\nCycPol                                      CycPol\nCycPolFakeDegreeSymbol                      fegsymbol\nCycPolGenericDegreeSymbol                   gendeg_symbol\nCycPolUnipotentDegrees                      CycPolUnipotentDegrees\nCycle                                       orbit\nCycles                                      orbits\nCyclotomicPolynomial(R,i)                   cyclotomic_polynomial(i)\nDecomposedMat                               diagblocks\nDefectSymbol                                defectsymbol\nDegree(p)                                   degree(p)\nDegreeFFE(x)                                field(x).n\nDeligneLusztigCharacter                     DLChar\nDeligneLusztigLefschetz                     DLLeftschetz\nDescribeInvolution                          describe_involution\nDetPerm(W)                                  vec(detPerm(W))\nDigits                                      digits\nDominates                                   dominates\nDrinfeldDouble                              drinfeld_double\nDrop                                        deleteat!\nDualBraid                                   DualBraidMonoid\nDualBraidMonoid                             DualBraidMonoid\nEigenspaceProjector                         eigenspace_projector\nElementWithInversions(W,l)                  with_inversions(W,l)\nElements                                    elements\nEltBraid                                    image\nEltWord(W,w)                                W(w...)\nExteriorPower                               exterior_power\nFactorizedSchurElement                      FactorizedSchurElement\nFactorizedSchurElements                     FactorizedSchurElements\nFakeDegree                                  fakedegree\nFakeDegrees                                 fakedegrees\nFamiliesClassical                           FamiliesClassical\nFamily                                      Family\nFamilyImprimitive                           family_imprimitive\nFiniteCoxeterTypeFromCartanMat(m)           type_cartan(m)\nFirstLeftDescending(W,w)                    firstleftdescent(W,w)\nForEachCoxeterWord(W,f)                     for w in W f(word(W,w)) end\nForEachElement(W,f)                         for w in W f(w) end\nFullSymbol                                  fullsymbol\nFundamentalGroup                            fundamental_group\nFusionAlgebra                               fusion_algebra\nFusionConjugacyClasses                      fusion_conjugacy_classes\nGaloisCyc                                   galois\nGarsideAlpha                                Î±\nGarsideWords                                elements\nGcdPartitions                               gcd_partitions\nGcdRepresentation(x,y)                      gcdx(x,y)[2:3]\nGenericOrder                                generic_order\nGenericSign                                 generic_sign\nGetRoot                                     root\nGraphAutomorphisms                          graph_automorphisms\nHasse                                       hasse\nHecke                                       hecke\nHeckeCentralMonomials                       central_monomials\nHeckeCharValues                             char_values\nHeckeClassPolynomials                       class_polynomials\nHeckeReflectionRepresentation               reflrep\nHighestPowerFakeDegreeSymbol                degree_fegsymbol\nHighestPowerFakeDegrees(W)                  charinfo(W)[:B]\nHighestPowerGenericDegreeSymbol             degree_gendeg_symbol\nHighestPowerGenericDegrees(W)               charinfo(W)[:A]\nHyperplaneOrbits                            hyperplane_orbits\nICCTable                                    ICCTable\nIncidence                                   incidence\nIndependentLines(M)                         echelon(M)[2]\nIndependentRoots                            independent_roots\nInducedLinearForm                           induced_linear_form\nInductionTable                              InductionTable\nIntFFE                                      Int\nIntListToString                             joindigits\nIntersection                                intersect\nInvariantForm                               invariant_form\nInvariants                                  invariants\nInversions                                  inversions\nIsAbelian                                   isabelian\nIsCycPol(p)                                 p isa CycPol\nIsFFE(x)                                    x isa FFE\nIsFamily(f)                                 f isa Family\nIsIsolated                                  is_isolated\nIsJoinLattice                               is_join_lattice\nIsLeftDescending(W,w,i)                     isleftdescent(W,w,i)\nIsMeetLattice                               is_meet_lattice\nIsSubset(a,b)                               issubset(b,a)\nIsUnipotentElement(x)                       x isa UnipotentElement\nIsomorphismType                             IsomorphismType\nJInductionTable                             JInductionTable\nJoin                                        join\nKazhdanLusztigPolynomial                    KLPol\nKroneckerProduct                            kron\nLargestMovedPoint                           largest_moved_point\nLcmPartitions                               lcm_partitions\nLeadingCoefficient(p)                       p[end]\nLeftCell                                    LeftCell\nLeftCells                                   LeftCells\nLeftDescentSet(W,w)                         leftdescents(W,w)\nLeftDivisorsSimple                          left_divisors\nLeftGcd                                     leftgcd\nLeftLcm                                     leftlcm\nLinearExtension                             linear_extension\nList(ConjugacyClasses(G),Representative)    classreps(G)\nListBlist(a,b)                              a[b]\nListPerm(p)                                 vec(p)\nLogFFE                                      log\nLongestCoxeterElement(W)                    longest(W)\nLongestCoxeterWord(W)                       word(W,longest(W))\nLowestPowerFakeDegreeSymbol                 valuation_fegsymbol\nLowestPowerFakeDegrees(W)                   charinfo(W)[:b]\nLowestPowerGenericDegreeSymbol              valuation_gendeg_symbol\nLowestPowerGenericDegrees(W)                charinfo(W)[:a]\nLusztigAw                                   LusztigAw\nLusztigInduction                            LusztigInduce\nLusztigInductionTable                       LusztigInductionTable\nLusztigRestriction                          LusztigRestrict\nLusztigaw                                   Lusztigaw\nMappingPermListList                         mappingPerm\nMatStab                                     stab_onmats\nMatXPerm(W,p)                               reflrep(W,p)\nMatYPerm                                    matY\nMovedPoints                                 support\nMvp(\"x\")                                    Mvp(:x)\nNrArrangements                              narrangements\nNrCombinations                              ncombinations\nNrConjugacyClasses                          nconjugacy_classes\nNrDrinfeldDouble                            ndrinfeld_double\nNrPartitionTuples                           npartition_tuples\nNrPartitions                                npartitions\nNrPartitionsSet                             npartitions_set\nOnFamily(f,p::Int)                          galois(f,p)\nOnFamily(f,p::Perm)                         f^p\nOnMatrices(m,p)                             ^(m,p;dims=(1,2))\nOnPolynomials(m,p)                          p^m\nOnSets(s,g)                                 unique!(sort(s.^g))\nOnTuples(l,p)                               l.^p\nOrderFFE                                    order\nOrderMod(n,m)                               order(Mod{m}(n))\nOrderedPartitions                           compositions\nParabolicRepresentatives                    parabolic_reps\nPartBeta                                    partÎ²\nPartition                                   partition\nPartitionTuples                             partition_tuples\nPartitions                                  partitions\nPartitionsSet                               partitions_set\nPermCosetsSubgroup(H,W)                     D=reduced(H,W);map(s->Perm(reduced.(Ref(H),D.*s),D),gens(W))\nPermList(v)                                 Perm(v)\nPermListList(l1,l2)                         Perm(l1,l2)\nPermMatMat                                  Perm_onmats\nPermMatX                                    PermX\nPermutationMat(p,dim)                       Matrix(p,dim)\nPermuted(v,p)                               v^p\nPermutedByCols(m,p)                         ^(m,p;dims=2)\nPoset                                       Poset\nPosition(l,x)                               findfirst(==(x),l)\nPositionCartesian(a,b)                      LinearIndices(reverse(Tuple(a)))[CartesianIndices(Tuple(b))]\nPositionClass                               position_class\nPositionDet                                 charinfo(W)[:positionDet]\nPositionId                                  charinfo(W)[:positionId]\nPositionRegularClass                        position_regular_class\nPresentation                                Presentation\nPrintDiagram(W)                             Diagram(W)\nProportionalityCoefficient(v,w)             ratio(v,w)\nQuasiIsolatedRepresentatives                QuasiIsolatedRepresentatives\nRank                                        rank\nRankSymbol                                  ranksymbol\nReducedCoxeterWord(W,w)                     word(W,W(w...))\nReducedExpressions(W,w)                     words(W,w)\nReducedInRightCoset(W,w)                    reduced(W,w)\nReducedRightCosetRepresentatives(W,H)       reduced(H,W)\nReflection                                  reflection\nReflectionCharacter                         reflchar\nReflectionCoDegrees(W)                      codegrees(W)\nReflectionDegrees(W)                        degrees(W)\nReflectionEigenvalues                       refleigen\nReflectionGroup                             reflection_group\nReflectionLength(W,w)                       reflength(W,w)\nReflectionSubgroup                          reflection_subgroup\nReflectionType                              refltype\nReflections                                 reflections\nRegularEigenvalues                          regular_eigenvalues\nRelativeDegrees                             relative_degrees\nRepresentations                             representations\nRepresentativeConjugation(b,b'[,F][,type])  conjugating_elt(b,b'[,F],ss=type)\nRepresentativeDiagonalConjugation           diagconj_elt\nRepresentativeOperation                     transporting_elt\nRepresentativeRowColPermutation             Perm_rowcolmat\nRestricted                                  restricted\nRestrictedPerm(p,d)                         restricted(p,d)\nReversed                                    reverse\nRightDescentSet(W,w)                        rightdescents(W,w)\nRightGcd                                    rightgcd\nRightLcm                                    rightlcm\nRootDatum                                   rootdatum\nRootsCartan(m)                              roots(m)\nRotation(v,i)                               circshift(v,-i)\nRotations(v)                                circshift.(Ref(v),length(v):-1:1)\nScalMvp                                     scal\nScalarProduct                               scalarproduct\nSchurElements                               schur_elements\nSchurFunctor                                schur_functor\nSemisimpleCentralizerRepresentatives        SScentralizer_reps\nSemisimpleElement                           SS\nSemisimpleRank                              semisimplerank\nSemisimpleRank(W::CoxeterGroup)             coxrank(W)\nSemisimpleSubgroup                          torsion_subgroup\nShiftBeta                                   shiftÎ²\nShrinkGarsideGeneratingSet                  shrink\nSignedMatStab                               sstab_onmats\nSignedPerm                                  SPerm\nSignedPermListList                          SPerm\nSignedPermMatMat                            SPerm_onmats\nSize(W)                                     length(W)\nSmallestMovedPoint                          smallest_moved_point\nSolutionMat                                 solutionmat\nSpecialPieces                               special_pieces\nSpets                                       spets\nSplitLevis                                  split_levis\nStandardParabolic                           standard_parabolic\nStandardParabolicClass                      standard_parabolic_class\nStructureRationalPointsConnectedCentre      StructureRationalPointsConnectedCentre\nSubSpets                                    subspets\nSubTorus                                    SubTorus\nSymbolsDefect(e,r,def,ct)                   symbols(e,r,ct,def)\nSymmetricDifference                         symdiff\nSymmetricPower                              symmetric_power\nTableaux                                    tableaux\nTorus                                       torus\nTorusOrder                                  torus_order\nTransitiveClosure                           transitive_closure\nTransporter                                 transporter\nTriangulizeMat                              echelon!\nTwistings                                   twistings\nTwoTree(m)                                  twotree(m)\nUnipotentAbelianPart                        abelianpart\nUnipotentCharacter                          UniChar\nUnipotentCharacters                         UnipotentCharacters\nUnipotentClasses                            UnipotentClasses\nUnipotentDecompose                          decompose\nUnipotentDegrees(W,q)                       degrees(UnipotentCharacters(W),q)\nUnipotentGroup                              UnipotentGroup\nUnorderedTuples                             submultisets\nValuation(p)                                valuation(p)\nValue(p,x)                                  p(x)\nW.N                                         nref(W)\nW.matgens[i]                                reflrep(W,i)\nW.orbitRepresentative                       simple_reps(W)\nW.orbitRepresentativeElements[i]            simple_conjugating(W,i)\nW.rootInclusion                             inclusion(W)\nW.rootLengths                               rootlengths(W)\nW.rootRestriction                           restriction(W)\nWeightInfo                                  weightinfo\njInductionTable                             jInductionTable\nlast                                        ans","category":"page"}]
}
