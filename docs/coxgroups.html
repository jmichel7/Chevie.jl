<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Coxeter groups ¬∑ Gapjm.jl documentation</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Gapjm.jl documentation</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Gapjm</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Infrastructure</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="sperm.html">Signed permutations</a></li><li><a class="tocitem" href="symbols.html">Symbols</a></li><li><a class="tocitem" href="nf.html">Number fields</a></li><li><a class="tocitem" href="presentations.html">Presentations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Reflection groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="permroot.html">Finite reflection groups</a></li><li class="is-active"><a class="tocitem" href="coxgroups.html">Coxeter groups</a></li><li><a class="tocitem" href="weyl.html">Finite Coxeter groups, Weyl groups, crystallographic root systems</a></li><li><a class="tocitem" href="chars.html">Classes/characters of reflection groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Hecke algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="hecke.html">Hecke algebras</a></li><li><a class="tocitem" href="kl.html">Kazhdan-Lusztig polynomials and bases</a></li><li><a class="tocitem" href="algebras.html">Algebras</a></li></ul></li><li><a class="tocitem" href="garside.html">Garside monoids and groups, braids.</a></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Reductive groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="semisimple.html">Reductive groups, semisimple elements</a></li><li><a class="tocitem" href="cosets.html">Reflection cosets and Spets</a></li><li><a class="tocitem" href="sscoset.html">Non-connected reductive groups</a></li><li><a class="tocitem" href="uch.html">Unipotent characters</a></li><li><a class="tocitem" href="ct.html">Classtypes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Eigenspaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="eigen.html">Eigenspaces</a></li><li><a class="tocitem" href="dseries.html">d-Harish-Chandra series</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Unipotent elements</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="ucl.html">Unipotent classes of reductive groups</a></li><li><a class="tocitem" href="urad.html">Unipotent Elements</a></li></ul></li><li><a class="tocitem" href="gendec.html">Decomposition Matrices</a></li><li><a class="tocitem" href="dict.html">Dictionary from GAP3/Chevie</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reflection groups</a></li><li class="is-active"><a href="coxgroups.html">Coxeter groups</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="coxgroups.html">Coxeter groups</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jmichel7/Gapjm.jl/blob/master/docs/src/coxgroups.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Coxeter-groups"><a class="docs-heading-anchor" href="#Coxeter-groups">Coxeter groups</a><a id="Coxeter-groups-1"></a><a class="docs-heading-anchor-permalink" href="#Coxeter-groups" title="Permalink"></a></h1><ul><li><a href="coxgroups.html#Gapjm.CoxGroups"><code>Gapjm.CoxGroups</code></a></li><li><a href="coxgroups.html#FinitePosets.Poset"><code>FinitePosets.Poset</code></a></li><li><a href="coxgroups.html#Base.length-Tuple{CoxeterGroup, Any}"><code>Base.length</code></a></li><li><a href="coxgroups.html#Gapjm.CoxGroups.bruhatless"><code>Gapjm.CoxGroups.bruhatless</code></a></li><li><a href="coxgroups.html#Gapjm.CoxGroups.coxeter_group-Tuple{AbstractMatrix}"><code>Gapjm.CoxGroups.coxeter_group</code></a></li><li><a href="coxgroups.html#Gapjm.CoxGroups.coxeter_matrix"><code>Gapjm.CoxGroups.coxeter_matrix</code></a></li><li><a href="coxgroups.html#Gapjm.CoxGroups.coxeter_symmetric_group"><code>Gapjm.CoxGroups.coxeter_symmetric_group</code></a></li><li><a href="coxgroups.html#Gapjm.CoxGroups.firstleftdescent"><code>Gapjm.CoxGroups.firstleftdescent</code></a></li><li><a href="coxgroups.html#Gapjm.CoxGroups.isleftdescent-Tuple{CoxSym, Any, Int64}"><code>Gapjm.CoxGroups.isleftdescent</code></a></li><li><a href="coxgroups.html#Gapjm.CoxGroups.isrightdescent"><code>Gapjm.CoxGroups.isrightdescent</code></a></li><li><a href="coxgroups.html#Gapjm.CoxGroups.leftdescents-Tuple{CoxeterGroup, Any}"><code>Gapjm.CoxGroups.leftdescents</code></a></li><li><a href="coxgroups.html#Gapjm.CoxGroups.longest"><code>Gapjm.CoxGroups.longest</code></a></li><li><a href="coxgroups.html#Gapjm.CoxGroups.standard_parabolic_class"><code>Gapjm.CoxGroups.standard_parabolic_class</code></a></li><li><a href="coxgroups.html#Gapjm.PermRoot.cartan-Tuple{CoxSym}"><code>Gapjm.PermRoot.cartan</code></a></li><li><a href="coxgroups.html#Gapjm.PermRoot.cartan-Tuple{AbstractMatrix}"><code>Gapjm.PermRoot.cartan</code></a></li><li><a href="coxgroups.html#Gapjm.PermRoot.reflection_subgroup-Tuple{CoxSym, AbstractVector{Int64}}"><code>Gapjm.PermRoot.reflection_subgroup</code></a></li><li><a href="coxgroups.html#PermGroups.Groups.elements-Tuple{CoxeterGroup, Int64}"><code>PermGroups.Groups.elements</code></a></li><li><a href="coxgroups.html#PermGroups.Groups.word-Tuple{CoxeterGroup, Any}"><code>PermGroups.Groups.word</code></a></li><li><a href="coxgroups.html#PermGroups.Groups.words-Tuple{CoxeterGroup}"><code>PermGroups.Groups.words</code></a></li><li><a href="coxgroups.html#PermGroups.Groups.words-Union{Tuple{T}, Tuple{CoxeterGroup{T}, T}} where T"><code>PermGroups.Groups.words</code></a></li><li><a href="coxgroups.html#PermGroups.reduced"><code>PermGroups.reduced</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups" href="#Gapjm.CoxGroups"><code>Gapjm.CoxGroups</code></a> ‚Äî <span class="docstring-category">Module</span></header><section><div><p>A  suitable  reference  for  the  general  theory of Coxeter groups is, for example, Bourbaki &quot;Lie Groups and Lie Algebras&quot; chapter 4.</p><p>A <em>Coxeter group</em> is a group which has the presentation <span>$W=‚ü®S|(st)^{m(s,t)}=1\text{  for  }s,t‚àà  S‚ü©$</span>  for some symmetric integer matrix <code>m(s,t)</code> called the <em>Coxeter matrix</em>, where <code>m(s,t)&gt;1</code> for <code>s‚â†t</code> and <code>m(s,s)=1</code>;  <code>m(s,t)=‚àû</code> is allowed meaning there is no relation between <code>s</code> and <code>t</code>. It is true (but a non-trivial theorem) that in a Coxeter group the order  of <code>st</code> is exactly  <code>m(s,t)</code>, thus a Coxeter  group is the same as a <em>Coxeter  system</em>, that is a pair <code>(W,S)</code> of a group <code>W</code> and a set <code>S‚äÇW</code> of involutions,  such  that  the  group  is  presented  by  generators <code>S</code> and relations describing the order of the product of two elements of <code>S</code>.</p><p>A   Coxeter   group   has   a   natural   representation,  its  <em>reflection representation</em>, on a real vector space <code>V</code> of dimension <code>length(S)</code> (which is  the  <em>Coxeter  rank</em>  of  W),  where  each  element  of  <code>S</code>  acts as a reflection; the faithfulness of this representation in the main argument to prove  that the order  of <code>st</code> is  exactly <code>m(s,t)</code>. This representation is defined as follows on a space <code>V</code> with basis <code>{e‚Çõ}</code> for <code>s‚àà S</code>. The <em>cartan matrix</em>  associated to the  Coxeter matrix <code>m(s,t)</code>  is the matrix <code>C</code> with entries  <code>C(s,t)=-2cos(œÄ/m(s,t))</code>; we  set <code>C(s,t)=-2</code>  if <code>m(s,t)=‚àû</code>. Then the action of <code>s‚àà S</code> on <code>V</code> is given by <code>s(e‚Çú)=e‚Çú-C(s,t)e‚Çõ</code>.</p><p>Thus, Coxeter groups are  real reflection groups.  The converse need not be true  if the set of reflecting  hyperplanes has bad topological properties, but  it turns out  that finite Coxeter  groups are the  same as finite real reflection  groups. The possible Coxeter matrices for finite Coxeter groups have  been  completely  classified,  see  <a href="weyl.html#Gapjm.Weyl"><code>Weyl</code></a>; the corresponding finite groups play a deep role in several areas of mathematics.</p><p>Coxeter  groups  have  a  nice  solution  to the word problem. The <em>length</em> <code>l(w)</code>  of an element  <code>w‚àà W</code> is  the minimum number  of elements of <code>S</code> of which it is a product (since the elements of <code>S</code> are involutions, we do not need inverses). An expression of <code>w</code> of minimum length is called a <em>reduced word</em>  for <code>w</code>. The main property of  reduced words is the <em>exchange lemma</em> which  states that if <code>s‚ÇÅ‚Ä¶s‚Çñ</code> is a reduced word for <code>w</code> (thus <code>k=l(w)</code>) and <code>s‚àà  S</code> is such that <code>l(sw)‚â§l(w)</code> then one  of the <code>s·µ¢</code> in the word for <code>w</code> can be deleted to obtain a reduced word for <code>sw</code>. Thus given <code>s‚àà S</code> and <code>w‚àà W</code>,  either <code>l(sw)=l(w)+1</code> or <code>l(sw)=l(w)-1</code> and  in the latter case we say that <code>s</code> belongs to the <em>left descent set</em> of <code>w</code>. Computing a reduced word for  an  element,  and  other  word  problems,  are  easy if we know how to multiply elements and know left descent sets. In each of the Coxeter groups that we implement, the left descent set is easy to compute (see for example <a href="coxgroups.html#Gapjm.CoxGroups.coxeter_symmetric_group"><code>coxeter_symmetric_group</code></a> below), so this suggests how to deal with Coxeter groups generically:</p><p>The  type  <code>CoxeterGroup</code>  is  an  abstract  type;  an  actual struct which implements it must define a function</p><p><code>isleftdescent(W,w,i)</code> which tells whether the <code>i</code>-th element of <code>S</code> is in    the left descent set of <code>w</code>.</p><p>the other functions needed in an instance of a Coxeter group are</p><ul><li><code>gens(W)</code> which returns the set <code>S</code> (the list of <em>Coxeter generators</em>)</li><li><code>nref(W)</code> which  returns the  number of  reflections of  <code>W</code>, if  <code>W</code> is  finite or <code>nothing</code> if <code>W</code> is infinite.</li></ul><p>It  should  be  noted  that  a  Coxeter  group  can  be <em>any</em> kind of group implementing the above functions.</p><p>Because  of the  easy solution  of the  word problem  in Coxeter  groups, a convenient  way  to  represent  their  elements  is as words in the Coxeter generators,  that  is  lists  of  integers  in <code>1:length(S)</code>. The functions &#39;word&#39;  and &#39;W(...)&#39; do the conversion between Coxeter words and elements of the group.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; W=coxsym(4)
ùîñ ‚ÇÑ

julia&gt; p=W(1,3,2,1,3)
(1,4)

julia&gt; word(W,p)
5-element Vector{Int64}:
 1
 2
 3
 2
 1</code></pre><p>We  notice that the word we started with and the one that we ended up with, are  not the same, even though they  represent the same element of <code>W</code>. The reason  is that there are several reduced  words for an element of <code>W</code>. The function &#39;word&#39; calculates a lexicographically smallest word for <code>w</code>. Below are some other possible computations using the same Coxeter group:</p><pre><code class="language-julia-repl hljs">julia&gt; word(W,longest(W))  # the (unique) longest element in W
6-element Vector{Int64}:
 1
 2
 1
 3
 2
 1

julia&gt; w0=longest(W)
(1,4)(2,3)

julia&gt; length(W,w0)
6
julia&gt; map(w-&gt;word(W,w),refls(W,1:nref(W)))
6-element Vector{Vector{Int64}}:
 [1]
 [2]
 [3]
 [1, 2, 1]
 [2, 3, 2]
 [1, 2, 3, 2, 1]
julia&gt; [length(elements(W,i)) for i in 0:nref(W)]
7-element Vector{Int64}:
 1
 3
 5
 6
 5
 3
 1</code></pre><p>The  last list tells us that there is 1 element of length 0, there are 6 of length 3, ‚Ä¶</p><p>For  most basic functions the convention is that the input is an element of the  group, rather than a  Coxeter word. The reason  for this is that for a Coxeter  group which is a permutation  group, using the low level functions for   permutations  is   usually  much   faster  than   manipulating  lists representing reduced expressions.</p><p>The only Coxeter group constructors implemented in this module are <code>coxsym</code> and  <code>coxgroup</code>; the last constructor takes  a Cartan matrix and builds the corresponding  Coxeter group as  a matrix group.  The module <a href="weyl.html#Gapjm.Weyl"><code>Weyl</code></a> defines  other methods for <code>coxgroup</code> building  a finite Coxeter group as a permutation group, given its type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/5277c7a48dfa76ff5c56756b6b269ac22b3e43d9/src/CoxGroups.jl#L1-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.isleftdescent-Tuple{CoxSym, Any, Int64}" href="#Gapjm.CoxGroups.isleftdescent-Tuple{CoxSym, Any, Int64}"><code>Gapjm.CoxGroups.isleftdescent</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>isleftdescent(W::CoxeterGroup,w,i::Integer)</code></p><p>returns  <code>true</code> iff the  <code>i</code>-th generating reflection  of the Coxeter group <code>W</code>  is in  the left  descent set  of the  element <code>w</code>  of <code>W</code>, that is iff <code>length(W,W(i)*w)&lt;length(W,w)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxsym(3)
ùîñ ‚ÇÉ

julia&gt; isleftdescent(W,Perm(1,2),1)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/5277c7a48dfa76ff5c56756b6b269ac22b3e43d9/src/CoxGroups.jl#L926-L939">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.isrightdescent" href="#Gapjm.CoxGroups.isrightdescent"><code>Gapjm.CoxGroups.isrightdescent</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p><code>isrightdescent(W::CoxeterGroup,w,i::Integer)</code></p><p>returns  <code>true</code> iff the  <code>i</code>-th generating reflection  of the Coxeter group <code>W</code>  is in the  right descent set  of the element  <code>w</code> of <code>W</code>,  that is iff <code>length(W,w*W(i))&lt;length(W,w)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxsym(3)
ùîñ ‚ÇÉ

julia&gt; isrightdescent(W,Perm(1,2),1)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/5277c7a48dfa76ff5c56756b6b269ac22b3e43d9/src/CoxGroups.jl#L945-L958">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.firstleftdescent" href="#Gapjm.CoxGroups.firstleftdescent"><code>Gapjm.CoxGroups.firstleftdescent</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p><code>firstleftdescent(W,w)</code></p><p>returns the index in <code>gens(W)</code> of the first element of the left descent set of  <code>w</code> ‚Äì- that is, the first  <code>i</code> such that if <code>s=W(i)</code> then <code>l(sw)&lt;l(w). It returns</code>nothing<code>for</code>one(W)`.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxsym(3)
ùîñ ‚ÇÉ

julia&gt; firstleftdescent(W,Perm(2,3))
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/5277c7a48dfa76ff5c56756b6b269ac22b3e43d9/src/CoxGroups.jl#L153-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.leftdescents-Tuple{CoxeterGroup, Any}" href="#Gapjm.CoxGroups.leftdescents-Tuple{CoxeterGroup, Any}"><code>Gapjm.CoxGroups.leftdescents</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>leftdescents(W,w)</code></p><p>The  left descents of the element <code>w</code> of the Coxeter group <code>W</code>, that is the set of <code>i</code> such that <code>length(W,W(i)*w)&lt;length(W,w)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxsym(3)
ùîñ ‚ÇÉ

julia&gt; leftdescents(W,Perm(1,3))
2-element Vector{Int64}:
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/5277c7a48dfa76ff5c56756b6b269ac22b3e43d9/src/CoxGroups.jl#L172-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PermGroups.Groups.word-Tuple{CoxeterGroup, Any}" href="#PermGroups.Groups.word-Tuple{CoxeterGroup, Any}"><code>PermGroups.Groups.word</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>word(W::CoxeterGroup,w)</code></p><p>returns  a reduced word in the standard generators of the Coxeter group <code>W</code> for  the  element  <code>w</code>  (represented  as  the  vector  of the corresponding generator indices).</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A‚ÇÉ

julia&gt; w=perm&quot;(1,11)(3,10)(4,9)(5,7)(6,12)&quot;
(1,11)(3,10)(4,9)(5,7)(6,12)

julia&gt; w in W
true

julia&gt; word(W,w)
5-element Vector{Int64}:
 1
 2
 3
 2
 1</code></pre><p>The  result  of  ¬†<code>word</code>  is  the  lexicographically  smallest reduced word for <code>w</code> (for the ordering of the Coxeter generators given by <code>gens(W)</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/5277c7a48dfa76ff5c56756b6b269ac22b3e43d9/src/CoxGroups.jl#L194-L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{CoxeterGroup, Any}" href="#Base.length-Tuple{CoxeterGroup, Any}"><code>Base.length</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>length(W::CoxeterGroup ,w)</code></p><p>returns the length of a reduced expression in the Coxeter generators of the element <code>w</code> of <code>W</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxsym(4)
ùîñ ‚ÇÑ

julia&gt; p=W(1,2,3,1,2,3)
(1,3)(2,4)

julia&gt; length(W,p)
4

julia&gt; word(W,p)
4-element Vector{Int64}:
 2
 1
 3
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/5277c7a48dfa76ff5c56756b6b269ac22b3e43d9/src/CoxGroups.jl#L232-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.longest" href="#Gapjm.CoxGroups.longest"><code>Gapjm.CoxGroups.longest</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p><code>longest(W)</code></p><p>If  <code>W</code> is  finite, returns  the unique  element of  maximal length  of the Coxeter group <code>W</code>. May loop infinitely otherwise.</p><pre><code class="language-julia-repl hljs">julia&gt; longest(coxsym(4))
(1,4)(2,3)</code></pre><p><code>longest(W,I)</code></p><p>returns  the longest element of the  parabolic subgroup of <code>W</code> generated by the generating reflections of indices in <code>I</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; longest(coxsym(4))
(1,4)(2,3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/5277c7a48dfa76ff5c56756b6b269ac22b3e43d9/src/CoxGroups.jl#L797-L817">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PermGroups.Groups.elements-Tuple{CoxeterGroup, Int64}" href="#PermGroups.Groups.elements-Tuple{CoxeterGroup, Int64}"><code>PermGroups.Groups.elements</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>elements(W::CoxeterGroup[,l])</code></p><p>When  <code>l</code> is  not given  this works  only if  <code>W</code> is finite; it returns the elements of <code>W</code> sorted by increasing Coxeter length. If the second argument is an integer <code>l</code>, the elements of <code>W</code> of Coxeter length <code>l</code> are returned.</p><pre><code class="language-julia_repl hljs">julia&gt; W=coxgroup(:G,2)
G‚ÇÇ

julia&gt; e=elements(W,6)
1-element Vector{Perm{Int16}}:
 (1,7)(2,8)(3,9)(4,10)(5,11)(6,12)

julia&gt; e[1]==longest(W)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/5277c7a48dfa76ff5c56756b6b269ac22b3e43d9/src/CoxGroups.jl#L338-L356">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PermGroups.Groups.words-Union{Tuple{T}, Tuple{CoxeterGroup{T}, T}} where T" href="#PermGroups.Groups.words-Union{Tuple{T}, Tuple{CoxeterGroup{T}, T}} where T"><code>PermGroups.Groups.words</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>words(W::CoxeterGroup,w)</code></p><p>returns  the list  of all  reduced expressions  of the  element <code>w</code>  of the Coxeter group <code>W</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A‚ÇÉ

julia&gt; words(W,longest(W))
16-element Vector{Vector{Int64}}:
 [1, 2, 1, 3, 2, 1]
 [1, 2, 3, 1, 2, 1]
 [1, 2, 3, 2, 1, 2]
 [1, 3, 2, 1, 3, 2]
 [1, 3, 2, 3, 1, 2]
 [2, 1, 2, 3, 2, 1]
 [2, 1, 3, 2, 1, 3]
 [2, 1, 3, 2, 3, 1]
 [2, 3, 1, 2, 1, 3]
 [2, 3, 1, 2, 3, 1]
 [2, 3, 2, 1, 2, 3]
 [3, 1, 2, 1, 3, 2]
 [3, 1, 2, 3, 1, 2]
 [3, 2, 1, 2, 3, 2]
 [3, 2, 1, 3, 2, 3]
 [3, 2, 3, 1, 2, 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/5277c7a48dfa76ff5c56756b6b269ac22b3e43d9/src/CoxGroups.jl#L589-L618">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PermGroups.Groups.words-Tuple{CoxeterGroup}" href="#PermGroups.Groups.words-Tuple{CoxeterGroup}"><code>PermGroups.Groups.words</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>words(W::CoxeterGroup[,l::Integer])</code></p><p>With  one argument this works only if <code>W</code> is finite; it returns the reduced Coxeter  words  of  elements  of  <code>W</code>  by  increasing length. If the second argument  is an integer <code>l</code>, only the  elements of length <code>l</code> are returned; this works for infinite Coxeter groups.</p><pre><code class="language-julia_repl hljs">julia&gt; W=coxgroup(:G,2)
G‚ÇÇ

julia&gt; e=elements(W,6)
1-element Vector{Perm{Int16}}:
 (1,7)(2,8)(3,9)(4,10)(5,11)(6,12)

julia&gt; e[1]==longest(W)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/5277c7a48dfa76ff5c56756b6b269ac22b3e43d9/src/CoxGroups.jl#L417-L436">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.bruhatless" href="#Gapjm.CoxGroups.bruhatless"><code>Gapjm.CoxGroups.bruhatless</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p><code>bruhatless(W, x, y)</code></p><p>whether <code>x‚â§y</code> in the Bruhat order, for <code>x,y‚àà W</code>. We have <code>x‚â§y</code> if a reduced expression  for <code>x</code>  can be  extracted from  one for  <code>w</code>). See  <a href="biblio.htm#Hum90">(5.9) and (5.10) Humphreys1990</a> for properties of the Bruhat order.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:H,3)
H‚ÇÉ

julia&gt; w=W(1,2,1,3);

julia&gt; b=filter(x-&gt;bruhatless(W,x,w),elements(W));

julia&gt; word.(Ref(W),b)
12-element Vector{Vector{Int64}}:
 []
 [1]
 [2]
 [3]
 [1, 2]
 [2, 1]
 [1, 3]
 [2, 3]
 [1, 2, 1]
 [1, 2, 3]
 [2, 1, 3]
 [1, 2, 1, 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/5277c7a48dfa76ff5c56756b6b269ac22b3e43d9/src/CoxGroups.jl#L441-L471">source</a></section><section><div><p><code>bruhatless(W, y)</code></p><p>returns  a vector  whose <code>i</code>-th  element is  the vector  of elements of <code>W</code> smaller for the Bruhat order than <code>w</code> and of Coxeter length <code>i-1</code>. Thus the first  element  of  the  returned  list  contains  only  <code>one(W)</code>  and  the <code>length(W,w)</code>-th element contains only <code>w</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxsym(3)
ùîñ ‚ÇÉ

julia&gt; bruhatless(W,Perm(1,3))
4-element Vector{Vector{Perm{Int16}}}:
 [()]
 [(1,2), (2,3)]
 [(1,2,3), (1,3,2)]
 [(1,3)]</code></pre><p>see also <a href="coxgroups.html#FinitePosets.Poset"><code>Poset</code></a> for Coxeter groups.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/5277c7a48dfa76ff5c56756b6b269ac22b3e43d9/src/CoxGroups.jl#L488-L509">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.coxeter_matrix" href="#Gapjm.CoxGroups.coxeter_matrix"><code>Gapjm.CoxGroups.coxeter_matrix</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p><code>coxeter_matrix(type, rank [,bond])</code> or <code>coxmat</code></p><p>Like <code>cartan</code>, the function <code>coxmat</code> can be defined from the type and rank of a finite Coxeter group.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/5277c7a48dfa76ff5c56756b6b269ac22b3e43d9/src/Weyl.jl#L346-L351">source</a></section><section><div><p><code>coxeter_matrix(m::AbstractMatrix)</code> or <code>coxmat</code></p><p>returns  the  Coxeter  matrix  of  the  Coxeter group defined by the cartan matrix <code>m</code></p><pre><code class="language-julia-repl hljs">julia&gt; C=cartan(:H,3)
3√ó3 Matrix{Cyc{Int64}}:
       2  Œ∂‚ÇÖ¬≤+Œ∂‚ÇÖ¬≥   0
 Œ∂‚ÇÖ¬≤+Œ∂‚ÇÖ¬≥        2  -1
       0       -1   2

julia&gt; coxmat(C)
3√ó3 Matrix{Int64}:
 1  5  2
 5  1  3
 2  3  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/5277c7a48dfa76ff5c56756b6b269ac22b3e43d9/src/CoxGroups.jl#L686-L705">source</a></section><section><div><p><code>coxeter_matrix(W)</code> or <code>coxmat</code></p><p>returns the Coxeter matrix of the Coxeter group <code>W</code>, that is the matrix <code>m</code> whose  entry <code>m[i,j]</code> contains the order of <code>W(i)*W(j)</code> where <code>W(i)</code> is the <code>i</code>-th  Coxeter generator of  <code>W</code>. An infinite  order is represented by the entry <code>0</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxsym(4)
ùîñ ‚ÇÑ

julia&gt; coxmat(W)
3√ó3 Matrix{Int64}:
 1  3  2
 3  1  3
 2  3  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/5277c7a48dfa76ff5c56756b6b269ac22b3e43d9/src/CoxGroups.jl#L722-L740">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.cartan-Tuple{AbstractMatrix}" href="#Gapjm.PermRoot.cartan-Tuple{AbstractMatrix}"><code>Gapjm.PermRoot.cartan</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>cartan(M::AbstractMatrix)</code> Cartan matrix from Coxeter matrix</p><p>The  argument should be the Coxeter matrix  <code>M</code> for a Coxeter group <code>W</code> and the   result  is  the  Cartan  Matrix   <code>C</code>  for  the  standard  reflection representation  of <code>W</code>. We have <code>C[s,t]=-2cos(œÄ/M[s,t])</code>, where <code>M[s,s]==1</code> and  by  convention  <code>œÄ/M[s,t]==0</code>  if  <code>M[s,t]==‚àû</code>,  which we represent by <code>M[s,t]==0</code>.  Since  <code>M</code>  is  symmetric,  the  resulting  <code>C</code> is symmetric, meaning  that all roots  in the constructed  reflection representation have same length.</p><pre><code class="language-julia-repl hljs">julia&gt; cartan([1 3;3 1])
2√ó2 Matrix{Cyc{Int64}}:
  2  -1
 -1   2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/5277c7a48dfa76ff5c56756b6b269ac22b3e43d9/src/Weyl.jl#L208-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.coxeter_symmetric_group" href="#Gapjm.CoxGroups.coxeter_symmetric_group"><code>Gapjm.CoxGroups.coxeter_symmetric_group</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p><code>coxeter_symmetric_group(n::Integer)</code> or <code>coxeter_symmetric_group(m:n)</code> or <code>coxsym</code></p><p>The  symmetric group on the  letters <code>1:n</code> (or if  a <code>m‚â§n</code> is given, on the letters  <code>m:n</code>)  as  a  Coxeter  group.  The  Coxeter  generators  are  the <code>Perm(i,i+1)</code> for <code>i</code> in <code>m:n-1</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxsym(3)
ùîñ ‚ÇÉ

julia&gt; gens(W)
2-element Vector{Perm{Int16}}:
 (1,2)
 (2,3)

julia&gt; e=elements(W)
6-element Vector{Perm{Int16}}:
 ()
 (1,2)
 (2,3)
 (1,3,2)
 (1,2,3)
 (1,3)

julia&gt; length.(Ref(W),e) # length in the genrators of the elements
6-element Vector{Int64}:
 0
 1
 1
 2
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/5277c7a48dfa76ff5c56756b6b269ac22b3e43d9/src/CoxGroups.jl#L850-L884">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.reflection_subgroup-Tuple{CoxSym, AbstractVector{Int64}}" href="#Gapjm.PermRoot.reflection_subgroup-Tuple{CoxSym, AbstractVector{Int64}}"><code>Gapjm.PermRoot.reflection_subgroup</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>reflection_subgroup(W::CoxSym,I)</code></p><p>The only reflection subgroups defined for <code>coxsym(n)</code> are for <code>I=1:m</code> for <code>m‚â§n</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/5277c7a48dfa76ff5c56756b6b269ac22b3e43d9/src/CoxGroups.jl#L971-L975">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.PermRoot.cartan-Tuple{CoxSym}" href="#Gapjm.PermRoot.cartan-Tuple{CoxSym}"><code>Gapjm.PermRoot.cartan</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>cartan(W::CoxeterGroup)</code>  The Cartan matrix of <code>W</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/5277c7a48dfa76ff5c56756b6b269ac22b3e43d9/src/CoxGroups.jl#L964-L966">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PermGroups.reduced" href="#PermGroups.reduced"><code>PermGroups.reduced</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p><code>reduced(W,w)</code></p><p>The  unique element of  minimal length in  the coset W.w.  This makes sense when  <code>isleftdescent(W,u)</code> makes sense for <code>u‚àà  W.w</code> which happens when <code>w</code> is  a Coxeter automorphism of <code>W</code> or  when <code>w</code> lives in a Coxeter overgroup of <code>W</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
G‚ÇÇ

julia&gt; H=reflection_subgroup(W,[2,6])
G‚ÇÇ‚Çç‚ÇÇ‚ÇÜ‚Çé=AÃÉ‚ÇÅ√óA‚ÇÅ

julia&gt; word.(Ref(W),unique(reduced.(Ref(H),elements(W))))
3-element Vector{Vector{Int64}}:
 []
 [1]
 [1, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/5277c7a48dfa76ff5c56756b6b269ac22b3e43d9/src/CoxGroups.jl#L259-L280">source</a></section><section><div><p><code>reduced(H::CoxeterGroup,W::CoxeterGroup,i=nref(W))</code></p><p>The  elements <code>w‚àà W</code> which are <code>H</code>-reduced, and of length <code>‚â§i</code> (by default all of them), grouped by length.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
G‚ÇÇ

julia&gt; H=reflection_subgroup(W,[2,6])
G‚ÇÇ‚Çç‚ÇÇ‚ÇÜ‚Çé=AÃÉ‚ÇÅ√óA‚ÇÅ

julia&gt; [word(W,w) for S in reduced(H,W) for w in S]
3-element Vector{Vector{Int64}}:
 []
 [1]
 [1, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/5277c7a48dfa76ff5c56756b6b269ac22b3e43d9/src/CoxGroups.jl#L289-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.standard_parabolic_class" href="#Gapjm.CoxGroups.standard_parabolic_class"><code>Gapjm.CoxGroups.standard_parabolic_class</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p><code>standard_parabolic_class(W,I)</code></p><p><code>I</code>  should be a  subset of <code>eachindex(gens(W))</code>.  The function returns the list of such subsets <code>W</code>-conjugate to <code>I</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; CoxGroups.standard_parabolic_class(coxgroup(:E,8),[7,8])
7-element Vector{Vector{Int64}}:
 [7, 8]
 [6, 7]
 [5, 6]
 [4, 5]
 [2, 4]
 [3, 4]
 [1, 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/5277c7a48dfa76ff5c56756b6b269ac22b3e43d9/src/CoxGroups.jl#L654-L671">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gapjm.CoxGroups.coxeter_group-Tuple{AbstractMatrix}" href="#Gapjm.CoxGroups.coxeter_group-Tuple{AbstractMatrix}"><code>Gapjm.CoxGroups.coxeter_group</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>coxeter_group(m)</code> or <code>coxgroup(m)</code></p><p><code>m</code>  should be a square  matrix of real cyclotomic  numbers. It returns the Coxeter  group  whose  Cartan  matrix  is  <code>m</code>.  This is a matrix group <code>W</code> constructed  as  follows.  Let  <code>V</code>  be  a  real  vector space of dimension <code>size(m,1)</code>, let <code>e·µ¢</code> be the canonical basis of <code>V</code>. Then <code>W</code> is the matrix group generated by the reflections <code>s·µ¢(e‚±º)=e‚±º-m·µ¢‚±º e·µ¢</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup([2 -2;-2 2])
coxeter_group([2 -2; -2 2])</code></pre><p>Above is a way to construct the affine Weyl group  <code>AÃÉ‚ÇÅ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/5277c7a48dfa76ff5c56756b6b269ac22b3e43d9/src/CoxGroups.jl#L991-L1006">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinitePosets.Poset" href="#FinitePosets.Poset"><code>FinitePosets.Poset</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p><code>Poset(W::CoxeterGroup,w=longest(W))</code></p><p>returns  as a poset the Bruhat interval <code>[1,w]</code>of <code>W</code>. If <code>w</code> is not given, the whole Bruhat Poset of <code>W</code> is returned (<code>W</code> must then be finite).</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxsym(3)
ùîñ ‚ÇÉ

julia&gt; Poset(W)
.&lt;1,2&lt;21,12&lt;121</code></pre><p>The  above  poset  is  constructed  efficiently  by  constructing the Hasse diagram, but it could be constructed naively as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; p=Poset((x,y)-&gt;bruhatless(W,x,y),elements(W))
()&lt;(1,2),(2,3)&lt;(1,3,2),(1,2,3)&lt;(1,3)</code></pre><p>The  output is not so nice, showing permutations instead of words. This can be fixed by defining:</p><pre><code class="language-julia-repl hljs">julia&gt; p.show_element=(io,x,n)-&gt;join(io,word(W,x.elements[n]));

julia&gt; p
&lt;1,2&lt;12,21&lt;121

julia&gt; W=coxsym(4)
ùîñ ‚ÇÑ

julia&gt; Poset(W,W(1,3))
.&lt;3,1&lt;13</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Gapjm.jl/blob/5277c7a48dfa76ff5c56756b6b269ac22b3e43d9/src/CoxGroups.jl#L521-L554">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="permroot.html">¬´ Finite reflection groups</a><a class="docs-footer-nextpage" href="weyl.html">Finite Coxeter groups, Weyl groups, crystallographic root systems ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 14 September 2023 19:33">Thursday 14 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
