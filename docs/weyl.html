<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Finite Coxeter groups, Weyl groups, crystallographic root systems · Chevie.jl documentation</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Chevie.jl documentation</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Chevie</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Infrastructure</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="format.html">formatting facilities</a></li><li><a class="tocitem" href="symbols.html">Symbols</a></li><li><a class="tocitem" href="nf.html">Number fields</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Reflection groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="permroot.html">Finite reflection groups</a></li><li><a class="tocitem" href="coxgroups.html">Coxeter groups</a></li><li class="is-active"><a class="tocitem" href="weyl.html">Finite Coxeter groups, Weyl groups, crystallographic root systems</a></li><li><a class="tocitem" href="chars.html">Classes/characters of reflection groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Hecke algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="hecke.html">Hecke algebras</a></li><li><a class="tocitem" href="kl.html">Kazhdan-Lusztig polynomials and bases</a></li><li><a class="tocitem" href="algebras.html">Algebras</a></li></ul></li><li><a class="tocitem" href="garside.html">Garside monoids and groups, braids.</a></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Reductive groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="semisimple.html">Reductive groups, semisimple elements</a></li><li><a class="tocitem" href="cosets.html">Reflection cosets and Spets</a></li><li><a class="tocitem" href="sscoset.html">Non-connected reductive groups</a></li><li><a class="tocitem" href="uch.html">Unipotent characters</a></li><li><a class="tocitem" href="ct.html">Classtypes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Eigenspaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="eigen.html">Eigenspaces</a></li><li><a class="tocitem" href="dseries.html">d-Harish-Chandra series</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Unipotent elements</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="ucl.html">Unipotent classes of reductive groups</a></li><li><a class="tocitem" href="urad.html">Unipotent Elements</a></li></ul></li><li><a class="tocitem" href="gendec.html">Decomposition Matrices</a></li><li><a class="tocitem" href="dict.html">Dictionary from GAP3/Chevie</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reflection groups</a></li><li class="is-active"><a href="weyl.html">Finite Coxeter groups, Weyl groups, crystallographic root systems</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="weyl.html">Finite Coxeter groups, Weyl groups, crystallographic root systems</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jmichel7/Chevie.jl/blob/master/docs/src/weyl.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Finite-Coxeter-groups,-Weyl-groups,-crystallographic-root-systems"><a class="docs-heading-anchor" href="#Finite-Coxeter-groups,-Weyl-groups,-crystallographic-root-systems">Finite Coxeter groups, Weyl groups, crystallographic root systems</a><a id="Finite-Coxeter-groups,-Weyl-groups,-crystallographic-root-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-Coxeter-groups,-Weyl-groups,-crystallographic-root-systems" title="Permalink"></a></h1><ul><li><a href="weyl.html#Chevie.Weyl"><code>Chevie.Weyl</code></a></li><li><a href="weyl.html#Chevie.CoxGroups.coxeter_group"><code>Chevie.CoxGroups.coxeter_group</code></a></li><li><a href="weyl.html#Chevie.CoxGroups.coxeter_group-Tuple{}"><code>Chevie.CoxGroups.coxeter_group</code></a></li><li><a href="weyl.html#Chevie.CoxGroups.inversions"><code>Chevie.CoxGroups.inversions</code></a></li><li><a href="weyl.html#Chevie.PermRoot.cartan-Tuple{Symbol, Integer, Integer}"><code>Chevie.PermRoot.cartan</code></a></li><li><a href="weyl.html#Chevie.PermRoot.radical"><code>Chevie.PermRoot.radical</code></a></li><li><a href="weyl.html#Chevie.PermRoot.reflection_subgroup-Tuple{Chevie.Weyl.FCG, AbstractVector{&lt;:Integer}}"><code>Chevie.PermRoot.reflection_subgroup</code></a></li><li><a href="weyl.html#Chevie.PermRoot.roots-Tuple{AbstractMatrix}"><code>Chevie.PermRoot.roots</code></a></li><li><a href="weyl.html#Chevie.Semisimple.affine"><code>Chevie.Semisimple.affine</code></a></li><li><a href="weyl.html#Chevie.Weyl.badprimes"><code>Chevie.Weyl.badprimes</code></a></li><li><a href="weyl.html#Chevie.Weyl.derived_datum"><code>Chevie.Weyl.derived_datum</code></a></li><li><a href="weyl.html#Chevie.Weyl.describe_involution"><code>Chevie.Weyl.describe_involution</code></a></li><li><a href="weyl.html#Chevie.Weyl.highest_short_root"><code>Chevie.Weyl.highest_short_root</code></a></li><li><a href="weyl.html#Chevie.Weyl.istorus"><code>Chevie.Weyl.istorus</code></a></li><li><a href="weyl.html#Chevie.Weyl.relative_group"><code>Chevie.Weyl.relative_group</code></a></li><li><a href="weyl.html#Chevie.Weyl.rootdatum-Tuple{AbstractMatrix, AbstractMatrix}"><code>Chevie.Weyl.rootdatum</code></a></li><li><a href="weyl.html#Chevie.Weyl.rootdatum-Tuple{AbstractMatrix}"><code>Chevie.Weyl.rootdatum</code></a></li><li><a href="weyl.html#Chevie.Weyl.rootlengths"><code>Chevie.Weyl.rootlengths</code></a></li><li><a href="weyl.html#Chevie.Weyl.standard_parabolic-Tuple{Union{Chevie.Weyl.FCG, Chevie.Weyl.FCSG}, AbstractVector{&lt;:Integer}}"><code>Chevie.Weyl.standard_parabolic</code></a></li><li><a href="weyl.html#Chevie.Weyl.torus-Tuple{Integer}"><code>Chevie.Weyl.torus</code></a></li><li><a href="weyl.html#Chevie.Weyl.two_tree"><code>Chevie.Weyl.two_tree</code></a></li><li><a href="weyl.html#Chevie.Weyl.with_inversions"><code>Chevie.Weyl.with_inversions</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Chevie.Weyl" href="#Chevie.Weyl"><code>Chevie.Weyl</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Finite Coxeter groups are the finite complex reflection groups which can be defined on a real vector space <code>V</code>.</p><p><em>Weyl  groups</em> are the  finite Coxeter groups  which can be  defined over a rational vector space <code>V</code> (thus over the integers).</p><p>Like   finite  complex   reflection  groups,   finite  Coxeter  groups  are implemented  as groups  of permutations  of a  set of roots. The particular <em>crystallographic</em>  root systems for Weyl groups  play an important role in mathematics as they classify semi-simple Lie algebras and algebraic groups.</p><p>Let  us give precise definitions.  Let <code>V</code> be a  real vector space and <code>Vⱽ</code> its  dual. A <em>root system</em> is a finite set of vectors <code>R⊂ V</code> (the <em>roots</em>), together  with  a  map  <code>r↦  rⱽ</code>  from  <code>R</code>  to  a subset <code>Rⱽ</code> of <code>Vⱽ</code> (the <em>coroots</em>) such that:</p><ul><li>For any <code>r∈ R</code>,  we have <code>rⱽ(r)=2</code>, so  that the formula <code>x↦ x-rⱽ(x)r</code> defines  a  reflection  <code>sᵣ:V→  V</code>  with  root  <code>r</code>  and coroot <code>rⱽ</code>.</li><li>The reflection <code>sᵣ</code> stabilizes <code>R</code>.</li></ul><p>The  subgroup <code>W=W(R)</code> of <code>GL(V)</code> generated by the reflections <code>sᵣ</code> for <code>r∈ R</code>  is a finite Coxeter  group. We require <em>reduced</em>  root systems, that is such  that the only elements of <code>R</code> colinear  with <code>r∈ R</code> are <code>r</code> and <code>-r</code>; for Weyl groups, we also require that the root system be <em>crystallographic</em>, that is <code>rⱽ(s)</code> is an integer, for any <code>s∈ R,rⱽ∈ Rⱽ</code>.</p><p>If  we identify  <code>V</code> with  <code>Vⱽ</code> by  choosing a  <code>W</code>-invariant bilinear form <code>(.;.)</code>,  then we have <code>rⱽ=2r/(r;r)</code>. A root system <code>R</code> is <em>irreducible</em> if <code>R</code>   is  not  the  union  of  two  orthogonal  subsets;  equivalently  the representation  of <code>W</code> on the subspace  generated by <code>R</code> is irreducible. If <code>R</code> is reducible then the corresponding Coxeter group is the direct product of the Coxeter groups associated with the irreducible components of <code>R</code>.</p><p>Let  us  now  describe  how  a  root  system  <code>R</code> and a presentation of the corresponding  <code>W</code> are encoded in  a Cartan matrix or  a Dynkin diagram. We can  choose a linear  form on <code>V</code>  which does not  vanish on any element of <code>R</code>.  Depending on the sign of the value of this linear form on a root <code>r ∈ R</code>  we call <code>r</code> <em>positive</em> or <em>negative</em>. Then there exists a unique subset <code>Π</code>  of the positive roots, the <em>simple roots</em>, such that any positive root is a linear combination with non-negative coefficients of the roots in <code>Π</code>. Any  two sets of simple roots (corresponding to different choices of linear forms) can be transformed into each other by a unique element of <code>W(R)</code>. If <code>S</code>  is  the  set  of  reflections  with  respect to the simple roots, then <code>(W,S)</code>  is  a  Coxeter  system.  These  generating  reflections are called <em>Coxeter generators</em> or <em>simple reflections</em>.</p><p>Since the pairing between <code>V</code> and <code>Vⱽ</code> is <code>W</code>-invariant, if <code>Π</code> is a set of simple  roots and if we  define the <em>Cartan matrix</em>  as being the <code>n</code> times <code>n</code>  matrix <code>C={rⱽ(r&#39;)}</code>  for <code>r,r&#39;∈Π</code>,  this matrix  is independent of the chosen  linear form  up to  simultaneous permutation  of rows  and columns. Since the action of <code>sᵣ</code> on <code>r&#39;</code> for <code>r,r&#39;∈Π</code> is given by <code>sᵣ(r&#39;)=r&#39;-C(r,r&#39;)r</code>,   the   Cartan   matrix   determines  the  reflection representation of <code>W</code>.</p><p>For  a crystallographic root system the Cartan matrix has integral entries, and  in the basis <code>Π</code> (completed by a basis of the orthogonal), <code>sᵣ</code> has an integral  matrix.  All  finite-dimensional  (complex)  representations of a finite  Coxeter  group  can  be  realized  over  the field generated by the entries of the Cartan matrix.</p><p>The  Cartan matrix is encoded  in a <em>Dynkin diagram</em>,  a tree with weighted edges  and  an  orientation  on  edges  of  even weight &gt;2, as follows. The vertices are indexed by the simple reflections; an edge is drawn between <code>s</code> and <code>t</code> if the order <code>mₛₜ</code> of <code>st</code> is greater than <code>2</code> and is given the weight  <code>mₛₜ</code>. These  weights are  encoded by  drawing the  edge single for weight  3, double for weight 4 and triple for weight 6. The arrows indicate the relative root lengths (going from the longer to the shorter root) which may  differ between different orbits of  <code>W</code> on <code>R</code>. Alternately the Dynkin diagram  can be obtained  from the Cartan  matrix as follows:  if <code>Cᵣₛ</code> and <code>Cₛᵣ</code>  are integers  such that  <code>|Cₛᵣ|≥|Cᵣₛ|=1</code> there  is an edge of weight <code>|Cₛᵣ|</code>  from <code>r</code> to <code>s</code>  with an arrow pointing  to <code>s</code> if <code>|Cₛᵣ|&gt;1</code>. Note that  the Cartan matrices  we consider here  are not necessarily symmetric, contrary  to the  Cartan matrices  we considered  describing the reflection representation  of a general Coxeter  group; being symmetric corresponds to all roots being taken of the same length.</p><p>The  irreducible  crystallographic  root  systems  are  classified  by  the following  list of Dynkin diagrams. The labeling  of the nodes is the order of the generators and is shown by the function <code>diagram</code>.</p><pre><code class="nohighlight hljs">Aₙ O—O—O—…—O   Bₙ O⇐ O—O—…—O  Cₙ O⇒ O—O—…—O  Dₙ O 2
   1 2 3 … n      1  2 3 … n     1  2 3 … n     ￨
                                              O—O—…—O
                                              1 3 … n

G₂ O⇛ O  F₄ O—O⇒O—O    E₆  O 2    E₇  O 2      E₈  O 2
   1  2     1 2 3 4        ￨          ￨            ￨
                       O—O—O—O—O  O—O—O—O—O—O  O—O—O—O—O—O—O
                       1 3 4 5 6  1 3 4 5 6 7  1 3 4 5 6 7 8</code></pre><p>We get the <em>Coxeter diagram</em>, which describes the underlying Weyl group, if we  ignore  the  arrows:  we  see  that  the  root  systems <code>B_n</code> and <code>C_n</code> correspond to the same Coxeter group (the Coxeter diagram is defined by the <em>Coxeter  matrix</em>). Weyl  groups can  also be  characterized as  the finite Coxeter groups such that all off-diagonal entries of the Coxeter matrix are in <code>{2,3,4,6}</code>.</p><p>Here  are the Coxeter diagrams for the  finite Coxeter groups which are not crystallographic (<code>I₂(e)</code> is not crystallographic if <code>e∉ {2,3,4,6}</code>).</p><pre><code class="nohighlight hljs">       e        5         5
I₂(e) O—O   H₃ O—O—O  H₄ O—O—O—O
      1 2      1 2 3     1 2 3 4</code></pre><p>The function <code>cartan</code> gives the cartan matrix for an irreducible root system</p><pre><code class="language-julia-repl hljs">julia&gt; cartan(:D,4)
4×4 Matrix{Int64}:
  2   0  -1   0
  0   2  -1   0
 -1  -1   2  -1
  0   0  -1   2

julia&gt; cartan(:I,2,5) # for type I₂(e) give e as 3rd argument
2×2 Matrix{Cyc{Int64}}:
       2  ζ₅²+ζ₅³
 ζ₅²+ζ₅³        2</code></pre><p>Given   two  Cartan  matrices  <code>c1</code>  and  <code>c2</code>,  their  matrix  direct  sum (corresponding  to the  orthogonal direct  sum of  the root systems) can be obtained by <code>cat(c1,c2,dims=[1,2])</code>.</p><p>The  whole  root  system  can  be  recovered  from the simple roots and the corresponding  coroots, since each root  is in the orbit  of a simple root. The  restriction of the simple reflections to the span of <code>R</code> is determined by the Cartan matrix, so <code>R</code> is determined by the Cartan matrix and the set of simple roots.</p><p>The  function  <code>rootdatum</code>  takes  as  arguments  a  matrix <code>r</code> whose lines represents the list of simple roots and another matrix <code>cr</code> whose lines are the  corresponding  coroots  and  produces  a <code>FiniteCoxeterGroup</code>. Such an object  is a permutation group containing  in addition the description of a root  system. <code>cr*transpose(r)</code> should be a  Cartan matrix. Each element of the  coxeter  group  is  represented  as  the permutation it induces on the roots,  coded as a permutation of <code>1:2N</code>  where we label the positive roots by <code>1:N</code>, and the negative roots by <code>N+1:2N</code>.</p><p>If a single matrix argument is given to <code>rootdatum</code> it is taken as <code>cr</code> and <code>r</code>  is taken  to be  the identity  matrix; we  get thus  a particular root system  where the  roots are  the canonical  basis of <code>V</code>. For convenience, <code>rootdatum(cartan(t...))</code> can be simplified to <code>coxgroup(t...)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:D,4) # same as rootdatum(cartan(:D,4))
D₄

julia&gt; cartan(W)
4×4 Matrix{Int64}:
  2   0  -1   0
  0   2  -1   0
 -1  -1   2  -1
  0   0  -1   2</code></pre><p>Also,  the <code>FiniteCoxeterGroup</code> associated to a direct sum of irreducible root systems can be obtained as</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,2)*coxgroup(:B,2)
A₂×B₂

julia&gt; cartan(W) # same as cat(cartan(:A,2), cartan(:B,2),dims=[1,2])
4×4 Matrix{Int64}:
  2  -1   0   0
 -1   2   0   0
  0   0   2  -2
  0   0  -1   2</code></pre><p>The elements of a Weyl group are permutations of the roots:</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:D,4)
D₄

julia&gt; p=W(1,3,2,1,3) # permutes the 24 roots
(1,14,13,2)(3,17,8,18)(4,12)(5,20,6,15)(7,10,11,9)(16,24)(19,22,23,21)

julia&gt; word(W,p)
5-element Vector{Int64}:
 1
 3
 1
 2
 3</code></pre><p>finally, a benchmark on julia 1.0.2</p><pre><code class="language-benchmark hljs">julia&gt; @btime length(elements(coxgroup(:E,7)))
  531.385 ms (5945569 allocations: 1.08 GiB)</code></pre><p>GAP3 for the same computation takes 2.2s</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/ba0f39da137d91b021b7995080791755084d9a52/src/Weyl.jl#L1-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.PermRoot.cartan-Tuple{Symbol, Integer, Integer}" href="#Chevie.PermRoot.cartan-Tuple{Symbol, Integer, Integer}"><code>Chevie.PermRoot.cartan</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>cartan(type, rank [,bond])</code></p><p>the  Cartan matrix for a  finite Coxeter group described  by type and rank. The  recognized types are <code>:A, :B, :Bsym, :C, :D, :E, :F, :Fsym, :G, :Gsym, :I,  :H</code>. For type <code>:I</code> a third  argument must be given describing the bond between the two generators. The <code>sym</code> types correspond to (non-crystallographic)  root systems where all  roots have the same length; they  afford automorphisms that  the crystallographic root  system does not afford, which allow to define the &quot;very twisted&quot; Chevalley groups.</p><pre><code class="language-julia-repl hljs">julia&gt; cartan(:F,4)
4×4 Matrix{Int64}:
  2  -1   0   0
 -1   2  -1   0
  0  -2   2  -1
  0   0  -1   2

julia&gt; cartan(:I,2,5)
2×2 Matrix{Cyc{Int64}}:
       2  ζ₅²+ζ₅³
 ζ₅²+ζ₅³        2

julia&gt; cartan(:Bsym,2)
2×2 Matrix{Cyc{Int64}}:
   2  -√2
 -√2    2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/ba0f39da137d91b021b7995080791755084d9a52/src/Weyl.jl#L307-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.PermRoot.roots-Tuple{AbstractMatrix}" href="#Chevie.PermRoot.roots-Tuple{AbstractMatrix}"><code>Chevie.PermRoot.roots</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>roots(C::AbstractMatrix)</code></p><p>returns the set of positive roots defined by the Cartan matrix <code>C</code>, which should be the Cartan matrix of a finite Coxeter group.</p><p>For  an integer Cartan matrix, the returned  roots are sorted by height and reverse lexicographically for a given height.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/ba0f39da137d91b021b7995080791755084d9a52/src/Weyl.jl#L469-L477">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Weyl.two_tree" href="#Chevie.Weyl.two_tree"><code>Chevie.Weyl.two_tree</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>two_tree(m)</code></p><p>Given  a  square  matrix  <code>m</code>  with  zeroes  symmetric  with respect to the diagonal,  let  <code>G</code>  be  the  graph  with vertices <code>axes(m)[1]</code> and an edge between <code>i</code> and <code>j</code> iff <code>!iszero(m[i,j])</code>.</p><p>If  <code>G</code> is a line this function returns  it as a <code>Vector{Int}</code>. If <code>G</code> is a tree with one vertex <code>c</code> of valence <code>3</code> the function returns <code>(c,b1,b2,b3)</code> where  <code>b1,b2,b3</code> are  the branches  from this  vertex sorted by increasing length. Otherwise the function returns <code>nothing</code>.</p><p>This function is used when recognizing the type of a Cartan matrix.</p><pre><code class="language-julia-repl hljs">julia&gt; two_tree(cartan(:A,4))
4-element Vector{Int64}:
 1
 2
 3
 4

julia&gt; two_tree(cartan(:E,8))
(4, [2], [3, 1], [5, 6, 7, 8])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/ba0f39da137d91b021b7995080791755084d9a52/src/Weyl.jl#L352-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.PermRoot.reflection_subgroup-Tuple{Chevie.Weyl.FCG, AbstractVector{&lt;:Integer}}" href="#Chevie.PermRoot.reflection_subgroup-Tuple{Chevie.Weyl.FCG, AbstractVector{&lt;:Integer}}"><code>Chevie.PermRoot.reflection_subgroup</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>reflection_subgroup(W::FiniteCoxeterGroup,I)</code></p><p>For <code>I⊆1:nref(W)</code>, the subgroup <code>H</code> of <code>W</code> generated by <code>refls(W,I)</code>.</p><p>A   theorem  found  independently  by  <a href="biblio.htm#Deo89">Deodhar1989</a>  and <a href="biblio.htm#Dye90">Dyer1990</a>  is that  a subgroup  <code>H</code> of  a Coxeter system <code>(W,S)</code>  generated by reflections  has a canonical  Coxeter generating set, formed  of the <code>t  ∈ Ref(H)</code> such  <code>length(W,tt&#39;)&gt;length(W,t)</code> for any <code>t&#39;∈ Ref(H)</code>  different  from  <code>t</code>.  This  is  used  by <code>reflection_subgroup</code> to determine the Coxeter system of <code>H</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; diagram(W)
O⇛ O G₂
1  2

julia&gt; H=reflection_subgroup(W,[2,6])
G₂₍₂₆₎=Ã₁×A₁

julia&gt; diagram(H)
O Ã₁
1
O A₁
2</code></pre><p>The  notation <code>G₂₍₂₆₎</code>  means that  <code>roots(W,[2,6])</code> is  a system of simple roots for <code>H</code>.</p><p>If  <code>H</code> is a  standard parabolic subgroup  of a Coxeter  group <code>W</code> then the length  function on  <code>H</code> (with  respect to  its set  of generators)  is the restriction  of the length function on <code>W</code>. This need not no longer be true for  arbitrary reflection subgroups of  <code>W</code>. </p><pre><code class="language-julia-repl hljs">julia&gt; elH=word.(Ref(H),elements(H))
4-element Vector{Vector{Int64}}:
 []
 [1]
 [2]
 [1, 2]

julia&gt; elW=word.(Ref(W),elements(H))
4-element Vector{Vector{Int64}}:
 []
 [2]
 [1, 2, 1, 2, 1]
 [1, 2, 1, 2, 1, 2]

julia&gt; map(w-&gt;H(w...),elH)==map(w-&gt;W(w...),elW)
true</code></pre><p>We  implement finite  reflection groups  as permutation  groups on a set of roots.  Consequently,  a  reflection  subgroup  <code>H⊆  W</code>  is  a  permutation subgroup, thus its elements are represented as permutations of the roots of the parent group.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/ba0f39da137d91b021b7995080791755084d9a52/src/Weyl.jl#L1025-L1084">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.CoxGroups.coxeter_group" href="#Chevie.CoxGroups.coxeter_group"><code>Chevie.CoxGroups.coxeter_group</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>coxeter_group(type,rank[,bond];sc=false)</code> (or <code>coxgroup</code>)</p><p>If <code>C=cartan(type,rank[,bond])</code>, this is equivalent to <code>rootdatum(C)</code>. If <code>sc=true</code> this is equivalent to <code>rootdatum(permutedims(C),one(C))</code>.</p><p>The  resulting object <code>W</code>, a  <code>FiniteCoxeterGroup</code>, has an additional entry compared to a <code>PermRootGroup</code>.</p><ul><li><code>W.rootdec</code>:  the root vectors, given  as linear combinations of simple roots.  The first <code>nref(W)</code> roots are  positive, the next <code>nref(W)</code> are the corresponding negative roots. Moreover, the first <code>semisimplerank(W)</code>  roots are the simple roots. The positive roots are ordered by increasing height.</li></ul><p>and <code>roots(W)</code> is ordered is the same way as <code>W.rootdec</code>.</p><p>For  how to  get various  information on  the root  system and  the Coxeter group,   see  the  functions   <code>nref,  coroots,  rootlengths,  simple_reps, simple_conjugating,  reflrep,  simpleroots,  simplecoroots,  PermX, cartan, inclusion, restriction, action, rank, semisimplerank</code></p><p>In terms of root data, this function returns the adjoint root datum of Weyl group  <code>W</code>.  If  <code>sc=true</code>  it  returns  the  simply  connected root datum.</p><pre><code class="language-julia_repl hljs">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; cartan(W)
2×2 Matrix{Int64}:
  2  -1
 -3   2

julia&gt; W.rootdec
12-element Vector{Vector{Int64}}:
 [1, 0]
 [0, 1]
 [1, 1]
 [1, 2]
 [1, 3]
 [2, 3]
 [-1, 0]
 [0, -1]
 [-1, -1]
 [-1, -2]
 [-1, -3]
 [-2, -3]

julia&gt; reflrep(W)
2-element Vector{Matrix{Int64}}:
 [-1 0; 1 1]
 [1 3; 0 -1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/ba0f39da137d91b021b7995080791755084d9a52/src/Weyl.jl#L760-L813">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.CoxGroups.coxeter_group-Tuple{}" href="#Chevie.CoxGroups.coxeter_group-Tuple{}"><code>Chevie.CoxGroups.coxeter_group</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>coxeter_group()</code> or <code>coxgroup()</code> the trivial Coxeter group</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/ba0f39da137d91b021b7995080791755084d9a52/src/Weyl.jl#L895">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Weyl.rootlengths" href="#Chevie.Weyl.rootlengths"><code>Chevie.Weyl.rootlengths</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>rootlengths(W::FiniteCoxeterGroup)</code>  the vector  of the (squared)  length of the roots of <code>W</code>.  The  shortest roots in an irreducible subsystem are given the length 1. In  a Weyl group the others then have length 2 (or 3 in type <code>G₂</code>). The matrix  of the <code>W</code>-invariant bilinear form is given by  <code>Diagonal(rootlengths(W)[1:ngens(W)])*cartan(W)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/ba0f39da137d91b021b7995080791755084d9a52/src/Weyl.jl#L926-L933">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Weyl.highest_short_root" href="#Chevie.Weyl.highest_short_root"><code>Chevie.Weyl.highest_short_root</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>highest_short_root(W)</code></p><p>It  is  an  error  if  <code>W</code>  is  not an irreducible Coxeter group. Otherwise <code>HighestShortRoot</code>  returns the index  of the unique  short root of maximal height  of <code>W</code>. If all roots have the same length then this is the index of the unique root of maximal height, equal to <code>nref(W)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:G,2)
G₂

julia&gt; highest_short_root(W)
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/ba0f39da137d91b021b7995080791755084d9a52/src/Weyl.jl#L954-L969">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Weyl.rootdatum-Tuple{AbstractMatrix}" href="#Chevie.Weyl.rootdatum-Tuple{AbstractMatrix}"><code>Chevie.Weyl.rootdatum</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>rootdatum(C::AbstractMatrix)</code>  adjoint root datum  from Cartan matrix <code>C</code>. It  is the  same as  <code>rootdatum(one(C),C)</code>. The  adjoint group  is also the default  returned for <code>coxeter_group(type,rank)</code>. The following methods all define <code>pgl₃</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; rootdatum(cartan(:A,3))==coxgroup(:A,3)
true

julia&gt; rootdatum(:pgl,3)
pgl₃</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/ba0f39da137d91b021b7995080791755084d9a52/src/Weyl.jl#L817-L829">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Weyl.rootdatum-Tuple{AbstractMatrix, AbstractMatrix}" href="#Chevie.Weyl.rootdatum-Tuple{AbstractMatrix, AbstractMatrix}"><code>Chevie.Weyl.rootdatum</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>rootdatum(R::AbstractMatrix,CR::AbstractMatrix)</code></p><p>constructs  the root datum given by the  simple roots which are the rows of <code>R</code>  and  the  simple  coroots  which  are  the  rows  of <code>CR</code>. This is the reflection  group  on  the  rowspace  of  <code>R</code>  generated by the reflections <code>reflectionMatrix(R[i,:],CR[i,:])</code>.</p><p>In  another interpretation this constructs the  root datum of the algebraic group  such that the rows of <code>R</code> are  the simple roots on a basis of <code>X(T)</code> and  the rows of <code>CR</code> are the simple  coroots on a basis of <code>Y(T)</code>. In this interpretation the following methods all define <code>gl₃</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; rootdatum(:gl,3)==rootdatum(&quot;gl&quot;,3)
true

julia&gt; rootdatum([1 -1 0;0 1 -1],[1 -1 0;0 1 -1])
A₂Φ₁</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/ba0f39da137d91b021b7995080791755084d9a52/src/Weyl.jl#L832-L852">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Weyl.torus-Tuple{Integer}" href="#Chevie.Weyl.torus-Tuple{Integer}"><code>Chevie.Weyl.torus</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>torus(rank::Integer)</code></p><p>This  function returns the object corresponding to the notion of a torus of dimension  <code>rank</code>, a Coxeter  group of semisimple  rank 0 and given <code>rank</code>. This  corresponds to a split torus; the extension to Coxeter cosets is more useful.</p><pre><code class="language-julia-repl hljs">julia&gt; torus(3)
Φ₁³</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/ba0f39da137d91b021b7995080791755084d9a52/src/Weyl.jl#L875-L887">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Weyl.istorus" href="#Chevie.Weyl.istorus"><code>Chevie.Weyl.istorus</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>istorus(W)</code> whether <code>W</code> is a torus</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/ba0f39da137d91b021b7995080791755084d9a52/src/Weyl.jl#L890">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.PermRoot.radical" href="#Chevie.PermRoot.radical"><code>Chevie.PermRoot.radical</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>radical(G::ComplexReflectionGroup)</code></p><p>A torus of dimension <code>rank(W)-semisimplerank(W))</code>.</p><p>The  radical datum of a root datum <code>(X,Φ,Y,Φ^∨)</code> is <code>(X/(X∩ ℚ Φ),∅ ,Φ^⟂,∅)</code>, a toral  datum. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/ba0f39da137d91b021b7995080791755084d9a52/src/PermRoot.jl#L1780-L1787">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Weyl.derived_datum" href="#Chevie.Weyl.derived_datum"><code>Chevie.Weyl.derived_datum</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>derived_datum(G)</code></p><p>The  derived datum of <code>(X,Φ,Y,Φ^∨)</code> is <code>(X/Φ^{∨⟂}, Φ, Y∩ ℚ Φ^∨, Φ^∨)</code> where <code>⟂</code>  denotes the orthogonal. This function  starts with a root datum object <code>G</code> and returns the root datum object corresponding to the derived datum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/ba0f39da137d91b021b7995080791755084d9a52/src/Weyl.jl#L903-L909">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Weyl.describe_involution" href="#Chevie.Weyl.describe_involution"><code>Chevie.Weyl.describe_involution</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>describe_involution(W,w)</code></p><p>Given  an  involution  <code>w</code>  of  a  Coxeter  group  <code>W</code>,  by  a  theorem  of <a href="biblio.htm#rich82">Richardson1982</a>  there is  a unique  parabolic subgroup <code>P</code>  of <code>W</code> such that <code>P</code> is finite  and <code>w</code> is the longest element of <code>P</code>, and is central in <code>P</code>. The function returns <code>I</code> such that <code>P==reflection_subgroup(W,I)</code> and <code>w==longest(reflection_subgroup(W,I))</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,2)
A₂

julia&gt; w=longest(W)
(1,5)(2,4)(3,6)

julia&gt; describe_involution(W,w)
1-element Vector{Int64}:
 3

julia&gt; w==longest(reflection_subgroup(W,[3]))
true</code></pre><p>For now only works for finite Coxeter groups.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/ba0f39da137d91b021b7995080791755084d9a52/src/Weyl.jl#L653-L677">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Weyl.badprimes" href="#Chevie.Weyl.badprimes"><code>Chevie.Weyl.badprimes</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>badprimes(W)</code></p><p>Let  <code>W</code>  be  a  Weyl  group.  A  prime  is  <em>bad</em>  for <code>W</code> if it divides a coefficient  of some  root on  the simple  roots. The  function <code>badprimes</code> returns the list of primes which are bad for <code>W</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:E,8)
E₈

julia&gt; badprimes(W)
3-element Vector{Int64}:
 2
 3
 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/ba0f39da137d91b021b7995080791755084d9a52/src/Weyl.jl#L630-L647">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Weyl.standard_parabolic-Tuple{Union{Chevie.Weyl.FCG, Chevie.Weyl.FCSG}, AbstractVector{&lt;:Integer}}" href="#Chevie.Weyl.standard_parabolic-Tuple{Union{Chevie.Weyl.FCG, Chevie.Weyl.FCSG}, AbstractVector{&lt;:Integer}}"><code>Chevie.Weyl.standard_parabolic</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>standard_parabolic(W,H)</code></p><p>Given  a reflection subgroup <code>H</code> or the indices of its simple roots returns <code>nothing</code> if <code>H</code> is not parabolic, otherwise returns <code>w</code> such that <code>H^w</code> is a standard parabolic subgroup of <code>W</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:E,6)
E₆

julia&gt; R=reflection_subgroup(W,[20,30,19,22])
E₆₍₁‚₉‚₁₉‚₂₀₎=A₄₍₃₁₂₄₎Φ₁²

julia&gt; p=standard_parabolic(W,R)
(1,4,49,12,10)(2,54,62,3,19)(5,17,43,60,9)(6,21,34,36,20)(7,24,45,41,53)(8,65,50,15,22)(11,32,31,27,28)(13,48,46,37,40)(14,51,58,44,29)(16,23,35,33,30)(18,26,39,55,38)(42,57,70,72,56)(47,68,67,63,64)(52,59,71,69,66)

julia&gt; p==standard_parabolic(W,[19,1,9,20]) # can give inclusiongens
true

julia&gt; reflection_subgroup(W,[20,30,19,22].^p) # same as R^p
E₆₍₂₄₅₆₎=A₄Φ₁²

julia&gt; R=reflection_subgroup(W,[1,2,3,5,6,35])
E₆₍₁‚₂‚₃‚₅‚₆‚₃₅₎=A₂₍₁₃₎×A₂₍₂₆₎×A₂₍₄₅₎

julia&gt; standard_parabolic(W,R)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/ba0f39da137d91b021b7995080791755084d9a52/src/Weyl.jl#L576-L604">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.CoxGroups.inversions" href="#Chevie.CoxGroups.inversions"><code>Chevie.CoxGroups.inversions</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>inversions(W,w)</code></p><p>Returns  the inversions of the element <code>w</code> of the finite Coxeter group <code>W</code>, that  is, the list of the  indices of reflections <code>r</code> of <code>W</code> such that <code>l(rw)&lt;l(w)</code> where <code>l</code> is the Coxeter length.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; inversions(W,W(1,2,1))
3-element Vector{Int64}:
 1
 2
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/ba0f39da137d91b021b7995080791755084d9a52/src/CoxGroups.jl#L643-L660">source</a></section><section><div><p><code>inversions(W::FiniteCoxeterGroup, w::AbstractVector{&lt;:Integer})</code></p><p>Given  a word <code>w=[s₁,…,sₙ]</code> (a vector of integers) representing the element <code>W(w...)</code>,  returns the inversions of  <code>w</code>, that is the  list of indices of the reflections of <code>W</code> given by <code>W(s₁), W(s₁,s₂,s₁), …, W(s₁,s₂,…,sₙ,sₙ₋₁,…,s₁)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,3)
A₃

julia&gt; inversions(W,[2,1,2])
3-element Vector{Int64}:
 2
 4
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/ba0f39da137d91b021b7995080791755084d9a52/src/Weyl.jl#L517-L535">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Weyl.with_inversions" href="#Chevie.Weyl.with_inversions"><code>Chevie.Weyl.with_inversions</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>with_inversions(W,N)</code></p><p><code>W</code>  should be  a finite  Coxeter group  and <code>N</code>  a subset  of <code>1:nref(W)</code>. Returns  the  element  <code>w</code>  of  <code>W</code> such that <code>N==inversions(W,w)</code>. Returns <code>nothing</code> if no such element exists.</p><pre><code class="language-julia-repl hljs">julia&gt; W=coxgroup(:A,2)
A₂

julia&gt; map(N-&gt;with_inversions(W,N),combinations(1:nref(W)))
8-element Vector{Union{Nothing, Perm{Int16}}}:
 ()
 (1,4)(2,3)(5,6)
 (1,3)(2,5)(4,6)
 nothing
 nothing
 (1,6,2)(3,5,4)
 (1,2,6)(3,4,5)
 (1,5)(2,4)(3,6)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/ba0f39da137d91b021b7995080791755084d9a52/src/Weyl.jl#L539-L561">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Weyl.relative_group" href="#Chevie.Weyl.relative_group"><code>Chevie.Weyl.relative_group</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>relative_group(W::FiniteCoxeterGroup,J)</code></p><p><code>J</code>  should be a if <em>distinguished</em> subset of <code>S==eachindex(gens(W))</code>, that is if for <code>s∈ S-J</code> we set <span>$v(s,J)=w₀^{J∪ s}w₀ᴶ$</span> then <code>J</code> is stable by all <code>v(s,J)</code>.  Then <span>$N_W(W_J)=W_J⋊ N₁$</span>  where <code>N₁</code> is  the group generated by the  <code>v(s,J)</code>,  which  form  a  Coxeter  system for <code>N₁</code>. Equivalently <code>N₁</code> consists   of  the   <code>J</code>-reduced  elements   of  <code>N_W(W_J)</code>.  The  quotient <code>R=N_W(W_J)/W_J</code> has a natural reflection representation on <span>$X(ZL_J/ZG)$</span>, using  that by <a href="biblio.htm#Lus76">Lusztig1976</a>, the  images of the roots of <code>W</code>  in  <span>$X(ZL_J)$</span>  form  a  root  system.  The function returns <code>R</code> as a reflection  group on <span>$X(ZL_J/ZG)$</span>, with  some extra attributes reflecting its origin</p><ul><li><code>R.relative_indices=setdiff(S,J)</code> in a certain order</li><li><code>R.toparent=</code> the list of <code>v(s,J)</code> corresponding to <code>.relative_indices</code>;  defines an isomorphism <code>R→ N₁</code>.</li><li><code>R.fromparent</code>  is  a  function  mapping elements of <code>N₁</code> to <code>R</code>. The  inverse mapping to <code>.toparent</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/ba0f39da137d91b021b7995080791755084d9a52/src/Weyl.jl#L1140-L1158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Chevie.Semisimple.affine" href="#Chevie.Semisimple.affine"><code>Chevie.Semisimple.affine</code></a> — <span class="docstring-category">Function</span></header><section><div><p>A  <em>generalized Cartan matrix</em> <code>C</code>  is a square integer  matrix of size <code>n</code> such  that <code>cᵢᵢ=2</code>, <code>cᵢⱼ≤0</code> if <code>i≠j</code>, and <code>cᵢⱼ==0</code> if and only if <code>cⱼᵢ==0</code>. We  say  that  <code>C</code>  is  <em>indecomposable</em>  if  it  does  not admit any block decomposition.</p><p>Let  <code>C</code> be a generalized  Cartan matrix. For <code>I</code>  a subset of <code>{1,…,n}</code> we denote  by <code>C_I</code> the square  submatrix with indices <code>i,j</code>  taken in <code>I</code>. If <code>v</code>  is a real vector of length <code>n</code>, we write <code>v&gt;0</code> if for all <code>i∈ {1,…,n}</code> we  have <code>vᵢ&gt;0</code>. It can be shown that <code>C</code> is a Cartan matrix if and only if for  all sets  <code>I</code>, we  have <code>det  C_I&gt;0</code>; or  equivalently, if and only if there  exists  <code>v&gt;0</code>  such  that  <code>C.v&gt;0</code>.  <code>C</code> is called an <em>affine Cartan matrix</em>  if for all proper subsets <code>I</code> we have <code>det C_I&gt;0</code>, but <code>det C==0</code>; or equivalently if there exists <code>v&gt;0</code> such that <code>C.v==0</code>.</p><p>Given  an  irreducible  Weyl  group  <code>W</code>  with  Cartan  matrix  <code>C</code>, we can construct  a generalized  Cartan matrix  <code>C̃</code> as  follows. Let  <code>α₀</code> be the opposed of the highest root. Then the matrix <span>$\left(\begin{array}{cc}C&amp;C.α₀\\  α₀.C&amp;2\end{array}\right)$</span> is  an  affine  Cartan  matrix.  The  affine  Cartan  matrices which can be obtained  in this way  are those we  are interested in,  which give rise to affine Weyl groups.</p><p>Let <code>d=n-rank(C)</code>. A <em>realization</em> of a generalized Cartan matrix is a pair <code>V,Vᵛ</code>  of vector spaces of dimension <code>n+d</code> together with vectors <code>α₁,…,αₙ∈ V</code>  (the <em>simple roots</em>), <code>αᵛ₁,…,αᵛₙ∈ Vᵛ</code> (the <em>simple coroots</em>), such that <code>(αᵛᵢ,  αⱼ)=c_{i,j}</code>.  Up  to  isomorphism,  a  realization  is obtained as follows: write <span>$C=\left(\begin{array}{c}C_1\\C_2\end{array}\right)$</span> where  <code>C₁</code> is  of same  rank as  <code>C</code>. Then  take <code>αᵢ</code>  to be the first <code>n</code> vectors  in a basis of <code>V</code>, and take <code>αᵛⱼ</code> to be given in the dual basis by the rows of the matrix <span>$\left(\begin{array}{cc}C₁&amp;0\\ C_2&amp;\hbox{Id}_d\\ \end{array}\right).$</span> To  <code>C</code> we associate a reflection group  in the space <code>V</code>, generated by the <em>fundamental  reflections</em>  <code>rᵢ</code>  given  by  <code>rᵢ(v)=v-(αᵛᵢ,v)αᵢ</code>. This is a Coxeter  group, called the <em>affine Weyl group</em> <code>ilde W</code> associated to <code>W</code> when we start with the affine Cartan matrix associated to a Weyl group <code>W</code>.</p><p>The  affine Weyl  group is  infinite; it  has one additional generator <code>s₀</code> (the  reflection with respect to <code>α₀</code>) compared  to <code>W</code>. We can not use <code>0</code> as  a label  by default  for a  generator of  a Coxeter  group (because the default  labels are used as indices, and indices start at 1 in Julia) so we label it as <code>n+1</code> where <code>n</code> is the numbers of generators of <code>W</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; W=affine(coxgroup(:A,4))
Ã₄

julia&gt; diagram(W)
       ————5————
      /         \
Ã₄   1———2———3———4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/Chevie.jl/blob/ba0f39da137d91b021b7995080791755084d9a52/src/Semisimple.jl#L687-L740">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="coxgroups.html">« Coxeter groups</a><a class="docs-footer-nextpage" href="chars.html">Classes/characters of reflection groups »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 16 December 2024 18:13">Monday 16 December 2024</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
