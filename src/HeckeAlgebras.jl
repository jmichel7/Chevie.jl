"""
This   module  ports   Chevie  functionality   for  Iwahori-Hecke  algebras
associated to Coxeter groups.

Let  (W,S) be a Coxeter  system where `m‚Çõ‚Çú` is  the order of `st` for `s,t‚àà
S`. Let `R` be a commutative ring with 1 and for `s‚àà S` let `u‚Çõ‚ÇÄ,u‚Çõ‚ÇÅ‚àà R` be
elements which depend ony on the conjugacy class of `s` in `W` (this is the
same  as requiring that `u‚Çõ·µ¢=u‚Çú·µ¢` whenever `m‚Çõ‚Çú` is odd). The Iwahori-Hecke
algebra of `W` over `R` with parameters `u‚Çõ·µ¢` is a deformation of the group
algebra  of `W` over `R` defined as  follows: it is the unitary associative
`R`-algebra generated by elements `T‚Çõ, s‚àà S` subject to the relations:

``(T‚Çõ-u‚Çõ‚ÇÄ)(T‚Çõ-u‚Çõ‚ÇÅ)=0`` for all `s‚àà S` (the quadratic relations)

``T‚ÇõT‚ÇúT‚Çõ‚Ä¶= T‚ÇúT‚ÇõT‚Çú‚Ä¶`` with `m‚Çõ‚Çú` factors on each side (the braid relations)

If  `u‚Çõ‚ÇÄ=1` and  `u‚Çõ‚ÇÅ=-1` for  all `s`  then the quadratic relations become
`T‚Çõ¬≤=1` and the deformation of the group algebra is trivial.

Since  the generators `T‚Çõ` satisfy the  braid relations, the algebra `H` is
in  fact a quotient of the group algebra of the braid group associated with
`W`.  It follows that, if `w=s_1‚ãØ s_m`  is a reduced expression of `w ‚àà W`
then  the  product  `T‚Çõ_1‚ãØ T‚Çõ_m`  depends  only  on `w`. We will therefore
denote by `T_w`. We have `T_1=1`.

If  one of `u‚Çõ‚ÇÄ` or `u‚Çõ‚ÇÅ` is invertible  in `R`, for example `u‚Çõ‚ÇÅ`, then by
changing  the generators  to `T‚Ä≤‚Çõ=-T‚Çõ/u‚Çõ‚ÇÅ`,  and setting `q‚Çõ=-u‚Çõ‚ÇÄ/u‚Çõ‚ÇÅ`, the
braid  relations do no change  (since when `m‚Çõ‚Çú` is  odd we have `u‚Çõ·µ¢=u‚Çú·µ¢`)
but  the quadratic relations become  `(T‚Ä≤‚Çõ-q‚Çõ)(T‚Ä≤‚Çõ+1)=0`. This last form is
the  most common  form considered  in the  literature. Another common form,
considered  in  the  context  of  Kazhdan-Lusztig  theory, is `u‚Çõ‚ÇÄ=‚àöq‚Çõ` and
`u‚Çõ‚ÇÅ=-‚àöq‚Çõ‚Åª¬π`.  The general form of parameters provided is a special case
of general cyclotomic Hecke algebras, and can be useful in many contexts.

For  some  algebras  the  character  table,  and in general Kazhdan-Lusztig
bases,  require a square root of `-u‚Çõ‚ÇÄu‚Çõ‚ÇÅ`.  We provide a way to specify it
with  the  field  `.rootpara`  which  can  be  given  when constructing the
algebra. If not given a root is automatically extracted when needed (and we
know  how to compute it) by the function `RootParameter`. Note however that
sometimes  an  explicit  choice  of  root  is  necessary  which  cannot  be
automatically determined.

There  is a universal choice  for `R` and `u‚Çõ·µ¢`:  Let `u‚Çõ·µ¢:s‚àà S,i‚àà[0,1]` be
indeterminates   such  that  `u‚Çõ·µ¢=u‚Çú·µ¢`  whenever  `m‚Çõ‚Çú`  is  odd,  and  let
`A=‚Ñ§[u‚Çõ·µ¢]` be the corresponding polynomial ring. Then the Hecke algebra `H`
of  `W` over a  with parameters `u‚Çõ·µ¢`  is called the *generic Iwahori-Hecke
algebra*  of  with  `W`.  Any  other  algebra  with parameters `v‚Çõ·µ¢` can be
obtained  by specialization from  `H`: There is  a unique ring homomorphism
`f:A  ‚Üí R` such that `f(u‚Çõ·µ¢)=v‚Çõ·µ¢`  for all `i`. Then we  can view `R` as an
`A`-module via `f` and we can identify the other algebra to ``R‚äó _A H``.

The  elements `{T_w‚à£w‚àà W}` actually form an  `R`-basis of `H` if one of the
`u‚Çõ·µ¢`  is invertible for all `s`. The  structure constants in that basis is
obtained  as  follows.  To  multiply  `T_v`  by  `T_w`,  choose  a  reduced
expression for `v`, say `v=s_1 ‚ãØ s_k` and apply inductively the formula:

``T_sT_w=T_{sw}``               if `l(sw)=l(w)+1`

``T_sT_w=-u‚Çõ‚ÇÄu‚Çõ‚ÇÅT_{sw}+(u‚Çõ‚ÇÄ+u‚Çõ‚ÇÅ)T_w`` if `l(sw)=l(w)-1`.

If all `s` we have `u‚Çõ‚ÇÄ=q`, `u‚Çõ‚ÇÅ=-1` then we call the corresponding algebra
the one-parameter or Spetsial Iwahori-Hecke algebra associated with `W`; it
can  be obtained with the  simplified call 'hecke(W,q)'. Certain invariants
of  the irreducible characters of  this algebra play a  special role in the
representation  theory of the underlying  finite Coxeter groups, namely the
`a`- and `A`-invariants. For basic properties of Iwahori-Hecke algebras and
their  relevance to the representation theory of finite groups of Lie type,
see for example Curtis and Reiner 1987, Sections~67 and 68.

In  the  following  example,  we  compute  the multiplication table for the
`0`-Iwahori--Hecke algebra associated with the Coxeter group of type `A_2`.

```julia-repl
julia> W=coxgroup(:A,2)
A‚ÇÇ

julia> H=hecke(W,0)             # One-parameter algebra with `q=0`
hecke(A‚ÇÇ,0)

julia> T=Tbasis(H);             # Create the `T` basis

julia> el=words(W)
6-element Array{Array{Int8,1},1}:
 []       
 [2]      
 [1]      
 [2, 1]   
 [1, 2]   
 [1, 2, 1]

julia> T.(el)*permutedims(T.(el))        # multiplication table
6√ó6 Array{HeckeTElt{Perm{Int16},Int64,FiniteCoxeterGroup{Perm{Int16},Int64}},2}:
 T.    T‚ÇÇ     T‚ÇÅ     T‚ÇÇ‚ÇÅ    T‚ÇÅ‚ÇÇ    T‚ÇÅ‚ÇÇ‚ÇÅ 
 T‚ÇÇ    -T‚ÇÇ    T‚ÇÇ‚ÇÅ    -T‚ÇÇ‚ÇÅ   T‚ÇÅ‚ÇÇ‚ÇÅ   -T‚ÇÅ‚ÇÇ‚ÇÅ
 T‚ÇÅ    T‚ÇÅ‚ÇÇ    -T‚ÇÅ    T‚ÇÅ‚ÇÇ‚ÇÅ   -T‚ÇÅ‚ÇÇ   -T‚ÇÅ‚ÇÇ‚ÇÅ
 T‚ÇÇ‚ÇÅ   T‚ÇÅ‚ÇÇ‚ÇÅ   -T‚ÇÇ‚ÇÅ   -T‚ÇÅ‚ÇÇ‚ÇÅ  -T‚ÇÅ‚ÇÇ‚ÇÅ  T‚ÇÅ‚ÇÇ‚ÇÅ 
 T‚ÇÅ‚ÇÇ   -T‚ÇÅ‚ÇÇ   T‚ÇÅ‚ÇÇ‚ÇÅ   -T‚ÇÅ‚ÇÇ‚ÇÅ  -T‚ÇÅ‚ÇÇ‚ÇÅ  T‚ÇÅ‚ÇÇ‚ÇÅ 
 T‚ÇÅ‚ÇÇ‚ÇÅ  -T‚ÇÅ‚ÇÇ‚ÇÅ  -T‚ÇÅ‚ÇÇ‚ÇÅ  T‚ÇÅ‚ÇÇ‚ÇÅ   T‚ÇÅ‚ÇÇ‚ÇÅ   -T‚ÇÅ‚ÇÇ‚ÇÅ

```
Thus,  we work  with algebras  with arbitrary  parameters. We will see that
this also works on the level of characters and representations.
 
finally, benchmarks on julia 1.0.2
```benchmark
julia> function test_w0(n)
         W=coxgroup(:A,n)
         Tbasis(hecke(W,Pol([1],1)))(longest(W))^2
       end
test_w0 (generic function with 1 method)

julia> @btime test_w0(7);
  132.737 ms (1788153 allocations: 157.37 MiB)
```
Compare to GAP3 where the following function takes 0.92s
```
test_w0:=function(n)local W,T,H;
  W:=CoxeterGroup("A",n);H:=Hecke(W,X(Rationals));T:=Basis(H,"T");
  T(LongestCoxeterWord(W))^2;
end;
```
"""
module HeckeAlgebras
using Gapjm
export HeckeElt, Tbasis, central_monomials, hecke, HeckeAlgebra, HeckeTElt, 
  rootpara, equalpara, class_polynomials, char_values

struct HeckeAlgebra{C,TW<:Group}
  W::TW
  para::Vector{Vector{C}}
  prop::Dict{Symbol,Any}
end

"""
   hecke( W [, parameter][,rootpara=r]) return a Hecke algebra for W

# Example
```julia-repl
julia> W=coxgroup(:B,2)
B‚ÇÇ

julia> Pol(:q)
Pol{Int64}: q

julia> H=hecke(W,q)
hecke(B‚ÇÇ,q)

julia> H.para
2-element Array{Array{Pol{Int64},1},1}:
 [q, -1]
 [q, -1]

julia> H=hecke(W,q^2,rootpara=q)
hecke(B‚ÇÇ,q¬≤,rootpara=q)

julia> [H.para,rootpara(H)]
2-element Array{Array{T,1} where T,1}:
 Array{Pol{Int64},1}[[q¬≤, -1], [q¬≤, -1]]
 Pol{Int64}[q, q]                                  

julia> H=hecke(W,[q^2,q^4],rootpara=[q,q^2])
hecke(B‚ÇÇ,Pol{Int64}[q¬≤, q‚Å¥],rootpara=Pol{Int64}[q, q¬≤])

julia> [H.para,rootpara(H)]
2-element Array{Array{T,1} where T,1}:
 Array{Pol{Int64},1}[[q¬≤, -1], [q‚Å¥, -1]]
 Pol{Int64}[q, q¬≤]

julia> H=hecke(W,9,rootpara=3)
hecke(B‚ÇÇ,9,rootpara=3)

julia> [H.para,rootpara(H)]
2-element Array{Array{T,1} where T,1}:
 Array{Int64,1}[[9, -1], [9, -1]]
 [3, 3]                              
```
"""
function hecke(W::Group,para::Vector{Vector{C}};
    rootpara::Vector{C}=C[]) where C
  para=map(eachindex(gens(W)))do i
    j=simple_representatives(W)[i]
    if i<=length(para) 
     if j<i && para[i]!=para[j] error("one should have  para[$i]==para[$j]") end
      return para[i]
    elseif j<i return para[j]
    else error("parameters should be given for first reflection in a class")
    end
  end
  d=Dict{Symbol,Any}(:equal=>constant(para))
  if !isempty(rootpara) d[:rootpara]=rootpara end
  HeckeAlgebra(W,para,d)
end

function hecke(W,p::Vector{C};rootpara::Vector{C}=C[])where C
  oo=order.(gens(W))
  if all(isequal(2),oo) z=0 else z=zero(Cyc) end
  para=map(p,oo)do p, o
    if o==2 return [p,-one(p)].+z end
    map(i->iszero(i) ? p+z : zero(p)+E(o,i),0:o-1)
  end
  hecke(W,para,rootpara=convert(Vector{typeof(para[1][1])},rootpara))
end
  
function hecke(W,p::C;rootpara::C=zero(C))where C
  rootpara= iszero(rootpara) ? C[] : fill(rootpara,nbgens(W))
  hecke(W,fill(p,nbgens(W)),rootpara=rootpara)
end

function hecke(W,p::Tuple;rootpara=zero(p[1]))
  rootpara= iszero(rootpara) ? typeof(p[1])[] : fill(rootpara,nbgens(W))
  hecke(W,[collect(p) for j in 1:nbgens(W)],rootpara=rootpara)
end

hecke(W::Group)=hecke(W,1)

function rootpara(H::HeckeAlgebra)
  gets(H,:rootpara) do H
    map(eachindex(H.para)) do i
       if isone(-prod(H.para[i])) return -prod(H.para[i]) end
       error("could not compute rootpara[$i]")
    end
  end
end

equalpara(H::HeckeAlgebra)::Bool=H.prop[:equal]

function Base.show(io::IO, H::HeckeAlgebra)
  print(io,"hecke(",H.W,",")
  tr(p)= p[2]==-one(p[2]) ? p[1] : p
  if constant(H.para) print(io,tr(H.para[1]))
  else print(io,map(tr,H.para))
  end
  if haskey(H.prop,:rootpara)
    rp=rootpara(H)
    if constant(rp) print(io,",rootpara=",rp[1])
    else print(io,",rootpara=",rp)
    end
  end
  print(io,")")
end

impl1(l)=length(l)==1 ? l[1] : error("implemented only for irreducible groups")

function Chars.CharTable(H::HeckeAlgebra)
  W=H.W
  ct=impl1(getchev(W,:HeckeCharTable,H.para,
       haskey(H.prop,:rootpara) ? rootpara(H) : fill(nothing,length(H.para))))
  if haskey(ct,:irredinfo) names=getindex.(ct[:irredinfo],:charname)
  else                     names=charinfo(W)[:charnames]
  end
  CharTable(improve_type(toM(ct[:irreducibles])),names,
     ct[:classnames],map(Int,ct[:centralizers]),ct[:identifier])
end

function Chars.representation(H::HeckeAlgebra,i::Int)
  r=impl1(getchev(H.W,:HeckeRepresentation,H.para,
    haskey(H.prop,:rootpara) ? rootpara(H) : fill(nothing,length(H.para)),i))
  if r!=false return improve_type.(toM.(r)) end
end

Chars.representations(H::HeckeAlgebra)=representation.(Ref(H),1:HasType.NrConjugacyClasses(H.W))

function Chars.WGraphToRepresentation(H::HeckeAlgebra,gr::Vector)
  S=-H.para[1][2]*WGraphToRepresentation(length(H.para),gr,
                                   rootpara(H)[1]//H.para[1][2])
  CheckHeckeDefiningRelations(H,S)
  S
end

"""
central_monomials(H)
  Let  `H` be an Hecke  algebra for the reflection  group `W`. The function
  returns  the  scalars  by  which  the  image  in  `H`  of  œÄ  acts on the
  irreducible  representations of  the Iwahori-Hecke  algebra. When  `W` is
  irreducible, œÄ is the generator of the center of the pure braid group. In
  general,  it  is  the  product  of  such  elements  for  each irreducible
  component. When `W` is an irreducible Coxeter group, œÄ is the lift to the
  braid group of the square of the longest element of `W`.

```julia-repl
julia> H=hecke(coxgroup(:H,3),Pol(:q))
hecke(H‚ÇÉ,q)

julia> central_monomials(H)
10-element Array{Pol{Cyc{Int64}},1}:
 1  
 q¬≥‚Å∞
 q¬π¬≤
 q¬π‚Å∏
 q¬π‚Å∞
 q¬π‚Å∞
 q¬≤‚Å∞
 q¬≤‚Å∞
 q¬π‚Åµ
 q¬π‚Åµ
```
"""
function central_monomials(H::HeckeAlgebra)
# Cf. BrMi, 4.16 for the formula used
  W=H.W
  v=hyperplane_orbits(W)
  map(eachrow(CharTable(W).irr)) do irr
    prod(v)do C
      q=H.para[restriction(W)[C.s]]
      m=map(0:C.order-1)do j
       (irr[1]+sum(l->irr[C.cl_s[l]]*E(C.order,-j*l),1:C.order-1))//C.order
      end
      E.(irr[1],-C.N_s*sum(m.*(0:C.order-1)))*
          prod(j->q[j]^Int(C.N_s*C.order*m[j]//irr[1]),1:C.order)
    end
  end
end

#--------------------------------------------------------------------------
abstract type HeckeElt{P,C} end

Base.zero(h::HeckeElt)=clone(h,zero(h.d))
Base.iszero(h::HeckeElt)=iszero(h.d)

function Base.show(io::IO, h::HeckeElt)
  function showbasis(io::IO,e)
    repl=get(io,:limit,false)
    TeX=get(io,:TeX,false)
    w=word(h.H.W,e)
    res=basename(h)
    if repl || TeX
      if isempty(w) res*="."
      else res*="_{"*(any(>=(10),w) ? join(w,",") : join(w))*"}"
      end
    else res*="("*join(map(x->"$x",w),",")*")"
    end
    fromTeX(io,res)
  end
  show(IOContext(io,:showbasis=>showbasis),h.d)
end


Base.:+(a::HeckeElt, b::HeckeElt)=clone(a,a.d+b.d)
Base.:-(a::HeckeElt)=clone(a,-a.d)
Base.:-(a::HeckeElt, b::HeckeElt)=a+(-b)

Base.:*(a::HeckeElt, b)=clone(a,a.d*b)
Base.:*(a::HeckeElt, b::Pol)=clone(a,a.d*b)
Base.:*(a::HeckeElt, b::Mvp)=clone(a,a.d*b)
Base.:*(b::Pol, a::HeckeElt)=a*b
Base.:*(b::Mvp, a::HeckeElt)=a*b
Base.:*(b::Number, a::HeckeElt)= a*b

Base.:^(a::HeckeElt, n::Integer)= n>=0 ? Base.power_by_squaring(a,n) : 
                                   Base.power_by_squaring(inv(a),-n)
#--------------------------------------------------------------------------
struct HeckeTElt{P,C,G<:CoxeterGroup}<:HeckeElt{P,C}
  d::ModuleElt{P,C} # has better merge performance than Dict
  H::HeckeAlgebra{C,G}
end

clone(h::HeckeTElt,d)=HeckeTElt(d,h.H)

basename(h::HeckeTElt)="T"
 
function Base.one(H::HeckeAlgebra{C}) where C
  HeckeTElt(ModuleElt(one(H.W)=>one(C)),H)
end

function Base.zero(H::HeckeAlgebra{C}) where C
  HeckeTElt(zero(ModuleElt{typeof(one(H.W)),C}),H)
end

Tbasis(h::HeckeTElt)=h

function Tbasis(H::HeckeAlgebra{C,TW})where C where TW<:CoxeterGroup{P} where P
  function f(w::Vararg{Integer})
    if isempty(w) return one(H) end
    HeckeTElt(ModuleElt(H.W(w...)=>one(C)),H)
  end
  f(w::Vector{<:Integer})=f(w...)
  f(w::P)=HeckeTElt(ModuleElt(w=>one(C)),H)
# Base.show(io::IO,t::Type{f})=print(io,"Tbasis($H)")
  f(h::HeckeElt)=Tbasis(h)
end

function Base.:*(a::HeckeTElt, b::HeckeTElt)
  if iszero(a) return a end
  if iszero(b) return b end
  W=a.H.W
  sum(a.d) do (ea,pa)
    h=b.d*pa
    for i in reverse(word(W,ea))
      s=gens(W)[i]
      up=zero(h)
      down=zero(h)
      for (e,p)  in h
        if isleftdescent(W,e,i) push!(down,e=>p) 
        else push!(up,s*e=>p) end
      end
if ModuleElts.usedict
      h=ModuleElt(up.d)
else
      h=ModuleElt(sort!(up.d,by=x->x[1]))
end
      if !iszero(down)
        pp=a.H.para[i]
        ss,p=(sum(pp),-prod(pp))
        if !iszero(ss) h+=down*ss end
        if !iszero(p)  
          let s=s, p=p
            h+=ModuleElt(sort!([s*e=>c*p for (e,c) in down],by=first))
          end
        end
      end
    end
    HeckeTElt(h,a.H)
  end
end

function Base.inv(a::HeckeTElt)
  if length(a.d)!=1 error("can only invert single T(w)") end
  w,coeff=first(a.d)
  H=a.H
  T=Tbasis(H)
  l=reverse(word(H.W,w))
  inv(coeff)*prod(i->inv(prod(H.para[i]))*(T()*sum(H.para[i])-T(i)),l)
end

"""
`class_polynomials(h)`

returns the class polynomials of the Hecke element `h` of the Hecke algebra
`H=h.H`  with respect  to representatives  `reps` of  minimal length in the
conjugacy  classes  of  the  Coxeter  group  `W=H.W`.  Such  minimal length
representatives  are given by  the function `classinfo(W)[:classtext]`. The
vector  `p` of these polynomials has the property that if `X` is the matrix
of  the values of  the irreducible characters  of `H` on  `T_w` (for `w` in
`reps`),  then the product `X*p`  is the list of  values of the irreducible
characters on `h`.

```julia-repl
julia> W=CoxSym(4)
ùîñ ‚ÇÑ

julia> H=hecke(W,Pol(:q))
hecke(ùîñ ‚ÇÑ,q)

julia> h=Tbasis(H)(longest(W))
T‚ÇÅ‚ÇÇ‚ÇÅ‚ÇÉ‚ÇÇ‚ÇÅ

julia> p=class_polynomials(h)
5-element Array{Pol{Int64},1}:
 0        
 0        
 q¬≤       
 q¬≥-2q¬≤+q 
 q¬≥-q¬≤+q-1
```
The class polynomials were introduced in  cite{GP93}.
"""
function class_polynomials(h)
  H=h.H
# if IsBound(h.coset) WF=Spets(h.coset); W=Group(WF);
# else 
    W=H.W
    WF=W
# end
  minl=length.(classinfo(WF)[:classtext])
  h=Tbasis(H)(h)
# Since  vF is not of minimal length in its class there exists wF conjugate
# by   cyclic  shift  to  vF  and  a  generating  reflection  s  such  that
# l(swFs)=l(vF)-2. Return T_sws.T_s^2
  function orb(w)
    orbit=[w]
    for w in orbit
      for s in leftdescents(W,w)
        sw=W(s)*w
        sws=sw*W(s)
        if isleftdescent(W,inv(sw),s) 
          q1,q2=H.para[s]
          return (elm=[sws,sw],coeff=[-q1*q2,q1+q2])
        elseif !(sws in orbit) push!(orbit,sws)
        end
      end
    end
    error("Geck-Kim-Pfeiffer theory")
  end

  elm,coeff=first(h.d)
  min=fill(zero(coeff),length(minl))
  while length(h.d)>0
    elms=typeof(elm)[]
    coeffs=typeof(coeff)[]
    l=[length(W,elm) for (elm,coeff) in h.d]
    maxl=maximum(l)
    for (elm,coeff) in h.d
      if length(W,elm)<maxl 
        push!(elms,elm)
        push!(coeffs,coeff)
      else
        p=position_class(WF,elm)
        if minl[p]==maxl min[p]+=coeff
        else o=orb(elm)
          append!(elms,o.elm)
          append!(coeffs,o.coeff.*coeff)
        end
      end
    end
    h=clone(h,ModuleElt(map(Pair,elms,coeffs);check=true))
  end
  return min
end

"""
`char_values(h)`

`h`  is an  element of  an Iwahori-Hecke  algebra `H`  (in any  basis). The
function  returns the  values of  the irreducible  characters of `H` on `h`
(the   method  used  is  to  convert  to   the  `T`  basis,  and  then  use
`class_polynomials`).

```julia-repl
julia> W=coxgroup(:B,2)
B‚ÇÇ

julia> H=hecke(W,q^2;rootpara=q)
hecke(B‚ÇÇ,q¬≤,rootpara=q)

julia> char_values(Cpbasis(H)(1,2,1))
5-element Array{Pol{Int64},1}:
 -q-q‚Åª¬π        
 q+q‚Åª¬π         
 0             
 q¬≥+2q+2q‚Åª¬π+q‚Åª¬≥
 0             
```
"""
char_values(h::HeckeElt)=CharTable(h.H).irr*class_polynomials(h)

end
