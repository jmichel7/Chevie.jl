"""
This   module  ports   Chevie  functionality   for  Iwahori-Hecke  algebras
associated to Coxeter groups.

Let  (W,S) be a Coxeter  system where `mâ‚›â‚œ` is  the order of `st` for `s,tâˆˆ
S`. Let `R` be a commutative ring with 1 and for `sâˆˆ S` let `uâ‚›â‚€,uâ‚›â‚âˆˆ R` be
elements which depend ony on the conjugacy class of `s` in `W` (this is the
same  as requiring that `uâ‚›áµ¢=uâ‚œáµ¢` whenever `mâ‚›â‚œ` is odd). The Iwahori-Hecke
algebra of `W` over `R` with parameters `uâ‚›áµ¢` is a deformation of the group
algebra  of `W` over `R` defined as  follows: it is the unitary associative
`R`-algebra generated by elements `Tâ‚›, sâˆˆ S` subject to the relations:

``(Tâ‚›-uâ‚›â‚€)(Tâ‚›-uâ‚›â‚)=0`` for all `sâˆˆ S` (the quadratic relations)

``Tâ‚›Tâ‚œTâ‚›â€¦= Tâ‚œTâ‚›Tâ‚œâ€¦`` with `mâ‚›â‚œ` factors on each side (the braid relations)

If  `uâ‚›â‚€=1` and  `uâ‚›â‚=-1` for  all `s`  then the quadratic relations become
`Tâ‚›Â²=1` and the deformation of the group algebra is trivial.

Since  the generators `Tâ‚›` satisfy the  braid relations, the algebra `H` is
in  fact a quotient of the group algebra of the braid group associated with
`W`.  It follows that, if `w=s_1â‹¯ s_m`  is a reduced expression of `w âˆˆ W`
then  the  product  `Tâ‚›_1â‹¯ Tâ‚›_m`  depends  only  on `w`. We will therefore
denote by `T_w`. We have `T_1=1`.

If  one of `uâ‚›â‚€` or `uâ‚›â‚` is invertible  in `R`, for example `uâ‚›â‚`, then by
changing  the generators  to `Tâ€²â‚›=-Tâ‚›/uâ‚›â‚`,  and setting `qâ‚›=-uâ‚›â‚€/uâ‚›â‚`, the
braid  relations do no change  (since when `mâ‚›â‚œ` is  odd we have `uâ‚›áµ¢=uâ‚œáµ¢`)
but  the quadratic relations become  `(Tâ€²â‚›-qâ‚›)(Tâ€²â‚›+1)=0`. This last form is
the  most common  form considered  in the  literature. Another common form,
considered  in  the  context  of  Kazhdan-Lusztig  theory, is `uâ‚›â‚€=âˆšqâ‚›` and
`uâ‚›â‚=-âˆšqâ‚›â»Â¹`.  The general form of parameters provided is a special case
of general cyclotomic Hecke algebras, and can be useful in many contexts.

For  some  algebras  the  character  table,  and in general Kazhdan-Lusztig
bases,  require a square root of `-uâ‚›â‚€uâ‚›â‚`.  We provide a way to specify it
with  the  field  `.rootpara`  which  can  be  given  when constructing the
algebra. If not given a root is automatically extracted when needed (and we
know  how to compute it) by the function `RootParameter`. Note however that
sometimes  an  explicit  choice  of  root  is  necessary  which  cannot  be
automatically determined.

There  is a universal choice  for `R` and `uâ‚›áµ¢`:  Let `uâ‚›áµ¢:sâˆˆ S,iâˆˆ[0,1]` be
indeterminates   such  that  `uâ‚›áµ¢=uâ‚œáµ¢`  whenever  `mâ‚›â‚œ`  is  odd,  and  let
`A=â„¤[uâ‚›áµ¢]` be the corresponding polynomial ring. Then the Hecke algebra `H`
of  `W` over a  with parameters `uâ‚›áµ¢`  is called the *generic Iwahori-Hecke
algebra*  of  with  `W`.  Any  other  algebra  with parameters `vâ‚›áµ¢` can be
obtained  by specialization from  `H`: There is  a unique ring homomorphism
`f:A  â†’ R` such that `f(uâ‚›áµ¢)=vâ‚›áµ¢`  for all `i`. Then we  can view `R` as an
`A`-module via `f` and we can identify the other algebra to ``RâŠ— _A H``.

The  elements `{T_wâˆ£wâˆˆ W}` actually form an  `R`-basis of `H` if one of the
`uâ‚›áµ¢`  is invertible for all `s`. The  structure constants in that basis is
obtained  as  follows.  To  multiply  `T_v`  by  `T_w`,  choose  a  reduced
expression for `v`, say `v=s_1 â‹¯ s_k` and apply inductively the formula:

``T_sT_w=T_{sw}``               if `l(sw)=l(w)+1`

``T_sT_w=-uâ‚›â‚€uâ‚›â‚T_{sw}+(uâ‚›â‚€+uâ‚›â‚)T_w`` if `l(sw)=l(w)-1`.

If all `s` we have `uâ‚›â‚€=q`, `uâ‚›â‚=-1` then we call the corresponding algebra
the one-parameter or Spetsial Iwahori-Hecke algebra associated with `W`; it
can  be obtained with the  simplified call 'hecke(W,q)'. Certain invariants
of  the irreducible characters of  this algebra play a  special role in the
representation  theory of the underlying  finite Coxeter groups, namely the
`a`- and `A`-invariants. For basic properties of Iwahori-Hecke algebras and
their  relevance to the representation theory of finite groups of Lie type,
see for example Curtis and Reiner 1987, Sections~67 and 68.

In  the  following  example,  we  compute  the multiplication table for the
`0`-Iwahori--Hecke algebra associated with the Coxeter group of type `A_2`.

```julia-repl
julia> W=coxgroup(:A,2)
Aâ‚‚

julia> H=hecke(W,0)             # One-parameter algebra with `q=0`
hecke(Aâ‚‚,0)

julia> T=Tbasis(H);             # Create the `T` basis

julia> el=words(W)
6-element Array{Array{Int8,1},1}:
 []       
 [2]      
 [1]      
 [2, 1]   
 [1, 2]   
 [1, 2, 1]

julia> T.(el)*permutedims(T.(el))        # multiplication table
6Ã—6 Array{HeckeTElt{Perm{Int16},Int64,HeckeAlgebra{Int64,FiniteCoxeterGroup{Perm{Int16},Int64}}},2}:
 T.    Tâ‚‚     Tâ‚     Tâ‚‚â‚    Tâ‚â‚‚    Tâ‚â‚‚â‚ 
 Tâ‚‚    -Tâ‚‚    Tâ‚‚â‚    -Tâ‚‚â‚   Tâ‚â‚‚â‚   -Tâ‚â‚‚â‚
 Tâ‚    Tâ‚â‚‚    -Tâ‚    Tâ‚â‚‚â‚   -Tâ‚â‚‚   -Tâ‚â‚‚â‚
 Tâ‚‚â‚   Tâ‚â‚‚â‚   -Tâ‚‚â‚   -Tâ‚â‚‚â‚  -Tâ‚â‚‚â‚  Tâ‚â‚‚â‚ 
 Tâ‚â‚‚   -Tâ‚â‚‚   Tâ‚â‚‚â‚   -Tâ‚â‚‚â‚  -Tâ‚â‚‚â‚  Tâ‚â‚‚â‚ 
 Tâ‚â‚‚â‚  -Tâ‚â‚‚â‚  -Tâ‚â‚‚â‚  Tâ‚â‚‚â‚   Tâ‚â‚‚â‚   -Tâ‚â‚‚â‚

```
Thus,  we work  with algebras  with arbitrary  parameters. We will see that
this also works on the level of characters and representations.
 
finally, benchmarks on julia 1.0.2
```benchmark
julia> function test_w0(n)
         W=coxgroup(:A,n)
         Tbasis(hecke(W,Pol([1],1)))(longest(W))^2
       end
test_w0 (generic function with 1 method)

julia> @btime test_w0(7);
  132.737 ms (1788153 allocations: 157.37 MiB)
```
Compare to GAP3 where the following function takes 0.92s
```
test_w0:=function(n)local W,T,H;
  W:=CoxeterGroup("A",n);H:=Hecke(W,X(Rationals));T:=Basis(H,"T");
  T(LongestCoxeterWord(W))^2;
end;
```
"""
module HeckeAlgebras
using Gapjm
export HeckeElt, Tbasis, central_monomials, hecke, HeckeAlgebra, HeckeTElt, 
  rootpara, equalpara, class_polynomials, char_values, schur_elements,
  isrepresentation

struct HeckeAlgebra{C,TW}
  W::TW
  para::Vector{Vector{C}}
  prop::Dict{Symbol,Any}
end

"""
   hecke( W [, parameter][,rootpara=r]) return a Hecke algebra for W

# Example
```julia-repl
julia> W=coxgroup(:B,2)
Bâ‚‚

julia> Pol(:q)
Pol{Int64}: q

julia> H=hecke(W,q)
hecke(Bâ‚‚,q)

julia> H.para
2-element Array{Array{Pol{Int64},1},1}:
 [q, -1]
 [q, -1]

julia> H=hecke(W,q^2,rootpara=q)
hecke(Bâ‚‚,qÂ²,rootpara=q)

julia> H.para,rootpara(H)
(Array{Pol{Int64},1}[[qÂ², -1], [qÂ², -1]], Pol{Int64}[q, q])

julia> H=hecke(W,[q^2,q^4],rootpara=[q,q^2])
hecke(Bâ‚‚,Pol{Int64}[qÂ², qâ´],rootpara=Pol{Int64}[q, qÂ²])

julia> H.para,rootpara(H)
(Array{Pol{Int64},1}[[qÂ², -1], [qâ´, -1]], Pol{Int64}[q, qÂ²])

julia> H=hecke(W,9,rootpara=3)
hecke(Bâ‚‚,9,rootpara=3)

julia> H.para,rootpara(H)
([[9, -1], [9, -1]], [3, 3])
```
"""
function hecke(W::Group,para::Vector{Vector{C}};rootpara::Vector{C}=C[]) where C
  para=map(eachindex(gens(W)))do i
    j=simple_representatives(W)[i]
    if i<=length(para) 
     if j<i && para[i]!=para[j] error("one should have  para[$i]==para[$j]") end
      return para[i]
    elseif j<i return para[j]
    else error("parameters should be given for first reflection in a class")
    end
  end
  d=Dict{Symbol,Any}(:equal=>constant(para))
  if !isempty(rootpara) d[:rootpara]=rootpara end
  HeckeAlgebra(W,para,d)
end

function hecke(W::Group,p::Vector{C};rootpara::Vector{C}=C[])where C
  oo=order.(gens(W))
  if all(isequal(2),oo) z=0 else z=zero(Cyc) end
  para=map(p,oo)do p, o
    if o==2 return [p,-one(p)].+z end
    map(i->iszero(i) ? p+z : zero(p)+E(o,i),0:o-1)
  end
  hecke(W,para;rootpara=convert(Vector{eltype(para[1])},rootpara))
end
  
function hecke(W::Group,p::C=1;rootpara::C=zero(C))where C
  rootpara= iszero(rootpara) ? C[] : fill(rootpara,nbgens(W))
  hecke(W,fill(p,nbgens(W));rootpara=rootpara)
end

function hecke(W::Group,p::Tuple;rootpara=zero(p[1]))
  rootpara= iszero(rootpara) ? typeof(p[1])[] : fill(rootpara,nbgens(W))
  hecke(W,[collect(p) for j in 1:nbgens(W)];rootpara=rootpara)
end

function rootpara(H::HeckeAlgebra)
  gets(H,:rootpara)do
    map(eachindex(H.para)) do i
       if isone(-prod(H.para[i])) return -prod(H.para[i]) end
       return root(-prod(H.para[i]))
    end
  end
end

equalpara(H::HeckeAlgebra)::Bool=H.prop[:equal]

function Base.show(io::IO, H::HeckeAlgebra)
  print(io,"hecke(",H.W,",")
  tr(p)= p[2]==-one(p[2]) ? p[1] : p
  if constant(H.para) print(io,tr(H.para[1]))
  else print(io,map(tr,H.para))
  end
  if haskey(H.prop,:rootpara)
    rp=rootpara(H)
    if constant(rp) print(io,",rootpara=",rp[1])
    else print(io,",rootpara=",rp)
    end
  end
  print(io,")")
end

function Chars.CharTable(H::HeckeAlgebra)
  gets(H,:chartable)do
    W=H.W
    cts=map(refltype(W))do t
       getchev(t,:HeckeCharTable,H.para[t.indices], haskey(H.prop,:rootpara) ? 
               rootpara(H)[t.indices] : fill(nothing,length(H.para)))
    end
    cts=map(cts) do ct
      if haskey(ct,:irredinfo) names=getindex.(ct[:irredinfo],:charname)
      else                     names=charinfo(W)[:charnames]
      end
      CharTable(improve_type(toM(ct[:irreducibles])),names,ct[:classnames],
             map(Int,ct[:centralizers]),ct[:identifier],Dict{Symbol,Any}())
    end
    prod(cts)
  end
end

function Chars.representation(H::HeckeAlgebra,i::Int)
  tt=refltype(H.W)
  dims=Tuple(getchev.(tt,:NrConjugacyClasses))
  inds=reverse(Tuple(CartesianIndices(reverse(dims))[i]))
  rp=haskey(H.prop,:rootpara) ? rootpara(H) : fill(nothing,length(H.para))
  mm=map((t,j)->toM.(getchev(t,:HeckeRepresentation,H.para,rp,i)),tt,inds)
  if any(x->x==false,mm) return false end
  mm=improve_type.(mm)
  n=length(tt)
  if n==1 return mm[1] end
  id(i)=fill(1,i,i)^0
  vcat(map(1:n) do i
         map(mm[i]) do m
           cat(map(j->j==i ? m : mm[j][1]^0,1:n)...;dims=(1,2))
         end
       end...)
end

Chars.representations(H::HeckeAlgebra)=representation.(Ref(H),1:HasType.NrConjugacyClasses(H.W))

"""
`isrepresentation(H::HeckeAlgebra,r)`

returns `true` or `false`, according  to whether a  given set `r` of matrices
corresponding to the standard generators  of the Coxeter group `H.W`
defines a representation of the Iwahori-Hecke algebra `H` or not.

```julia-repl
julia> H=hecke(coxgroup(:F,4))
hecke(Fâ‚„,1)

julia> isrepresentation(H,refrep(H))
true
```
"""
function isrepresentation(H::HeckeAlgebra,t;verbose=false)
  W=H.W
  res=true
  for i in eachindex(gens(W))
    e=prod(q->(t[i]-q.*one(t[i])),H.para[i])
    if !iszero(e)
      if verbose
        println("Error in ",ordinal(i)," parameter relation");
        res=false
      else return false
      end
    end
  end
  for (l,r) in braid_relations(W)
    e=prod(t[l])-prod(t[r])
    if !iszero(e)
       if verbose
          println("Error in relation ",l,"=",r)
          res=false
       else return false
       end
    end
  end
  res
end

"""
`refrep(H)`

returns  a list of matrices which give the reflection representation of the
Iwahori-Hecke algebra `H`.

```julia-repl
julia> Pol(:q);W=coxgroup(:B,2);H=hecke(W,q)
hecke(Bâ‚‚,q)

julia> refrep(H)
2-element Array{Array{Pol,2},1}:
 [-1 0; -q q]
 [q -2; 0 -1]

julia> H=hecke(coxgroup(:H,3))
hecke(Hâ‚ƒ,1)

julia> refrep(H)
3-element Array{Array{Cyc{Rational{Int64}},2},1}:
 [-1 0 0; -1 1 0; 0 0 1]
 [1 (-3-âˆš5)/2 0; 0 -1 0; 0 -1 1]
 [1 0 0; 0 1 -1; 0 0 -1]
```
"""
function PermRoot.refrep(H::HeckeAlgebra)
  W=H.W
  if !equalpara(H) || !(W isa CoxeterGroup)
        error("Reflexion representation of Cyclotomic Hecke algebras or\n",
          "Hecke algebras with unequal parameters not implemented")
  end
  q=-1*H.para[1][1]//H.para[1][2]
  r=length(gens(W))
  C=fill(q*E(1),r,r)
  CM=coxmat(W)
  for i  in eachindex(gens(W))
    for j  in 1:i-1
      m=CM[i,j]
      if m!=0 m=E(m)+E(m,-1) else m=2 end
      C[i,j]=2+m
      if m==-2 C[j,i]=0 else C[j,i]=q end
    end
    C[i,i]=q+1
  end
  map(eachindex(gens(W)))do i
    a=fill(0*q*E(1),r,r)
    for j  in eachindex(gens(W))
      a[j,j]=q
      a[j,i]-=C[i,j]
    end
    -H.para[1][2]*a
  end
end 

function Chars.WGraphToRepresentation(H::HeckeAlgebra,gr::Vector)
  S=-H.para[1][2]*WGraphToRepresentation(length(H.para),gr,
                                   rootpara(H)[1]//H.para[1][2])
  if !isrepresentation(H,S;verbose=true) error() end
  S
end

"""
central_monomials(H)
  Let  `H` be an Hecke  algebra for the reflection  group `W`. The function
  returns  the  scalars  by  which  the  image  in  `H`  of  Ï€  acts on the
  irreducible  representations of  the Iwahori-Hecke  algebra. When  `W` is
  irreducible, Ï€ is the generator of the center of the pure braid group. In
  general,  it  is  the  product  of  such  elements  for  each irreducible
  component. When `W` is an irreducible Coxeter group, Ï€ is the lift to the
  braid group of the square of the longest element of `W`.

```julia-repl
julia> H=hecke(coxgroup(:H,3),Pol(:q))
hecke(Hâ‚ƒ,q)

julia> central_monomials(H)
10-element Array{Pol{Cyc{Int64}},1}:
 1  
 qÂ³â°
 qÂ¹Â²
 qÂ¹â¸
 qÂ¹â°
 qÂ¹â°
 qÂ²â°
 qÂ²â°
 qÂ¹âµ
 qÂ¹âµ
```
"""
function central_monomials(H::HeckeAlgebra)
# Cf. BrMi, 4.16 for the formula used
  W=H.W
  v=hyperplane_orbits(W)
  map(eachrow(CharTable(W).irr)) do irr
    prod(v)do C
      q=H.para[restriction(W)[C.s]]
      m=map(0:C.order-1)do j
       (irr[1]+sum(l->irr[C.cl_s[l]]*E(C.order,-j*l),1:C.order-1))//C.order
      end
      E.(irr[1],-C.N_s*sum(m.*(0:C.order-1)))*
          prod(j->q[j]^Int(C.N_s*C.order*m[j]//irr[1]),1:C.order)
    end
  end
end

#--------------------------------------------------------------------------
abstract type HeckeElt{P,C} end

Base.zero(h::HeckeElt)=clone(h,zero(h.d))
Base.iszero(h::HeckeElt)=iszero(h.d)

function Base.show(io::IO, h::HeckeElt)
  function showbasis(io::IO,e)
    repl=get(io,:limit,false)
    TeX=get(io,:TeX,false)
    w=word(h.H.W,e)
    res=basename(h)
    if repl || TeX
      if isempty(w) res*="."
      else res*="_{"*(any(>=(10),w) ? join(w,",") : join(w))*"}"
      end
    else res*="("*join(map(x->"$x",w),",")*")"
    end
    fromTeX(io,res)
  end
  show(IOContext(io,:showbasis=>showbasis),h.d)
end


Base.:+(a::HeckeElt, b::HeckeElt)=clone(a,a.d+b.d)
Base.:-(a::HeckeElt)=clone(a,-a.d)
Base.:-(a::HeckeElt, b::HeckeElt)=a+(-b)

Base.:*(a::HeckeElt, b)=clone(a,a.d*b)
Base.:*(a::HeckeElt, b::Pol)=clone(a,a.d*b)
Base.:*(a::HeckeElt, b::Mvp)=clone(a,a.d*b)
Base.:*(b::Pol, a::HeckeElt)=a*b
Base.:*(b::Mvp, a::HeckeElt)=a*b
Base.:*(b::Number, a::HeckeElt)= a*b

Base.:^(a::HeckeElt, n::Integer)= n>=0 ? Base.power_by_squaring(a,n) : 
                                   Base.power_by_squaring(inv(a),-n)
#--------------------------------------------------------------------------
struct HeckeTElt{P,C1,TH<:HeckeAlgebra}<:HeckeElt{P,C1}
  d::ModuleElt{P,C1} # has better merge performance than Dict
  H::TH
end

clone(h::HeckeTElt,d)=HeckeTElt(d,h.H)

basename(h::HeckeTElt)="T"
 
function Base.one(H::HeckeAlgebra{C}) where C
  HeckeTElt(ModuleElt(one(H.W)=>one(C)),H)
end

function Base.zero(H::HeckeAlgebra{C}) where C
  HeckeTElt(zero(ModuleElt{typeof(one(H.W)),C}),H)
end

Tbasis(h::HeckeTElt)=h

function Tbasis(H::HeckeAlgebra{C,TW})where C where TW<:CoxeterGroup{P} where P
  function f(w::Vararg{Integer})
    if isempty(w) return one(H) end
    HeckeTElt(ModuleElt(H.W(w...)=>one(C)),H)
  end
  f(w::Vector{<:Integer})=f(w...)
  f(w::P)=HeckeTElt(ModuleElt(w=>one(C)),H)
# eval(:(Base.show(io::IO,t::typeof($f))=print(io,"Tbasis(",$H,")")))
  f(h::HeckeElt)=Tbasis(h)
end

function Base.:*(a::HeckeTElt, b::HeckeTElt)
  if iszero(a) return a end
  if iszero(b) return b end
  W=a.H.W
  sum(a.d) do (ea,pa)
    h=b.d*pa
    for i in reverse(word(W,ea))
      s=gens(W)[i]
      up=empty(h.d)
      down=empty(h.d)
      for (e,p)  in h
        if isleftdescent(W,e,i) push!(down,e=>p) 
        else push!(up,s*e=>p) end
      end
      h=ModuleElt(up;check=true)
      if !isempty(down)
        pp=a.H.para[i]
        ss,p=(sum(pp),-prod(pp))
        if !iszero(ss) h+=ModuleElt(down)*ss end
        if !iszero(p)  
          let s=s, p=p
            h+=ModuleElt([s*e=>c*p for (e,c) in down];check=true)
          end
        end
      end
    end
    HeckeTElt(h,a.H)
  end
end

function Base.inv(a::HeckeTElt)
  if length(a.d)!=1 error("can only invert single T(w)") end
  w,coeff=first(a.d)
  H=a.H
  T=Tbasis(H)
  l=reverse(word(H.W,w))
  inv(coeff)*prod(i->inv(prod(H.para[i]))*(T()*sum(H.para[i])-T(i)),l)
end

"""
`class_polynomials(h)`

returns the class polynomials of the Hecke element `h` of the Hecke algebra
`H=h.H`  with respect  to representatives  `reps` of  minimal length in the
conjugacy  classes  of  the  Coxeter  group  `W=H.W`.  Such  minimal length
representatives  are given by  the function `classinfo(W)[:classtext]`. The
vector  `p` of these polynomials has the property that if `X` is the matrix
of  the values of  the irreducible characters  of `H` on  `T_w` (for `w` in
`reps`),  then the product `X*p`  is the list of  values of the irreducible
characters on `h`.

```julia-repl
julia> W=CoxSym(4)
ð”– â‚„

julia> H=hecke(W,Pol(:q))
hecke(ð”– â‚„,q)

julia> h=Tbasis(H)(longest(W))
Tâ‚â‚‚â‚â‚ƒâ‚‚â‚

julia> p=class_polynomials(h)
5-element Array{Pol{Int64},1}:
 0        
 0        
 qÂ²       
 qÂ³-2qÂ²+q 
 qÂ³-qÂ²+q-1
```
The class polynomials were introduced in  cite{GP93}.
"""
function class_polynomials(h)
  H=h.H
# if IsBound(h.coset) WF=Spets(h.coset); W=Group(WF);
# else 
    W=H.W
    WF=W
# end
  minl=length.(classinfo(WF)[:classtext])
  h=Tbasis(H)(h)
# Since  vF is not of minimal length in its class there exists wF conjugate
# by   cyclic  shift  to  vF  and  a  generating  reflection  s  such  that
# l(swFs)=l(vF)-2. Return T_sws.T_s^2
  function orb(w)
    orbit=[w]
    for w in orbit
      for s in leftdescents(W,w)
        sw=W(s)*w
        sws=sw*W(s)
        if isleftdescent(W,inv(sw),s) 
          q1,q2=H.para[s]
          return (elm=[sws,sw],coeff=[-q1*q2,q1+q2])
        elseif !(sws in orbit) push!(orbit,sws)
        end
      end
    end
    error("Geck-Kim-Pfeiffer theory")
  end

  elm,coeff=first(h.d)
  min=fill(zero(coeff),length(minl))
  while length(h.d)>0
    elms=typeof(elm)[]
    coeffs=typeof(coeff)[]
    l=[length(W,elm) for (elm,coeff) in h.d]
    maxl=maximum(l)
    for (elm,coeff) in h.d
      if length(W,elm)<maxl 
        push!(elms,elm)
        push!(coeffs,coeff)
      else
        p=position_class(WF,elm)
        if minl[p]==maxl min[p]+=coeff
        else o=orb(elm)
          append!(elms,o.elm)
          append!(coeffs,o.coeff.*coeff)
        end
      end
    end
    h=clone(h,ModuleElt(Pair.(elms,coeffs);check=true))
  end
  return min
end

"""
`char_values(h)`

`h`  is an  element of  an Iwahori-Hecke  algebra `H`  (in any  basis). The
function  returns the  values of  the irreducible  characters of `H` on `h`
(the   method  used  is  to  convert  to   the  `T`  basis,  and  then  use
`class_polynomials`).

```julia-repl
julia> W=coxgroup(:B,2)
Bâ‚‚

julia> H=hecke(W,q^2;rootpara=q)
hecke(Bâ‚‚,qÂ²,rootpara=q)

julia> char_values(Cpbasis(H)(1,2,1))
5-element Array{Pol{Int64},1}:
 -q-qâ»Â¹        
 q+qâ»Â¹         
 0             
 qÂ³+2q+2qâ»Â¹+qâ»Â³
 0             
```
"""
char_values(h::HeckeElt,ch=CharTable(h.H).irr)=ch*class_polynomials(h)

"""
`schur_elements(H)`

returns the list of Schur elements for the (cyclotomic) Hecke algebra `H`

```julia-repl
julia> H=hecke(ComplexReflectionGroup(4),Pol(:q))
hecke(Gâ‚„,Pol{Cyc{Int64}}[q, Î¶â‚ƒ, Î¶â‚ƒÂ²])

julia> s=schur_elements(H)
7-element Array{Pol{Cyc{Rational{Int64}}},1}:
 qâ¸+2qâ·+3qâ¶+4qâµ+4qâ´+4qÂ³+3qÂ²+2q+1              
 2âˆš-3+(6+4âˆš-3)qâ»Â¹+12qâ»Â²+(6-4âˆš-3)qâ»Â³+(-2âˆš-3)qâ»â´
 -2âˆš-3+(6-4âˆš-3)qâ»Â¹+12qâ»Â²+(6+4âˆš-3)qâ»Â³+(2âˆš-3)qâ»â´
 2+2qâ»Â¹+4qâ»Â²+2qâ»Â³+2qâ»â´                        
 (-2Î¶â‚ƒ-Î¶â‚ƒÂ²)qÂ³+(3-âˆš-3)qÂ²+3q+3+âˆš-3+(-Î¶â‚ƒ-2Î¶â‚ƒÂ²)qâ»Â¹
 (-Î¶â‚ƒ-2Î¶â‚ƒÂ²)qÂ³+(3+âˆš-3)qÂ²+3q+3-âˆš-3+(-2Î¶â‚ƒ-Î¶â‚ƒÂ²)qâ»Â¹
 qÂ²+2q+2+2qâ»Â¹+qâ»Â²                             

julia> CycPol.(s)
7-element Array{CycPol{Cyc{Rational{Int64}}},1}:
 Î¦â‚‚Â²Î¦â‚ƒÎ¦â‚„Î¦â‚†             
 (2âˆš-3)qâ»â´Î¦â‚‚Â²Î¦â€²â‚ƒÎ¦â€²â‚†    
 (-2âˆš-3)qâ»â´Î¦â‚‚Â²Î¦â€³â‚ƒÎ¦â€³â‚†   
 2qâ»â´Î¦â‚ƒÎ¦â‚„              
 (-2Î¶â‚ƒ-Î¶â‚ƒÂ²)qâ»Â¹Î¦â‚‚Â²Î¦â€²â‚ƒÎ¦â€³â‚†
 (-Î¶â‚ƒ-2Î¶â‚ƒÂ²)qâ»Â¹Î¦â‚‚Â²Î¦â€³â‚ƒÎ¦â€²â‚†
 qâ»Â²Î¦â‚‚Â²Î¦â‚„              
```
"""
function schur_elements(H::HeckeAlgebra)
  W=H.W
  map(p->getchev(W,:SchurElement,p,H.para,
     haskey(H.prop,:rootpara) ? rootpara(H) : fill(nothing,length(H.para)))[1],
      first.(charinfo(W)[:charparams]))
end
#---------------------- Hecke Cosets

struct HeckeCoset{TH<:HeckeAlgebra,TW<:Spets}
  H::TH
  W::TW
  prop::Dict{Symbol,Any}
end

hecke(WF::Spets,H::HeckeAlgebra)=HeckeCoset(H,WF,Dict{Symbol,Any}())
hecke(WF::Spets,a...;b...)=HeckeCoset(hecke(Group(WF),a...;b...),WF)

function Base.show(io::IO, H::HeckeCoset)
  print(io,"hecke(",H.W,",")
  tr(p)= p[2]==-one(p[2]) ? p[1] : p
  if constant(H.H.para) print(io,tr(H.H.para[1]))
  else print(io,map(tr,H.H.para))
  end
  if haskey(H.H.prop,:rootpara)
    rp=rootpara(H.H)
    if constant(rp) print(io,",rootpara=",rp[1])
    else print(io,",rootpara=",rp)
    end
  end
  print(io,")")
end

function Chars.CharTable(H::HeckeCoset)
  gets(H,:chartable)do
    W=H.W
    cts=map(refltype(W))do t
      inds=t.orbit[1].indices
      getchev(t,:HeckeCharTable,H.H.para[inds], haskey(H.H.prop,:rootpara) ? 
               rootpara(H.H)[inds] : fill(nothing,length(H.H.para)))
    end
    cts=map(cts) do ct
      if haskey(ct,:irredinfo) names=getindex.(ct[:irredinfo],:charname)
      else                     names=charinfo(W)[:charnames]
      end
      CharTable(improve_type(toM(ct[:irreducibles])),names,ct[:classnames],
                map(Int,ct[:centralizers]),ct[:identifier],Dict{Symbol,Any}())
    end
    prod(cts)
  end
end
end
