"""
Let  `V` be a vector  space over a subfield  `K` of the complex numbers (in
Julia  the elements  of `K`  will be  usually represented by `Rational`s or
`Cyc`s).

A *complex reflection* is an element `s∈ GL(V)` of finite order whose fixed
point  set is  a hyperplane,  the *reflecting  hyperplane* `Hₛ` of `s`.

Most  of the  time we  abbreviate "complex  reflection" to *reflection*; in
some  literature "reflection" is reserved for  `s` of order 2 and otherwise
*pseudo-reflection* is used.

A  reflection `s` has a unique eigenvalue `ζₛ` not equal to `1`, which is a
root  of  unity;  if  `K`  is  a  subfield  of  the  real  numbers, `ζₛ` is
necessarily  equal to `-1` and `s` is of  order 2. An eigenvector `r∈ V` of
`s`  for the eigenvalue  `ζₛ` is called  a *root* of  `s` and a linear form
`rᵛ`  on `V` of  kernel `Hₛ` is  called a *coroot*  of `s`. Usually `r` and
`rᵛ`  are scaled so that `rᵛ(r)=1-ζ`; then `s` is the map on `V` defined by
`s(x)=x-rᵛ(x)r`.  Such roots and  coroots for `s`  are unique up to scaling
the root and inversely scaling the coroot.

A  finite  complex  reflection  group  `W`  is  a finite group generated by
complex  reflections.  Since  whenever  `W`  contains  a  reflection `s` it
contains  its powers, `W` is always  generated by reflections `s` such that
`ζₛ==E(d)`  where `d` is the  order of `s`; we  can also assume that `s` is
not  a  power  of  another  reflection  of  `W`  with  larger order. Such a
reflection is called a *distinguished* reflection of `W`; it is a canonical
generator  of the cyclic subgroup of  `W` centralizing `Hₛ`. The generators
of  the  complex  reflection  groups  we construct are always distinguished
reflections; the set of distinguished reflections are in bijection with the
reflecting  hyperplanes.  In  a  real  reflection group all reflections are
distinguished.

It  is much  more efficient  to compute  with permutation  groups than with
matrix  groups; hence we use for computing with a finite complex reflection
group  `W` a permutation representation on  a `W`-invariant set of root and
coroot vectors for reflections of `W`; that is, a set `R` of pairs `(r,rᵛ)∈
V×Vᵛ`  invariant by `W` and such that every distinguished reflection in `W`
is determined by some pair in `R` (see [`reflectionMatrix`](@ref)). Using a
`W`-invariant set implies that there are several pairs determining the same
reflection,  which differ  by roots  of unity.  This generalizes  the usual
construction  for Coxeter groups (the case `K=ℝ `) where to each reflection
of `W` is associated two roots, one positive and one negative.

A  complex reflection group  is *irreducible* if  the representation `V` is
irreducible.  For irreducible complex reflection groups, there are at least
as  many roots for a given distinguished reflection as the lcm of the order
of the reflection and of the order of the center of `W`.

The  following  methods  are  always  defined for finite complex reflection
groups:

  - `gens(W)`: the (distinguished) reflections which generate `W`, given as
    permutations of the roots. `reflrep(W)` gives them as matrices.

  - `roots(W)`: the list of roots of `W`.

  - `coroots(W)`: the list of coroots, in the same order as the roots.

  - `refls(W)`:  a list of  distinguished reflections of  `W`, as permutations.
    This list is of same length as the roots, and its `i`-th element is the
    distinguished   reflection  for  the  `i`-th  root,  so  it  will  have
    repetitions. `unique_refls(W)` returns a sublist of
    `1:length(roots(W))` such that the distinguished reflections around the
    corresponding  roots reach one time  only each distinguished reflection
    of `W`.

The  lists  `roots`,  `coroots`  and  `refls`  starts with the ones for the
reflections  `gens(W)`;  these  are  called  *simple* roots and coroots and
*simple* reflections.

  - `simpleroots(W)`:  the simple roots as a matrix.

  - `simplecoroots(W)`:  the simple coroots as a matrix.

  - `reflections(W)` gives a list without repetitions of all reflections of
    `W`   (not   only   the   distinguished   ones),  as  objects  of  type
    [`Reflection`](@ref),  starting  with  the  distinguished  reflections.
    These objects contain more information on each reflection.

The  finite irreducible complex  reflection groups have  been classified by
Shephard and Todd, see [ShephardTodd1954](biblio.htm#ST54). They consist of
one  infinite family `G(de,e,r)` depending  on 3 parameters (which includes
the infinite families of Weyl groups), and 34 exceptional groups which have
been given by Shephard and Todd names which range from `G₄` to `G₃₇`. These
exceptional   groups   include   the   exceptional   Weyl   groups,   e.g.,
`coxgroup(:E,8)` is the same as `G₃₇`.

We provide functions to build any finite reflection group, either by giving
a  list of simple roots and simple coroots (see [`PRG`](@ref)), or in terms
of  the  classification  (see  [`complex_reflection_group`](@ref)).  In the
context  e.g. of  Weyl groups,  one wants  to describe  the particular root
system chosen in term of the traditional classification of crystallographic
root systems. This is done via calls to the function
[`coxeter_group`](@ref) (see the module [`Weyl`](@ref)). There is not yet a
general  theory on  how to  construct a  nice set  of roots  for a non-real
reflection  group;  the  roots  chosen  here  where  obtained case-by-case;
however, they satisfy several important properties:

  - The simple reflections  satisfy braid relations  which present the
    braid group associated to `W` (see [`diagram`](@ref)).

  - The *field  of definition*  of `W`  is the  field `K` generated by the
    traces  of the elements of `W` acting on  `V`. It is a theorem that `W`
    may be realized as a reflection group over `K`.

  - The Cartan matrix `rᵛ(r')` where `r` and `r'` runs over the simple roots
    and  coroots has entries in  the ring `ℤₖ` of  integers of `K`, and the
    other  roots (resp. coroots) are  linear combinations with coefficients
    in `ℤₖ` of a linearly independent subset of them.

It  turns out that all representations of `W` are defined over the field of
definition `K` (see. [Benard1976](biblio.htm#Ben76) and D.~Bessis' thesis).
This  has been known for a  long time in the case  `K=ℚ `, the case of Weyl
groups, whose representations are all integral.

```julia-repl
julia> W=complex_reflection_group(4)
G₄

julia> gens(W) # as permutations of the 24 roots
2-element Vector{Perm{Int16}}:
 (1,3,9)(2,4,7)(5,10,18)(6,11,16)(8,12,19)(13,15,20)(14,17,21)(22,23,24)
 (1,5,13)(2,6,10)(3,7,14)(4,8,15)(9,16,22)(11,12,17)(18,19,23)(20,21,24)

julia> length(unique(refls(W)))
4

julia> length(refls(W)) # 24=4*(number of roots of unity in ℚ (ζ₃))
24

julia> reflrep(W) # the generators as matrices
2-element Vector{Matrix{Cyc{Rational{Int64}}}}:
 [1 0; 0 ζ₃]
 [√-3/3 -ζ₃²√-3/3; (-3+√-3)/3 -ζ₃√-3/3]
```
For  almost  all  irreducible  complex  reflection  groups,  the generating
matrices  for `W` we give have coefficients in the field of definition `K`.
Further,  the set of matrices for all elements of `W` is globally invariant
under  the  Galois  group  of  `K/ℚ  `,  thus  the  Galois  action  induces
automorphisms  of `W`. The exceptions are `G₂₂, G₂₇` where the matrices are
in  a  degree  two  extension  of  `K`  (this  is needed to have a globally
invariant  model, see [MarinMichel2010](biblio.htm#MarinMichel10)) and some
dihedral  groups, as well as  `H₃` and `H₄`, where  the matrices given (the
usual   Coxeter  reflection  representation  over  `K`)  are  not  globally
invariant (but one can get invariant ones by
`chevieget(:H4,:InvariantModel)`).

```julia-repl
julia> braid_relations(W) # as tuples of equal words in the generators
1-element Vector{Tuple{Vector{Int64}, Vector{Int64}}}:
 ([1, 2, 1], [2, 1, 2])

julia> diagram(W) # the same in pictures
③ ——③ G₄
1   2

julia> cartan(W)
2×2 Matrix{Cyc{Rational{Int64}}}:
 ζ₃²√-3     ζ₃²
   -ζ₃²  ζ₃²√-3

julia> simpleroots(W)
2×2 Matrix{Cyc{Rational{Int64}}}:
    0  ζ₃²√-3
 2ζ₃²     ζ₃²

julia> simplecoroots(W)
2×2 Matrix{Cyc{Rational{Int64}}}:
     0      1
 √-3/3  √-3/3
```

Let `SV` be the symmetric algebra of `V`. The invariants of `W` in `SV` are
called the *polynomial invariants* of `W`. If `n=dim V`, they are generated
as   a  polynomial  ring  by   `n`  homogeneous  algebraically  independent
polynomials `f₁,…,fₙ`. The polynomials `fᵢ` are not uniquely determined but
their  degrees are. The `fᵢ` are called  the *basic invariants* of `W`, and
their  degrees the *reflection  degrees* of `W`;  the function `degrees(W)`
returns these invariants.

Let  `I` be the  ideal generated by  the homogeneous invariants of positive
degree  in `SV`. Then `SV/I` is isomorphic to the regular representation of
`W`  as a  `W`-module. It  is thus  a graded  (by the degree of elements of
`SV`)  version of the  regular representation of  `W`. The polynomial which
gives  the graded  multiplicity of  a character  `φ` of  `W` in  the graded
module   `SV/I`  is  called   the  *fake  degree*   of  `φ`.  The  function
`fakedegrees` returns these polynomials.

```julia-repl
julia> degrees(W)
2-element Vector{Int64}:
 4
 6

julia> fakedegrees(W,Pol(:x))
7-element Vector{Pol{Int64}}:
 1
 x⁴
 x⁸
 x⁷+x⁵
 x⁵+x³
 x³+x
 x⁶+x⁴+x²
```
"""
module PermRoot

export PermRootGroup, PRG, PRSG, reflection_subgroup, simple_reps, roots,
  simple_conjugating, refls, unique_refls, asreflection, reflectionMatrix,
  refltype, reflection_type, cartan, independent_roots, inclusion, 
  inclusiongens, restriction, coroot, TypeIrred, 
  refleigen, reflection_eigenvalues,
  reflchar, reflection_character,
  bipartite_decomposition, torus_order, PermX, coroots, baseX,
  invbaseX, semisimplerank, invariant_form, generic_order, parabolic_reps,
  invariants, YMatrix, PermY, simpleroots, simplecoroots, action, radical,
  parabolic_closure, isparabolic, central_action, 
  reflrep, reflection_representation,
  nhyp, number_of_hyperplanes,
  nref, number_of_reflections,
  coxnum, coxeter_number,
  indices
using ..Chevie

"""
`coroot(r,λ=-1)`

the coroot for a unitary reflection of root `r` and eigenvalue `λ`.
"""
function coroot(root::AbstractVector,eigen::Number=-1)
  cr=conj(root)
  cr*((1-eigen)//(transpose(cr)*root))
end

"""
`reflectionMatrix(root,  coroot)` the matrix of the reflection with a given
root and coroot.

A (complex) reflection is a finite order element `s` of `GL(V)`, the linear
group of a vector space over a subfield of the complex numbers, whose fixed
points  form  a  hyperplane  `H`  (the  *reflecting hyperplane* of `s`); an
eigenvector  `r` for  the non-trivial  eigenvalue `ζ`  (a root of unity) is
called  a *root* of `s`. If we choose  a linear form `rᵛ` defining `H` such
that `rᵛ(r)=1-ζ` (a *coroot* of `s`) then `s` is given by `x↦ x-rᵛ(x)r`.

A  way  of  specifying  `s`  is  by  giving  a root and a coroot, which are
uniquely determined by `s` up to multiplication of the root by a scalar and
of  the coroot by the inverse scalar. The function `reflectionMatrix` gives
the  matrix of the  corresponding reflection in  the standard basis of `V`,
where  the `root` and the `coroot` are  vectors given in the standard bases
of `V` and `Vᵛ`, so the pairing `rᵛ(r)` is obtained as
`transpose(root)*coroot`.

```
julia> r=reflectionMatrix([1,0,0],[2,-1,0])
3×3 Matrix{Int64}:
 -1  0  0
  1  1  0
  0  0  1

julia> r==reflrep(coxgroup(:A,3),1)
true

julia> r*[2,-1,0]
3-element Vector{Int64}:
 -2
  1
  0

julia> [1 0 0]*r
1×3 Matrix{Int64}:
 -1  0  0
```
As  we see in the last lines, in  Julia a matrix operates from the right on
the  vector space `V`  of row vectors  and from the  left on the dual space
`Vᵛ` of column vectors.
"""
reflectionMatrix(r::AbstractVector,cr::AbstractVector)=I-cr*transpose(r)

"""
`reflectionMatrix(r, ζ=-1)`

returns the matrix of the unitary complex reflection determined by the root
`r` and the eigenvalue `ζ`, that is, when the vector space and its dual are
identified  via the scalar product `<x,y>=transpose(x)*conj(y)`; the coroot
`rᵛ` is then equal to the linear form `x->(1-ζ)<x,r>/<r,r>`.
```julia-repl
julia> reflectionMatrix([1,0,-E(3,2)])
3×3 Matrix{Cyc{Rational{Int64}}}:
  0  0  ζ₃²
  0  1    0
 ζ₃  0    0
```
"""
function reflectionMatrix(r::AbstractVector,l::Number=-1)
  r1=conj(r)
  I-(r1*transpose(r))*((1-l)//(transpose(r)*r1))
end

"""
`asreflection(s::Matrix [,r::AbstractVector])`

`s`  should be is a square  matrix, and if given `r`  should be a vector of
length  `size(s,1)`.  The  function  determines  if  `s` is the matrix of a
complex  reflection  (resp.  if  `r`  is  given  if  it  is the matrix of a
reflection  of root `r`; the point of  giving `r` is to specify exactly the
desired root and coroot, which otherwise are determined only up to a scalar
and  its  inverse).  The  function  returns  `nothing`  if  `s` if is not a
reflection  (resp. not a reflection with root `r`), and otherwise returns a
named tuple with four fields:

`.root`:   the root of the reflection `s` (equal to `r` if given)

`.coroot`:  the coroot of `s`

`.eigenvalue`:  the non-trivial eigenvalue of `s`

`.isunitary`: a boolean which is `true` if and only if `s` is unitary
  with  respect to the usual scalar product  (then `s` is determined by the
  root and the eigenvalue as `reflectionMatrix(.root,.eigenvalue)`)

```julia-repl
julia> asreflection([-1 0 0;1 1 0;0 0 1])
(root = [2, 0, 0], coroot = Rational{Int64}[1, -1//2, 0], eig = -1, isunitary = false)

julia> asreflection([-1 0 0;1 1 0;0 0 1],[1,0,0])
(root = [1, 0, 0], coroot = Rational{Int64}[2, -1, 0], eig = -1, isunitary = false)
```
"""
function asreflection(m::AbstractMatrix,r::AbstractVector)
  rr=I-m
  rc=map(j->ratio(rr[j,:],r),axes(m,1))
  zeta=ratio(transpose(m)*r,r)
  if isnothing(zeta) return end
  rzeta=Root1(zeta)
  if isnothing(rzeta) return end
  (root=r,coroot=rc,eig=rzeta,isunitary=rc*(r'*r)==(1-zeta)*conj(r))
end

function asreflection(m::AbstractMatrix)
  rr=I-m
  r=findfirst(!iszero,eachrow(rr))
  if !isnothing(r) asreflection(m,rr[r,:]) end
end
#------------------------------------------------------------------------
@GapObj mutable struct TypeIrred end
@doc """
a  `TypeIrred` object  classifies an  irreducible finite complex reflection
group,  or an  irreducible coset  (the latter  means that  the group  has a
single orbit of irreducible components under `.phi`).

For an irreducible group a `TypeIrred` has the properties:
  - `.rank`  the semisimplerank of the group
  - `.series` which takes one of the values `:A,:B,:D,:E,:F,:G,:H,:I` for an 
      irreducible Coxeter group, and is `:ST` for non-real groups.
  - `.ST` for a primitive non-real group holding the Shepard-Todd number
  - `.p` and `.q` for an imprimitive non-real group, holding `.p=de` and `.q=e`
    for `G(de,e,r)`.

a  `TypeIrred` may  also contain  information specifying  a specific Cartan
matrix  for  the  given  type.  When  there  are  two  conjugacy classes of
generators,  `.cartanType`  (assumed  to  be  `1`  if  this  key is absent)
contains  the ratio  of the  root lengths  compared to  the standard cartan
matrix  for  that  type;  that  is,  the  Cartan matrix is conjugate to the
standard  Cartan matrix by `Diagonal([1,…,1,c,…,c])` where `c=.cartanType`.
This  this  how  type  `B`  (with  `.cartanType==2`)  and  type  `C`  (with
`.cartanType==1`), which have both `.series==:B`,  are distinguished.

For an irreducible coset a `TypeIrred` has the properties
  - `.orbit` a `Vector{TypeIrred}` holding the types of the groups in the
    orbit under `.phi`, such that `.phi` send each item to the next.
  - `.phi` if `k` is the length of `.orbit`, contains the permutation
    effected by `.phi^k` on the simple roots of the first item of the orbit.

In addition, a `TypeIrred` `t` for a group `W` or a `t` appearing in a
`.orbit` for a coset of a group `W` contains a property
   - `.indices` giving the indices in `gens(W)` represented by the generators
     of the irreducible component described by `t`.

The `.indices` of a `TypeIrred` are always in a canonical order for a given component, such that the associated Cartan matrix is the "canonical" one. For
instance, in type `C`, the longest root is always the first one, etc…
""" TypeIrred

TypeIrred(;kw...)=TypeIrred(Dict(kw...))

Base.copy(t::TypeIrred)=TypeIrred(copy(t.prop))

function indices(t::TypeIrred)::Vector{Int}
  if haskey(t,:indices) t.indices
  elseif haskey(t,:orbit) 
    o=t.orbit::Vector{TypeIrred}
    if isempty(o)  Int[] 
    elseif length(o)==1 o[1].indices
    else vcat(indices.(o)...)
    end
  elseif haskey(t,:rank) 1:t.rank
  end
end

indices(t::Vector{TypeIrred})=isempty(t) ? Int[] : length(t)==1 ? indices(t[1]) : vcat(indices.(t)...)

function Symbols.rank(t::TypeIrred)::Int
  if haskey(t,:rank) return t.rank end
  i=indices(t)
  if i!==nothing return length(i) end
end

function Base.show(io::IO, t::TypeIrred)
  function sub(p,n)
    s=string(n)
    string(p)*(length(s)==1 ? "_"*s : "_{"*s*"}")
  end
  if haskey(t,:series)
    s=t.series
    if s==:ST
      if hasdecor(io)
        n="G"
        if haskey(t,:cartanType)
          n*="("*xrepr(io,t.cartanType)*")"
        end
      else n="crg"
      end
      if hasdecor(io)
        if haskey(t,:ST) n=sub(n,t.ST)
        else n*="_{$(t.p),$(t.q),$(t.rank)}"
        end
      else
        if haskey(t,:ST) n*="($(t.ST)"
        else n*="($(t.p),$(t.q),$(t.rank)"
        end
        if haskey(t,:cartanType) n*=","*xrepr(io,t.cartanType)*")"
        else n*=")"
        end
      end
    else
      r=rank(t)
      ct=1
      if haskey(t,:cartanType)
        if s==:B
          if t.cartanType==1 s=:C
          elseif t.cartanType==2 s=:B
          elseif t.cartanType==root(2) s=:Bsym
          else ct=t.cartanType
          end
        elseif s==:F
          if t.cartanType==1 s=:F
          elseif t.cartanType==root(2) s=:Fsym
          else ct=t.cartanType
          end
        elseif s==:G
          if t.cartanType==1 s=:G
          elseif t.cartanType==root(3) s=:Gsym
          else ct=t.cartanType
          end
        elseif s==:I
          if t.cartanType==1 s=:I
          elseif t.cartanType==E(2*t.bond)+E(2*t.bond,-1) s=:Isym
          else ct=t.cartanType
          end
        end
      end
      if hasdecor(io)
        if ct!=1 s=Symbol(s,"(",xrepr(io,t.cartanType),")") end
        if haskey(t,:bond) n=sub(s,r)*"($(t.bond))"
        elseif haskey(t,:short) n="\\tilde "*sub(s,r)
        else n=sub(s,r)
        end
      else
        if haskey(t,:bond) n="coxgroup(:$s,$r,$(t.bond)"
        else n="coxgroup(:$s,$r"
        end
        if ct!=1 n*=","*xrepr(io,t.cartanType)*")"
        else n*=")"
        end
      end
    end
    if hasdecor(io) printTeX(io,n) else print(io,n) end
  else
    o=order(t.twist)
    if hasdecor(io)
      if o!=1 printTeX(io,"{}^{$o}") end
      if length(t.orbit)==1 print(io,t.orbit[1])
      else print(io,"(")
        for t1 in t.orbit print(io,t1) end
        print(io,")")
      end
    else
      print(io,"spets(",t.orbit)
      p=prod(Perm.(map(x->x.indices,t.orbit)...))*t.twist
      if !isone(p) print(io,",",p) end
      print(io,")")
    end
    if haskey(t,:scalar) && !all(isone,t.scalar)
      print(io,"[");join(io,t.scalar,",");print(io,"]")
    end
  end
end

#---------------------------------------------------------------------------
"""
`PermRootGroup`   is  the  type  of  reflection  groups  represented  as  a
permutation group on a set of roots.
"""
abstract type PermRootGroup{T,T1<:Integer}<:PermGroup{T1} end

"""
`inclusion(W::ComplexReflectionGroup)`

the indices of `simpleroots(W)` in the roots of `parent(W)`.
"""
inclusiongens(W::PermRootGroup)=inclusion(W,eachindex(gens(W)))
"""
`inclusion(W::ComplexReflectionGroup)`

the indices of the roots of `W` in the roots of `parent(W)`.

`inclusion(W::PermRootGroup,i::Integer)`
`inclusion(W::PermRootGroup,v::AbstractVector{<:Integer})`

same as `inclusion(W)[i]` or `inclusion(W)[v]` (but more efficient).
"""
inclusion(L,W,i)=restriction(W,inclusion(L,i))
inclusion(L,W)=restriction(W,inclusion(L))
inclusiongens(L,W)=restriction(W,inclusiongens(L))
"""
`number_of_reflections(W::ComplexReflectionGroup)` or `nref(W)`

the number of reflections of `W`
"""
number_of_reflections(W::PermRootGroup)=sum(nref,refltype(W);init=0)
number_of_reflections(t::TypeIrred)=sum(degrees(t).-1)
const nref=number_of_reflections

"""
`number_of_hyperplanes(W::ComplexReflectionGroup)` or `nhyp(W)`

The number of reflecting hyperplanes of `W`
"""
number_of_hyperplanes(W::PermRootGroup)=sum(nhyp,refltype(W);init=0)
number_of_hyperplanes(t::TypeIrred)=sum(codegrees(t).+1)
const nhyp=number_of_hyperplanes

"""
`coxeter_number(W::PermRootGroup,i)` or `coxnum`

Gordon  and  Griffeth  [GG2012](biblio.htm#gg12)  have defined the *Coxeter
number*  of an irreducible  character `φ` of  a complex reflection group as
the scalar by which the central element `∑_{s in reflections(W)}(1-s)` acts
on  the representation of character `φ`.  The function `coxnum` returns the
Coxeter number of the `i`-th irreducible character of `W`.
"""
coxeter_number(W::PermRootGroup,i)=Int(charinfo(W).a[i]+charinfo(W).A[i])
# The computation uses Proposition 0.1 of Michel's "tower equivalence"

"""
`coxeter_number(W::PermRootGroup)` or `coxnum`

Gordon  and  Griffeth  [GG2012](biblio.htm#gg12)  have defined the *Coxeter
number* of an irreducible complex reflection group as the Coxeter number of
its reflection character. It is also given by the formula
`(nref(W)+nhyp(W))/rank(W)`;  for a well-generated group it is equal to the
highest  reflection degree. For a non-irreducible group, the Coxeter number
is the sum of those of its irreducible components.
"""
coxeter_number(W::PermRootGroup)=sum(t->coxnum(t),refltype(W);init=0)

coxeter_number(t::TypeIrred)=div(nhyp(t)+nref(t),rank(t))

const coxnum=coxeter_number

# should use independent_roots
function Base.:(==)(W::PermRootGroup,W1::PermRootGroup)
  if ngens(W)!=ngens(W1) return false end
  all(i->roots(W,i)==roots(W1,i) && coroots(W,i)==coroots(W1,i), 1:ngens(W))
end

function Base.hash(W::PermRootGroup,h::UInt)
  for i in 1:ngens(W) h=hash(roots(W,i),h) end
  for i in 1:ngens(W) h=hash(coroots(W,i),h) end
  h
end

"""
`simple_reps(W)`

for  each root, the index  of the first simple  root conjugate to it (it is
the index of a generator of `W`).
"""
function simple_reps(W::PermRootGroup) # fills .simple_conjugating and .refls
  get!(W,:simple_reps)do
    reps=fill(0,length(roots(W)))
    repelts=fill(one(W),length(roots(W)))
    for i in eachindex(gens(W))
      if iszero(reps[i])
        d=transversal(W,inclusion(W,i))
        for (n,e) in d
          reps[restriction(W,n)]=i
          repelts[restriction(W,n)]=e
        end
      end
    end
    W.simple_conjugating=repelts
    W.refls=map((i,p)->gens(W)[i]^p,reps,repelts)
    W.unique_refls=unique(i->W.refls[i],eachindex(W.refls))
    reps
  end::Vector{Int}
end

"""
`simple_reps(W,i)`

the  smallest index of a root in the  same `W`-orbit as the `i`-th root (it
is the index of a generator of `W`).
"""
simple_reps(W,i)=simple_reps(W)[i]

"""
`refls(W::ComplexReflectionGroup)`

a  list of same length as `W.roots` giving the corresponding element of `W`
representing  a distinguished reflection.  In particular this  list is much
longer  than `unique(refls(W))`  since in  general there  are several roots
corresponding to a reflection.
"""
refls(W::PermRootGroup{T,T1}) where{T,T1}=getp(simple_reps,W,:refls)::Vector{Perm{T1}}

"""
`refls(W::ComplexReflectionGroup,i)`

the  element of `W` representing  the distinguished reflection around
the `i`-th root of `W` (`i` can be an index or a vector of indices)
"""
refls(W,i::Integer)=i<=ngens(W) ? gens(W)[i] : refls(W)[i]
refls(W,i::AbstractVector)=map(j->refls(W,j),i)

"""
`simple_conjugating(W::ComplexReflectionGroup)`

For each index `i` of a root, an element `w∈ W` such that
`action(W,simple_reps(W,i),w)==i`. 
"""
simple_conjugating(W::PermRootGroup{T,T1}) where{T,T1}=getp(simple_reps,W,:simple_conjugating)::Vector{Perm{T1}}

"""
`unique_refls(W::ComplexReflectionGroup)`
A  sublist of `1:length(roots(W))` such  that the distinguished reflections
around  the  corresponding  roots  reach  one  time only each distinguished
reflection of `W`.
"""
unique_refls(W)=getp(simple_reps,W,:unique_refls)::Vector{Int}

"""
`simple_conjugating(W,i)`

an element `w∈ W` such that `action(W,simple_reps(W,i),w)==i`. In particular
`W(simple_reps(W,i))^simple_conjugating(W,i)==refls(W,i)`.
"""
simple_conjugating(W::PermRootGroup,i)=simple_conjugating(W)[i]

"""
`cartan(W::PermRootGroup,i,j)`
the  cartan coefficient `cᵢ(rⱼ)`, the value of the linear form given by the
`i`-th coroot `cᵢ` on the `j`-th root `rᵢ` of `W`
"""
cartan(W::PermRootGroup,i,j)=transpose(coroots(W,i))*roots(W,j)

"""
`cartan(W::PermRootGroup)`    Cartan matrix of `W`.

Let  `s₁,…,sₙ` be reflections with associated  roots `rᵢ` and coroots `cᵢ`.
The  matrix `C` with  entries `Cᵢ,ⱼ=cᵢ(rⱼ)` is  called a *Cartan matrix* of
`s₁,…,sₙ`.  Since a reflection determines up to scalar a root and a coroot,
`C`  is uniquely  determined by  `s₁,…,sₙ` up  to conjugation by a diagonal
matrix.

If `s₁,…,sₙ` generate a reflection group `W`, then `C` up to conjugation by
a  diagonal matrix is an invariant of the reflection representation of `W`.
If invertible, the matrix `C` determines this representation since then the
`rᵢ`  form a basis in  which the matrix for  `sᵢ` differs from the identity
only  on  the  `i`-th  row,  where  the  corresponding  row of `C` has been
subtracted.

In general `cartan(W)==simplecoroots(W)*permutedims(simpleroots(W))`.
```julia-repl
julia> W=coxgroup(:A,3)
A₃

julia> cartan(W)
3×3 Matrix{Int64}:
  2  -1   0
 -1   2  -1
  0  -1   2
```
"""
function cartan(W::PermRootGroup{T,T1})where {T,T1}
  get!(W,:cartan)do
    istorus(W) ? fill(0,0,0) : cartan(W,1:ngens(W))
  end
end

function cartan(t::TypeIrred;permute=false)
  if t.series==:ST return chevieget(t,:CartanMat) end
  C=haskey(t,:bond) ? haskey(t,:cartanType) ? 
     cartan(t.series,rank(t),t.bond,t.cartanType) : 
     cartan(t.series,rank(t),t.bond) : 
     haskey(t,:cartanType) ? cartan(t.series,rank(t),t.cartanType) : 
     cartan(t.series,rank(t))
  if permute && indices(t)!=1:rank(t)
    p=sortperm(indices(t));C=C[p,p]
  end
  C
end

cartan(W::PermRootGroup,I)=[cartan(W,i,j) for i in I, j in I]

"""
`rank(W::ComplexReflectionGroup)`

returns  the *rank* of  `W`, which is  the dimension of  the space where it
acts.

```julia-repl
julia> rank(complex_reflection_group(31))
4
```
"""
Symbols.rank(W::PermRootGroup)=istorus(W) ? W.rank : length(roots(W,1))

"""
`TypeIrred(W::PermRootGroup)`

`W` must be an *irreducible* finite complex reflection group, computed as a
permutation   group  of  a  set  of  roots,  generated  by  a  set  `S`  of
distinguished   reflections.   `TypeIrred`   classifies   `W`   (returns  a
`TypeIrred` object) by using the following algorithm. It computes in order:
  - `r=semisimplerank(W)`, the dimension of the space spanned by the roots
  - `i=length(W)/factorial(r)`
  - `o`=the maximum order of a reflection=``max_{s∈ S}o(s)``
  - `D`=all distinguished reflections of `W`, the `W`-orbit of `S`
  - `h`=the Coxeter number=``(∑_{s∈ D}o(s))/r``
`(r,i,o)`  are sufficient  to determine  a ``G_{de,e,r}``  excepted for the
ambiguity  between ``G_{2e,e,2}`` and ``I₂(4e)``,  which is resolved by `h`
(excepted   for   `e=1`,   where   the   two   solutions  are  isomorphic).
``G_{de,e,r}`` has ``i=(de)ʳ/e``, ``o=max(2,d)``, ``h=ed(r-1)+d-δ_{d,1}``

`(r,i,o)`  are also sufficient  to distinguish primitive  groups except for
the tuples (which are resolved by `h`):
```
(G₉, G₂₄‚₆‚₂)
(G₁₂, G₁₂‚₆‚₂, I₂(24))
(G₁₃, G₂₄‚₁₂‚₂, I₂(48))
(G₂₂, G₆₀‚₃₀‚₂, I₂(120))
(G₇, G₁₄, G₂₄‚₈‚₂)
(G₈, G₁₂‚₃‚₂)
(G₁₅, G₄₈‚₁₆‚₂)
(G₁₇, G₁₂₀‚₂₄‚₂)
(G₂₁, G₁₂₀‚₄₀‚₂)
```
"""
function TypeIrred(W::PermRootGroup)
prim=[
  (r=2, s=12, o=3, h=6),
  (r=2, s=36, o=3, h=12),
  (r=2, s=24, o=3, h=12),
  (r=2, s=72, o=3, h=18),
  (r=2, s=48, o=4, h=12),
  (r=2, s=96, o=4, h=24),
  (r=2, s=144, o=4, h=24),
  (r=2, s=288, o=4, h=36),
  (r=2, s=24, o=2, h=12),
  (r=2, s=48, o=2, h=18),
  (r=2, s=72, o=3, h=24),
  (r=2, s=144, o=3, h=30),
  (r=2, s=300, o=5, h=30),
  (r=2, s=600, o=5, h=60),
  (r=2, s=900, o=5, h=60),
  (r=2, s=1800, o=5, h=90),
  (r=2, s=180, o=3, h=30),
  (r=2, s=360, o=3, h=60),
  (r=2, s=120, o=2, h=30),
  (r=3, s=20, o=2, h=10),
  (r=3, s=56, o=2, h=14),
  (r=3, s=108, o=3, h=12),
  (r=3, s=216, o=3, h=18),
  (r=3, s=360, o=2, h=30),
  (r=4, s=48, o=2, h=12),
  (r=4, s=320, o=2, h=20),
  (r=4, s=600, o=2, h=30),
  (r=4, s=1920, o=2, h=30),
  (r=4, s=6480, o=3, h=30),
  (r=5, s=432, o=2, h=18),
  (r=6, s=54432, o=2, h=42),
  (r=6, s=72, o=2, h=12),
  (r=7, s=576, o=2, h=18),
  (r=8, s=17280, o=2, h=30)]

  r=semisimplerank(W)
  s=div(length(W),factorial(r))
  if s==r+1 return TypeIrred(series=:A,rank=r)
  elseif r==1 return TypeIrred(series=:ST,p=s,q=1,rank=1)
  else l=([p.^(a+m-a*r,a*r-m) for a in div(m+r-1,r):div(m,r-1)]
                       for (p,m) in eachfactor(s))
    de=vec((x->(d=prod(first.(x)),e=prod(last.(x)))).(Iterators.product(l...)))
  end # here de=possible namedtuples (d=..,e=..)
  o=maximum(ordergens(W))
  de=filter(x->o==max(2,x.d),de) #  after this length(de)<=2
  ST=findall(p->r==p.r && s==p.s && o==p.o,prim).+3
# if isempty(de) && length(ST)==1 # shortcut
#   return TypeIrred(series=:ST, ST=only(ST), rank=r)
# end
  h=div(sum(order,refls(W,unique_refls(W))),r) # Coxeter number
# println("de=$de, o=$o, h=$h")
  if length(de)>1
    sort!(de)
    if h==de[1].e de=[de[1]]
    elseif h==2*de[2].e+2 de=[de[2]]
    else return TypeIrred(series=:ST,ST=only(ST),rank=r)
    end
  end
  if length(de)>0 && length(ST)>0
    ST=filter(i->prim[i-3].h==h,ST)
    if !isempty(ST) return TypeIrred(series=:ST,ST=only(ST),rank=r) end
  end
  if length(de)==0
    if only(ST) in [23,30] return TypeIrred(series=:H,rank=r)
    elseif only(ST)==28 return TypeIrred(series=:F,rank=r)
    elseif only(ST) in 35:37 return TypeIrred(series=:E,rank=r)
    else return TypeIrred(series=:ST,ST=only(ST),rank=r)
    end
  end
  d=only(de)
  if d.d==2 && d.e==1 return TypeIrred(series=:B,rank=r) end
  if d.d==1 && d.e==2 return TypeIrred(series=:D,rank=r) end
  if d.d==1 && r==2
    if d.e==4 return TypeIrred(series=:B, rank=2)
    elseif d.e==6 return TypeIrred(series=:G, rank=2)
    else return TypeIrred(series=:I, rank=2, bond=d.e)
    end
  end
  TypeIrred(series=:ST,p=d.d*d.e,q=d.e,rank=r)
end

"""
`check_minimal_relation(gens,rel;verbose=false)`

returns `true` iff the homogeneous relation
`prod(gens[rel[1]])==prod(gens[rel[2]])` is a minimal relation between gens
(that is, no left factor homogeneous relation holds), `false` otherwise. If
`verbose=true` prints a description of failure.
"""
function check_minimal_relation(gens,rel;verbose=false)
  p(l,r)=joindigits(l)*"="*joindigits(r)
  L,R=rel
  l=gens[L[1]]
  r=gens[R[1]]
  i=1
  while i<length(L)
    if l==r
      if verbose print(" relation ",p(L[1:i],R[1:i])," already holds") end
      return false
    end
    i+=1
    l*=gens[L[i]]
    r*=gens[R[i]]
  end
  if l==r return true end
  if verbose print(" relation ",p(L,R)," failed") end
  false
end

Groups.ordergens(t::TypeIrred)=chevieget(t,:ordergens)

# g is a sublist of 1:length(H.roots). Returns sublist k of g such that
# refls(H,k) satisfy braid and order relations of type t
function findgoodgens(H,g,t::TypeIrred)
# println("g=$g\n t=");ds(t)
  orders=ordergens(t)
  rels=groupby(r->maximum(r[1]),braid_relations(t))
  # check gens satisfy relations concerning them, find if can add
  # another gen from rest
  function findarr(gens,rest)
    if length(gens)==length(orders)
      if length(Group(gens))==length(H) return Int[]
      else return nothing
      end
    end
    i=length(gens)+1
    for e in rest
#     println("$e(",length(gens),")")
      if ordergens(H)[simple_reps(H)[e]]!=orders[i] continue end
      newgens=vcat(gens,[refls(H,e)])
      if !haskey(rels,i) || all(r->check_minimal_relation(newgens,r),rels[i])
        res=findarr(newgens,setdiff(rest,[e]))
        if !isnothing(res) return vcat([e],res) end
      end
    end
    return nothing
  end
  return findarr(eltype(H)[],g)
end

# findgoodcartan(H,g,C):  g is a sublist of eachindex(H.roots).
# Returns sublist k of g such that cartan(H,k)=C or nothing if none exists.
function findgoodcartan(H,g,C)
  function find(k,rest) # k has good cartan, see if can add some e∈ rest
    if length(k)==size(C,1) return k end
    i=length(k)+1
    for e in rest
#     println("$e(",length(k),")")
      if cartan(H,e,e)==C[i,i] &&
         all(j->cartan(H,e,k[j])==C[i,j],1:i-1) &&
         all(j->cartan(H,k[j],e)==C[j,i],1:i-1)
        res=find(vcat(k,[e]),setdiff(rest,[e]))
        if !isnothing(res) return res end
      end
    end
    return nothing
  end
  return find(Int[],g)
end

# try to make cartan(H,p) like C by changing p rotating roots (C indecomposable)
function fixCartan(H,C,p)
  CH=cartan(H,p)
  r=Weyl.fincoxTypeIrred(CH)
  if !isnothing(r) return (r,p) end
  d=diagconj_elt(C,CH)
 #if isnothing(d) error("raté") end
  seen=[size(CH,1)]
  for i in size(CH,1):-1:1
  # go reverse for better luck in type B?
    for j in i:-1:1
      if CH[i,j]!=C[i,j]
        if CH[i,j]==0 || (j in seen) return nothing end
        r=C[i,j]//CH[i,j]
        r=findfirst(==(roots(H,p[j])*r),roots(H))
        if r===nothing return nothing end
        p=copy(p)
        p[j]=r
        return fixCartan(H,C,p)
      end
      if C[i,j]!=0 push!(seen,j) end
    end
  end
  (r,p)
end

# find roots p in inclusion(H) with cartan(H,p) equal to C^(diagonal matrix D)
# returns [p, diagonal of D]
function findgensDiagCartan2(H,C)
  f(x,y)=y==0 ? (x==0 ? 0 : nothing) : x//y
  # here cartan(H,l) is conjugate by Diagonal(d) to beginning of C
  function complete(l,d)
    local r,c,cc,n
    if length(l)==size(C,1) return (l,d) end
    n=length(l)+1
    for r in Iterators.filter(i->cartan(H,i,i)==C[n,n],eachindex(roots(H)))
      cc=vcat(map(i->f(d[i]*C[i,n],cartan(H,l[i],r)),1:n-1),
              map(i->f(d[i]*cartan(H,r,l[i]),C[n,i]),1:n-1))
      cc=setdiff(cc,[0])
      if length(cc)<=1 && !(nothing in cc)
        if length(cc)==0 cc=[1] end
        c=complete(vcat(l,[r]),vcat(d,[cc[1]]))
        if c!==nothing return c end
      end
    end
  end
  return complete(Int[],eltype(C)[])
end

# find other roots p' in inclusion(H) with same reflections as p 
# with cartan(H,p') equal to C^(diagonal matrix D)
# returns [p', diagonal of D]
function findgensDiagCartan(H,C,p)
  CH=cartan(H,p)
  f(x,y)=y==0 ? (x==0 ? 0 : nothing) : x//y
  d=zeros(eltype(CH),size(CH,1))
  d[1]=1
  for n in 2:size(C,1)
  # here cartan(H,l) is conjugate by Diagonal(d) to beginning of C
    l=filter(i->ratio(roots(H,p[n]),roots(H,i))!==nothing,eachindex(roots(H)))
    cc=map(r->vcat(map(i->f(d[i]*C[i,n],cartan(H,p[i],r)),1:n-1),
                   map(i->f(d[i]*cartan(H,r,p[i]),C[n,i]),1:n-1)),l)
    if any(x->nothing in x,cc) error("grave") end
    cc=filter.(!iszero,cc)
    cc=unique.(cc)
    if any(x->length(x)>1,cc) return nothing end
    cc=only.(cc)
    best=findfirst(==(d[n-1]),cc)
    if !isnothing(best)
      p[n]=l[best]
      d[n]=d[n-1]
    else
      d[n]=cc[1]
      p[n]=l[1]
    end
  end
  p,d
end

"""
`refltype(W::ComplexReflectionGroup` or coset`)` or `reflection_type(W)`

returns the `Vector{TypeIrred}` which classifies `W` (see
[`TypeIrred`](@ref)).  The  `refltype`  is  used  for displaying `W` at the
repl. The function `indices` on the result of `refltype`or on a `TypeIrred`
tells  the index in `gens(W)` of each standard generator of the irreducible
component  s. In the  REPL display of  `W`, these indices  are omitted when
they  are the  expected ones  (the component  is in  order at  the expected
indices).
```julia-repl
julia> W=coxgroup(:D,3) # a D₃ is an A₃ in disorder
A₃₍₁₃₂₎

julia> t=refltype(W)
A₃₍₁₃₂₎

julia> indices(t)
3-element Vector{Int64}:
 1
 3
 2
```
"""
function refltype(W::PermRootGroup;verbose=false)
  get!(W,:refltype)do
    if isempty(gens(W)) return TypeIrred[] end
    map(diagblocks(cartan(W))) do I
      R=I==eachindex(gens(W)) ? W : reflection_subgroup(W,I;NC=true)
      CR=cartan(R)
      d=TypeIrred(R)
      C=cartan(d)
      if C==CR 
        if d.series!=:ST d=Weyl.fincoxTypeIrred(CR) end
        d.indices=I
        return d
      end
      if verbose print("#1") end
      good=findgoodcartan(R,eachindex(gens(R)),C)
      if !isnothing(good) d.indices=inclusion(R,W,good); return d end
      if verbose print("#2") end
      good=findgoodcartan(R,eachindex(roots(R)),C)
      if !isnothing(good) d.indices=inclusion(R,W,good); return d end
      if verbose print("#3") end
      good=findgoodgens(R,unique_refls(R),d)
      better=fixCartan(R,C,good)
      if !isnothing(better) 
        if !isnothing(better[1]) d=better[1] end
        d.indices=inclusion(R,W,better[2]); return d
      end
      better=findgensDiagCartan(R,C,good)
      if verbose print("#4") end
      if !isnothing(better) good=better[1]
        rd=diagconj_elt(C,cartan(R,good))
        if rd[1]!=1 error("hah non") end
        if !allequal(rd[2:end])
        println("##### Warning: cartantypes for ",d,"=",rd[3:end].//rd[2]) end
        d.cartanType=improve_type(rd[2])
      else better=findgensDiagCartan2(R,C)
        if verbose print("#5") end
        if !isnothing(better) good=better[1] 
          if length(better[2])==2 && isone(better[2][1])
            d.cartanType=improve_type(better[2][2])
          end
        end
      end
      if d.series!=:ST d=Weyl.fincoxTypeIrred(cartan(R,good)) end
      d.indices=inclusion(R,W,good)
      d
    end
  end::Vector{TypeIrred}
end

const reflection_type=refltype

"""
`bipartite_decomposition(W)`

Returns  a bipartite decomposition `[L,R]` of the indices of the generators
of  the  reflection  group  `W`,  such  that `reflection_subgroup(W,L)` and
`reflection_subgroup(W,R)` are abelian subgroups, and
`W=reflection_subgroup(W,   vcat(L,R))`.   Gives   an   error  if  no  such
decomposition is possible.

```julia-repl
julia> bipartite_decomposition(coxgroup(:E,8))
([1, 4, 6, 8], [3, 2, 5, 7])

```
"""
function bipartite_decomposition(W)
  L=Int[]
  R=Int[]
  rest=collect(eachindex(gens(W)))
  commute(x,y)=W(x)*W(y)==W(y)*W(x)
  while length(rest)>0
    r=findfirst(x->any(y->!commute(x,y),L),rest)
    if r!=nothing
      if any(y->!commute(rest[r],y),R)
        error(W," has no bipartite decomposition")
      end
      push!(R,rest[r])
      deleteat!(rest,r)
    else r=findfirst(x->any(y->!commute(x,y),R),rest)
      if r!=nothing push!(L,rest[r]); deleteat!(rest,r)
      else push!(L,rest[1]); deleteat!(rest,1);
      end
    end
  end
  L,R
end

"""
`reflection_character(W::ComplexReflectionGroup,w)` or `reflchar`

Returns  the trace  of the  element `w`  of `W`  as an  endomorphism of the
vector space `V` on which `W` acts.

```julia-repl
julia> W=coxgroup(:B,3)
B₃

julia> reflchar(W,longest(W))
-3
```
"""
reflection_character(W,w)=tr(reflrep(W,w))

const reflchar=reflection_character

"""
`reflection_character(W::ComplexReflectionGroup)` or `reflchar`

Returns  the reflection  character of  `W`. When  `W` is irreducible, it is
`CharTable(W).irr[charinfo(W).extRefl[2]]`.

```julia-repl
julia> reflchar(coxgroup(:A,3))
5-element Vector{Int64}:
  3
  1
 -1
  0
 -1
```
"""
reflection_character(W)=reflchar.(Ref(W),classreps(W))

"""
`reflection_eigenvalues(W)` or `refleigen(W)`

Let `W` be a reflection group on the vector space `V`.
`reflection_eigenvalues(W)` returns for each conjugacy class representative
`x`  of `W` (see `classreps`)  the eigenvalues of `x`  on `V`, as a list of
`Root1`.

```julia-repl
julia> refleigen(coxgroup(:B,2))
5-element Vector{Vector{Root1}}:
 [1, 1]
 [-1, 1]
 [-1, -1]
 [-1, 1]
 [ζ₄³, ζ₄]
```
"""
function reflection_eigenvalues(W)
  get!(classinfo(W),:refleigen) do
    t=refltype(W)
    if !any(x->haskey(x,:orbit) && (length(x.orbit)>1 || order(x.twist)>1 ||
       (haskey(x,:scalar) && !all(isone,x.scalar))),t)
      if isempty(t) ll=[Root1[]]
      else ll=splat(vcat).(tcartesian(refleigen.(t)...))
      end
      central=(W isa Spets ? torusfactors(W) :
                            fill(E(1),rank(W)-semisimplerank(W)))
      ll=map(x->vcat(x,central),ll)
      sort.(ll)
    else eigen.(conjugacy_classes(W))
    end
  end::Vector{Vector{Root1}}
end

const refleigen=reflection_eigenvalues

function refleigen(t::TypeIrred)
  if haskey(t,:orbit) t=t.orbit[1] end #orbits are trivial after above function
  ct=CharTable(t).irr[charinfo(t).extRefl,:]
  l=map(v->Pol(reverse(v).*((-1).^axes(ct,1))),eachcol(ct))
  l=CycPol.(l)
  ll=map(p->[Root1(;r=e) for (e,m) in p.v for i in 1:m],l)
  if haskey(t,:scalar) ll.*=Root1(prod(t.scalar)) end
  ll
end

" `refleigen(W,i)` faster than `refleigen(W)[i]`"
reflection_eigenvalues(W,i)=refleigen(W)[i] # not faster this way...

"""
`reflection_length(W::PermRootGroup,w::Perm)` or `reflength`

This  function returns the  number of eigenvalues  of `w` in the reflection
representation  which are not equal to 1.  For a finite Coxeter group, this
is  equal to the  reflection length of  `w`, that is  the minimum number of
reflections  of which `w`  is a product.  This also holds  in general for a
well-generated  complex reflection group if  `w` divides for the reflection
length a Coxeter element.

```julia-repl
julia> W=coxgroup(:A,4)
A₄

julia> reflength(W,longest(W))
2

julia> reflength(W,W(1,2,3,4))
4
```
"""
function Perms.reflection_length(W::PermRootGroup,w::Perm)
  reflength(conjugacy_classes(W)[position_class(W,w)])
end

"""
`torus_order(W::ComplexReflectionGroup,i,q=Pol())`

returns  as a  polynomial in  `q` the  toric order  of the `i`-th conjugacy
class  of `W`. This is the characteristic  polynomial of an element of that
class  on  the  reflection  representation  of  `W`.  It is the same as the
generic  order of the reflection subcoset `torus(W,i)` of `W` determined by
the trivial subgroup and a representative of the `i`-th conjugacy class.

```julia-repr
julia> W=complex_reflection_group(4)

julia> torus_order.(Ref(W),1:nconjugacy_classes(W),Pol(:q))
7-element Vector{Pol{Cyc{Int64}}}:
 q²-2q+1
 q²+2q+1
 q²+1
 q²-ζ₃q+ζ₃²
 q²+ζ₃q+ζ₃²
 q²+ζ₃²q+ζ₃
 q²-ζ₃²q+ζ₃
```
"""
torus_order(W::PermRootGroup,i,q=Pol())=prod(l->q-l,refleigen(W)[i])

Base.show(io::IO,::MIME"text/plain",v::Vector{TypeIrred})=show(io,v)

function Base.show(io::IO, t::AbstractVector{<:TypeIrred})
  r=0
  join(io,map(t)do t
    n=xrepr(io,t)
    inds=indices(t)
    if isnothing(inds) n*="?"
    elseif inds!=r.+eachindex(inds) && hasdecor(io)
      n=fromTeX(io,"{"*n*"}"*"_{"*joindigits(inds;always=true)*"}")
    end
    r+=rank(t)
    n
   end,hasdecor(io) ? fromTeX(io,"\\times{}") : "*")
end

function showtorus(io::IO,W)
  t=rank(W)-semisimplerank(W)
  if t>0
    if hasdecor(io) print(io,CycPol(1,0,(1,0,t)))
    else print(io,(istorus(W) ? "" : "*"),"PRG($t)")
    end
  elseif istorus(W) print(io,hasdecor(io) ? "." : "PRG(0)")
  end
end

function Base.show(io::IO, W::PermRootGroup)
  show(io,refltype(W))
  showtorus(io,W)
end

"""
`independent_roots(W::ComplexReflectionGroup)`

A vector of indices of length `semisimplerank(W)` such that
`simpleroots(W)[independent_roots(W)]`  is  a  basis  of  the  vector space
spanned by the roots of `W`.
"""
function independent_roots(W::PermRootGroup{T,T1})where{T,T1}
  get!(W,:indeproots) do
    if istorus(W) Int[]
    else sort(independent_rows(toM(roots(W))))
    end
   end::Vector{Int}
end

"""
`semisimpleRank(W::ComplexReflectionGroup)`

returns  the *semisimple rank* of `W`, which  is the dimension of the space
where  it effectively acts. If `W` is  a reflection group on the space `V`,
and  `V₁` is the subspace generated by `roots(W)`, then `semisimplerank(W)`
is the dimension of `V₁`. The reflection group `W` is called *essential* if
`V₁=V`.

```julia-repl
julia> W=reflection_subgroup(coxgroup(:A,3),[1,3])
A₃₍₁₃₎=A₁×A₁Φ₁

julia> semisimplerank(W)
2

julia> rank(W)
3
```
"""
function semisimplerank(W::PermRootGroup)
  get!(W,:semisimplerank)do
    length(independent_roots(W))
  end::Int
end

"""
`baseX(W::ComplexReflectionGroup)`

returns  as the rows of a matrix a  particular basis of the space `V` where
`W` acts: the first `semisimplerank(W)` rows contain the coordinates on the
basis of `V` of a basis of the root lattice (given by
`simpleroots(W)[independent_roots(W)]`) and the last
`rank(W)-semisimplerank(W)` ones contain the same for the orthogonal of the
coroots.

When `W` represents a rootdatum for a reductive group, the first lines are
the same as `simpleroots(W)`.
"""
function baseX(W::PermRootGroup{T})where T
  get!(W,:baseX) do
    if istorus(W) return one(zeros(T,rank(W),rank(W))) end
    ir=independent_roots(W)
    u=lnullspace(transpose(simplecoroots(W)[ir,:]))
    if eltype(u)<:Rational || eltype(u)<:Cyc{<:Rational}
      for v in eachrow(u) v.*=lcm(denominator.(v)...) end
    end
    vcat(simpleroots(W)[ir,:],improve_type(u))
  end::Matrix{T}
end

function invbaseX(W::PermRootGroup)
  get!(W,:invbaseX)do
    X=baseX(W)
    improve_type(inv(X*1//1))
  end
end

"""
`central_action(L::ComplexReflectionGroup,M)`

If `L` is a reflection subgroup and `M̀` a matrix which normalizes `L` in its
reflection representation, returns the matrix by which `M` acts on `X(Z_L)`.
"""
function central_action(L,m)
  if size(m,2)==0 return m end
  m=improve_type(baseX(L)*m*invbaseX(L))
  r=semisimplerank(L)
  improve_type(m[r+1:end,r+1:end])
end

"""
`PermX(W::ComplexReflectionGroup,M::AbstractMatrix)`

Let `M` be an invertible linear map of the reflection representation of `W`
which  preserves the set  of roots of  `parent(W)`, and normalizes `W` (for
the  action of  matrices on  the right).  `PermX` returns the corresponding
permutation  of the roots of `parent(W)`;  it returns `nothing` if `M` does
not normalize the set of roots of `parent(W)`.

```julia-repl
julia> W=reflection_subgroup(rootdatum("E7sc"),1:6)
E₇₍₁₂₃₄₅₆₎=E₆Φ₁

julia> PermX(W,reflrep(W,longest(W)))==longest(W)
true
```
"""
function PermX(W::PermRootGroup,M::AbstractMatrix)
  Perm(parent(W).roots,Ref(transpose(M)).*parent(W).roots)
end

function PermGroups.reduced(W::PermRootGroup,F)
  function redcenter(W,F)
    FF=F.*elements(center(W))
    if true
      if F in parent(W)
        ch=map(x->refleigen(parent(W))[position_class(parent(W),x)],FF)
      else
        ch=map(x->eigmat(reflrep(W,x)),FF)
      end
      m=minimum(map(x->sum(order.(x)),ch))
      if length(m)>1 println("warning",length(m)) end
      m=findall(x->sum(order.(x))==m,ch)
    else
      ch=map(x->conductor(charpoly(reflrep(W,x))),FF)
      m=minimum(ch)
      m=findall(==(m),ch)
    end
    minimum(FF[m])
  end
  if isone(F) return F end
  if issubset(inclusiongens(W).^F,inclusion(W))
    w=PermX(W,reflrep(W,F))
    if !isnothing(w) && w in W return redcenter(W,w\F)
    elseif length(W)==1 return F
    end
  end
  base=gens(W)
  w=transporting_elt(W,base,base.^F,ontuples)
  if !isnothing(w) return redcenter(W,F/w) end
  w=transporting_elt(W,sort(base),sort(base.^F),onsets)
  t=refltype(W)
  for a in t
    if Cosets.isG333(a)
      subgroup=reflection_subgroup(W,a.indices)
      base=gens(subgroup).^F
      if !all(x->x in W,base) error("F must normalize W") end
      if !all(x->x in subgroup,base)
        error("not implemented: F permutes components")
      end
      base=chevieget(:timp,:ReducedInRightCoset)(subgroup,F)
      if isnothing(base) error("should not happen subgroup=$subgroup F=$F")
      else indices=restriction(W,base.gen)
        F=base.phi
      end
      return (phi=F,reflectiongroup=reflection_subgroup(W,indices;NC=true))
    end
  end
  if !isnothing(w) return redcenter(W,F/w) end
  return nothing
end

function Groups.classreps(W::PermRootGroup{T,T1})where{T,T1}
  get!(W,:classreps)do
    map(x->x.representative,conjugacy_classes(W))
  end::Vector{Perm{T1}}
end

function Groups.nconjugacy_classes(W::PermRootGroup)
  prod(nconjugacy_classes.(refltype(W));init=1)
end

"""
`parabolic_reps(W)`

For  a Coxeter group or finite complex reflection group `W`, returns a list
of  indices  of  roots  of  `W`  describing  representatives  of  orbits of
parabolic  subgroups  under  conjugation  by  `W`. For Coxeter groups, each
orbit  has a representative which is a standard parabolic subgroup, that is
whose indices is a subset of `eachindex(gens(W))`. This may not be the case
in general.

```julia-repl
julia> parabolic_reps(coxgroup(:A,4))
7-element Vector{Vector{Int64}}:
 []
 [1]
 [1, 2]
 [1, 3]
 [1, 2, 3]
 [1, 2, 4]
 [1, 2, 3, 4]

julia> parabolic_reps(complex_reflection_group(3,3,3))
7-element Vector{Vector{Int64}}:
 []
 [1]
 [1, 2]
 [1, 3]
 [1, 9]
 [2, 3]
 [1, 2, 3]
```

`parabolic_reps(W,r)`

If  a second  argument `r`  is given,  returns only  representatives of the
parabolic subgroups of semisimple rank `r`.
```julia-repl
julia> parabolic_reps(coxgroup(:A,4),2)
2-element Vector{Vector{Int64}}:
 [1, 2]
 [1, 3]

julia> parabolic_reps(complex_reflection_group(3,3,3),2)
4-element Vector{Vector{Int64}}:
 [1, 2]
 [1, 3]
 [1, 9]
 [2, 3]
```
"""
parabolic_reps(W)=vcat(parabolic_reps.(Ref(W),0:semisimplerank(W))...)

parabolic_reps(t::TypeIrred,s)=chevieget(t,:ParabolicRepresentatives,s)

function recompute_parabolic_reps(W) # W irreducible
  by=1+ngens(W)-semisimplerank(W)
  stoi=s->findfirst(i->refls(W,i)==s,eachindex(roots(W)))
  l=[map(x->reflection_subgroup(W,[x]),sort(unique(simple_reps(W))))]
  for i in 2:semisimplerank(W)-1
    new=[];ref=Vector{Pair{Int,Int}}[]
    for v in l[i-1]
      InfoChevie("# Extending ",v)
      S=normalizer(W,v)
      if ngens(v)==i-1
        c=union(map(i->combinations(unique_refls(W),i),1:by)...)
      else c=combinations(unique_refls(W),1)
      end
      c=map(x->union(x,restriction(W,inclusiongens(v))),c)
      c=filter(x->GenLinearAlgebra.rank(toM(roots(W,x)))==i,c)
      InfoChevie(" ",length(c)," new subgroups")
      c=map(function(x)InfoChevie("*");reflection_subgroup(W,x) end,c)
      c=filter(isparabolic,c)
      c=sort(unique(map(x->sort(unique(refls(x))),c)))
      O=orbits(S,c,onsets)
      O=map(o->o[argmin(map(x->sum(stoi,x),o))],O)
      O=map(x->reflection_subgroup(W,stoi.(x)),O)
      InfoChevie("# ",length(O)," to go\n")
      for c in O
        rr=tally(degrees(c))
        cand=filter(i->ref[i]==rr,eachindex(ref))
        InfoChevie("# candidates for ",c," to be conjugate:",new[cand],"\n")
        if all(v->transporting_elt(W,v,c)===nothing,new[cand])
             InfoChevie("# new:",c,"\n")
             push!(new,c);push!(ref,rr);
        end
      end
    end
    InfoChevie("# i=",i," found:",new,"\n")
    push!(l,new)
  end
  l=map(vcat(l...))do v
    p=standard_parabolic(W,v)
    if p!==nothing v=v^p end
    v
  end
  l=collectby(semisimplerank,l)
  l=map(v->inclusiongens.(v),l)
  l=vcat([[Int[]]],l)
  push!(l,[inclusiongens(W)])
  l=map(v->map(x->map(y->Int(stoi(refls(W,restriction(W,y)))),x),v),l)
  [sort(sort.(x)) for x in l]
end

function parabolic_reps(W::PermRootGroup,s)
  t=refltype(W)
  sols=filter(l->sum(l)==s,tcartesian(map(x->0:rank(x),t)...))
  vcat(map(sols)do c
    splat(vcat).(tcartesian(map(eachindex(c))do i
    r=parabolic_reps(t[i],c[i])
    if r===nothing
      R=reflection_subgroup(W,t[i].indices)
      return recompute_parabolic_reps(R)[c[i]+1]
    elseif all(x->all(y->y in 1:t[i].rank,x),r)
      return map(x->t[i].indices[x],r)
    else R=reflection_subgroup(W,t[i].indices)
      return map(x->inclusion(R,W,x),r);
    end
    end...))end...)
end

"""
`reflection_representation(W::ComplexReflectionGroup,w)` or `reflrep(W,w)`

Let  `V` be the space on  which `W` acts as a  reflection group and let `w∈
W`,  represented  as  a  permutation  of  the roots. The function `reflrep`
returns  the matrix of `w` acting on  `V` (*from the right* on the elements
of  `V` seen as  row vectors by  our conventions in  `Chevie`). This is the
linear  transformation of `V` which acts trivially on the orthogonal of the
coroots  and has same effect as `w` on the simple roots. The function makes
sense  more generally for a permutation of  the roots induced by an element
of  `GL(V)` which stabilizes the roots (thus in particular normalizes `W`);
thus  it works for reflection cosets.  For a `rootdatum` corresponding to a
coset `Wσ` we get the action of `Wσ` on `X(𝐓)`.

```julia-repl
julia> W=reflection_subgroup(rootdatum("E7sc"),1:6)
E₇₍₁₂₃₄₅₆₎=E₆Φ₁

julia> reflrep(W,longest(W))
7×7 Matrix{Int64}:
  0   0   0   0   0  -1  2
  0  -1   0   0   0   0  2
  0   0   0   0  -1   0  3
  0   0   0  -1   0   0  4
  0   0  -1   0   0   0  3
 -1   0   0   0   0   0  2
  0   0   0   0   0   0  1
```
"""
function reflection_representation(W::PermRootGroup,w)
  W=parent(W)
  X=baseX(W)
  if isone(w) return one(X) end
  if istorus(W) return X end
  ir=independent_roots(W)
  X=vcat(toM(roots(W,ir.^w)),X[length(ir)+1:end,:])
  improve_type(invbaseX(W)*X)
end

const reflrep=reflection_representation

"""
`YMatrix(W,w)`

Let  `W` be a finite reflection group on  the space `V` and let `w∈ W`. The
function  `YMatrix` returns the  matrix of `w`  acting on the  dual `V*` of
`V`.  This is the linear transformation of `V*` which acts trivially on the
orthogonal  of the roots and has same  effect as `w` on the simple coroots.
The function makes sense more generally for an element of the normalizer of
`W`  in the whole permutation group of the coroots. The resulting matrix is
the  transposed  of  the  matrix  `reflrep(W,w)`,  which,  according to our
conventions  acts on the right (on the row vectors representing elements of
the  dual of `V`). For  a `rootdatum` corresponding to  a coset `Wσ` we get
the action of `Wσ` on `Y(𝐓)`.

```julia-repl
julia> W=reflection_subgroup(rootdatum("E7sc"),1:6)
E₇₍₁₂₃₄₅₆₎=E₆Φ₁

julia> YMatrix(W,longest(W))
7×7 transpose(::Matrix{Int64}) with eltype Int64:
  0   0   0   0   0  -1  0
  0  -1   0   0   0   0  0
  0   0   0   0  -1   0  0
  0   0   0  -1   0   0  0
  0   0  -1   0   0   0  0
 -1   0   0   0   0   0  0
  2   2   3   4   3   2  1
```
"""
YMatrix(W::PermRootGroup,w)=transpose(reflrep(W,inv(w)))
"""
`PermY(W::ComplexReflectionGroup,M::AbstractMatrix)`

Let  `M`  be  an  invertible  linear  map  on  the  dual  of the reflection
representation  of `W` which  preserves the set  of coroots of `parent(W)`,
and  normalizes  `W`  (for  the  action  of matrices on the right). `PermY`
returns  the corresponding  permutation of  the coroots  of `parent(W)`; it
returns  `nothing`  if  `M`  does  not  normalize  the  set  of  coroots of
`parent(W)`.

```julia-repl
julia> W=reflection_subgroup(rootdatum("E7sc"),1:6)
E₇₍₁₂₃₄₅₆₎=E₆Φ₁

julia> PermY(W,YMatrix(W,longest(W)))==longest(W)
true
```
"""
PermY(W::PermRootGroup,m)=inv(PermX(W,transpose(m)))

"""
`isparabolic(W)`

whether the reflection subgroup `W` is a parabolic subgroup of `parent(W)`.
```julia-repl
julia> W=complex_reflection_group(7)
G₇

julia> isparabolic(reflection_subgroup(W,[1,2]))
false

julia> isparabolic(reflection_subgroup(W,[1]))
true
```
"""
function isparabolic(W,H)
  if iszero(ngens(H)) return true end
  v=rowspace(simpleroots(H))
  gens=filter(i->in_rowspace(roots(W,i),v),eachindex(roots(W)))
  setr=s->Set(refls(W,s))
  setr(gens)==setr(inclusion(H,W))
end

isparabolic(H)=isparabolic(parent(H),H)

"""
`parabolic_closure(W,I)`

`I`  should be a  list of indices  of reflections of  `W`. Returns `J` such
that  `reflection_subgroup(W,J)` is the smallest  parabolic subgroup of `W`
containing `reflection_subgroup(W,I)`.

```julia-repl
julia> W=complex_reflection_group(7)
G₇

julia> parabolic_closure(W,[1])
1-element Vector{Int64}:
 1

julia> parabolic_closure(W,[1,2])
3-element Vector{Int64}:
 1
 2
 3
```
"""
function parabolic_closure(W,I::AbstractVector{<:Integer})
  if isempty(I) return I end
  if isparabolic(reflection_subgroup(W,I)) return I end
  v=rowspace(toM(roots(W,I)))
  gens=filter(i->in_rowspace(roots(W,i),v),eachindex(roots(W)))
  inclusiongens(reflection_subgroup(W,gens),W)
end

function parabolic_closure(W,H::Group)
  reflection_subgroup(W,parabolic_closure(W,inclusiongens(H,W)))
end

function Groups.normalizer(W::PermGroup,L::PermRootGroup)
  if length(L)==1 return W end
  s=sort(refls(L,unique_refls(L)))
  J=filter(x->refls(W,x) in s,eachindex(roots(W)))
# C=stabilizer(W,J,onsets)
  R=stabilizer(W,s,onsets)
#  if length(R)<length(C) error("not expected") end
  R
end
#--------------- PRG: an implementation of PermRootGroups--------------------
@GapObj struct PRG{T,T1}<:PermRootGroup{T,T1}
  gens::Vector{Perm{T1}}
  one::Perm{T1}
  matgens::Vector{Matrix{T}}
  roots::Vector{Vector{T}}
  coroots::Vector{Vector{T}}
end

"""
`PRG(roots,coroots)` complex reflection group with given roots and coroots
"""
function PRG(r::AbstractVector{<:AbstractVector},
             cr::AbstractVector{<:AbstractVector};NC=false,T1=Perms.Idef)
# println("r=",r,"\ncr=",cr)
  if isempty(r) error("should call torus instead") end
  matgens=reflectionMatrix.(r,cr)
  T=eltype(matgens[1])  # promotion of r and cr types
  r=convert.(Vector{T},r)
  cr=convert.(Vector{T},cr)

  # the following section is quite subtle: it has the (essential -- this is
  # what  allows  to  construct  reflexion  subgroups  in a consistent way)
  # property  that the order of the  constructed roots (thus the generating
  # permutations) depends only on the Cartan matrix of g, not on the actual
  # root values.

# println("# roots: ")
  gens_=map(x->T1[],matgens)
  newroots=true
  while newroots
    newroots=false
    for (j,refl) in pairs(gens_)
      lr=length(r)
      if length(refl)<lr
      for y in eachrow(toM(r[length(refl)+1:end])*matgens[j])
        p=findfirst(==(y),r)
	if p===nothing || p>lr
          push!(r,y)
#         println("j=$j r[$(length(refl)+1)...] ",length(r),":",y)
          newroots=true
          push!(refl,length(r))
        else push!(refl,p)
	end
      end
      end
    end
#   println(" ",length(r))
  end
  coroots_=Vector{eltype(cr)}(undef,length(r))
  coroots_[eachindex(cr)].=cr
  W=PRG(Perms.Perm_.(gens_),Perm{T1}(),matgens,r,coroots_,Dict{Symbol,Any}())
  if !NC
    t=refltype(W)
    l=indices(t)
    if sort(l)!=eachindex(l)
      InfoChevie("# changing gens to <",join(l,","),"> for ",
                                             t,"<",ngens(W)," refs>\n")
      save=haskey(W,:fromparent)
      if save n=W.fromparent end
      W=PRG(roots(W,l),coroots(W,l))
      if save W.fromparent=n end
    end
  end
  W
end

PRG(a::Matrix,b::Matrix;k...)=PRG(toL(a),toL(b);k...)

PRG(i::Integer;T1=Perms.Idef)=PRG(Perm{T1}[],Perm{T1}(),Matrix{Int}[],
          Vector{Int}[],Vector{Int}[],Dict{Symbol,Any}(:rank=>i))
"""
`radical(G::ComplexReflectionGroup)`

A torus of dimension `rank(W)-semisimplerank(W))`.

The  radical datum of a root datum `(X,Φ,Y,Φ^∨)` is `(X/(X∩ ℚ Φ),∅ ,Φ^⟂,∅)`,
a toral  datum. 
"""
radical(W::PermRootGroup)=PRG(rank(W)-semisimplerank(W))

"`roots(W::PermRootGroup)` the roots of `W`"
roots(W::PRG)=W.roots
"`roots(W::PermRootGroup,i)` same as `roots(W)[i]`"
roots(W::PRG,i)=W.roots[i]
"""
`simpleroots(W::ComplexReflectionGroup)`  the  simple  roots  of `W` (those
corresponding to `gens(W)`) as the rows of a matrix.
"""
function simpleroots(W::PRG{T})where T
  get!(W,:simpleroots) do
    ngens(W)==0 ? fill(0,0,rank(W)) : toM(view(W.roots,eachindex(gens(W))))
  end::Matrix{T}
end

"`coroots(W)` the list of coroots of `W` (listed in the same order as the roots)"
coroots(W::PRG)=all(i->isassigned(W.coroots,i),eachindex(W.coroots)) ? 
    W.coroots : coroots(W,eachindex(W.coroots))
"""
`simplecoroots(W::ComplexReflectionGroup)` the simple coroots of `W` (those
`corresponding to gens(W)`) as the rows of a matrix.
"""
simplecoroots(W::PRG)=ngens(W)==0 ? fill(0,0,rank(W)) : toM(view(W.coroots,eachindex(gens(W))))
inclusion(W::PRG,i::Integer)=i
inclusion(W::PRG,i::AbstractVector)=collect(i) # we do not want ranges
inclusion(W::PRG)=inclusion(W,eachindex(W.roots))
restriction(W::PRG,i=eachindex(W.roots))=i
Base.parent(W::PRG)=W
action(W::PRG,i,p)=i^p

"`coroots(W,i)` same as but better than `coroots(W)[i]`"
function coroots(W::PRG{T},i::Integer)where T
  if isassigned(W.coroots,i) return W.coroots[i] end
  j=findfirst(!iszero,roots(W,i))
  m=I-reflrep(W,i)
  W.coroots[i]=T.(m[:,j].//roots(W,i)[j])::Vector{T}
end

coroots(W::PRG,I::AbstractVector{<:Integer})=isempty(I) ? empty(W.coroots) : 
  [coroots(W,i) for i in I]
# map(i->coroots(W,i),I) #is much slower

function Base.:*(W::PRG,V::PRG)
  if rank(W)==0 return V
  elseif rank(V)==0 return W
  end
  r=cat(simpleroots(W),simpleroots(V),dims=(1,2))
  cr=cat(simplecoroots(W),simplecoroots(V),dims=(1,2))
  PRG(toL(r),toL(cr))
end

"""
`reflection_representation(W::ComplexReflectionGroup)` or `reflrep(W)`

returns  `reflrep.(Ref(W),gens(W))`,  that  is  the  generators  of  `W` as
matrices.
"""
reflection_representation(W::PRG)=W.matgens

"""
`reflection_representation(W,i::Integer)`  or `reflrep(W,i)`

the matrix for the distinguished reflection around the `i`-th root of `W`.
"""
reflection_representation(W::PRG,i::Integer)=i<=ngens(W) ? W.matgens[i] : reflrep(W,refls(W,i))

#--------------- type of subgroups of PRG----------------------------------
@GapObj struct PRSG{T,T1}<:PermRootGroup{T,T1}
  gens::Vector{Perm{T1}}
  one::Perm{T1}
  inclusion::Vector{Int}
  restriction::Vector{Int}
  parent::PRG{T,T1}
end

inclusion(W::PRSG)=W.inclusion
inclusion(W::PRSG,i::Integer)=W.inclusion[i]
inclusion(W::PRSG,i::AbstractVector)=W.inclusion[i]
"""
`restriction(W::PermRootGroup)`

A  list for each root of `parent(W)`, which  holds `0` if the root is not a
root of `W` and `i` if the root is the `i`-th root of `W`.

`restriction(W::PermRootGroup,i::Integer)`
`restriction(W::PermRootGroup,v::AbstractVector{<:Integer})`

same as `restriction(W)[i]` or `restriction(W)[v]` (but more efficient).
"""
restriction(W::PRSG)=W.restriction
restriction(W::PRSG,i)=W.restriction[i]
@inline roots(W::PRSG)=roots(parent(W),inclusion(W))
@inline roots(W::PRSG,i)=roots(parent(W),inclusion(W,i))
function simpleroots(W::PRSG)
  get!(W,:simpleroots)do
   ngens(W)==0 ? fill(0,0,rank(W)) : toM(view(parent(W).roots,inclusiongens(W)))
  end
end
coroots(W::PRSG)=coroots(parent(W),inclusion(W))
coroots(W::PRSG,i)=coroots(parent(W),inclusion(W,i))
simplecoroots(W::PRSG)=ngens(W)==0 ? fill(0,0,rank(W)) : toM(coroots(parent(W),inclusiongens(W)))
Base.parent(W::PRSG)=W.parent
"""
`action(W::ComplexReflectionGroup,i::Integer,p::Perm)`

The elements of a `PermRootGroup` permute the roots of `parent(W)`, that is
are  permutations on  `eachindex(roots(parent(W)))`. The  function `action`
translates  this action of `p∈W` to `eachindex(roots(W))`. For a reflection
subgroup we have `action(W,i,p)==restriction(W,inclusion(W,i)^p)` and for a
parent  group `action(W,i,p)==i^p`. The first formula is always valid since
for a parent group `restriction(W)==inclusion(W)==eachindex(roots(W))`.
"""
action(W::PRSG,i,p)=restriction(W,inclusion(W,i)^p)

function Base.:^(W::PRSG{T,T1},p::Perm{T1})where {T,T1}
  WW=parent(W)
  if !(p in WW) error("can only conjugate in parent") end
  reflection_subgroup(WW,inclusiongens(W).^p)
end

"""
`reflection_subgroup(W,r)`
    
returns  the  reflection  subgroup  of  the  complex  reflection  group `W`
generated by `refls(W,r)`.

A  reflection subgroup `H` of  `W` is a permutation  subgroup with the same
additional  information as  `W`, and  some new  one added which express the
relationship with the parent `W`:

`inclusion(H)`:   the indices of the roots of `H` in the roots of `W`

`parent(H)`:  is set to `W`.

`restriction(H)`:  a list of length `length(roots(W))` with non-zero entries
   in positions `inclusion(H)` bound to `eachindex(roots(H))`.

A  reflection  group  which  is  not  a  subgroup  actually  also  has this
information, set to the trivial values:
`inclusion(W)==restriction(W)==eachindex(roots(W))`,   and   `parent()==W`.
This  allows a lot of code to be  written in the same way for parent groups
or reflection subgroups.

`reflection_subgroup(R)` where `R` is itself a reflection subgroup returns a 
reflection subgroup of the parent of `R`.

```julia_repl
julia> W=coxgroup(:F,4)
F₄

julia> H=reflection_subgroup(W,[1,2,11,20])
F₄₍₉‚₂‚₁‚₁₆₎=D₄₍₃₂₁₄₎

julia> [restriction(H)]
1-element Vector{Vector{Int64}}:
 [1, 2, 0, 0, 5, 0, 0, 0, 3, 0  …  0, 16, 0, 19, 0, 21, 0, 22, 23, 24]

julia> reflection_subgroup(H,[1,2,3])
F₄₍₉₁₂₎=A₃₍₃₁₂₎Φ₁
```
"""
function reflection_subgroup(W::PRG,I::AbstractVector;NC=false)
  if !haskey(W,:reflsubgroups)
    W.reflsubgroups=Dict(
         Int[]=>PRSG(empty(gens(W)),one(W),Int[],zeros(Int,length(W.roots)),W,
                  Dict{Symbol,Any}(:rank=>rank(W),:refltype=>TypeIrred[])))
  end
  I=Vector{Int}(I)
  if NC
    if I==eachindex(gens(W)) G=W
      inclu=collect(eachindex(roots(W)))
    else
      G=PRG(roots(W,I),coroots(W,I);NC=true)
      inclu=Int.(indexin(G.roots,W.roots))
    end
    restr=zeros(Int,length(W.roots));restr[inclu]=1:length(inclu)
    return PRSG(refls(W,I),one(W),inclu,restr,W,Dict{Symbol,Any}())
  end
  if haskey(W.reflsubgroups,I) return W.reflsubgroups[I] end
  H=reflection_subgroup(W,I;NC=true)
  t=refltype(H)
  l=indices(t)
  if sort(l)!=eachindex(gens(H))
    InfoChevie("# changing inclusiongens to <",join(inclusion(H,l),
      ","),"> for ",t,"<",length(inclusion(H))," refs>\n")
    save=haskey(H,:fromparent)
    if save n=H.fromparent end
    H=reflection_subgroup(W,inclusion(H,l);NC=true)
    if save H.fromparent=n end
    for tt in t tt.indices=map(x->findfirst(==(x),l),tt.indices) end
  end
  H.refltype=t
  W.reflsubgroups[I]=H
  H
end

reflection_subgroup(W::PRSG,I::AbstractVector{Int};u...)=
   reflection_subgroup(parent(W),inclusion(W,I);u...)

function Base.show(io::IO, W::PRSG)
  I=inclusiongens(W)
  if !hasdecor(io)
    print(io,"reflection_subgroup(",W.parent,",",I,")")
    return
  end
# n=inclusion(W,indices(refltype(W)))
  n=inclusiongens(W)
  if n!=eachindex(gens(W.parent)) && get(io,:parent,true)
    printTeX(io,"{",W.parent,"}_{"*joindigits(n;always=true)*"}=")
  end
  show(io,refltype(W))
  showtorus(io,W)
end

reflrep(W::PRSG,i::Integer)=reflrep(parent(W),inclusion(W,i))
reflrep(W::PRSG)=map(i->reflrep(W,i),eachindex(gens(W)))

#-------------------------------------------------
"""
`catalan(W::ComplexReflectionGroup)`

returns the Catalan Number of the irreducible complex reflection group `W`.
For well-generated groups, this number is equal to the number of simples in
the  dual Braid  monoid. For  other groups  it was  defined by  [Gordon and
Griffeth2012](biblio.htm#gg12).  For Weyl groups, it also counts the number
of antichains of roots.

```julia-repl
julia> catalan(coxgroup(:A,7))
1430
```

`catalan(W,i)`

returns   the  `i`-th  Fuss-Catalan  Number   of  the  irreducible  complex
reflection  group `W`. For  well-generated groups, this  number is equal to
the  number of chains  `s₁,…,sᵢ` of simples  in the dual  monoid where `sⱼ`
divides  `sⱼ₊₁`. For these groups, it is also equal to `∏ⱼ(ih+dⱼ)/dⱼ` where
the  product runs over the reflection degrees  of `W`, and where `h` is the
Coxeter  number of `W`. For non-well generated groups, the definition is in
[Gordon and Griffeth2012](biblio.htm#gg12).

```julia-repl
julia> catalan(complex_reflection_group(7),2)
16
```

`catalan(W;q=1)`, resp. `catalan(W,i;q=1)`

for  `q`  a  variable  (like  `Pol()`  or an `Mvp`) returns the `q`-Catalan
number  (resp.  the  `i`-th  `q`-Fuss  Catalan  number)  of  `W`. Again the
definitions in general are in [Gordon and Griffeth2012](biblio.htm#gg12).

```julia-repl
julia> catalan(complex_reflection_group(7),2;q=Pol())
Pol{Int64}: q⁷²+2q⁶⁰+3q⁴⁸+4q³⁶+3q²⁴+2q¹²+1
```
"""
function Combinat.catalan(W,m=1;q=1)
  if length(refltype(W))>1 error(W," should be irreducible") end
  d=sort(degrees(W))
  d=filter(x->x!=1,d)
  fd=d
  if length(d)!=ngens(W)
    ci=charinfo(W)
    if haskey(ci,:hgal) hgal=ci[:hgal] else hgal=Perm() end
    ct=toL(CharTable(W).irr)
    complex=Perm(ct,conj(ct))
    fd=fakedegrees(W,Pol(:q))[ci[:extRefl][2]^(hgal^m*complex)]
    fd=vcat(map(i->fill(i+1,fd[i]),0:degree(fd))...)
  end
  f(i)=sum(j->q^j,0:i-1)
  h=div(nhyp(W)+nref(W),length(d))
  exactdiv(prod(x->f(m*h+x),fd),prod(x->f(x),d))
end

"""
`invariant_form(W::ComplexReflectionGroup)`

This  function  returns  the  matrix  `F`  (defined  up  to a scalar) of an
Hermitian form invariant under the action of the reflection group `W`. That
is, if `M` is the matrix of an element of `W`, then `M*F*M'=F`.

```julia-repl
julia> W=complex_reflection_group(4)
G₄

julia> invariant_form(W)
2×2 Matrix{Int64}:
 1  0
 0  2
```
"""
function invariant_form(W::PermRootGroup)
  I=independent_roots(W)
  C=cartan(W)[I,I]
# we use that C[i,j]/C[i,i]=F[j,i]/F[i,i]
  T=typeof(C[1,1]*1//1)
  F=zeros(T,size(C))
  for b in diagblocks(C)
    # first fill in the diagonal terms
    F[b[1],b[1]]=1
    next=[1]
    while !isempty(next)
      i=b[next[1]]
      next=next[2:end]
      for k in filter(k->F[b[k],b[k]]==0 && C[i,b[k]]!=0,eachindex(b))
	j=b[k]
        push!(next,k)
        F[j,j]=F[i,i]*C[i,j]*conj(C[j,j])//(conj(C[j,i])*C[i,i]);
      end
    end
    # then fill in the rest
    for i in b, j in b
      if i!=j F[j,i]=C[i,j]*F[i,i]//C[i,i] end
    end
  end
  d=rank(W)-semisimplerank(W)
  F=cat(F,one(zeros(T,d,d)),dims=(1,2))
  N=invbaseX(W)
  F=N*F*N'
  improve_type(F.//F[1,1])
end

"""
`generic_order(W,q=Pol())`

returns  the generic  order of  `W` as  a polynomial  in `q` (the "compact"
order  of the  Spets). This  is ``q^{Nₕ}Πᵢ(q^{dᵢ}-1)``  where `dᵢ`  are the
reflection  degrees and  `Nₕ` the  number of  reflecting hyperplanes. For a
Weyl  group, it is the order  of the associated semisimple finite reductive
group over the field with `q` elements.

```julia-repl
julia> PermRoot.generic_order(complex_reflection_group(4),Pol(:q))
Pol{Int64}: q¹⁴-q¹⁰-q⁸+q⁴
```
"""
function generic_order(W,q=Pol();nc=false)
  if rank(W)==0 return one(q) end
  if nc q^sum(degrees(W).-1)*prod(d->q^d-1,degrees(W))
  else q^sum(codegrees(W).+1)*prod(d->q^d-1,degrees(W))
  end
end

"""
`invariants(W::ComplexReflectionGroup)`

returns  the fundamental invariants of `W` in its reflection representation
`V`.  That is, returns  a set of  algebraically independent elements of the
symmetric  algebra  of  the  dual  of  `V` which generate the `W`-invariant
polynomial  functions on `V`. Each such invariant function is returned as a
function:  if `e₁,…,eₙ` is a basis of `V` and `f` is the function, then the
value  of the polynomial  function on `a₁e₁+…+aₙeₙ`  is obtained by calling
`f(a₁,…,aₙ)`. This function depends on the classification, and is dependent
on the exact reflection representation of `W`. So for the moment it is only
implemented   when  the  reflection   representation  for  the  irreducible
components has the same Cartan matrix as the one provided by Chevie for the
corresponding  irreducible  group.  The  polynomials  are invariant for the
natural   action  of   the  group   elements  as   matrices;  that  is,  if
`m==reflrep(W,w)`  for some  `w` in  `W`, then  an invariant  `f` satisfies
`f(a₁,…,aₙ)=f(v₁,…,vₙ)`   where  `[v₁,…,vₙ]=[a₁,…,aₙ]×m`.  This  action  is
implemented on `Mvp`s by the function `^`.

```julia-repl
julia> W=coxgroup(:A,2)
A₂

julia> @Mvp x,y,z

julia> i=invariants(W);

julia> map(f->f(x,y),i)
2-element Vector{Mvp{Int64, Int64}}:
 -2x²+2xy-2y²
 6x²y-6xy²

julia> W=complex_reflection_group(24)
G₂₄

julia> p=invariants(W)[1](x,y,z)
Mvp{Rational{Int64}}: (14//1)x⁴+(-12//1)x²y²+(-42//1)x²yz+(21//2)x²z²+(18//7)y⁴+(-6//1)y³z+(-9//2)y²z²+(-21//8)z⁴

julia> map(v->^(v,reflrep(W,1);vars=[:x,:y,:z]),(x,y,z))
((1//2)x+(3√-7/14)y, (-√-7/2)x+(-1//2)y, z)

julia> p^reflrep(W,1)-p
Mvp{Cyc{Rational{Int64}}}: 0
```
"""
function invariants(W::PermRootGroup)
  V=parent(W)
  i=Function[] # eltype abstract otherwise I do not know how to do it
  for t in refltype(W)
    H=reflection_group(t)
    if cartan(V,inclusion(W,t.indices))!=cartan(H)
      error("non standard Cartan matrix: invariants not implemented")
    end
    ir=independent_roots(H)
    li=chevieget(t,:Invariants)
    if li===nothing return false end
    append!(i,map(f->function(arg...)
         return f(improve_type(inv(E(1).*toM(coroots(H)[ir])*1//1)*
    toM(coroots(V,inclusion(W,t.indices[ir]))))*collect(arg)...) end, li))
  end
  N=toM(roots(W,independent_roots(W)))
  if !isempty(N)
    N=lnullspace(transpose(N))
    append!(i,map(v->function(arg...) sum(v.*arg) end,eachrow(N)))
  end
  i
end

BadNumber(W)=prod(BadNumber.(refltype(W));init=1)

function BadNumber(t::TypeIrred)
  r=rank(t)
  if iszero(r) return 1 end
  d=det_bareiss(cartan(t))
  if d==0 error(t," should be well generated") end
  improve_type(prod(degrees(t))//(factorial(r)*d))
end

end
