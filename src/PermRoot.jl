"""
Let  `V`  be  a  vector  space  over  a subfield `K` of the complex numbers
(usually  in Julia elements  of `K` are  `Rational`s or `Cyc`s). 

A *complex reflection* is an element `s∈ GL(V)` of finite order whose fixed
point  set is  an hyperplane,  the *reflecting  hyperplane* `Hₛ` of `s`.

Most  of the  time we  abbreviate "complex  reflection" to *reflection*; in
some  literature "reflection"  is reserved  for the  order 2  and otherwise
*pseudo-reflection* is used.

A  reflection `s` has a unique eigenvalue `ζₛ` not equal to `1`, which is a
root  of  unity;  if  `K`  is  a  subfield  of  the  real  numbers, `ζₛ` is
necessarily  equal to `-1` and the reflection is  of order 2. Let `r∈ V` be
an  eigenvector of `s` for the eigenvalue `ζₛ` (a *root*) and let `rᵛ` be a
linear  form  on  `V`  of  kernel  `Hₛ`  (a  *coroot*). If `r` and `rᵛ` are
normalized  such that `rᵛ(r)=1-ζ`,  then `s` is  the map on  `V` defined by
`s(x)=x-rᵛ(x)r`.  Such a root and  coroot for `s` are  unique up to scaling
the root and inversely scaling the coroot.

A  finite  complex  reflection  group  `W`  is  a finite group generated by
complex  reflections. Since when `W` contains  a reflection `s` it contains
its powers, `W` is always generated by reflections `s` such that `ζₛ==E(d)`
where  `d` is the order of `s`; we may in addition assume that `s` is not a
power  of another  reflection with  larger order  `d`. Such a reflection is
called  a *distinguished* reflection of `W`; it is a canonical generator of
the cyclic subgroup of `W` centralizing `Hₛ`. The generators of the complex
reflection  groups we construct are  always distinguished reflections; in a
real  reflection group all reflections are distinguished. Note that the set
of   distinguished  reflections  are  in   bijection  with  the  reflecting
hyperplanes.

It  is much  more efficient  to compute  with permutation  groups than with
matrix groups, when possible; thus the efficient representation that we use
for  computing with a finite complex reflection group `W`, is a permutation
representation  on  a  `W`-invariant  set  of  root  and coroot vectors for
reflections of `W`; that is, a set `R` of pairs `(r,rᵛ)∈ V×Vᵛ` invariant by
`W`  and such that each distinguished reflection  in `W` is defined by some
pair  in `R` (see [`reflection`](@ref)). Trying to find a `W`-invariant set
implies  that there may be several  pairs for each reflection, differing by
roots  of unity. This generalizes the usual construction for Coxeter groups
(the  case `K=ℝ `) where to each reflection of `W` is associated two roots,
a  positive and a negative one.  For irreducible complex reflection groups,
there are at least as many roots on a given line as the order of the center
of `W`.

For these groups the following methods are defined:

`gens(W)`: the (distinguished) reflections which generate `W`, given as
permutations of the roots. `reflrep(W)` will give them as matrices.

`roots(W)`: the list of roots of `W`.

`coroots(W)`: the list of coroots, in the same order as the roots.

`refls(W)`:  the list of distinguished reflections of `W`, as permutations,
which  starts with  gens(W). Actually  this list  is of  same length as the
roots,  and  its  `i`-th  element  is  the distinguished reflection for the
`i`-th  root, so it will have repetitions. `reflections(W)` gives a list of
all   reflections  of  `W`  (nor  only  the  distinguished  ones),  without
repetitions, as objects of type `Reflection` containing more information on
each reflection.

The  finite  irreducible  complex  reflection  groups  have been completely
classified  by  Shepard  and  Todd.  They  consist  of  one infinite family
`G(de,e,r)` depending on 3 parameters, and 34 exceptional groups which have
been given by Shephard and Todd names which range from `G₄` to `G₃₇`. These
exceptional   groups   contain   the   exceptional  Coxeter  groups,  e.g.,
`coxgroup(:E,8)` is the same as `G₃₇`.

We provide functions to build any finite reflection group, either by giving
a  list  of  roots  and  coroots  defining  the generating reflections (see
[`PRG`](@ref)), or in terms of the classification (see
[`complex_reflection_group`](@ref)).  In the  context e.g.  of Weyl groups,
one  wants to  describe the  particular root  system chosen  in term of the
traditional  classification of crystallographic root  systems. This is done
via   calls  to  the  function   [`coxeter_group`](@ref)  (see  the  module
[`Weyl`](@ref)).  There is not yet  a general theory on  how to construct a
nice  set of roots for  a non-real reflection group;  the roots chosen here
where  obtained  case-by-case;  however,  they  satisfy  several  important
properties:

  -  The generating reflections  satisfy braid relations  which present the
    braid group associated to `W` (see [`diagram`](@ref)).

  -  The *field  of definition*  of `W`  is the  field `K` generated by the
    traces  of the elements of `W` acting on  `V`. It is a theorem that `W`
    may be realized as a reflection group over `K`.

```julia-repl
julia> W=complex_reflection_group(4)
G₄

julia> gens(W) # as a permutation of the 24 roots
2-element Vector{Perm{Int16}}:
 (1,3,9)(2,4,7)(5,10,18)(6,11,16)(8,12,19)(13,15,20)(14,17,21)(22,23,24)
 (1,5,13)(2,6,10)(3,7,14)(4,8,15)(9,16,22)(11,12,17)(18,19,23)(20,21,24)

julia> length(unique(refls(W)))
4

julia> length(refls(W)) # 24=4*(number of roots of unity in ℚ (ζ₃))
24

julia> reflrep(W) # the reflection representations
2-element Vector{Matrix{Cyc{Rational{Int64}}}}:
 [1 0; 0 ζ₃]
 [√-3/3 -ζ₃²√-3/3; (-3+√-3)/3 -ζ₃√-3/3]

julia> braid_relations(W) # the braid relation between generators
1-element Vector{Vector{Vector{Int64}}}:
 [[1, 2, 1], [2, 1, 2]]

julia> diagram(W) # the same in pictures
③ ——③ G₄
1   2
```
For  almost  all  irreducible  complex  reflection  groups,  the generating
matrices  for `W` we give have coefficients in the field of definition `K`.
Further,  the set of matrices for all elements of `W` is globally invariant
under  the  Galois  group  of  `K/ℚ  `,  thus  the  Galois  action  induces
automorphisms  of `W`. The exceptions are `G₂₂, G₂₇` where the matrices are
in  a  degree  two  extension  of  `K`  (this  is needed to have a globally
invariant  model, see [MarinMichel2010](biblio.htm#MarinMichel10)) and some
dihedral  groups, as well as  `H₃` and `H₄`, where  the matrices given (the
usual   Coxeter  reflection  representation  over  `K`)  are  not  globally
invariant (but one can get invariant ones by
`chevieget(:H4,:InvariantModel)`).

It  turns out that all representations of `W` are defined over the field of
definition `K` (see. [Benard1976](biblio.htm#Ben76) and D.~Bessis' thesis).
This  has been known for a  long time in the case  `K=ℚ `, the case of Weyl
groups, whose representations are all integral.

-  The Cartan matrix (see [`cartan`](@ref)) for the generating roots (those
   which  correspond to the generating reflections) has entries in the ring
   `ℤₖ`  of  integers  of  `K`,  and  the  roots (resp. coroots) are linear
   combination  with coefficients in `ℤₖ`  of a linearly independent subset
   of them.

Some additional methods for finite reflection groups:

`simpleroots(W)`:  the generating roots as a matrix.

`simplecoroots(W)`:  the generating coroots as a matrix.

```julia-repl
julia> cartan(W)
2×2 Matrix{Cyc{Rational{Int64}}}:
 ζ₃²√-3     ζ₃²
   -ζ₃²  ζ₃²√-3

julia> simpleroots(W)
2×2 Matrix{Cyc{Rational{Int64}}}:
    0  ζ₃²√-3
 2ζ₃²     ζ₃²

julia> simplecoroots(W)
2×2 Matrix{Cyc{Rational{Int64}}}:
     0      1
 √-3/3  √-3/3
```

Let `SV` be the symmetric algebra of `V`. The invariants of `W` in `SV` are
called  the  *polynomial  invariants*  of  `W`.  They  are  generated  as a
polynomial   ring   by   `dim   V`  homogeneous  algebraically  independent
polynomials  `f₁,…,f_{dim  V}`.  The  polynomials  `fᵢ`  are  not  uniquely
determined   but  their  degrees  are.  The  `fᵢ`  are  called  the  *basic
invariants*  of `W`, and their degrees the *reflection degrees* of `W`; the
function `degrees(W)` returns these invariants.

Let  `I` be the  ideal generated by  the homogeneous invariants of positive
degree  in `SV`. Then `SV/I` is isomorphic to the regular representation of
`W`  as a  `W`-module. It  is thus  a graded  (by the degree of elements of
`SV`)  version of the  regular representation of  `W`. The polynomial which
gives  the graded  multiplicity of  a character  `φ` of  `W` in  the graded
module   `SV/I`  is  called   the  *fake  degree*   of  `φ`.  The  function
`fakedegrees` returns these polynomials.

```julia-repl
julia> degrees(W)
2-element Vector{Int64}:
 4
 6

julia> fakedegrees(W,Pol(:x))
7-element Vector{Pol{Int64}}:
 1
 x⁴
 x⁸
 x⁷+x⁵
 x⁵+x³
 x³+x
 x⁶+x⁴+x²
```
"""
module PermRoot

export PermRootGroup, PRG, PRSG, reflection_subgroup, simple_reps, roots,
  simple_conjugating, refls, unique_refls, reflection, reflectionmat,
  Diagram, diagram, refltype, cartan, independent_roots, inclusion, 
  inclusiongens, restriction, coroot, TypeIrred, refleigen, reflchar,
  bipartite_decomposition, torus_order, rank, PermX, coroots, baseX,
  invbaseX, semisimplerank, invariant_form, generic_order, parabolic_reps,
  invariants, matY, PermY, simpleroots, simplecoroots, action, radical,
  parabolic_closure, isparabolic, central_action, 
  reflrep, reflection_representation,
  nhyp, number_of_hyperplanes,
  nref, number_of_reflections,
  coxnum, coxeter_number,
  indices
using ..Gapjm

"""
`coroot(r,λ=1)`

the coroot for an orthogonal reflection of root `r` and eigenvalue `λ`.
"""
function coroot(root::AbstractVector,eigen::Number=-1)
  cr=conj.(root)
  cr.*((1-eigen)//(transpose(cr)*root))
end

"""
`reflectionmat(root,  coroot)` the  matrix of  the reflection  with a given
root and coroot.

A (complex) reflection is a finite order element `s` of `GL(V)`, the linear
group of a vector space over a subfield of the complex numbers, whose fixed
points  form  a  hyperplane  `H`  (the  *reflecting hyperplane* of `s`); an
eigenvector  `r` for  the non-trivial  eigenvalue `ζ`  (a root of unity) is
called  a *root* of `s`. If we choose  a linear form `rᵛ` defining `H` such
that `rᵛ(r)=1-ζ` (a *coroot* of `s`) then `s` is given by `x↦ x-rᵛ(x)r`.

A  way  of  specifying  `s`  is  by  giving  a root and a coroot, which are
uniquely determined by `s` up to multiplication of the root by a scalar and
of the coroot by the inverse scalar. The function `reflectionmat` gives the
matrix  of the corresponding reflection in the standard basis of `V`, where
the  `root` and the `coroot` are vectors given in the standard bases of `V`
and `Vᵛ`, so the pairing `rᵛ(r)` is obtained as `transpose(root)*coroot`.

```
julia> r=reflectionmat([1,0,0],[2,-1,0])
3×3 Matrix{Int64}:
 -1  0  0
  1  1  0
  0  0  1

julia> r==reflrep(coxgroup(:A,3),1)
true

julia> r*[2,-1,0]
3-element Vector{Int64}:
 -2
  1
  0

julia> [1 0 0]*r
1×3 Matrix{Int64}:
 -1  0  0
```
As  we see in the last lines, in  Julia a matrix operates from the right on
the  vector space `V`  of row vectors  and from the  left on the dual space
`Vᵛ` of column vectors.
"""
function reflectionmat(root::AbstractVector,coroot::AbstractVector)
  m=coroot*transpose(root)
  one(m)-m
end

"""
`reflectionmat(r, ζ=-1)`

returns the matrix of the complex reflection determined by the root `r` and
the  eigenvalue `ζ` when the  vector space and its  dual are identified via
the  scalar product `<x,y>=transpose(x)*y`; the coroot `rᵛ` is then equal
to the linear form `x->(1-ζ)<x,r>/<r,r>`.
```julia-repl
julia> reflectionmat([1,0,-E(3,2)])
3×3 Matrix{Cyc{Rational{Int64}}}:
  0  0  ζ₃²
  0  1    0
 ζ₃  0    0
```
"""
function reflectionmat(r::AbstractVector,l::Number=-1)
  m=(1-l)*transpose(r*r')//(r'*r)
  one(m)-m
end

"""
`reflection(s::Matrix [,r::AbstractVector])`

`s`  should be is a square  matrix, and if given `r`  should be a vector of
length  `size(s,1)`.  The  function  determines  if  `s` is the matrix of a
complex  reflection  (resp.  if  `r`  is  given  if  it  is the matrix of a
reflection  of root `r`; the point of  giving `r` is to specify exactly the
desired root and coroot, which otherwise are determined only up to a scalar
and  its  inverse).  The  function  returns  `nothing`  if  `s` if is not a
reflection  (resp. not a reflection with root `r`), and otherwise returns a
named tuple with four fields:

`.root`:   the root of the reflection `s` (equal to `r` if given)

`.coroot`:  the coroot of `s`

`.eigenvalue`:  the non-trivial eigenvalue of `s`

`.isOrthogonal`: a boolean which is `true` if and only if `s` is orthogonal
  with  respect to the usual scalar product  (then `s` is determined by the
  root and the eigenvalue as `reflectionmat(.root,.eigenvalue)`)

```julia-repl
julia> reflection([-1 0 0;1 1 0;0 0 1])
(root = [2, 0, 0], coroot = Rational{Int64}[1//1, -1//2, 0//1], eig = -1, isOrthogonal = false)

julia> reflection([-1 0 0;1 1 0;0 0 1],[1,0,0])
(root = [1, 0, 0], coroot = Rational{Int64}[2//1, -1//1, 0//1], eig = -1, isOrthogonal = false)
```
"""
function reflection(m::AbstractMatrix,r::AbstractVector)
  rr=one(m)-m
  rc=map(j->ratio(rr[j,:],r),axes(m,1))
  zeta=ratio(transpose(m)*r,r)
  if isnothing(zeta) return end
  rzeta=Root1(zeta)
  if isnothing(rzeta) return end
  orth=(rc*(r'*r)==(1-zeta)*conj(r))
  (root=r,coroot=rc,eig=rzeta,isOrthogonal=orth)
end

function reflection(m::AbstractMatrix)
  rr=one(m)-m
  if VERSION<v"1.7"
    r=findfirst(!iszero,collect(eachrow(rr)))
  else
    r=findfirst(!iszero,eachrow(rr))
  end
  if !isnothing(r) reflection(m,rr[r,:]) end
end
#------------------------------------------------------------------------
@GapObj struct TypeIrred end

Base.copy(t::TypeIrred)=TypeIrred(copy(t.prop))

indices(t::TypeIrred)=haskey(t,:indices) ? t.indices : haskey(t,:orbit) ?
isempty(t.orbit) ? Int[] : length(t.orbit)==1 ? t.orbit[1].indices :
vcat(getproperty.(t.orbit,:indices)...) : nothing

indices(t::Vector{TypeIrred})=isempty(t) ? Int[] : vcat(indices.(t)...)

function rank(t::TypeIrred)
  if haskey(t,:rank) return t.rank end
  i=indices(t)
  if i!==nothing return length(i) end
end

function Base.show(io::IO, t::TypeIrred)
  function sub(p,n)
    s=string(n)
    string(p)*(length(s)==1 ? "_"*s : "_{"*s*"}")
  end
  if haskey(t,:series)
    s=t.series
    if s==:ST
      if haskey(t,:ST)
        n=hasdecor(io) ? sub("G",t.ST) : "crg($(t.ST))"
      else
        n=hasdecor(io) ? "G_{$(t.p),$(t.q),$(t.rank)}" :
                         "crg($(t.p),$(t.q),$(t.rank))"
      end
    else
      r=rank(t)
      if haskey(t,:cartanType)
        if s==:B
          if t.cartanType==1 s=:C
          elseif t.cartanType==2 s=:B
          elseif t.cartanType==root(2) s=:Bsym
          else s=Symbol("B(",repr(t.cartanType;context=io),")")
          end
        elseif s==:F
          if t.cartanType==1 s=:F
          elseif t.cartanType==root(2) s=:Fsym
          else s=Symbol("F(",repr(t.cartanType;context=io),")")
          end
        elseif s==:G
          if t.cartanType==1 s=:G
          elseif t.cartanType==root(3) s=:Gsym
          else s=Symbol("G(",repr(t.cartanType;context=io),")")
          end
        elseif s==:I
          if t.cartanType==1 s=:I
          elseif t.cartanType==E(2*t.bond)+E(2*t.bond,-1) s=:Isym
          else s=Symbol("I(",repr(t.cartanType;context=io),")")
          end
        end
      end
      if haskey(t,:bond)
        b=t.bond
        n=hasdecor(io) ? sub(s,r)*"($b)" : "coxgroup(:$s,$r,$b)"
      elseif haskey(t,:short)
        n=hasdecor(io) ? "\\tilde "*sub(s,r) : "coxgroup(:$s,$r)"
      else
        n=hasdecor(io) ? sub(s,r) : "coxgroup(:$s,$r)"
      end
    end
    printTeX(io,n)
  else
    o=order(t.twist)
    if hasdecor(io)
      if o!=1 printTeX(io,"{}^{$o}") end
      if length(t.orbit)==1 print(io,t.orbit[1])
      else print(io,"(")
        for t1 in t.orbit print(io,t1) end
        print(io,")")
      end
    else
      print(io,"spets(",t.orbit)
      p=prod(map((x...)->Perm(x...),map(x->x.indices,t.orbit)...))*t.twist
      if !isone(p) print(io,",",p) end
      print(io,")")
    end
    if haskey(t,:scalar) && !all(isone,t.scalar)
      print(io,"[");join(io,t.scalar,",");print(io,"]")
    end
  end
end

struct Diagram
  t::TypeIrred
end

Base.show(io::IO,::MIME"text/plain",v::Vector{Diagram})=show(io,v)

Base.show(io::IO,v::Vector{Diagram})=join(io,v,"\n")

function Base.show(io::IO,d::Diagram)
  if !(get(io,:limit,false)|| get(io,:TeX,false))
    print(io,"Diagram(",d.t,")")
    return
  end
  t=d.t
  if haskey(t,:orbit)
    act=length(t.orbit)>1
    if act
      println(io,"ϕ permutes the next ",length(t.orbit)," components")
    end
    if !isone(t.twist)
     println(io,"ϕ",act ? "^$(length(t.orbit))" : "",
      " acts as ",t.twist^mappingPerm(t.orbit[1].indices,1:rank(t.orbit[1])),
      " on the component below")
    end
    show(io,Diagram.(t.orbit))
    return
  end
  series=t.series::Symbol
  if series!=:ST show(io,d,Val(series))
  elseif haskey(t,:ST) show(io,d,Val(Symbol("G",t.ST)))
  else getchev(t,:PrintDiagram,t.indices,"G$(t.p),$(t.q),$(rank(t))")
  end
end

"""
`diagram(W)` diagram of finite reflection group `W`
```julia-repl
julia> diagram(coxgroup(:E,8))
    O 2
    ￨
O—O—O—O—O—O—O E₈
1 3 4 5 6 7 8

julia> diagram(crg(33))
      3       G₃₃
     /^\\
1———2———4———5 423423==342342
```
"""
diagram(W)=Diagram.(refltype(W))
#---------------------------------------------------------------------------
"""
`PermRootGroup`   is  the  type  of  reflection  groups  represented  as  a
permutation group on a set of roots.
"""
abstract type PermRootGroup{T,T1<:Integer}<:PermGroup{T1} end

inclusiongens(W::PermRootGroup)=inclusion(W,eachindex(gens(W)))
"""
`inclusion(W::PermRootGroup)`

the indices of the roots of `W` in the roots of `parent(W)`.

`inclusion(W::PermRootGroup,i::Integer)`
`inclusion(W::PermRootGroup,v::AbstractVector{<:Integer})`

same as `inclusion(W)[i]` or `inclusion(W)[v]` (but more efficient).
"""
inclusion(L,W,i)=restriction(W,inclusion(L,i))
inclusion(L,W)=restriction(W,inclusion(L))
inclusiongens(L,W)=restriction(W,inclusiongens(L))
"""
`number_of_reflections(W::ComplexReflectionGroup)` or `nref(W)`

the number of reflections of `W`
"""
nref(W::PermRootGroup)=sum(nref,refltype(W);init=0)
nref(t::TypeIrred)=sum(degrees(t).-1)
const number_of_reflections=nref

"""
`number_of_hyperplanes(W::ComplexReflectionGroup)` or `nhyp(W)`

The number of reflecting hyperplanes of `W`
"""
nhyp(W::PermRootGroup)=sum(nhyp,refltype(W);init=0)
nhyp(t::TypeIrred)=sum(codegrees(t).+1)
const number_of_hyperplanes=nhyp

"""
`coxeter_number(W::PermRootGroup,i)` or `coxnum`

Gordon  and  Griffeth  [GG2012](biblio.htm#gg12)  have defined the *Coxeter
number*  of an irreducible  character `φ` of  a complex reflection group as
the scalar by which the central element `∑_{s in reflections(W)}(1-s)` acts
on  the representation of character `φ`.  The function `coxnum` returns the
Coxeter number of the `i`-th irreducible character of `W`.
"""
coxnum(W::PermRootGroup,i)=Int(charinfo(W).a[i]+charinfo(W).A[i])
# The computation uses Proposition 0.1 of Michel's "tower equivalence"

"""
`coxeter_number(W::PermRootGroup)` or `coxnum`

Gordon  and  Griffeth  [GG2012](biblio.htm#gg12)  have defined the *Coxeter
number* of an irreducible complex reflection group as the Coxeter number of
its reflection character. It is also given by the formula
`(nref(W)+nhyp(W))/rank(W)`;  for a well-generated group it is equal to the
highest  reflection degree. For a non-irreducible group, the Coxeter number
is the sum of those of its irreducible components.
"""
coxnum(W::PermRootGroup)=sum(t->coxnum(t),refltype(W);init=0)

coxnum(t::TypeIrred)=div(nhyp(t)+nref(t),rank(t))

const coxeter_number=coxnum

# should use independent_roots
function Base.:(==)(W::PermRootGroup,W1::PermRootGroup)
  if ngens(W)!=ngens(W1) return false end
  all(i->roots(W,i)==roots(W1,i) && coroots(W,i)==coroots(W1,i), 1:ngens(W))
end

function Base.hash(W::PermRootGroup,h::UInt)
  for i in 1:ngens(W) h=hash(roots(W,i),h) end
  for i in 1:ngens(W) h=hash(coroots(W,i),h) end
  h
end

"""
`simple_reps(W)`

for each root, the index of the first simple root conjugate to it
"""
function simple_reps(W::PermRootGroup) # fills .simple_conjugating and .refls
  get!(W,:simple_reps)do
    reps=fill(0,length(roots(W)))
    repelts=fill(one(W),length(roots(W)))
    for i in eachindex(gens(W))
      if iszero(reps[i])
        d=transversal(W,inclusion(W,i))
        for (n,e) in d
          reps[restriction(W,n)]=i
          repelts[restriction(W,n)]=e
        end
      end
    end
    W.simple_conjugating=repelts
    W.refls=map((i,p)->gens(W)[i]^p,reps,repelts)
    W.unique_refls=unique(i->W.refls[i],eachindex(W.refls))
    reps
  end::Vector{Int}
end

"""
`simple_reps(W,i)`

the  smallest index  of a root in the same `W`-orbit as the `i`-th root.
"""
simple_reps(W::PermRootGroup,i)=simple_reps(W)[i]

"""
`refls(W::ComplexReflectionGroup)`

a  list of same length as  `W.roots` giving the corresponding distinguished
reflections. In particular this list is much longer than `unique(refls(W))`
since in general there are several roots corresponding to a reflection.
"""
refls(W::PermRootGroup{T,T1}) where{T,T1}=getp(simple_reps,W,:refls)::Vector{Perm{T1}}

"""
`refls(W,i)`

reflection for `i`-th root(s) of `W` (`i` can be an index or a vector of indices)
"""
refls(W::PermRootGroup,i::Integer)=i<=ngens(W) ? gens(W)[i] : refls(W)[i]
refls(W::PermRootGroup,i::AbstractVector)=map(j->refls(W,j),i)

"""
`simple_conjugating(W)`

For each index `i` of a root, an element `w∈ W` such that
`restriction(W,inclusion(W,simple_reps(W,i))^w)==i`
(or `action(W,simple_reps(W,i))==i`)
"""
simple_conjugating(W::PermRootGroup{T,T1}) where{T,T1}=getp(simple_reps,W,:simple_conjugating)::Vector{Perm{T1}}

unique_refls(W)=getp(simple_reps,W,:unique_refls)::Vector{Int}

"""
`simple_conjugating(W,i)`

an element `w∈ W` such that `restriction(W,inclusion(W,simple_reps(W,i))^w)==i`
(or `action(W,simple_reps(W,i))==i`)
"""
simple_conjugating(W::PermRootGroup,i)=simple_conjugating(W)[i]

"""
`cartan(W::PermRootGroup,i,j)`
the  cartan coefficient `cᵢ(rⱼ)`, the value of the linear form given by the
`i`-th coroot `cᵢ` on the `j`-th root `rᵢ` of `W`
"""
cartan(W::PermRootGroup,i,j)=transpose(coroots(W,i))*roots(W,j)

"""
`cartan(W::PermRootGroup)`    Cartan matrix of `W`.

Let  `s₁,…,sₙ` be reflections with associated  roots `rᵢ` and coroots `cᵢ`.
The  matrix `C` with  entries `Cᵢ,ⱼ=cᵢ(rⱼ)` is  called a *Cartan matrix* of
`s₁,…,sₙ`.  Since a reflection determines up to scalar a root and a coroot,
`C`  is uniquely  determined by  `s₁,…,sₙ` up  to conjugation by a diagonal
matrix.

If `s₁,…,sₙ` generate a reflection group `W`, then `C` up to conjugation by
a  diagonal matrix is an invariant of the reflection representation of `W`.
If invertible, the matrix `C` determines this representation since then the
`rᵢ`  form a basis in  which the matrix for  `sᵢ` differs from the identity
only  on the  `i`-th line,  where the  corresponding line  of `C`  has been
subtracted.

```julia-repl
julia> W=coxgroup(:A,3)
A₃

julia> cartan(W)
3×3 Matrix{Int64}:
  2  -1   0
 -1   2  -1
  0  -1   2
```
"""
function cartan(W::PermRootGroup{T,T1})where {T,T1}
  get!(W,:cartan)do
    istorus(W) ? fill(0,0,0) : cartan(W,1:ngens(W))
  end
end

cartan(t::TypeIrred)=improve_type(toM(getchev(t,:CartanMat)))
cartan(W::PermRootGroup,I)=[cartan(W,i,j) for i in I, j in I]

"""
`rank(W::ComplexReflectionGroup)`

This  function  returns  the  *rank*  of  a  reflection group, which is the
dimension of the space where it acts.

```julia-repl
julia> rank(complex_reflection_group(31))
4
```
"""
rank(W::PermRootGroup)=istorus(W) ? W.rank : length(roots(W,1))

"""
Let  W be an irreducible CRG,  generated by distinguished reflections S.
type_irred classifies W (returns a type record) using:

  -  r=semisimplerank(W)
  -  s=length(W)/factorial(r)
  -  D=all distinguished reflections of W=orbit of S,    which gives
  -  o=the maximum order of a reflection=max_{s∈ S}o(s)
  -  h=the Coxeter number=sum_{s∈ D}o(s)

G(de,e,r) has s=(de)ʳ/e, o=max(2,d), h=ed(r-1)+d-δ_{d,1}

(r,s,o)  are  sufficient  to  determine  a G(de,e,r) excepted for ambiguity
G(2e,e,2)/G(4e,4e,2),  which is resolved  by h (excepted  for e=1, when the
two solutions are isomorphic).

(r,s,o) are also sufficient to distinguish primitive groups except in the
cases (which are resolved by h):
 G9/G(24,6,2)
 G12/G(12,6,2)/G(24,24,2)
 G13/G(24,12,2)/G(48,48,2)
 G22/G(60,30,2)/G(120,120,2)
 G7/G14/G(24,8,2)
 G8/G(12,3,2)
 G15/G(48,16,2)
 G17/G(120,24,2)
 G21/G(120,40,2)
"""
function type_irred(W::PermRootGroup)
prim=[
  (r=0, s=0, o=0, h=0),  # 3 dummy items to get right Shephard-Todd number
  (r=0, s=0, o=0, h=0),
  (r=0, s=0, o=0, h=0),
  (r=2, s=12, o=3, h=6),
  (r=2, s=36, o=3, h=12),
  (r=2, s=24, o=3, h=12),
  (r=2, s=72, o=3, h=18),
  (r=2, s=48, o=4, h=12),
  (r=2, s=96, o=4, h=24),
  (r=2, s=144, o=4, h=24),
  (r=2, s=288, o=4, h=36),
  (r=2, s=24, o=2, h=12),
  (r=2, s=48, o=2, h=18),
  (r=2, s=72, o=3, h=24),
  (r=2, s=144, o=3, h=30),
  (r=2, s=300, o=5, h=30),
  (r=2, s=600, o=5, h=60),
  (r=2, s=900, o=5, h=60),
  (r=2, s=1800, o=5, h=90),
  (r=2, s=180, o=3, h=30),
  (r=2, s=360, o=3, h=60),
  (r=2, s=120, o=2, h=30),
  (r=3, s=20, o=2, h=10),
  (r=3, s=56, o=2, h=14),
  (r=3, s=108, o=3, h=12),
  (r=3, s=216, o=3, h=18),
  (r=3, s=360, o=2, h=30),
  (r=4, s=48, o=2, h=12),
  (r=4, s=320, o=2, h=20),
  (r=4, s=600, o=2, h=30),
  (r=4, s=1920, o=2, h=30),
  (r=4, s=6480, o=3, h=30),
  (r=5, s=432, o=2, h=18),
  (r=6, s=54432, o=2, h=42),
  (r=6, s=72, o=2, h=12),
  (r=7, s=576, o=2, h=18),
  (r=8, s=17280, o=2, h=30)]

  r=semisimplerank(W)
  s=div(length(W),factorial(r))
  if s==r+1 return Dict(:series => :A, :rank => r)
  elseif r==1 return Dict(:series=>:ST,:p=>s,:q=>1,:rank=>1)
  else l=([p.^(a+m-a*r,a*r-m) for a in div(m+r-1,r):div(m,r-1)]
                       for (p,m) in eachfactor(s))
    de=vec((x->(d=prod(first.(x)),e=prod(last.(x)))).(Iterators.product(l...)))
  end
  o=maximum(ordergens(W))
# println("de=$de, o=$o, h=$h")
  de=filter(x->o==max(2,x.d),de) #  here we have length(de)<=2
  ST=filter(i->r==prim[i].r && s==prim[i].s && o==prim[i].o,eachindex(prim))
# if isempty(de) && length(ST)==1 # shortcut
#   return Dict(:series=>:ST, :ST=>only(ST), :rank=> r)
# end
  h=div(sum(order,refls(W,unique_refls(W))),r) # Coxeter number
  if length(de)>1
    de=sort(de)
    if h==de[1].e de=[de[1]]
    elseif h==2*de[2].e+2 de=[de[2]]
    else return Dict(:series=>:ST, :ST=>only(ST), :rank=> r)
    end
  end
  if length(de)>0 && length(ST)>0
    ST=filter(i->prim[i].h==h,ST)
    if !isempty(ST) return Dict(:series=>:ST, :ST=>only(ST), :rank=>r) end
  end
  if length(de)==0
    if only(ST) in [23,30] return Dict(:series=>:H, :rank => r)
    elseif only(ST)==28 return Dict(:series=>:F, :rank => r)
    elseif only(ST) in 35:37 return Dict(:series=>:E, :rank => r)
    else return Dict(:series=>:ST,:ST =>only(ST),:rank => r)
    end
  end
  d=only(de)
  if d.d==2 && d.e==1 return Dict(:series=>:B, :rank=>r) end
  if d.d==1 && d.e==2 return Dict(:series=>:D,:rank=>r) end
  if d.d==1 && r==2
    if d.e==4 return Dict(:series=>:B, :rank=>2)
    elseif d.e==6 return Dict(:series=>:G, :rank=>2)
    else return Dict(:series=>:I, :rank=>2, :bond=>d.e)
    end
  end
  Dict(:series=>:ST, :p=>d.d*d.e, :q=>d.e, :rank=>r)
end

"""
`check_minimal_relation(gens,rel;verbose=false)`

returns `true` iff the homogeneous relation
`prod(gens[rel[1]])==prod(gens[rel[2]])` is a minimal relation between gens
(in  particular,  no  left  factor  homogeneous  relation  holds),  `false`
otherwise. If `verbose=true` prints a description of failure.
"""
function check_minimal_relation(gens,rel;verbose=false)
  p(l,r)=joindigits(l)*"="*joindigits(r)
  L,R=rel
  l=gens[L[1]]
  r=gens[R[1]]
  i=1
  while i<length(L)
    if l==r
      if verbose print(" relation ",p(L[1:i],R[1:i])," already holds") end
      return false
    end
    i+=1
    l*=gens[L[i]]
    r*=gens[R[i]]
  end
  if l==r return true end
  if verbose print(" relation ",p(L,R)," failed") end
  false
end

function Groups.ordergens(t::TypeIrred)
  t.series in [:E,:F,:G,:H] ? fill(2,rank(t)) :
    Int.(inv.(getchev(t,:EigenvaluesGeneratingReflections)))
end

# g is a sublist of 1:length(H.roots). Returns sublist k of g such that
# refls(H,k) satisfy braid and order relations of type t
function findgoodgens(H,g,t::TypeIrred)
# println("g=$g\n t=");ds(t)
  orders=ordergens(t)
  rels=groupby(r->maximum(r[1]),braid_relations(t))
  # check gens satisfy relations concerning them, find if can add
  # another gen from rest
  function findarr(gens,rest)
    if length(gens)==length(orders)
      if length(Group(gens))==length(H) return Int[]
      else return nothing
      end
    end
    i=length(gens)+1
    for e in rest
#     println("$e(",length(gens),")")
      if ordergens(H)[simple_reps(H)[e]]!=orders[i] continue end
      newgens=vcat(gens,[refls(H,e)])
      if !haskey(rels,i) || all(r->check_minimal_relation(newgens,r),rels[i])
        res=findarr(newgens,setdiff(rest,[e]))
        if !isnothing(res) return vcat([e],res) end
      end
    end
    return nothing
  end
  return findarr(eltype(H)[],g)
end

# findgoodcartan(H,g,C):  g is a sublist of eachindex(H.roots).
# Returns sublist k of g such that cartan(H,k)=C or nothing if none exists.
function findgoodcartan(H,g,C)
  function find(k,rest) # k has good cartan, see if can add some e∈ rest
    if length(k)==size(C,1) return k end
    i=length(k)+1
    for e in rest
#     println("$e(",length(k),")")
      if cartan(H,e,e)==C[i,i] &&
         all(j->cartan(H,e,k[j])==C[i,j],1:i-1) &&
         all(j->cartan(H,k[j],e)==C[j,i],1:i-1)
        res=find(vcat(k,[e]),setdiff(rest,[e]))
        if !isnothing(res) return res end
      end
    end
    return nothing
  end
  return find(Int[],g)
end

# try to make indecomposable cartan(H,p) like C by rotating roots
function fixCartan(H,C,p)
  CH=cartan(H,p)
  r=Weyl.type_fincox_cartan(CH)
  if !isnothing(r) return [r,p] end
  seen=[size(CH,1)]
  for i in size(CH,1):-1:1
  # go reverse for better luck in type B?
    for j in i:-1:1
      if CH[i,j]!=C[i,j]
        if CH[i,j]==0 || (j in seen) return nothing end
          r=C[i,j]//CH[i,j]
          r=findfirst(==(roots(H,p[j])*r),roots(H))
          if r===nothing return nothing end
          p=copy(p)
          p[j]=r
          return fixCartan(H,C,p)
        end
      if C[i,j]!=0 push!(seen,j) end
    end
  end
  return [r,p]
end

function findgensDiagCartan2(H,C)
  f(x,y)=y==0 ? (x==0 ? 0 : nothing) : x//y
  # here CartanMat(H,l) is conjugate by DiagonalMat(d) to beginning of C
  function complete(l,d)
    local r,c,cc,n
    if length(l)==size(C,1) return (l,d) end
    n=length(l)+1
    for r in filter(i->cartan(H,i,i)==C[n,n],eachindex(roots(H)))
      cc=vcat(map(i->f(d[i]*C[i,n],cartan(H,l[i],r)),1:n-1),
              map(i->f(d[i]*cartan(H,r,l[i]),C[n,i]),1:n-1))
      cc=setdiff(cc,[0])
      if length(cc)<=1 && !(nothing in cc)
        if length(cc)==0 cc=[1] end
        c=complete(vcat(l,[r]),vcat(d,[cc[1]]))
        if c!==nothing return c end
      end
    end
  end
  return complete(Int[],eltype(C)[])
end

# find other roots with same reflection in inclusion(H) with cartan equal to
# C^diagonal matrix
# returns [sublist, coeffs of corresp. diagonal matrix]
function findgensDiagCartan(H,C,p)
  CH=cartan(H,p)
  f(x,y)=y==0 ? (x==0 ? 0 : nothing) : x//y
  d=zeros(eltype(CH),size(CH,1))
  d[1]=1
  for n in 2:size(C,1)
  # here CartanMat(H,l) is conjugate by DiagonalMat(d) to beginning of C
    l=filter(i->ratio(roots(H,p[n]),roots(H,i))!==nothing,eachindex(roots(H)))
    cc=map(r->vcat(map(i->f(d[i]*C[i,n],cartan(H,p[i],r)),1:n-1),
                   map(i->f(d[i]*cartan(H,r,p[i]),C[n,i]),1:n-1)),l)
    if any(x->nothing in x,cc) error("grave") end
    cc=filter.(!iszero,cc)
    cc=unique.(cc)
    if any(x->length(x)>1,cc) return nothing end
    cc=only.(cc)
    best=findfirst(==(1),cc)
    if !isnothing(best)
      p[n]=l[best]
      d[n]=1
    else
      d[n]=cc[1]
      p[n]=l[1]
    end
  end
  p,d
end

function refltype(W::PermRootGroup)
  get!(W,:refltype)do
    map(diagblocks(cartan(W))) do I
      R=I==eachindex(gens(W)) ? W : reflection_subgroup(W,I;NC=true)
      d=TypeIrred(type_irred(R))
      C=cartan(d)
      if C==cartan(R) indices=I
      else
        good=findgoodcartan(R,eachindex(gens(R)),C)
        if isnothing(good) good=findgoodcartan(R,eachindex(roots(R)),C) end
        if isnothing(good) good=findgoodgens(R,unique_refls(R),d)
          better=fixCartan(R,C,good)
          if !isnothing(better) good=better[2]
          else better=findgensDiagCartan(R,C,good)
            if !isnothing(better) good=better[1]
            else better=findgensDiagCartan2(R,C)
              if !isnothing(better) good=better[1] end
            end
          end
          if d.series!=:ST
            d=TypeIrred(Weyl.type_fincox_cartan(cartan(R,good)))
          end
        end
        indices=inclusion(R,W,good)
      end
      d.indices=indices
      d
    end
  end::Vector{TypeIrred}
end

"""
`bipartite_decomposition(W)`

Returns  a bipartite decomposition `[L,R]` of the indices of the generators
of  the  reflection  group  `W`,  such  that `reflection_subgroup(W,L)` and
`reflection_subgroup(W,R)` are abelian subgroups, and
`W=reflection_subgroup(W,   vcat(L,R))`.   Gives   an   error  if  no  such
decomposition is possible.

```julia-repl
julia> bipartite_decomposition(coxgroup(:E,8))
([1, 4, 6, 8], [3, 2, 5, 7])

```
"""
function bipartite_decomposition(W)
  L=Int[]
  R=Int[]
  rest=collect(eachindex(gens(W)))
  commute(x,y)=W(x)*W(y)==W(y)*W(x)
  while length(rest)>0
    r=findfirst(x->any(y->!commute(x,y),L),rest)
    if r!=nothing
      if any(y->!commute(rest[r],y),R)
        error(W," has no bipartite decomposition")
      end
      push!(R,rest[r])
      deleteat!(rest,r)
    else r=findfirst(x->any(y->!commute(x,y),R),rest)
      if r!=nothing push!(L,rest[r]); deleteat!(rest,r)
      else push!(L,rest[1]); deleteat!(rest,1);
      end
    end
  end
  L,R
end

"""
`reflchar(W::ComplexReflectionGroup,w)` Reflection character

Returns  the trace  of the  element `w`  of `W`  as an  endomorphism of the
vector space `V` on which `W` acts. This is the same as
`trace(reflrep(W,w))`.

```julia-repl
julia> W=coxgroup(:B,3)
B₃

julia> reflchar(W,longest(W))
-3
```
"""
reflchar(W::PermRootGroup,w)=tr(reflrep(W,w))

"""
`reflchar(W::ComplexReflectionGroup)`

Returns   the  reflection   character  of   `W`.  This   is  the   same  as
`map(c->reflchar(W,c),class-reps(W))`.  When `W` is irreducible, it is also
`CharTable(W).irr[charinfo(W).extRefl[2]]`.

```julia-repl
julia> reflchar(coxgroup(:A,3))
5-element Vector{Int64}:
  3
  1
 -1
  0
 -1
```
"""
reflchar(W::PermRootGroup)=reflchar.(Ref(W),classreps(W))

"""
`refleigen(W)` Reflection eigenvalues

Let  `W`  be  a  reflection  group  on the vector space `V`. `refleigen(W)`
returns   for  each  conjugacy   class  representative  `x`   of  `W`  (see
`classreps`) the eigenvalues of `x` on `V`, as a list of `Root1`.

```julia-repl
julia> refleigen(coxgroup(:B,2))
5-element Vector{Vector{Root1}}:
 [1, 1]
 [-1, 1]
 [-1, -1]
 [-1, 1]
 [ζ₄³, ζ₄]
```
"""
function refleigen(W)
  get!(classinfo(W),:refleigen) do
    t=refltype(W)
    if !any(x->haskey(x,:orbit) && (length(x.orbit)>1 || order(x.twist)>1 ||
       (haskey(x,:scalar) && !all(isone,x.scalar))),t)
      if isempty(t) ll=[Root1[]]
      else ll=map(x->vcat(x...),cartesian(map(refleigen,t)...))
      end
      central=(W isa Spets ? torusfactors(W) :
                            fill(E(1),rank(W)-semisimplerank(W)))
      ll=map(x->vcat(x,central),ll)
      sort.(ll)
    else eigen.(conjugacy_classes(W))
    end
  end::Vector{Vector{Root1}}
end

function refleigen(t::TypeIrred)
  if haskey(t,:orbit) t=t.orbit[1] end #orbits are trivial after above function
  ct=CharTable(t).irr[charinfo(t).extRefl,:]
  v=map(i->Pol([(-1)^i],i),size(ct,1)-1:-1:0)
  l=CycPol.(vec(transpose(v)*ct))
  ll=map(p->vcat(map(((r,c),)->fill(r,c),p.v.d)...),l)
  if haskey(t,:scalar) ll.*=Root1(prod(t.scalar)) end
  ll
end

" `refleigen(W,i)` faster than `refleigen(W)[i]`"
refleigen(W,i)=refleigen(W)[i] # not faster this way...

"""
`reflection_length(W::PermRootGroup,w::Perm)` or `reflength`

This  function returns the  number of eigenvalues  of `w` in the reflection
representation  which are not equal to 1.  For a finite Coxeter group, this
is  equal to the  reflection length of  `w`, that is  the minimum number of
reflections  of which  `w` is  a product.  This also  holds in general in a
well-generated  complex reflection group  if `w` divides  a Coxeter element
for the reflection length.

```julia-repl
julia> W=coxgroup(:A,4)
A₄

julia> reflength(W,longest(W))
2

julia> reflength(W,W(1,2,3,4))
4
```
"""
function Perms.reflection_length(W::PermRootGroup,w::Perm)
  reflength(conjugacy_classes(W)[position_class(W,w)])
end

"""
`torus_order(W::ComplexReflectionGroup,i,q=Pol())`

returns  as a  polynomial in  `q` the  toric order  of the `i`-th conjugacy
class  of `W`. This is the characteristic  polynomial of an element of that
class  on  the  reflection  representation  of  `W`.  It is the same as the
generic  order of the reflection subcoset `torus(W,i)` of `W` determined by
the trivial subgroup and a representative of the `i`-th conjugacy class.

```julia-repr
julia> W=complex_reflection_group(4)

julia> torus_order.(Ref(W),1:nconjugacy_classes(W),Pol(:q))
7-element Vector{Pol{Cyc{Int64}}}:
 q²-2q+1
 q²+2q+1
 q²+1
 q²-ζ₃q+ζ₃²
 q²+ζ₃q+ζ₃²
 q²+ζ₃²q+ζ₃
 q²-ζ₃²q+ζ₃
```
"""
torus_order(W::PermRootGroup,i,q=Pol())=prod(l->q-l,refleigen(W)[i])

Base.show(io::IO,::MIME"text/plain",v::Vector{TypeIrred})=show(io,v)

function Base.show(io::IO, t::AbstractVector{<:TypeIrred})
  r=0
  n=join(map(t)do t
    n=repr(t; context=io)
    inds=indices(t)
    if isnothing(inds) n*="?"
    elseif inds!=r .+eachindex(inds) && hasdecor(io)
      n="{"*n*"}"*"_{"*joindigits(inds;always=true)*"}"
    end
    r+=rank(t)
    n
   end,hasdecor(io) ? "\\times{}" : "*")
  n=fromTeX(io,n)
  print(io,n)
end

function showtorus(io::IO,W)
  t=rank(W)-semisimplerank(W)
  if t>0
    if hasdecor(io) print(io,CycPol(1,0,(1,0,t)))
    else print(io,(istorus(W) ? "" : "*"),"PRG($t)")
    end
  elseif istorus(W) print(io,hasdecor(io) ? "." : "PRG(0)")
  end
end

function Base.show(io::IO, W::PermRootGroup)
  show(io,refltype(W))
  showtorus(io,W)
end

function independent_roots(W::PermRootGroup{T,T1})where{T,T1}
  get!(W,:indeproots) do
    if istorus(W) Int[]
    else sort(independent_rows(toM(roots(W))))
    end
   end::Vector{Int}
end

"""
`semisimpleRank(W::ComplexReflectionGroup)`

This  function returns the  *semisimple rank* of  the reflection group `W`,
which  is the dimension of the space where it effectively acts. If `W` is a
reflection  group acting on `V`, and `V₁`  is the subspace generated by the
`roots(W)`,  then  the  dimension  of  `V₁`  is the semisimple rank. `W` is
called *essential* if `V₁=V`.

```julia-repl
julia> W=reflection_subgroup(coxgroup(:A,3),[1,3])
A₃₍₁₃₎=A₁×A₁Φ₁

julia> semisimplerank(W)
2

julia> rank(W)
3
```
"""
function semisimplerank(W::PermRootGroup)
  get!(W,:semisimplerank)do
    length(independent_roots(W))
  end::Int
end

function baseX(W::PermRootGroup{T,T1})where{T,T1}
  get!(W,:baseX) do
    if istorus(W) return one(zeros(T,rank(W),rank(W))) end
    ir=independent_roots(W)
    res=toM(roots(W,ir))
    u=lnullspace(transpose(toM(coroots(W,ir))))
    if eltype(u) <:Rational
      for v in eachrow(u) v.*=lcm(denominator.(v)...) end
      u=Int.(u)
    end
    vcat(res,u)
  end
end

function invbaseX(W::PermRootGroup)
  get!(W,:invbaseX)do
    X=baseX(W)
    improve_type(inv(X*1//1))
  end
end

# L is a reflection subgroup and  m a matrix which normalizes L in its
# reflection representation. Returns the matrix by which m acts on X(Z_L)
function central_action(L,m)
  if size(m,2)==0 return m end
  m=improve_type(baseX(L)*m*invbaseX(L))
  r=semisimplerank(L)
  improve_type(m[r+1:end,r+1:end])
end

"""
`PermX(W::ComplexReflectionGroup,M::AbstractMatrix)`

Let `M` be an invertible linear map of the reflection representation of `W`
which  preserves the set  of roots of  `parent(W)`, and normalizes `W` (for
the  action of  matrices on  the right).  `PermX` returns the corresponding
permutation  of the roots of `parent(W)`;  it returns `nothing` if `M` does
not normalize the set of roots of `parent(W)`.

```julia-repl
julia> W=reflection_subgroup(rootdatum("E7sc"),1:6)
E₇₍₁₂₃₄₅₆₎=E₆Φ₁

julia> PermX(W,reflrep(W,longest(W)))==longest(W)
true
```
"""
function PermX(W::PermRootGroup,M::AbstractMatrix)
  Perm(parent(W).roots,Ref(transpose(M)).*parent(W).roots)
end

function PermGroups.reduced(W::PermRootGroup,F)
  function redcenter(W,F)
    FF=F.*elements(center(W))
    if true
      if F in parent(W)
        ch=map(x->refleigen(parent(W))[position_class(parent(W),x)],FF)
      else
        ch=map(x->eigmat(reflrep(W,x)),FF)
      end
      m=minimum(map(x->sum(order.(x)),ch))
      if length(m)>1 println("warning",length(m)) end
      m=findall(x->sum(order.(x))==m,ch)
    else
      ch=map(x->conductor(charpoly(reflrep(W,x))),FF)
      m=minimum(ch)
      m=findall(==(m),ch)
    end
    minimum(FF[m])
  end
  if isone(F) return F end
  if issubset(inclusiongens(W).^F,inclusion(W))
    w=PermX(W,reflrep(W,F))
    if !isnothing(w) && w in W return redcenter(W,w\F)
    elseif length(W)==1 return F
    end
  end
  base=gens(W)
  w=transporting_elt(W,base,base.^F,ontuples)
  if !isnothing(w) return redcenter(W,F/w) end
  w=transporting_elt(W,sort(base),sort(base.^F),onsets)
  t=refltype(W)
  for a in t
    if Cosets.isG333(a)
      subgroup=reflection_subgroup(W,a.indices)
      base=gens(subgroup).^F
      if !all(x->x in W,base) error("F must normalize W") end
      if !all(x->x in subgroup,base)
        error("not implemented: F permutes components")
      end
      base=chevieget(:timp,:ReducedInRightCoset)(subgroup,F)
      if isnothing(base) error("should not happen subgroup=$subgroup F=$F")
      else indices=restriction(W,base.gen)
        F=base.phi
      end
      return (phi=F,reflectiongroup=reflection_subgroup(W,indices;NC=true))
    end
  end
  if !isnothing(w) return redcenter(W,F/w) end
  return nothing
end

function Groups.classreps(W::PermRootGroup{T,T1})where{T,T1}
  get!(W,:classreps)do
    map(x->x.representative,conjugacy_classes(W))
  end::Vector{Perm{T1}}
end

function Groups.nconjugacy_classes(W::PermRootGroup)
  prod(nconjugacy_classes.(refltype(W));init=1)
end

"""
`parabolic_reps(W)`

For  a Coxeter group or finite complex reflection group `W`, returns a list
of  indices  of  roots  of  `W`  describing  representatives  of  orbits of
parabolic  subgroups  under  conjugation  by  `W`. For Coxeter groups, each
orbit  has a representative which is a standard parabolic subgroup, that is
whose indices is a subset of `eachindex(gens(W))`. This may not be the case
in general.

```julia-repl
julia> parabolic_reps(coxgroup(:A,4))
7-element Vector{Vector{Int64}}:
 []
 [1]
 [1, 2]
 [1, 3]
 [1, 2, 3]
 [1, 2, 4]
 [1, 2, 3, 4]

julia> parabolic_reps(complex_reflection_group(3,3,3))
7-element Vector{Vector{Int64}}:
 []
 [1]
 [1, 2]
 [1, 3]
 [1, 9]
 [2, 3]
 [1, 2, 3]
```

`parabolic_reps(W,r)`

If  a second  argument `r`  is given,  returns only  representatives of the
parabolic subgroups of semisimple rank `r`.
```julia-repl
julia> parabolic_reps(coxgroup(:A,4),2)
2-element Vector{Vector{Int64}}:
 [1, 2]
 [1, 3]

julia> parabolic_reps(complex_reflection_group(3,3,3),2)
4-element Vector{Vector{Int64}}:
 [1, 2]
 [1, 3]
 [1, 9]
 [2, 3]
```
"""
parabolic_reps(W)=vcat(parabolic_reps.(Ref(W),0:semisimplerank(W))...)

parabolic_reps(t::TypeIrred,s)=getchev(t,:ParabolicRepresentatives,s)

function recompute_parabolic_reps(W) # W irreducible
  by=1+ngens(W)-semisimplerank(W)
  stoi=s->findfirst(i->refls(W,i)==s,eachindex(roots(W)))
  l=[map(x->reflection_subgroup(W,[x]),sort(unique(simple_reps(W))))]
  for i in 2:semisimplerank(W)-1
    new=[];ref=Vector{Pair{Int,Int}}[]
    for v in l[i-1]
      InfoChevie("# Extending ",v)
      S=normalizer(W,v)
      if ngens(v)==i-1
        c=union(map(i->combinations(unique_refls(W),i),1:by)...)
      else c=combinations(unique_refls(W),1)
      end
      c=map(x->union(x,restriction(W,inclusiongens(v))),c)
      c=filter(x->GenLinearAlgebra.rank(toM(roots(W,x)))==i,c)
      InfoChevie(" ",length(c)," new subgroups")
      c=map(function(x)InfoChevie("*");reflection_subgroup(W,x) end,c)
      c=filter(isparabolic,c)
      c=sort(unique(map(x->sort(unique(refls(x))),c)))
      O=orbits(S,c,onsets)
      O=map(o->o[argmin(map(x->sum(stoi,x),o))],O)
      O=map(x->reflection_subgroup(W,stoi.(x)),O)
      InfoChevie("# ",length(O)," to go\n")
      for c in O
        rr=tally(degrees(c))
        cand=filter(i->ref[i]==rr,eachindex(ref))
        InfoChevie("# candidates for ",c," to be conjugate:",new[cand],"\n")
        if all(v->transporting_elt(W,v,c)===nothing,new[cand])
             InfoChevie("# new:",c,"\n")
             push!(new,c);push!(ref,rr);
        end
      end
    end
    InfoChevie("# i=",i," found:",new,"\n")
    push!(l,new)
  end
  l=map(vcat(l...))do v
    p=standard_parabolic(W,v)
    if p!==nothing v=v^p end
    v
  end
  l=collectby(semisimplerank,l)
  l=map(v->inclusiongens.(v),l)
  l=vcat([[Int[]]],l)
  push!(l,[inclusiongens(W)])
  l=map(v->map(x->map(y->Int(stoi(refls(W,restriction(W,y)))),x),v),l)
  [sort(sort.(x)) for x in l]
end

function parabolic_reps(W::PermRootGroup,s)
  t=refltype(W)
  sols=filter(l->sum(l)==s,cartesian(map(x->0:rank(x),t)...))
  vcat(map(sols)do c
        map(x->vcat(x...),cartesian(map(eachindex(c))do i
    r=parabolic_reps(t[i],c[i])
    if r==false
      R=reflection_subgroup(W,t[i].indices)
      return recompute_parabolic_reps(R)[c[i]+1]
    elseif all(x->all(y->y in 1:t[i].rank,x),r)
      return map(x->t[i].indices[x],r)
    else R=reflection_subgroup(W,t[i].indices)
      return map(x->inclusion(R,W,x),r);
    end
    end...))end...)
end

"""
`reflection_representation(W,w)`  or `reflrep(W,w)`

Let  `W` be a  finite reflection group  on the space  `V` and let  `w` be a
permutation  of the roots of `W`. The function `reflrep` returns the matrix
of  `w` acting on `V`  (recall that matrices operate  *from the right* on a
vector  space in `Gapjm`).  This is the  linear transformation of `V` which
acts  trivially on the orthogonal of the coroots and has same effect as `w`
on the simple roots. The function makes sense more generally for an element
of the normalizer of `W` in the whole permutation group of the roots.

```julia-repl
julia> W=reflection_subgroup(rootdatum("E7sc"),1:6)
E₇₍₁₂₃₄₅₆₎=E₆Φ₁

julia> reflrep(W,longest(W))
7×7 Matrix{Int64}:
  0   0   0   0   0  -1  2
  0  -1   0   0   0   0  2
  0   0   0   0  -1   0  3
  0   0   0  -1   0   0  4
  0   0  -1   0   0   0  3
 -1   0   0   0   0   0  2
  0   0   0   0   0   0  1
```
"""
function reflrep(W::PermRootGroup,w)
  W=parent(W)
  X=baseX(W)
  if isone(w) return one(X) end
  if istorus(W) return X end
  ir=independent_roots(W)
  X=vcat(toM(roots(W,ir.^w)),X[length(ir)+1:end,:])
  improve_type(invbaseX(W)*X)
end

const reflection_representation=reflrep

"""
`matY(W,w)`

Let  `W` be a  finite reflection group  on the space  `V` and let `w` be an
element of `W`. The function `matY` returns the matrix of `w` acting on the
dual  of `V`. This  is the linear  transformation of this  space which acts
trivially  on the orthogonal of the roots and has same effect as `w` on the
simple  coroots. The function makes sense  more generally for an element of
the normalizer of `W` in the whole permutation group of the coroots.

```julia-repl
julia> W=reflection_subgroup(rootdatum("E7sc"),1:6)
E₇₍₁₂₃₄₅₆₎=E₆Φ₁

julia> matY(W,longest(W))
7×7 transpose(::Matrix{Int64}) with eltype Int64:
  0   0   0   0   0  -1  0
  0  -1   0   0   0   0  0
  0   0   0   0  -1   0  0
  0   0   0  -1   0   0  0
  0   0  -1   0   0   0  0
 -1   0   0   0   0   0  0
  2   2   3   4   3   2  1
```
"""
matY(W::PermRootGroup,w)=transpose(reflrep(W,inv(w)))
"""
`PermY(W::ComplexReflectionGroup,M::AbstractMatrix)`

Let  `M`  be  an  invertible  linear  map  on  the  dual  of the reflection
representation  of `W` which  preserves the set  of coroots of `parent(W)`,
and  normalizes  `W`  (for  the  action  of matrices on the right). `PermY`
returns  the corresponding  permutation of  the coroots  of `parent(W)`; it
returns  `nothing`  if  `M`  does  not  normalize  the  set  of  coroots of
`parent(W)`.

```julia-repl
julia> W=reflection_subgroup(rootdatum("E7sc"),1:6)
E₇₍₁₂₃₄₅₆₎=E₆Φ₁

julia> PermY(W,matY(W,longest(W)))==longest(W)
true
```
"""
PermY(W::PermRootGroup,m)=inv(PermX(W,transpose(m)))

"""
`isparabolic(W)`

whether the reflection subgroup `W` is a parabolic subgroup of `parent(W)`.
```julia-repl
julia> W=complex_reflection_group(7)
G₇

julia> isparabolic(reflection_subgroup(W,[1,2]))
false

julia> isparabolic(reflection_subgroup(W,[1]))
true
```
"""
function isparabolic(W,H)
  if iszero(ngens(H)) return true end
  v=rowspace(simpleroots(H))
  gens=filter(i->in_rowspace(roots(W,i),v),eachindex(roots(W)))
  setr=s->Set(refls(W,s))
  setr(gens)==setr(inclusion(H,W))
end

isparabolic(H)=isparabolic(parent(H),H)

"""
`parabolic_closure(W,I)`

`I`  should be a  list of indices  of reflections of  `W`. Returns `J` such
that  `reflection_subgroup(W,J)` is the smallest  parabolic subgroup of `W`
containing `reflection_subgroup(W,I)`.

```julia-repl
julia> W=complex_reflection_group(7)
G₇

julia> parabolic_closure(W,[1])
1-element Vector{Int64}:
 1

julia> parabolic_closure(W,[1,2])
3-element Vector{Int64}:
 1
 2
 3
```
"""
function parabolic_closure(W,I::AbstractVector{<:Integer})
  if isempty(I) return I end
  v=rowspace(toM(roots(W,I)))
  gens=filter(i->in_rowspace(roots(W,i),v),eachindex(roots(W)))
  inclusiongens(reflection_subgroup(W,gens),W)
end

function Groups.normalizer(W::PermGroup,L::PermRootGroup)
  if length(L)==1 return W end
  s=sort(refls(L,unique_refls(L)))
  J=filter(x->refls(W,x) in s,eachindex(roots(W)))
# C=stabilizer(W,J,onsets)
  R=stabilizer(W,s,onsets)
#  if length(R)<length(C) error("not expected") end
  R
end
#--------------- PRG: an implementation of PermRootGroups--------------------
@GapObj struct PRG{T,T1}<:PermRootGroup{T,T1}
  gens::Vector{Perm{T1}}
  one::Perm{T1}
  matgens::Vector{Matrix{T}}
  roots::Vector{Vector{T}}
  coroots::Vector{Vector{T}}
end

"""
`PRG(roots,coroots)` complex reflection group with given roots and coroots
"""
function PRG(r::AbstractVector{<:AbstractVector},
             cr::AbstractVector{<:AbstractVector};NC=false,T1=Int16)
# println("r=",r,"\ncr=",cr)
  if isempty(r) error("should call torus instead") end
  matgens=map(reflectionmat,r,cr)
  T=eltype(matgens[1])  # promotion of r and cr types
  roots_=map(x->convert.(T,x),r)
  cr=map(x->convert.(T,x),cr)

  # the following section is quite subtle: it has the (essential -- this is
  # what  allows  to  construct  reflexion  subgroups  in a consistent way)
  # property  that the order of the  constructed roots (thus the generating
  # permutations) depends only on the Cartan matrix of g, not on the actual
  # root values.

# println("# roots: ")
  gens_=map(x->Int[],matgens)
  newroots=true
  while newroots
    newroots=false
    for (j,refl) in pairs(gens_)
      lr=length(roots_)
      if length(refl)<lr
      for y in eachrow(toM(roots_[length(refl)+1:end])*matgens[j])
        p=findfirst(==(y),roots_)
	if p===nothing || p>lr
          push!(roots_,y)
#         println("j=$j roots_[$(length(refl)+1)...] ",length(roots_),":",y)
          newroots=true
          push!(refl,length(roots_))
        else push!(refl,p)
	end
      end
      end
    end
#   println(" ",length(roots_))
  end
  coroots_=Vector{eltype(cr)}(undef,length(roots_))
  coroots_[eachindex(cr)].=cr
  W=PRG(Perm{T1}.(gens_),Perm{T1}(),matgens,roots_,coroots_,Dict{Symbol,Any}())
  if !NC
    t=refltype(W)
    l=indices(t)
    if sort(l)!=eachindex(l)
      InfoChevie("# changing gens to <",join(l,","),"> for ",
                                             t,"<",ngens(W)," refs>\n")
      save=haskey(W,:MappingFromNormalizer)
      if save n=W.MappingFromNormalizer end
      W=PRG(roots(W,l),coroots(W,l))
      if save W.MappingFromNormalizer=n end
    end
  end
  W
end

PRG(a::Matrix,b::Matrix;k...)=PRG(toL(a),toL(b);k...)

PRG(i::Integer;T1=Int16)=PRG(Perm{T1}[],Perm{T1}(),Matrix{Int}[],Vector{Int}[],
                    Vector{Int}[],Dict{Symbol,Any}(:rank=>i))

radical(W::PermRootGroup)=PRG(rank(W)-semisimplerank(W))

"`roots(W::PermRootGroup)` the roots of `W`"
@inline roots(W::PRG)=W.roots
"`roots(W::PermRootGroup,i)` same as `roots(W)[i]`"
@inline roots(W::PRG,i)=W.roots[i]
"""
`simpleroots(W::ComplexReflectionGroup)`  the  simple  roots  of `W` (those
corresponding to `gens(W)`) as a matrix (each root is a row)
"""
simpleroots(W::PRG)=ngens(W)==0 ? fill(0,0,rank(W)) : toM(roots(W,eachindex(gens(W))))
"`coroots(W)` the list of coroots of `W` (listed in the same order as the roots)"
@inline coroots(W::PRG)=W.coroots
"""
`simplecoroots(W::ComplexReflectionGroup)` the simple coroots of `W` (those
`corresponding to gens(W)`) as a matrix (each coroot is a row)
"""
simplecoroots(W::PRG)=ngens(W)==0 ? fill(0,0,rank(W)) : toM(W.coroots[eachindex(gens(W))])
inclusion(W::PRG,i::Integer)=i
inclusion(W::PRG,i::AbstractVector)=i
inclusion(W::PRG)=inclusion(W,eachindex(W.roots))
restriction(W::PRG,i=eachindex(W.roots))=i
Base.parent(W::PRG)=W
action(W::PRG,i,p)=i^p

"`coroots(W,i)` same as but better than `coroots(W)[i]`"
function coroots(W::PRG,i::Integer)
  if isassigned(W.coroots,i) return W.coroots[i] end
  j=findfirst(!iszero,roots(W,i))
  m=reflrep(W,i)
  m=one(m)-m
  W.coroots[i]=improve_type(m[:,j].//roots(W,i)[j])
end

coroots(W::PRG,I::AbstractVector{<:Integer})=isempty(I) ? empty(W.coroots) : 
  map(i->coroots(W,i),I)

function Base.:*(W::PRG,V::PRG)
  if rank(W)==0 return V
  elseif rank(V)==0 return W
  end
  r=cat(simpleroots(W),simpleroots(V),dims=(1,2))
  cr=cat(simplecoroots(W),simplecoroots(V),dims=(1,2))
  PRG(toL(r),toL(cr))
end

"""
`reflection_representation(W::ComplexReflectionGroup)` or `reflrep(W)`

returns  the  list  of  `reflrep(W,x)`  for  `x`  in `gens(W)`, that is the
generators of `W` as matrices.
"""
reflrep(W::PRG)=W.matgens

"""
`reflection_representation(W,i::Integer)`  or `reflrep(W,i)`

for `i∈ 1:ngens(W)` same as but faster than `reflrep(W,W(i))`.
For  `ngens(W)<i≤nref(W)`  returns  the  matrix  for  the  i-th  reflection
`refls(W,i)` of `W`.
"""
reflrep(W::PRG,i::Integer)=i<=ngens(W) ? W.matgens[i] : reflrep(W,refls(W,i))

#--------------- type of subgroups of PRG----------------------------------
@GapObj struct PRSG{T,T1}<:PermRootGroup{T,T1}
  gens::Vector{Perm{T1}}
  one::Perm{T1}
  inclusion::Vector{Int}
  restriction::Vector{Int}
  parent::PRG{T,T1}
end

inclusion(W::PRSG)=W.inclusion
inclusion(W::PRSG,i::Integer)=W.inclusion[i]
inclusion(W::PRSG,i::AbstractVector)=W.inclusion[i]
"""
`restriction(W::PermRootGroup)`

A  list for each root of `parent(W)`, which  holds `0` if the root is not a
root of `W` and `i` if the root is the `i`-th root of `W`.

`restriction(W::PermRootGroup,i::Integer)`
`restriction(W::PermRootGroup,v::AbstractVector{<:Integer})`

same as `restriction(W)[i]` or `restriction(W)[v]` (but more efficient).
"""
restriction(W::PRSG)=W.restriction
restriction(W::PRSG,i)=W.restriction[i]
@inline roots(W::PRSG)=roots(parent(W),inclusion(W))
@inline roots(W::PRSG,i)=roots(parent(W),inclusion(W,i))
simpleroots(W::PRSG)=toM(roots(parent(W),inclusiongens(W)))
@inline coroots(W::PRSG)=coroots(parent(W),inclusion(W))
@inline coroots(W::PRSG,i)=coroots(parent(W),inclusion(W,i))
simplecoroots(W::PRSG)=ngens(W)==0 ? fill(0,0,rank(W)) : toM(coroots(parent(W),inclusiongens(W)))
@inline Base.parent(W::PRSG)=W.parent
"""
`action(W::PermRootGroup,i::Integer,p::Perm)`

The elements of a `PermRootGroup` permute the roots of `parent(W)`, that is
are  permutations on `1:nref(parent(W))`.  The function `action` translates
this action of `p∈ W` to `1:nref(W)`. Thus
`action(W,i,p)==restriction(W,inclusion(W,i)^p)`.
"""
action(W::PRSG,i,p)=restriction(W,inclusion(W,i)^p)

function Base.:^(W::PRSG{T,T1},p::Perm{T1})where {T,T1}
  WW=parent(W)
  if !(p in WW) error("can only conjugate in parent") end
  reflection_subgroup(WW,inclusiongens(W).^p)
end

"""
`reflection_subgroup(W,r)`
    
returns  the  reflection  subgroup  of  the  complex  reflection  group `W`
generated by `refls(W,r)`.

A  reflection subgroup `H` of  `W` is a permutation  subgroup with the same
additional  information as  `W`, and  some new  one added which express the
relationship with the parent `W`:

`inclusion(H)`:   the indices of the roots of `H` in the roots of `W`

`parent(H)`:  is set to `W`.

`restriction(H)`:  a list of length `length(roots(W))` with non-zero entries
   in positions `inclusion(H)` bound to `eachindex(roots(H))`.

A  reflection  group  which  is  not  a  subgroup  actually  also  has this
information, set to the trivial values:
`inclusion(W)==restriction(W)==eachindex(roots(W))`,   and   `parent()==W`.
This  allows a lot of code to be  written in the same way for parent groups
or reflection subgroups.

`reflection_subgroup(R)` where `R` is itself a reflection subgroup returns a 
reflection subgroup of the parent of `R`.

```julia_repl
julia> W=coxgroup(:F,4)
F₄

julia> H=reflection_subgroup(W,[1,2,11,20])
F₄₍₉‚₂‚₁‚₁₆₎=D₄₍₃₂₁₄₎

julia> [restriction(H)]
1-element Vector{Vector{Int64}}:
 [1, 2, 0, 0, 5, 0, 0, 0, 3, 0  …  0, 16, 0, 19, 0, 21, 0, 22, 23, 24]

julia> reflection_subgroup(H,[1,2,3])
F₄₍₉₁₂₎=A₃₍₃₁₂₎Φ₁
```
"""
function reflection_subgroup(W::PRG,I::AbstractVector;NC=false)
  if !haskey(W,:reflsubgroups)
    W.reflsubgroups=Dict(
         Int[]=>PRSG(empty(gens(W)),one(W),Int[],zeros(Int,length(W.roots)),W,
                  Dict{Symbol,Any}(:rank=>rank(W),:refltype=>TypeIrred[])))
  end
  I=Vector{Int}(I)
  if NC
    if I==eachindex(gens(W)) G=W
      inclu=collect(eachindex(roots(W)))
    else
      G=PRG(roots(W,I),coroots(W,I);NC=true)
      inclu=Int.(indexin(G.roots,W.roots))
    end
    restr=zeros(Int,length(W.roots));restr[inclu]=1:length(inclu)
    return PRSG(refls(W,I),one(W),inclu,restr,W,Dict{Symbol,Any}())
  end
  if haskey(W.reflsubgroups,I) return W.reflsubgroups[I] end
  H=reflection_subgroup(W,I;NC=true)
  t=refltype(H)
  l=indices(t)
  if sort(l)!=eachindex(gens(H))
    InfoChevie("# changing inclusiongens to <",join(inclusion(H,l),
      ","),"> for ",t,"<",length(inclusion(H))," refs>\n")
    save=haskey(H,:MappingFromNormalizer)
    if save n=H.MappingFromNormalizer end
    H=reflection_subgroup(W,inclusion(H,l);NC=true)
    if save H.MappingFromNormalizer=n end
    for tt in t tt.indices=map(x->findfirst(==(x),l),tt.indices) end
  end
  H.refltype=t
  W.reflsubgroups[I]=H
  H
end

reflection_subgroup(W::PRSG,I::AbstractVector{Int};u...)=
   reflection_subgroup(parent(W),inclusion(W,I);u...)

function Base.show(io::IO, W::PRSG)
  I=inclusiongens(W)
  if !hasdecor(io)
    print(io,"reflection_subgroup(",W.parent,",",I,")")
    return
  end
  n=inclusion(W,indices(refltype(W)))
  if n!=eachindex(gens(W.parent))
    printTeX(io,"{",W.parent,"}_{"*joindigits(n;always=true)*"}=")
  end
  show(io,refltype(W))
  showtorus(io,W)
end

reflrep(W::PRSG,i::Integer)=reflrep(parent(W),inclusion(W,i))
reflrep(W::PRSG)=map(i->reflrep(W,i),eachindex(gens(W)))

#-------------------------------------------------
"""
`Catalan(W::ComplexReflectionGroup)`

returns the Catalan Number of the irreducible complex reflection group `W`.
For well-generated groups, this number is equal to the number of simples in
the  dual Braid  monoid. For  other groups  it was  defined by  [Gordon and
Griffeth2012](biblio.htm#gg12).  For Weyl groups, it also counts the number
of antichains of roots.

```julia-repl
julia> catalan(coxgroup(:A,7))
1430
```

`Catalan(W,i)`

returns   the  `i`-th  Fuss-Catalan  Number   of  the  irreducible  complex
reflection  group `W`. For  well-generated groups, this  number is equal to
the  number of chains  `s₁,…,sᵢ` of simples  in the dual  monoid where `sⱼ`
divides  `sⱼ₊₁`. For these groups, it is also equal to `∏ⱼ(ih+dⱼ)/dⱼ` where
the  product runs over the reflection degrees  of `W`, and where `h` is the
Coxeter  number of `W`. For non-well generated groups, the definition is in
[Gordon and Griffeth2012](biblio.htm#gg12).

```julia-repl
julia> catalan(complex_reflection_group(7),2)
16
```

`Catalan(W;q=1)`, resp. `Catalan(W,i;q=1)`

for  `q`  a  variable  (like  `Pol()`  or an `Mvp`) returns the `q`-Catalan
number  (resp.  the  `i`-th  `q`-Fuss  Catalan  number)  of  `W`. Again the
definitions in general are in [Gordon and Griffeth2012](biblio.htm#gg12).

```julia-repl
julia> catalan(complex_reflection_group(7),2;q=Pol())
Pol{Int64}: q⁷²+2q⁶⁰+3q⁴⁸+4q³⁶+3q²⁴+2q¹²+1
```
"""
function Combinat.catalan(W::Group,m=1;q=1)
  if length(refltype(W))>1 error(W," should be irreducible") end
  d=sort(degrees(W))
  d=filter(x->x!=1,d)
  fd=d
  if length(d)!=ngens(W)
    ci=charinfo(W)
    if haskey(ci,:hgal) hgal=ci[:hgal] else hgal=Perm() end
    ct=toL(CharTable(W).irr)
    complex=Perm(ct,conj(ct))
    fd=fakedegrees(W,Pol(:q))[ci[:extRefl][2]^(hgal^m*complex)]
    fd=vcat(map(i->fill(i+1,fd[i]),0:degree(fd))...)
  end
  f(i)=sum(j->q^j,0:i-1)
  h=div(nhyp(W)+nref(W),length(d))
  exactdiv(prod(x->f(m*h+x),fd),prod(x->f(x),d))
end

"""
`invariant_form(W::ComplexReflectionGroup)`

This  function  returns  the  matrix  `F`  (defined  up  to a scalar) of an
Hermitian form invariant under the action of the reflection group `W`. That
is, if `M` is the matrix of an element of `W`, then `M*F*M'=F`.

```julia-repl
julia> W=complex_reflection_group(4)
G₄

julia> invariant_form(W)
2×2 Matrix{Int64}:
 1  0
 0  2
```
"""
function invariant_form(W::PermRootGroup)
  I=independent_roots(W)
  C=cartan(W)[I,I]
# we use that C[i,j]/C[i,i]=F[j,i]/F[i,i]
  T=typeof(C[1,1]*1//1)
  F=zeros(T,size(C))
  for b in diagblocks(C)
    # first fill in the diagonal terms
    F[b[1],b[1]]=1
    next=[1]
    while !isempty(next)
      i=b[next[1]]
      next=next[2:end]
      for k in filter(k->F[b[k],b[k]]==0 && C[i,b[k]]!=0,eachindex(b))
	j=b[k]
        push!(next,k)
        F[j,j]=F[i,i]*C[i,j]*conj(C[j,j])//(conj(C[j,i])*C[i,i]);
      end
    end
    # then fill in the rest
    for i in b, j in b
      if i!=j F[j,i]=C[i,j]*F[i,i]//C[i,i] end
    end
  end
  d=rank(W)-semisimplerank(W)
  F=cat(F,one(zeros(T,d,d)),dims=(1,2))
  N=invbaseX(W)
  F=N*F*N'
  improve_type(F.//F[1,1])
end

"""
`generic_order(W,q=Pol())`

returns  the generic  order of  `W` as  a polynomial  in `q` (the "compact"
order  of the  Spets). This  is ``q^{Nₕ}Πᵢ(q^{dᵢ}-1)``  where `dᵢ`  are the
reflection  degrees and  `Nₕ` the  number of  reflecting hyperplanes. For a
Weyl  group, it is the order  of the associated semisimple finite reductive
group over the field with `q` elements.

```julia-repl
julia> PermRoot.generic_order(complex_reflection_group(4),Pol(:q))
Pol{Int64}: q¹⁴-q¹⁰-q⁸+q⁴
```
"""
generic_order(W,q=Pol())=rank(W)==0 ? one(q) : q^sum(codegrees(W).+1)*prod(d->q^d-1,degrees(W))

"""
`invariants(W::ComplexReflectionGroup)`

returns  the fundamental invariants of `W` in its reflection representation
`V`.  That is, returns  a set of  algebraically independent elements of the
symmetric  algebra  of  the  dual  of  `V` which generate the `W`-invariant
polynomial  functions on `V`. Each such invariant function is returned as a
function:  if `e₁,…,eₙ` is a basis of `V` and `f` is the function, then the
value  of the polynomial  function on `a₁e₁+…+aₙeₙ`  is obtained by calling
`f(a₁,…,aₙ)`. This function depends on the classification, and is dependent
on the exact reflection representation of `W`. So for the moment it is only
implemented   when  the  reflection   representation  for  the  irreducible
components has the same Cartan matrix as the one provided by Chevie for the
corresponding  irreducible  group.  The  polynomials  are invariant for the
natural   action  of   the  group   elements  as   matrices;  that  is,  if
`m==reflrep(W,w)`  for some  `w` in  `W`, then  an invariant  `f` satisfies
`f(a₁,…,aₙ)=f(v₁,…,vₙ)`   where  `[v₁,…,vₙ]=[a₁,…,aₙ]×m`.  This  action  is
implemented on `Mvp`s by the function `^`.

```julia-repl
julia> W=coxgroup(:A,2)
A₂

julia> @Mvp x,y,z

julia> i=invariants(W);

julia> i[1](x,y)
Mvp{Int64}: -2x²+2xy-2y²

julia> i[2](x,y)
Mvp{Int64}: 6x²y-6xy²

julia> W=complex_reflection_group(24)
G₂₄

julia> i=invariants(W)[1];

julia> p=i(x,y,z)
Mvp{Rational{Int64}}: (14//1)x⁴+(-12//1)x²y²+(-42//1)x²yz+(21//2)x²z²+(18//7)y⁴+(-6//1)y³z+(-9//2)y²z²+(-21//8)z⁴

julia> p^reflrep(W,1)-p
Mvp{Cyc{Rational{Int64}}}: 0
```
"""
function invariants(W::PermRootGroup)
  V=parent(W)
  i=Function[] # eltype abstract otherwise I do not know how to do it
  for t in refltype(W)
    H=reflection_group(t)
    if cartan(V,inclusion(W,t.indices))!=cartan(H)
      error("non standard Cartan matrix: invariants not implemented")
    end
    ir=independent_roots(H)
    li=getchev(t,:Invariants)
    if li==false return false end
    append!(i,map(f->function(arg...)
         return f(improve_type(inv(E(1).*toM(coroots(H)[ir])*1//1)*
    toM(coroots(V,inclusion(W,t.indices[ir]))))*collect(arg)...) end, li))
  end
  N=toM(roots(W,independent_roots(W)))
  if !isempty(N)
    N=lnullspace(transpose(N))
    append!(i,map(v->function(arg...) sum(v.*arg) end,eachrow(N)))
  end
  i
end

BadNumber(W)=prod(BadNumber.(refltype(W));init=1)

function BadNumber(t::TypeIrred)
  r=rank(t)
  if iszero(r) return 1 end
  d=det_bareiss(cartan(t))
  if d==0 error(t," should be well generated") end
  improve_type(prod(degrees(t))//(factorial(r)*d))
end

end
