"""
The  combinatorial objects  in this  module are  *partitions*, *β-sets* and
*symbols*.

A  partition is a non-increasing  list of nonnegative integers `p₁≥p₂≥…pₙ`,
represented as a `Vector{Int}`, which is *normalized* if it has no trailing
zeroes. The functions for partitions in this module are
  - [`Partition`](@ref)`(p₁,…,pₙ)` or `Partition([p₁,…,pₙ])` makes a `Partition`
    object from the list `p₁,…,pₙ`.
  - [`core`](@ref)`(μ::Partition,e)` which returns the `e`-core of `μ`.
  - [`quotient`](@ref)`(μ::Partition,e)` which returns the `e`-quotient of `μ`.
  - [`partition_core_quotient`](@ref)`(μ::Partition,q)` which recovers a
    partition given its `e`-core `μ` and its `e`-quotient `q`.

A  *β-set* is a strictly increasing `Vector` of nonnegative integers, up to
*shift*,  the  equivalence  relation  generated  by the *elementary shifts*
`[b₁,…,bₙ]∼[0,1+b₁,…,1+bₙ]`.  An equivalence  class has  exactly one member
which does not contain `0`: it is called a normalized β-set.

To  a  normalized  partition  `p₁≥p₂≥…pₙ>0`  is  associated  a β-set, whose
normalized  representative is `pₙ,pₙ₋₁+1,…,p₁+n-1`. A mnemonic is that this
is  the areas of  the hooks in  the Young diagram  going up along the first
column.  Conversely, to each β-set `b₁<b₂<…<bₙ` is associated the partition
`bₙ-n+1≥…≥b₂-1≥b₁`,  which may have some trailing  zeros if starting from a
non-normalized representative.

The functions for βsets in this module are
  - [`βset`](@ref) which constructs a normalized βset from a partition.
  - [`shiftβ`](@ref) which shifts a βset
  - [`partβ`](@ref) which constructs a partition from a βset

As  a generalisation of `β`-sets, [lus77](@cite) has introduced `2`-symbols
and   more  general  `e`-symbols  were  introduced  in  [mal95](@cite).  An
`e`-symbol   is  a  vector  `S=[S₁,…,Sₑ]`   of  β-sets,  taken  modulo  the
equivalence  relation generated by the simultaneous elementary shift of all
β-sets,  and by  cyclic permutations  of `S`;  in the particular case where
`e=2`,  `S`  is  thus  an  unordered  pair  of β-sets. `S` is a *normalized
symbol*  if  `0`  is  not  in  the  intersection  of  the  `Sᵢ`; equivalent
normalized  symbols are equivalent by  cyclic permutation. The *content* of
`S`  is `mod(c,e)`  where `c=sum(length.(S))`;  it is  an invariant  of the
symbol, as well as the *rank*, defined for an `e`-symbol as
`sum(sum,S)-div((c-1)*(c-e+1),2*e)`.  Invariant  by  shift  but  not cyclic
permutation is the *shape* `s.-minimum(s)` where `s=length.(S)`.

When `e=2` we choose a normalized representative of a symbol `[S₁,S₂]` such
that `length(S₁)≥length(S₂)`, so the shape is `[d,0]` for some `d≥0` called
the *defect* of the symbol; the content is equal to `mod(d,2)`. When `d==0`
we  choose a normalized representative  such that `P₁≤P₂` lexicographically
where `P₁,P₂` are the partitions associated to `S₁,S₂`. For `e>2` we choose
the  *reduced* representative, which  means a symbol  `≥` to all its cyclic
permutations,  where a symbol  is `<` another  if the shape `length.(S)` is
lexicographically smaller and, if the shapes are the same, if the vector of
βsets is lexicographically greater.

Partitions  and  pairs  of  partitions  parametrize  characters of the Weyl
groups  of classical types, and tuples of partitions parametrize characters
of  imprimitive complex reflection  groups. 2-Symbols parametrize unipotent
characters  of  classical  Chevalley  groups,  and more general `e`-symbols
parametrize   unipotent  characters  of   spetses  associated  to  spetsial
imprimitive complex reflection groups. The rank of a symbol is equal to the
semi-simple rank of the corresponding Chevalley group or Spets.

Symbols of rank `n` and defect `0` parametrize characters of the Weyl group
`W(Dₙ)`,  and  symbols  of  rank  `n`  and  defect`≡0 (mod 4)` parameterize
unipotent  characters of `SO₂ₙ`; symbols of rank `n` and defect`≡2 (mod 4)`
parameterize  unipotent  characters  of  `SO⁻₂ₙ`.  Symbols  of rank `n` and
defect `1` parametrize characters of the Weyl group `W(Bₙ)`, and symbols of
rank  `n`  and  odd  defect  parametrize  unipotent characters of `Sp₂ₙ` or
`SO₂ₙ₊₁`.

To parametrize unipotent characters of spetses we need another statistic on
symbols, the *Malle-defect* defined in [mal95](@cite) as
`mod(binomial(e,2)*div(sum(length.(S)),e)-dot(O:e-1,length.(S)),e)`.  It is
invariant  under  shift;  it  is  invariant  under circular permutation for
symbols  of content `O` but not for  symbols of content `1`; for these only
one circular permutation has Malle-defect `0`.

`e`-symbols  of rank `n` and  content `1` parameterize unipotent characters
of the spets `G(e,1,n)`. The principal series (in bijection with characters
of   the  reflection  group)  is  parametrized  by  symbols  whose  reduced
representative has shape `[1,0,…,0]`.

Unipotent   characters  of   the  spets   `G(e,e,n)`  are  parametrized  by
`e`-symbols  of  content  `0`  and  Malle-defect  `0`.  The symbols for the
principal series characters have shape `[0,…,0]`.

Unipotent  characters of the twisted  spets `ᵗG(e,e,n)` are parametrized by
`e`-symbols of rank `n`, content `0` and Malle-defect `t`.

In  the above parametrizations, periodic symbols,  that is symbols `S` such
that  the  sequence  `S₁,…,Sₙ`  is  a  repetition  `k`  times  of a shorter
sequence,  must be  repeated `k`  times. To  distinguish the `k` copies, an
additional parameter, a `k`-th root of unity, is attached to the symbol. As
an example, here are the symbols for `G₃,₃,₃`:

```julia-repl
julia> symbols(3,3,0)
12-element Vector{CharSymbol}:
 (1+)
 (1ζ₃)
 (1ζ₃²)
 (01,12,02)
 (01,02,12)
 (012,012,123)
 (0,1,2)
 (0,2,1)
 (01,01,13)
 (0,0,3)
 (012,,)
 (012,012,)
```
when  the symbol has  a period, only  the period is  shown, followed by the
root  of unity (where  `1` is shown  as `+` and  `-1` is shown  as `-`.

The functions for symbols in this module are
  - [`CharSymbol`](@ref), which constructs a symbol
  - [`Symbol_partition_tuple`](@ref) which constructs a symbol of a given shape from a partition tuple
  - [`rank`](@ref) which computes the rank of a symbol
  - [`defect`](@ref) which returns the defect  of a 2-symbol
  - [`Malledefect`](@ref) which returns the Malle-defect of a symbol
  - [`core`](@ref)`(l,ζₑʲ)` which returns the `(l,ζₑʲ)`-core of a symbol
  - [`fakedegree`](@ref), [`degree_feg`](@ref), [`valuation_feg`](@ref) return the fake degree (resp. its degree and valuation) of the unipotent character parametrized by a symbol
  - [`gendeg`](@ref), [`degree_gendeg`](@ref), [`valuation_gendeg`](@ref) return the generic degree (resp. its degree and valuation) of the unipotent character parametrized by a symbol
  - [`symbols`](@ref) returns the list of symbols of a given length, rank and content.

Finally,  in this  module we  also provides  a function [`XSP`](@ref) which
returns  the "symbols"  (pairs of  vectors of  increasing positive integers
satisfying  some  conditions)  ``X̃^{ρ-s,s}_{n,d}``  defined by Lusztig and
Spaltenstein  which  parametrize  local  systems  on  unipotent classes for
classical reductive groups.
"""
module Symbols
using ..Format: joindigits, rio, xrepr, hasdecor
using Combinat: Combinat, arrangements, partition_tuples, collectby, 
  conjugate_partition, dominates
using CyclotomicNumbers: E
using CycPols: CycPol, subs
using LaurentPolynomials
using LinearAlgebra: dot
using ModuleElts: ModuleElt
export shiftβ, βset, partβ, CharSymbol, Symbol_partition_tuple,
gendeg, valuation_gendeg, degree_gendeg,  degree_feg, valuation_feg,
fakedegree, defectsymbol,   fullsymbol,
Malledefect, defect, rank,  symbols, XSP, string_partition_tuple, ennola,
quotient, core, Partition, partition_core_quotient

""" 
A  `Partition` object  is formed  from a  non-increasing of integers ending
with  a  number>0.  The  following  two  forms  are equivalent for making a
`Partition` object:
```julia-repl
julia> Partition([2,1,1])
Partition: 211

julia> p=Partition(2,1,1)
Partition: 211

julia> length(p) # how many parts
3

julia> size(p) # the sum of the parts
4
```
some basic operations on partitions is the union and the conjugate partition
```julia-repl
julia> union(p,p)
Partition: 221111

julia> p'
Partition: 31
```
we  get the `i`-th part by indexing with the convention that we get `0` for
large `i`.
```julia-repl
julia> p[1]
2

julia> p[4]
0
```
The partitions are ordered by size, and then lexicographically.
"""
struct Partition
  l::Vector{Int}
  function Partition(l::Vector{<:Integer})
    if length(l)>0 
      if !all(i->l[i]≥l[i+1],1:length(l)-1)
        error(l," not a partition: parts should be non-increasing")
      elseif l[end]<=0
        error(l," not a partition: parts should be positive")
      end
    end
    new(l)
  end
end

Base.hash(p::Partition,k::UInt)=hash(p.l,k)
Base.:(==)(a::Partition,b::Partition)=a.l==b.l
Base.:union(a::Partition,b::Partition)=Partition(sort!(vcat(a.l,b.l),rev=true))
Partition(a...)=Partition(collect(a))
Partition(a::AbstractVector{<:Integer})=Partition(collect(a))
Base.size(p::Partition)=sum(p.l)
Base.length(p::Partition)=length(p.l)
Base.sign(p::Partition)=(-1)^(size(p)-length(p))
Base.isless(a::Partition,b::Partition)=size(a)<size(b) || a.l<b.l
Base.:adjoint(a::Partition)=Partition(conjugate_partition(a.l))
Base.getindex(a::Partition,i)=i>length(a) ? 0 : a.l[i]
Combinat.dominates(a::Partition,b::Partition)=dominates(a.l,b.l)

function Base.show(io::IO,::MIME"text/plain", p::Partition)
  if get(io,:typeinfo,Any)!=Partition print(io,"Partition: ") end
  print(io,p)
end

function Base.show(io::IO, p::Partition)
  if hasdecor(io)
    print(io,isempty(p.l) ? "." : joindigits(p.l))
  else print(io,"Partition(",join(p.l,","),")")
  end
end

"""
`core(μ::Partition,e)` the  `e`-core of the partition `μ`.

It  is the partition left after removing recursively all possible `e`-hooks
from the young diagram of `μ`.
```julia-repl
julia> core(Partition(3,3,1),3)
Partition: 211
```
"""
function core(μ::Partition,e)
  β=βset(μ,mod(-length(μ),e))
  cnt=map(i->count(j->mod(j,e)==i,β),0:e-1)
  cnt.-=minimum(cnt)
  if maximum(cnt)==0 return Partition(Int[]) end
  core=[j for i in 1:e for j in (i-1).+e.*(0:cnt[i]-1)]
  Partition(partβ(sort!(core)))
end

"""
`quotient(μ::Partition,e)` the `e`-quotient of the partition `μ`.

The  `e`-quotient is best described  in terms of βsets.  Divide the βset of
`μ`  in `e` sets  `S₀,…,Sₑ₋₁` according to  the congruence mod `e`. Replace
`Sᵢ` by `S'ᵢ={(x-i)/e∣x∈Sᵢ}`. Then each `S'ᵢ` can be interpreted in turn as
the  βset  of  a  partition.  The  resulting `e`-tuple of partitions is the
`e`-quotient of `mu`.
```julia-repl
julia> quotient(Partition(3,3,1),3)
3-element Vector{Vector{Int64}}:
 []
 []
 [1]
```
"""
function quotient(μ::Partition,e)
  λ=conjugate_partition(μ.l)
  q=[Int[] for i in 1:e]
  for (i,m) in enumerate(μ.l)
    qj=mod(m-i,e)
    x=count(j->mod(j-λ[j]-1,e)==qj,1:m)
    if x!=0 push!(q[qj+1], x) end
  end
  q
end

"""
`partition_core_quotient(c::Partition,q)` 

given a partition `c` and an `e`-tuple q of partitions, return a partition  `p`
of `e`-core `c` and `e`-quotient `q`.
```julia-repl
julia> partition_core_quotient(Partition(2,1,1),[Int[],Int[],[1]])
Partition: 331
```
"""
function partition_core_quotient(c::Partition,q)
  e=length(q)
  bc=βset(c,mod(-length(c),e))
  cnt=map(i->count(j->mod(j,e)==i,bc),0:e-1)
  cnt.+=maximum(i->length(q[i])-cnt[i],1:e)
  bq=map((x,c)->βset(x,c-length(x)),q,cnt)
  bres=[j for i in 1:e for j in (i-1).+e*bq[i]]
  Partition(partβ(sort(bres)))
end
  
"""
`βset(p)` normalized β-set of partition `p`

```julia-repl
julia> βset([3,3,1])
3-element Vector{Int64}:
 1
 4
 5
```
"""
function βset(p,s=0)
#  simpler code but 2 more allocations:
#  p=prepend!(fill(0,s),p); reverse!(p).+(0:length(p)-1)
  res=Vector{Int}(undef,s+length(p))
@inbounds  for i in 1:s res[i]=i-1 end
@inbounds  for i in eachindex(p) res[s+i]=s+i-1+p[end-i+1] end
  res
end

βset(p::Partition,s=0)=βset(p.l,s)

struct CharSymbol
  S::Vector{Vector{Int}}
  repeats::Int
  no::Int # symbols which are a pattern repeated repeats time have 0≤no<repeats
end

"""
`CharSymbol(v::Vector{Vector{Int}},repeat::Int=1,no::Int=0)`

`CharSymbol` makes a vector of βsets into a symbol. If the vector of βsets
has a period this is specified by giving a number `repeats` of repetitions
and a number `0≤no<repat`.
```julia-repl
julia> CharSymbol([[1],Int[],[2]])
(1,,2)

julia> CharSymbol([[1],[1],[1]],3,2)
(1ζ₃²)
```
"""
CharSymbol(v::Vector{<:AbstractVector})=
      CharSymbol(convert(Vector{Vector{Int}},v),1,0)

Base.:(==)(S::CharSymbol,T::CharSymbol)=S.S==T.S && S.no==T.no && S.repeats==T.repeats

Base.hash(S::CharSymbol,h::UInt64)=hash(S.S,hash(S.repeats,hash(S.no,h)))

"""
`string_partition_tuple(tuple)`

converts  the partition tuple `tuple` to  a string where the partitions are
separated by a dot.

```julia-repl
julia> d=partition_tuples(3,2)
10-element Vector{Vector{Vector{Int64}}}:
 [[1, 1, 1], []]
 [[1, 1], [1]]
 [[1], [1, 1]]
 [[], [1, 1, 1]]
 [[2, 1], []]
 [[1], [2]]
 [[2], [1]]
 [[], [2, 1]]
 [[3], []]
 [[], [3]]

julia> string_partition_tuple.(d)
10-element Vector{String}:
 "111."
 "11.1"
 "1.11"
 ".111"
 "21."
 "1.2"
 "2.1"
 ".21"
 "3."
 ".3"
```
"""
function string_partition_tuple(n;opt...)
  if n[end] isa Vector return join(joindigits.(n),".") end
  r=xrepr(E(n[end-1],n[end]);opt...)
  if r=="1" r="+" end
  if r=="-1" r="-" end
  join(joindigits.(n[1:end-2]),".")*r
end

"""
`shiftβ( β, n)` shift the β-set `β` by `n`

```julia-repl
julia> shiftβ([2,3],2)
4-element Vector{Int64}:
 0
 1
 4
 5

julia> shiftβ([0,1,4,5],-2)
2-element Vector{Int64}:
 2
 3
```
"""
function shiftβ(β,n)
  if n>=0 return [0:n-1;β .+ n]
  elseif β[1:-n]!= 0:-n-1 error("Cannot shift $β by $n\n")
  else return β[1-n:end].+n
  end
end

"""
`shiftβ(β)` returns the unique normalized representative of `β`.

```julia-repl
julia> shiftβ([0,1,4,5])
2-element Vector{Int64}:
 2
 3
```
"""
function shiftβ(β)
  i=0
  while i+1<=length(β) && β[i+1]==i i+=1 end
  if i>0 β=shiftβ(β,-i) end
  β
end

"""
`partβ(β)` partition defined by β-set `β`

```julia-repl
julia> partβ([0,4,5])
2-element Vector{Int64}:
 3
 3
```
"""
partβ(β)=filter!(!iszero,reverse!(β.-(0:length(β)-1)))

# rank of partition_tuple described by symbol S
relative_rank(S::CharSymbol)=sum(x->sum(x)-div(length(x)*(length(x)-1),2),S.S)

"""
`Symbol_partition_tuple(p, s)` symbol of shape `s` for partition tuple `p`.

In  the general case, `s` is a `Vector{Int}`  of same length as `p` and the
`i`-th  element of the result is the β-set for `pᵢ` shifted to be of length
`sᵢ` (the minimal integer which makes this possible is added to `s`).

When  `s` is  a positive  integer it  is interpreted  as `[s,0,0,…]`  and a
negative  integer is interpreted  as `[0,-s,-s,…]` so  when `p` is a double
partition  one gets the  symbol of defect  `s` associated to  `p`; as other
uses  the  unipotent  symbol  for  a  character  of the principal series of
`G(e,1,r)`   parameterized   by   an   `e`-tuple   `p`   of  partitions  is
`Symbol_partition_tuple(p,1)` and for `G(e,e,r)` the similar computation is
`Symbol_partition_tuple(p,0)`  (the function handles coded periodic `p` for
`G(e,e,r)`).

```julia-repl
julia> Symbol_partition_tuple([[2,1],[1]],1)
(13,1)

julia> Symbol_partition_tuple([[2,1],[1]],0)
(13,02)

julia> Symbol_partition_tuple([[2,1],[1]],-1)
(13,013)
```
"""
function Symbol_partition_tuple(p,S)
  if p[end] isa Number
   return CharSymbol(Symbol_partition_tuple(repeat(p[1:end-2],p[end-1]),S).S,
                     p[end-1],p[end])
  end
  if S isa Integer
    if S<0 s=fill(-S,length(p));s[1]=0
    else   s=fill(0,length(p));s[1]=S
    end
  else s=copy(S)
  end
  s.-=length.(p)
  s.-=minimum(s)
  CharSymbol(βset.(p,s))
end

function fullsymbol(S)::Vector{Vector{Int}}
  if isempty(S) || S[end] isa AbstractVector return S end
  repeat(S[1:end-2],S[end-1])
end

"""
`rank(S)` rank of symbol `S`.

```julia-repl
julia> rank(CharSymbol([[1,5,6],[1,2]]))
11
```
"""
function rank(s::CharSymbol)
  if isempty(s.S) return 0 end
  ss=sum(length,s.S)
  e=length(s.S)
  sum(sum,s.S)-div((ss-1)*(ss-e+1),2*e)
end

Base.length(s::CharSymbol)=length(s.S)

entries(p)=sort!(vcat(p...))
entries(p::CharSymbol)=sort!(vcat(p.S...))

"""
`core(s::CharSymbol,l,j=0)` the `(l,ζₑʲ)` core of the `e`-symbol `s`

This core is obtained by removing recursively all possible `(l,ζₑʲ)`-hooks.
An  `(l,ζₑʲ)`-hook consists of,  assuming `x` occurs  in the `i`-th βset of
`s`  and `x-l` does not occur in the `mod1(i+j,e)`-th βset of `s`, removing
`x` from the `i`-th β-set and adding `x-l` to the `mod1(i+j,e)`-th βset.
"""
function core(s::CharSymbol,l,j=0)
  s=CharSymbol(copy.(s.S),s.repeats,s.no)
  e=length(s.S)
  j=mod(j,e)
  acted=true
  while acted
    acted=false
    for i in 1:e
      o=mod1(i+j,e)
      p=findall(x->x-l>=0 && !(x-l in s.S[o]),s.S[i])
      s.S[i][p].-=l
      acted=acted || !isempty(p)
      if i!=o
        s.S[o]=union(s.S[o],s.S[i][p])
        deleteat!(s.S[i],p)
      end
      sort!(s.S[o])
    end
  end
  while all(S->!isempty(S) && S[1]==0,s.S)
    for i in 1:e
      deleteat!(s.S[i],1)
      s.S[i].-=1
    end
  end
  s
end

"""
`valuation_gendeg(S::CharSymbol)`

the   valuation  of   the  generic   degree  of   the  unipotent  character
parameterized by the symbol `S`.

```julia-repl
julia> valuation_gendeg(CharSymbol([[1,5,6],[1,2]]))
13
```
"""
function valuation_gendeg(p::CharSymbol)
  e=length(p)
  en=entries(p)
  m=length(en)
  en'*(m-1:-1:0)-div(m*(m-e)*(2*m-3-e),12*e)
end

"""
`degree_gendeg(S::CharSymbol)`

the  degree of the generic degree  of the unipotent character parameterized
by the symbol `S`.

```julia-repl
julia> degree_gendeg(CharSymbol([[1,5,6],[1,2]]))
91
```
"""
function degree_gendeg(p::CharSymbol)
  r=rank(p)
  e=length(p)
  en=entries(p)
  m=length(en)
  if mod(m,e)==1 r=div(e*r*(r+1),2)
  else           r+=div(e*r*(r-1),2)
  end
  r+en'*(0:m-1)-sum(x->div(e*x*(x+1),2),en)-div(m*(m-e)*(2*m-3-e),12*e)
end

"""
`defectsymbol(s)'

For an `e`-symbol `[S₁,S₂,…,Sₑ]` returns `length(S₁)-length(S₂)`.

```julia-repl
julia> defectsymbol([[1,5,6],[1,2]])
1
```
"""
function defectsymbol(S)
  length(S)>1 && S[end] isa AbstractVector ? length(S[1])-length(S[2]) : 0
end

"""
`defect(s::CharSymbol)`

For an `e`-symbol `[S₁,S₂,…,Sₑ]` returns `length(S₁)-length(S₂)`.

```julia-repl
julia> defect(CharSymbol([[1,5,6],[1,2]]))
1
```
"""
function defect(S::CharSymbol)
  length(S)>1 && S.repeats==1 ? length(S.S[1])-length(S.S[2]) : 0
end

"""
`degree_feg(s::CharSymbol)`

the  degree  of  the  fake  degree  of  the  character parameterized by the
symbol `s`.

```julia-repl
julia> degree_feg(CharSymbol([[1,5,6],[1,2]]))
88
```
"""
function degree_feg(s::CharSymbol)
  d=defect(s)
  if d!=0 && d!=1 return -1 end
  r=rank(s)
  e=length(s)
  if d==1 res=div(e*r*(r+1),2)
  else    res=div(e*r*(r-1),2)+r
  end
  res+=e*sum(S->S'*(0:length(S)-1)-sum(l->div(l*(l+1),2),S;init=0),s.S)
  γ=i->sum(j->mod(i+j,e)*sum(s.S[j+1]),0:e-1)
  if d==1 res+=γ(0)
  else res+=maximum(γ(i) for i in 0:e-1)
  end
  res-sum(map(x->div(x*(x-1),2),e*(1:div(sum(length,s.S),e)-1).+mod(d,2)))
end

"""
`valuation_feg(s::CharSymbol)`

the  valuation of  the fake  degree of  the character  parameterized by the
symbol `s`.

```julia-repl
julia> valuation_feg(CharSymbol([[1,5,6],[1,2]]))
16
```
"""
function valuation_feg(s::CharSymbol)
  d=defect(s)
  if !(d in (0,1)) return -1 end
  e=length(s)
  res=e*sum(S->S'*(length(S)-1:-1:0),s.S)
  γ=i->sum(j->mod(i+j,e)*sum(s.S[j+1]),0:e-1)
  if d==1 res+=γ(0)
  else res+=minimum(γ(i) for i in 0:e-1)
  end
  res-sum(map(x->div(x*(x-1),2),e*(1:div(sum(length,s.S),e)-1).+mod(d,2)))
end

"""
`show(io=stdout,S)` string for symbol `S` [taking `io` in account].
```julia-repl
julia> symbols(2,4,0) # symbols for D₄
14-element Vector{CharSymbol}:
 (12+)
 (12-)
 (013,123)
 (0123,1234)
 (02,13)
 (03,12)
 (012,124)
 (2+)
 (2-)
 (01,23)
 (1,3)
 (01,14)
 (0,4)
 (0123,)
```
"""
function Base.show(io::IO,S::CharSymbol)
  if get(io,:limit,false) || get(io,:TeX,false)
    print(io,"(")
    join(io,joindigits.(S.S[1:div(length(S.S),S.repeats)]),",")
    if S.repeats>1
      r=repr(E(S.repeats,S.no);context=io)
      if r=="1" r="+" end
      if r=="-1" r="-" end
      print(io,r)
    end
    print(io,")")
  else
    print(io,"CharSymbol([")
    join(io,map(x->"["*join(x,",")*"]",S.S),",")
    print(io,"]")
    if S.repeats>1 print(io,",",S.repeats,",",S.no) end
    print(io,")")
  end
end

# should exist as Iterators.circshift
Iterators_circshift(s,i)=(s[mod1(j-i,length(s))] for j in eachindex(s))

# should exist as Iterators.cmp
function Iterators_cmp(s,t)
  is=iterate(s)
  it=iterate(t)
  while true
   if isnothing(is) return isnothing(it) ? 0 : -1
   elseif isnothing(it) return 1 end
   vs,states=is
   vt,statet=it
   c=cmp(vs,vt)
   if c!=0 return c end
   is=iterate(s,states)
   it=iterate(t,statet)
  end
end

# Malledefect of a shape s of a symbol
function Malledefect(s)
  e=length(s)
  mod(binomial(e,2)*div(sum(s),e)-dot(0:e-1,s),e)
end

"""
`Malledefect(S::CharSymbol)`

Malle-defect of `S`. This is an invariant by shift but not in general under
cyclic permutations.
"""
Malledefect(S::CharSymbol)=Malledefect(length(x) for x in S.S)

"""
`shapesSymbols(e,r,c=1,def=0)`

possible shapes for `e`-symbols of rank `r`, content `c`, Malle-defect `def`"
"""
function shapesSymbols(e,r,c=1,def=0)
  if e==1 return [[0]] end
  if !(c in 0:e-1) error("the content should be in ",0:e-1) end
  if !(def in 0:e-1) error("the Malle-defect should be in ",0:e-1) end
  function f(lim2,len,nb,max) local res,a # possible decreasing shapes
    if nb==1
      if len==0   return [[len]]
      else return Vector{Int}[] end
    end
    res=Vector{Int}[]
    a=div(len,nb-1)
    while a<=max  &&  binomial(a,2)<=lim2  &&  a<=len
      append!(res,map(x->pushfirst!(x,a),f(lim2-binomial(a,2),len-a,nb-1,a)))
      a+=1
    end
    return res
  end

  res=Vector{Int}[]
  m=0
  while true
    new=f(r+div((m*e+c-1)*(m*e+c-e+1),2*e),c+m*e,e,c+m*e)
    if length(new)==0 break end
    append!(res,new)
    m+=1
  end
  res=reduce(vcat,arrangements.(res,e))
  # for symbols of content 1 only one circshift of the shape has Malledefect=0
  filter(s->Malledefect(s)==def &&
    all(1:length(s)-1)do i
      x=Iterators_circshift(s,i)
      Malledefect(x)!=def || Iterators_cmp(s,x)!=-1
    end,res)
end

"""
`isless(s::CharSymbol,t::CharSymbol)`

A symbol is smaller than another if the shape is lexicographically smaller,
or the shape is the same and the vector of βsets is lexicographically bigger.
"""
function Base.isless(s::CharSymbol,t::CharSymbol)
  c=Iterators_cmp((length(x) for x in s.S),length(x) for x in t.S)
  c==-1 || (c==0 && t.S<s.S)
end

# s is reduced if >= to all its circshifts
function isreduced(s::CharSymbol)
  !any(1:length(s.S)-1)do i
    c=Iterators_cmp((length(x) for x in s.S),
                   (length(x) for x in Iterators_circshift(s.S,i)))
    c==-1 || (c==0 && Iterators_cmp(Iterators_circshift(s.S,i),s.S)==-1)
  end
end

"`symbolsshape(r,s)` symbols of rank `r` and shape `s`"
function Symbolsshape(r,s)
  S=map(x->Symbol_partition_tuple(x,s),
     partition_tuples(r-rank(CharSymbol(map(x->0:x-1,s))),length(s)))
  if !iszero(sum(s)%length(s)) return S end
  S=filter(isreduced,S)
  if !iszero(Malledefect(s)) return S end
  res=CharSymbol[]
  for s in S
    p=findfirst(i->Iterators_cmp(s.S,Iterators_circshift(s.S,1-i))==0,2:length(s))
    if p===nothing push!(res,s)
    else repeats=div(length(s),p)
      for i in 0:repeats-1 push!(res,CharSymbol(s.S,repeats,i)) end
    end
  end
  res
end

"""
`symbols(e,r,content=1,Malledefect=0)`

The list of `e`-symbols of rank `r` and given content and Malle-defect.

The symbols parametrize unipotent characters of:
  - `G(d,1,r)` : `symbols(d,r)`
  - `G(e,e,r)` : `symbols(e,r,0)`.
  - `G(e,e,r).s₁ᵗ` where `s₁` is the first generator of `G(e,1,r)` and `t|e`:
    `symbols(e,r,0,t)`

In particular we have
  - `Aₙ` : `symbols(1,n)`
  - `Bₙ` : `symbols(2,n)`
  - `Dₙ` : `symbols(2,n,0)`
  - `²Dₙ` : `symbols(2,n,0,1)`
  - `²B₂` : `symbols(4,2,0,1)`
  - `²G₂` : `symbols(6,2,0,1)`
```julia-repl
julia> symbols(2,4,0,1) # unipotent characters of ²D₄
10-element Vector{CharSymbol}:
 (123,0)
 (023,1)
 (0124,12)
 (01234,123)
 (13,)
 (013,2)
 (014,1)
 (0123,13)
 (04,)
 (012,3)
```
"""
symbols(e,r,c=1,def=0)=vcat(Symbolsshape.(r,shapesSymbols(e,r,c,def))...)

# for S β-numbers ∏(x^{ei}-x^{ej}) for i>j, i,j∈S
function Δ(S,e)
  l=length(S)
  if l<2 return one(CycPol) end
  v=sum(e*S[i] for i in 1:l for j in i+1:l)
  p=[k//(e*(S[j]-S[i])) for i in 1:l for j in i+1:l for k in 0:e*(S[j]-S[i])-1]
  CycPol(1,v,ModuleElt(p.=>1))
end

# for S β-numbers ∏(x^{eh}-1) for l in S for h in 1:l
function Θ(S,e)
  if iszero(sum(S)) return one(CycPol) end
  p=[i//(e*h) for l in S for h in 1:l for i in 0:e*h-1]
  CycPol(1,0,ModuleElt(p.=>1))
end

"""
`fakedegree(S::CharSymbol,p=0)`

returns as  a `CycPol` the  fake degree of  the character of symbol `S`.
```julia-repl
julia> fakedegree(CharSymbol([[1,5,6],[1,2]]))
q¹⁶Φ₅Φ₇Φ₈Φ₉Φ₁₀Φ₁₁Φ₁₄Φ₁₆Φ₁₈Φ₂₀Φ₂₂
```
If `S` is an `e`-symbol, when given a second argument `p` dividing `e`, and
a  first  argument  of  shape  `(0,…,0)`  representing  the  restriction of
the character to `G(e,e,r)`, works for the coset `G(e,e,r).s₁ᵖ`.
"""
function fakedegree(s::CharSymbol,p=0) # See Mal95, 2.11 and 5.7
  if length(s)==0 return one(CycPol) end
  e=length(s)
  r=rank(s)
  ep=E(e,p)
  if !allequal(length,s.S[2:end]) return zero(CycPol) end
  d=defect(s)
  if d==1 res=Θ([r],e)
  elseif d==0 res=Θ([r-1],e)*CycPol(Pol([1],r)-Pol(ep))
  else return zero(CycPol)
  end
  res*=prod(S->Δ(S,e)//Θ(S,e),s.S)
  res//=CycPol(1,sum([div(x*(x-1),2) for x in e.*(1:div(sum(length,s.S),e)-1).+d%2]))
  if d==1 res*=CycPol(1,sum(((x,y),)->x*sum(y),zip(0:e-1,s.S)))
  else
    rot=circshift.(Ref(s.S),e:-1:1)
    u=ep.^(0:e-1).*map(s->Pol([1],sum(((x,y),)->x*sum(y),zip(0:e-1,s))),rot)
    res*=CycPol(sum(u))
    res=div(res,count(==(s.S), rot))
    if e==2 && ep==-1 res=-res end
  end
  if r==2 && (e>2 && ep==E(e))
    res=subs(res,Pol([E(2e)],1))//E(2e,degree(res))
  end
  res
end

"""
`gendeg(S::CharSymbol)`

returns  as  a  `CycPol`  the  generic  degree  of  the unipotent character
parameterized by `S`.

```julia-repl
julia> gendeg(CharSymbol([[1,2],[1,5,6]]))
q¹³Φ₅Φ₆Φ₇Φ₈²Φ₉Φ₁₀Φ₁₁Φ₁₄Φ₁₆Φ₁₈Φ₂₀Φ₂₂/2
```
works for spetses G(e,1,r),  G(e,e,r), ᵗG(e,e,r)

see [mal95; 3.9 and 6.4](@cite).
"""
function gendeg(S::CharSymbol)
  r=rank(S)
  e=length(S)
  sh=length.(S.S)
  if e==0 return one(CycPol) end
  m=div(sum(sh),e)
  d=sum(sh)% e
  defect=(binomial(e,2)*m-transpose(sh)*(0:e-1))%e
  # initialize with the q'-part of the group order
  if d==1 res=Θ([r],e)
  elseif d==0 res=Θ([r-1],e)*CycPol(Pol([1],r)-E(e,defect))
  end
  res*=(-1)^(sum(((x,y),)->x*binomial(y,2),zip(0:e-1,sh)))*
    prod(i->prod(j->prod(map(l->prod(map(m->CycPol(l-m),
    filter(m->i<j || degree(m)<degree(l),
       Pol.(Ref([E(e,j)]),S.S[j+1])));init=one(CycPol)),
       Pol.(Ref([E(e,i)]),S.S[i+1]));init=one(CycPol)),i:e-1),0:e-1)//
    (prod(x->Θ(x,e),S.S)*(E(4)^binomial(e-1,2)*root(e)^e)^m
      *CycPol(1,sum(binomial.(e.*(1:m-1).+d,2))))
  if d==0 res*=findfirst(i->circshift(S.S,-i)==S.S,1:e) end
  if defect==0 || r!=2 || e<=2 return res
  else return E(e)^-1*subs(res,Pol([E(2*e)],1)) # 2I(e)
  end
end

"""
`ennola(S::CharSymbol)`

Ennola of `e`-symbol `S` (of content `1` or `0`) The order of Ennola (order
of  center of  reflection group)  is computed  automatically: it is `e` for
content `1` and `gcd(e,rank(S))` for content `0`.
"""
function ennola(s::CharSymbol)
  e=length(s)
  z=sum(length,s.S)%e==1 ? e : gcd(e,rank(s))
  if isone(z) return s end
  res=map(x->Int[],s.S)
  for i in 1:length(s), k in s.S[i]
    push!(res[1+(i+k*div(e,z))%e],k)
  end
  res=sort.(res)
  if s.repeats==1 return CharSymbol(res) end
  if div(e,s.repeats)!=findfirst(i->circshift(res,-i)==res,1:e)
    error("period changed!")
  end
  ind=isodd(e) ? s.no : (s.no+div(e,2)-1)%s.repeats
  # works for types D,I and G(3,3,3) but ???
  CharSymbol(res,s.repeats,ind)
end

function xsp(rho,s,n,d)
  nrsd=rho*div(d^2,4)-s*div(d-mod(d,2),2)
  if n<nrsd return Vector{Vector{Int}}[] end
  return map(partition_tuples(n-nrsd,2)) do S
    S = Symbol_partition_tuple(S, d).S
    S = map(x->isempty(x) ? x : x+(0:length(x)-1)*(rho-1),S)
    [S[1],S[2].+s]
  end
end

"""
`XSP(ρ,s,n,even=false)` Lusztig-Spaltenstein symbols.

returns  the union of the  [lusp85](@cite) symbols ``X̃^{ρ-s,s}_{n,d}`` for
all  `d`  even  when  `even=true`,  all  `d`  odd  otherwise; these symbols
parametrize  local  systems  on  unipotent  conjugacy classes for classical
groups.  In [lus04;  13.2](@cite) the  notation is  ``{}^ρ X^s_{n,d}``. The
result  is a vector of vectors, each inner vector regrouping the symbols in
a  similarity class (the local systems  whose support is the same conjugacy
class). If `s==0`, only positive defects `d` are considered.

  - `XSP(2,1,n)` gives Lusztig-Spaltenstein symbols for Sp₂ₙ
  - `XSP(4,2,n)` gives Lusztig-Spaltenstein symbols for Sp₂ₙ in char.2
  - `XSP(2,0,n)` gives Lusztig-Spaltenstein symbols for SO₂ₙ₊₁ of odd defect
  - `XSP(2,0,n,true)` gives Lusztig-Spaltenstein symbols for SO₂ₙ of even defect
  - `XSP(4,0,n,true)` gives Lusztig-Spaltenstein symbols for SO₂ₙ in char 2

Each  Lusztig-Spaltenstein symbol  is represented  by a  `NamedTuple` whose
fields describe the local system. The fields are

  - `symbol` the Lusztig-Spaltenstein symbol
  - `dimBu` for the support `u` of the local system
  - `Au` describes the character  of `A(u)` corresponding to the  local system 
     as a boolean list where `true`->sgn, `false`->Id
  - `sp`  is the parameter (double partition) of the generalized Springer
     correspondent (a character of the relative Weyl group)
"""
function XSP(rho,s,n,even=false)
  d=Int(!Bool(even))
  res = Vector{Vector{Int}}[]
  while true
    S=xsp(rho, s, n, d)
    if iszero(d) S=unique!(sort!(sort.(S))) end
    append!(res,S)
    d+=2
    if isempty(S) break end
  end
  if !iszero(s) && !iszero(mod(d,2))
    d=-1
    while true
      S=xsp(rho, s, n, d)
      append!(res, S)
      d-=2
      if isempty(S) break end
    end
  end
  map(collectby(x->[sort(unique!(union(x...))),sort(unique!(intersect(x...)))],res)) do f
    ii=Vector{Int}[]
    d=sort(symdiff(f[1]...))
    if length(d)>0
      i=[d[1]]
      for j in d[2:end]
        if j-i[end]<rho push!(i, j)
        else push!(ii, i)
          i=[j]
        end
      end
      push!(ii,i)
      ii=filter(x->x[1]>=s,ii)
    end
    u=findfirst(f) do x
      if !(defectsymbol(x) in [0,1]) return false end
      l=zeros(Int,1+sum(length,x))
      l[1:2:2*length(x[1])-1]=x[1]
      l[2:2:2*length(x[2])]=x[2]
      issorted(l[1:sum(length,x)])
    end
    if isnothing(u) error("f=$f") end
    dist=f[u]
    n=sum(length,dist)
    d=defectsymbol(dist)
    m=div(n,2)
    i=sort(reduce(vcat,dist),rev=true)
    n=sum(i.*(0:n-1))-div(rho*m*(m-1)*((4m-5)+6d),6)-s*m*(m+d-1)
    return map(f) do S
      function rr(x,s)
        isempty(x) ? x : reverse(filter(!iszero,x.-(0:length(x)-1).*rho.-s))
      end
      sp=[rr(S[1],0), rr(S[2],s)]
      if defectsymbol(S) == 0
        if sp>reverse(sp) reverse!(sp) end
        if sp[1]==sp[2] sp=[sp[1],2,0] end
      elseif defectsymbol(S)<0 reverse!(sp)
      end
      Au=map(i->intersect(S[1],i)!=intersect(dist[1],i), ii)
      if iszero(s) && S[1]!=S[2]
        if Au[end] Au=.!(Au) end
        Au=Au[1:end-1]
      end
      (symbol=S,Au,dimBu=n,sp)
  end
end
end

showxsp(r)=println("(symbol=",string_partition_tuple(r.symbol),
    ", sp=",string_partition_tuple(r.sp),", dimBu=",r.dimBu,", Au=",r.Au,")")
end
