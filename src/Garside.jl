"""
Garside  monoids are a general class  of monoids whose most famous examples
are  the braid and dual braid monoids.  They have groups of fractions which
in  both cases are the  braid group. Here we  implement braid groups in the
framework of a general implementation of Garside monoids and groups.

To  define Garside monoids we  introduce some vocabulary about divisibility
in  monoids. A *left  divisor* of `x`  is a `d`  such that there exists `y`
with  `x=dy` (and then  we say that  `x` is a  *right multiple* of `d`, and
write  `dâ‰¼ x`). We say that a monoid `M` is left cancellable if an equality
`dx=dy`  implies  `x=y`.  We  define  symmetrically  right  divisors,  left
multiples and right cancellability. We say that `x` is an *atom* if `1` and
`x`  are its only  divisors. A *left  gcd* of `x`  and `y` is a common left
divisor  `d` of `x`  and `y` such  that any other  common left divisor is a
left  divisor of `d`.  Similarly a *right  lcm* of `x`  and `y` is a common
multiple which is a left divisor of any other common multiple.

We  call *Garside* a monoid `M` which:
  * is left and right cancellable.
  * is generated by its atoms.
  * admits left and  right  gcds  and  lcms.
  * is such that any element has only finitely many left (or right) divisors.
  * admits a *Garside element*, which is an element `Î”` whose set of left
    and right divisors coincide and generate `M`.

Garside  elements are not  unique, but there  is a unique  minimal one (for
divisibility);  we assume a  Garside element `Î”`  has been chosen. Then the
divisors  of `Î”` are called  the *simples* of `M`.  A Garside monoid embeds
into  its group of fractions, which is  called a *Garside group* (a Garside
group  may have  several distinct  Garside structures,  as we  will see for
Braid groups of finite Coxeter groups).

We  also implement *locally Garside* monoids,  which are monoids where lcms
do  not always exist, but exist when any common multiple exists; the set of
simples  is then not defined using a  Garside element, but by the condition
that  they contain the atoms and are  closed under lcms and taking divisors
(see  [BDM01](biblio.htm#BDM01)); since it is  not ensured by the existence
of  `Î”`, one  has to  add the  condition that  any element  is divisible by
finitely many simples (but the number of simples can be infinite). The main
example  is the Artin monoid of an  infinite Coxeter group. It is not known
if  these monoids embed in  their group of fractions  (though that has been
proved for braid monoids of Coxeter groups by Paris
[Paris01](biblio.htm#Paris01))  and thus  computing in  the monoid does not
help  for computing in the group (only  the monoid is implemented for these
cases).

What allows computing with Garside and locally Garside monoids, and Garside
groups,  is the fact  that they admit  normal forms ---  these normal forms
where   exhibited  for   braid  monoids   of  Coxeter   groups  by  Deligne
[Del72](biblio.htm#Del72),  who extended previous  work of Brieskorn, Saito
[BS72](biblio.htm#BS72) and Garside [Gar69](biblio.htm#Gar69):

  1. Let `M` be a locally Garside monoid. Then for `bâˆˆ M` there is a unique  maximal simple left divisor `Î±(b)` of `b`; any other simple dividing `b` divides `Î±(b)`.

  2. Let `M` be a Garside monoid with Garside element `Î”` and group of fractions `G`. Then for any `xâˆˆ  G`, for large enough `i` we have `Î”â±xâˆˆ M`.

A  consequence of 1. is that any element has a canonical decomposition as a
product of simples, called its left-greedy normal form. If we define `Ï‰(x)`
by  `x=Î±(x)Ï‰(x)`, then the normal form of `x` is `Î±(x)Î±(Ï‰(x))Î±(Ï‰^2(x))â€¦` We
use  the normal form to represent elements  of `M`, and when `M` is Garside
we  use  2.  to  represent  elements  of  `G`:  given `xâˆˆ G` we compute the
smallest  power `i` such that `Î”â± xâˆˆ M`, and we represent `x` by the couple
`(i,Î”â»â±x)`.  We are thus reduced to the case where `xâˆˆ M`, not divisible by
`Î”`,  where we represent  `x` by the  sequence of simples which constitutes
its normal form.

We  now describe Artin-Tits braid monoids. Let `(W,S)` be a Coxeter system,
that is `W` has presentation

`âŸ¨sâˆˆ Sâˆ£sÂ²=1, stsâ‹¯ =tstâ‹¯   (mâ‚›â‚œ factors on each side) for s,tâˆˆ SâŸ©`

for some Coxeter matrix `mâ‚›â‚œ`. The braid group `B` associated to `(W,S)` is
the group defined by the presentation

`âŸ¨ð¬âˆˆ ð’âˆ£ ð¬ð­ð¬â‹¯ =ð­ð¬ð­â‹¯  (mâ‚›â‚œ factors on each side) for ð¬,ð­âˆˆ ð’âŸ©`

The *positive* braid monoid `Bâº` associated to `W` is the monoid defined by
the  presentation above --- it identifies to the submonoid of `B` generated
by  `ð’` by  the result  of Paris  mentioned above.  This monoid  is locally
Garside,  with set of simples  in bijection with elements  of `W` and atoms
the elements of `ð’`; we will denote by `ð– ` the set of simples, and by `ð° â†¦
w`  the bijection between simples and elements  of `W`. The group `W` has a
length  defined  in  terms  of  reduced expressions. Similarly, having only
homogeneous relations, `Bâº` has a natural length function. Then `ð– ` can be
characterized  as the subset of the elements  of `Bâº` of the same length as
their image in `W`.

If  `W` is finite, then `Bâº` is Garside with Garside element the element of
`ð–  ` whose image is the longest element  of `W`. A finite Coxeter group is
also  a reflection group in  a real vector space,  thus in its complexified
`V`,  and `B` has also a topological definition as the fundamental group of
the  space `VÊ³áµ‰áµ/W`, where `VÊ³áµ‰áµ`  is the set of  elements of `V` which are
fixed  by no  non-identity element  of `S`;  however, we  will not use this
here.

We  implement in general only  monoids which have a  finite number of atoms
(there  is  a  special  implementation  for  the  Dual monoid of the affine
Coxeter group `W(AÌƒâ‚™)`).

Given a Coxeter group `W`,
```julia-repl
julia> W=coxgroup(:A,4)
Aâ‚„

julia> B=BraidMonoid(W)
BraidMonoid(Aâ‚„)
```
constructs  the  associated  braid  monoid,  and  then  as  a  function `B`
constructs  elements of the braid monoid (or group when `W` is finite) from
a list of generators:

```julia-repl
julia> w=B(1,2,3,4) # represents ð¬â‚ð¬â‚‚ð¬â‚ƒð¬â‚„
1234

julia> w^3  # the terms of the normal form are separated by a .
121321432.343

julia> word(Î±(w^3))
9-element Vector{Int64}:
 1
 2
 1
 3
 2
 1
 4
 3
 2

julia> w^4
Î”.232432

julia> inv(w)
(1234)â»Â¹
```
How  an  element  of  a  Garside  group  is  printed  is  controlled by the
`IOcontext`  attribute  ':greedy'.  By  default,  elements  are  printed as
fractions `aâ»Â¹b` where `a` and `b` have no left common divisor. Each of `a`
and  `b` is printed  using its left-greedy  normal form, that  is a maximal
power of the Garside element followed by the rest. One can print the entire
element   in  the  left-greedy  normal  from  by  setting  the  `IOContext`
`:greedy=>true`; with the same `w` as above we have:

```julia-repl
julia> repr(w^-1,context=IOContext(stdout,:greedy=>true,:limit=>true))
"Î”â»Â¹.232432"
```
By default,  `repr` gives   `w`  back   in  a   form  which   after  assigning
`B=BraidMonoid(W)` can be input back into Julia:

```julia-repl
julia> repr(w)
"B(1,2,3,4)"

julia> repr(w^3)
"B(1,2,1,3,2,1,4,3,2,3,4,3)"

julia> repr(w^-1)
"B(-4,-3,-2,-1)"
```
In  general elements of a  Garside monoid are displayed  as a list of their
constituting atoms.

We  now describe the dual braid monoid.  For that, we first define interval
monoids.  Given a group `W` and a set `S` of generators of `W` as a monoid,
we  define the `S`-length `l_S(w)` as the minimum number of elements of `S`
needed  to write `w`. We  then define left divisors  of `x` as the `d` such
that  there exists `y` with `x=dy`  and `l_S(d)+l_S(y)=l_S(x)`. We say that
`wâˆˆ W` is balanced if its set of left and right divisors coincide; in which
case  we  denote  this  set  by  `[1,w]`,  an  "interval"  for the poset of
`S`-divisibility.  We say that `w`  is Garside for the  `S`-length if it is
balanced  and `[1,w]` is a  lattice (where upper and  lower bounds are lcms
and gcds), which generates `W`. Then we have the theorem:

Suppose  `w`  is  Garside  for  the  `S`-length.  Then  the monoid `M` with
generators  `[1,w]` and relations  `xy=z` whenever `xy=z`  holds in `W` and
`l_S(x)+l_S(y)=l_S(z)`, is a Garside monoid, with simples `[1,w]` and atoms
`S`. It is called the interval monoid defined by the interval `[1,w]`.

The  Artin-Tits braid monoid  is an interval  monoid by taking  for `S` the
Coxeter  generators, in which case `l_S`  is the Coxeter length, and taking
for `w` the longest element of `W`. The dual monoid, constructed by Birman,
Ko  and  Lee  for  type  `A`  and  by Bessis for all well-generated complex
reflection  groups, is obtained in  a similar way, by  taking this time for
`w`  a Coxeter element, for `l_S` the reflection length 'reflength' and for
`S_S`  the  reflections  which  divide  `w`  for the reflection length (for
Coxeter  groups all reflections  divide `w` but  for well-generated complex
reflection  groups not  all reflections  divide); for  the dual  monoid the
simples  are of cardinality  the generalized Catalan  numbers `catalan`. An
interval  monoid has naturally an inverse  morphism from `M` to `W`, called
'image'  which is the  quotient map from  the interval monoid  to `W` which
sends back simple braids to `[1,w]`.

A last pertinent notion is *reversible* monoids. Since we store left normal
forms,  it is easy to compute left lcms and gcds, but hard to compute right
lcms  and gcds. But this becomes easy to  do if the monoid has an operation
'reverse',  which has the property that 'a' is a left divisor of 'b' if and
only  if 'reverse(a)'  is a  right divisor  of 'reverse(b)'. This holds for
Artin-Tits  and dual braid monoids of groups generated by true reflections;
Artin-Tits monoids have a `reverse` operation which consists of reversing a
word,  written as  a list  of atoms.  The dual  monoid also has a `reverse`
operation  defined in the  same way, but  this operation changes monoid: it
goes  from the dual monoid  for the Coxeter element  `w` to the dual monoid
for  the Coxeter element  `wâ»Â¹`. The operations  'rightlcm' and 'rightgcd',
and  some other algorithms, have faster implementations if the monoid has a
`reverse` operation.

This  module implements also  functions to solve  the conjugacy problem and
compute  centralizers  in  Garside  groups,  following  the work of Franco,
Gebhardt and Gonzalez-Meneses.

Two  elements `w` and `w'` of a monoid  `M` are *conjugate* in `M` if there
exists  `xâˆˆ M` such that `wx=xw'`; if  `M` satisfies the Ã–re conditions, it
has  a  group  of  fractions  where  this  becomes  `xâ»Â¹wx=w'`,  the  usual
definition  of conjugacy. A special case  which is even closer to conjugacy
in  the group is if there exists `yâˆˆ  M` such that `w=xy` and `w'=yx`. This
relation  is not transitive in general,  but we call *cyclic conjugacy* the
transitive closure of this relation, a restricted form of conjugacy.

The  next  observation  is  that  if  `w,w'`  are conjugate in the group of
fractions  of the Garside monoid `M` then  they are conjugate in `M`, since
if  `wx=xw'` then  there is  a power  `Î”â±` which  is central and such that
`xÎ”â±âˆˆ M`. Then `wxÎ”â±=xÎ”â± w'` is a conjugation in `M`.

The  crucial observation for solving the  conjugacy problem is to introduce
`inf(w):=sup{i  such that  Î”â± divides  w}` and  `sup(w):=inf{i such  that w
divides  Î”â±}`, and to notice that the number of conjugates of `w` with same
`inf` and `sup` as `w` is finite (since our monoids have a finite number of
atoms).  Further,  a  theorem  of  Birman  shows that the maximum `inf` and
minimum  `sup` in  a conjugacy  class can  be achieved  simultaneously; the
elements  achieving this are called the super summit set of `w`. Thus a way
to  determine if two elements are conjugate  is to find a representative of
both  of them in  their super summit  set, and then  solve conjugacy within
that  set. This can also be used  to compute the centralizer of an element:
if  we consider  the super  summit set  as the  objects of a category whose
morphisms are the conjugations by simple elements, the centralizer is given
by the endomorphisms of the given object.

We illustrate this on an example:
```julia-repl
julia> b=B(2,1,4,1,4)
214.14

julia> c=B(1,4,1,4,3)
14.143

julia> d=conjugating_elt(b,c)
(1)â»Â¹21321432

julia> b^d
14.143

julia> centralizer_gens(b)
3-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 321432.213243
 21.1
 4

julia> C=conjcat(b;ss=:ss)
category with 10 objects and 32 generating maps

julia> C.obj
10-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 1214.4
 214.14
 124.24
 1343.1
 14.124
 143.13
 24.214
 134.14
 13.134
 14.143
```

There   is  a   faster  solution   to  the   conjugacy  problem   given  in
[gebgon10](biblio.htm#gebgon10):  for each `bâˆˆ M`, they define a particular
simple  left divisor of `b`, its *preferred prefix* such that the operation
*sliding*  which  cyclically  conjugates  `b`  by  its preferred prefix, is
eventually periodic, and the period is contained in the super summit set of
`x`.  We say that `x` is in its sliding circuit if some iterated sliding of
`x` is equal to `x`. The set of sliding circuits in a given conjugacy class
is  smaller than the super  summit set, thus allows  to solve the conjugacy
problem faster. Continuing from the above example,

```julia-repl
julia> word(W,preferred_prefix(b))
2-element Vector{Int64}:
 2
 1

julia> b^B(preferred_prefix(b))
1214.4

julia> b1=b^B(preferred_prefix(b))
1214.4

julia> C=conjcat(b)
category with 2 objects and 6 generating maps

julia> C.obj
2-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 1214.4
 1343.1
```
Finally,  we have implemented  Hao Zheng's algorithm  to extract roots in a
Garside monoid:

```julia-repl
julia> W=coxgroup(:A,3)
Aâ‚ƒ

julia> B=BraidMonoid(W)
BraidMonoid(Aâ‚ƒ)

julia> Pi=B(B.Î´)^2
Î”Â²

julia> root(Pi,2)
Î”

julia> root(Pi,3)
1232

julia> root(Pi,4)
132
```
"""
module Garside
using ..Gapjm
export BraidMonoid, braid, shrink, Î±, DualBraidMonoid, conjcat, fraction,
centralizer_gens, preferred_prefix, left_divisors, Category,
endomorphisms, image, leftgcd, leftgcdc, rightgcd, rightgcdc, 
leftlcm, leftlcmc, rightlcm, rightlcmc, conjugating_elt, GarsideElt, 
Brieskorn_normal_form, GarsideMonoid, LocallyGarsideMonoid, hurwitz,
rightascents

"""
`LocallyGarsideMonoid{T}`  is the abstract type of locally Garside monoids,
where  `T`  is  the  type  of  simples.  Such a monoid `M` needs, for `a,b`
simples, to implement the functions
  - `one(M)`
  - `isleftdescent(M,a,i::Int)`  whether `M.atoms[i]â‰¼ a`
  - `isrightdescent(M,a,i::Int)` whether `aâ‰½ M.atoms[i]`
  - `isrightascent(M,a,i::Int)`  whether `a*M.atoms[i]` is simple
  - `*(M,a,b)`  when `a*b` is simple returns the simple `a*b`
  - `\\(M,a,b)` when `aâ‰¼ b` returns `inv(a)*b`
  - `/(M,a,b)`  when `aâ‰½ b` returns `a/b`
"""
abstract type LocallyGarsideMonoid{T} end # T=type of simples
"""
`GarsideMonoid{T}`  is the abstract  type of Garside  monoids, where `T` is
the type of simples. Such a monoid `M` should implement the same methods as
`LocallyGarsideMonoid`  except  that  `isrightascent(M,a)` is automatically
defined as `isleftdescent(M,\\(M,a,M.Î´),i)`.

An implementation should have fields `M.Î´`, `M.stringÎ´`, `M.orderÎ´`.
"""
abstract type GarsideMonoid{T}<:LocallyGarsideMonoid{T} end

CoxGroups.firstleftdescent(M::LocallyGarsideMonoid,elts...)=
  findfirst(i->all(b->isleftdescent(M,b,i),elts),eachindex(M.atoms))

function leftgcdc(M::LocallyGarsideMonoid{T},simp::Vararg{T,N})where {T,N}
  if N==0 error("leftgcd needs at least one simple as argument") end
  x=copy(one(M)) # copy because of the mul! later
  while true
    i=firstleftdescent(M,simp...)
    if isnothing(i) return (x,simp) end
    a=M.atoms[i]
    x=mul!(M,x,a)
    simp=map(y->\(M,a,y),simp)
  end
end

"""
`leftgcd(M::LocallyGarsideMonoid,simp...)`
`leftgcdc(M::LocallyGarsideMonoid,simp...)`

`simp`  should be simples of `M`. The  function returns the left gcd `d` of
the `simp`.

`leftgcdc` returns `d` followed by the tuple of complements `inv(d).*simp`
"""
leftgcd(M::LocallyGarsideMonoid{T},simp::Vararg{T,N}) where {T,N}=first(leftgcdc(simp...))

function rightgcdc(M::LocallyGarsideMonoid{T},simp::Vararg{T,N})where {T,N}
  if N==0 error("rightgcd needs at least one simple as argument") end
  d=one(M)
  found=true
  while found
    found=false
    for (i,a) in pairs(M.atoms)
      if all(b->isrightdescent(M,b,i),simp)
        found=true
        d=*(M,a,d)
        simp=map(x->/(M,x,a),simp)
      end
    end
  end
  (d,simp)
end

"""
`rightgcd(M::LocallyGarsideMonoid,simp...)`
`rightgcdc(M::LocallyGarsideMonoid,simp...)`

`simp`  should be simples of `M`. The function returns the right gcd `d` of
the `simp`.

`rightgcdc` returns the `d` followed by the tuple of complements `simp./d`
"""
rightgcd(M::LocallyGarsideMonoid{T},simp::Vararg{T,N}) where{T,N}=
  first(rightgcdc(M,simp...))

"""
`Î±2(M::LocallyGarsideMonoid,x,v)` returns Î±(xv),Ï‰(xv) for the simples x and v
"""
function Î±2(M::LocallyGarsideMonoid,x,v)
  found=true
  while found
    found=false
    for (i,a) in pairs(M.atoms)
      if isleftdescent(M,v,i) && isrightascent(M,x,i)
        x=*(M,x,a)
        v=\(M,a,v)
        found=true
      end
    end
  end
  (x,v)
end

# julia is only 20% faster than Gap3
function Î±2(M::GarsideMonoid,x,v)
  g,(_,cv)=leftgcdc(M,rightcomplÎ´(M,x),v)
  (*(M,x,g),cv)
end

function rightlcmc(M::GarsideMonoid{T},simp::Vararg{T,N})where {T,N}
  _,c=rightgcdc(M,rightcomplÎ´.(Ref(M),simp)...)
  (*(M,simp[1],c[1]),c)
end

"""
`rightlcm(M::GarsideMonoid,simp...)`
`rightlcmc(M::GarsideMonoid,simp...)`

`simp`  should be simples of `M`. The function returns the right lcm `m` of
the `simp`.

`rightlcmc` returns `m` followed by the tuple of complements `simp.\\m`
"""
rightlcm(M::GarsideMonoid{T},simp::Vararg{T,N}) where {T,N}=
  first(rightlcmc(M,simp...))

function leftlcmc(M::GarsideMonoid{T},simp::Vararg{T,N})where {T,N}
  _,c=leftgcdc(M,leftcomplÎ´.(Ref(M),simp)...)
  (*(M,c[1],simp[1]),c)
end

"""
`leftlcm(M::GarsideMonoid,simp...)`
`leftlcmc(M::GarsideMonoid,simp...)`

`simp`  should be simples of `M`. The  function returns the left lcm `m` of
the  `simp`.

`leftlcmc` returns `m` followed by  the tuple of complements `m./simp`
"""
leftlcm(M::GarsideMonoid{T},simp::Vararg{T,N}) where {T,N}=
   first(leftlcmc(M,simp...))

function (M::LocallyGarsideMonoid{T})(l::Vararg{I,N})where {T,N,I<:Integer}
  if isempty(l) return GarsideElt(M,T[];check=false) end
  if l[1]>0 res=GarsideElt(M,[M.atoms[l[1]]];check=length(M.atoms)==1)
  else res=inv(M(-l[1]))
  end
  for s in l[2:end]
    res*= s>0 ? M.atoms[s] : M(s)
  end
  res
end

function (M::GarsideMonoid{T})(r::T)where T
  if r==M.Î´ GarsideElt(M,T[],1;check=false)
  elseif r==one(M) GarsideElt(M,T[];check=false)
  else GarsideElt(M,[r];check=false)
  end
end

function (M::LocallyGarsideMonoid{T})(r::T)where T
  if r==one(M) GarsideElt(M,T[];check=false)
  else GarsideElt(M,[r];check=false)
  end
end

"""
`word(M::GarsideMonoid,w)`

returns a word in the atoms of `M` representing the simple `w`

```julia-repl
julia> B=BraidMonoid(coxgroup(:A,3))
BraidMonoid(Aâ‚ƒ)

julia> word(B,B.Î´)
6-element Vector{Int64}:
 1
 2
 1
 3
 2
 1
```
"""
function PermGroups.word(M::LocallyGarsideMonoid,w)
  res=Int[]
  while true
    i=firstleftdescent(M,w)
    if i===nothing return res end
    push!(res,i)
    w=\(M,M.atoms[i],w)
  end
end

PermGroups.word(io::IO,M::LocallyGarsideMonoid,w)=joindigits(word(M,w);sep=" ")

"""
left_divisors(M::LocallyGarsideMonoid, s)

all  the left  divisors of  the simple  element `s`  of `M`, as a vector of
vectors  of simples, where the i+1-th  vector of simples holds the divisors
of length i in the atoms.

```julia-repl
julia> W=coxgroup(:A,3)
Aâ‚ƒ

julia> B=BraidMonoid(W)
BraidMonoid(Aâ‚ƒ)

julia> map(x->B.(x),left_divisors(B,W(1,3,2)))
4-element Vector{Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}}:
 [.]   
 [1, 3]
 [13]
 [132] 

julia> B=DualBraidMonoid(W)
DualBraidMonoid(Aâ‚ƒ,c=[1, 3, 2])

julia> map(x->B.(x),left_divisors(B,W(1,3,2)))
4-element Vector{Vector{GarsideElt{Perm{Int16}, DualBraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}}:
 [.]                     
 [1, 2, 3, 4, 5, 6]      
 [12, 13, 15, 25, 34, 45]
 [Î´]                     
```
"""
function left_divisors(M::LocallyGarsideMonoid,s)
  rest=[(left=one(M),right=s)]
  res=typeof(rest)[]
  while !isempty(rest)
    push!(res,rest)
    new=empty(rest)
    for x in rest, i in leftdescents(M,x.right)
      push!(new,(left=*(M,x.left,M.atoms[i]),right=\(M,M.atoms[i],x.right)))
    end
    rest=unique(new)
  end
  map(x->first.(x),res)
end

CoxGroups.leftdescents(M::LocallyGarsideMonoid,s)=
     filter(i->isleftdescent(M,s,i),eachindex(M.atoms))

"""
`rightascents(M,s)` where `s` is a simple return the right ascents of `s`,
that is the list of `i` such that `s*M.atoms[i]` is still simple.
"""
rightascents(M::LocallyGarsideMonoid,s)=
     filter(i->isrightascent(M,s,i),eachindex(M.atoms))

rightcomplÎ´(M::GarsideMonoid,x)=\(M,x,M.Î´)
leftcomplÎ´(M::GarsideMonoid,x)=/(M,M.Î´,x)
isrightascent(M::GarsideMonoid,x,i)=isleftdescent(M,rightcomplÎ´(M,x),i)

# w^(M.Î´^i)
function Î´ad(M::GarsideMonoid,x,i::Integer)
  if IntervalStyle(M)==Interval() #horrible: has to know interval exists
    i=mod(i,M.orderÎ´)
    return iszero(i) ? x : x^(M.Î´^i)
  end
  for j in i:-1:1 x=rightcomplÎ´(M,rightcomplÎ´(M,x)) end
  for j in i:-1   x=leftcomplÎ´(M,leftcomplÎ´(M,x)) end
  x
end

"""
`elements(M::LocallyGarsideMonoid,l::Integer)`
`elements(M::LocallyGarsideMonoid,v::AbstractVector{<:Integer})`
    
`M`  should have  an additive  length function  (that is,  a product of `l`
atoms  is not equal to any product of less than `l` atoms). `elements(M,l)`
returns the list of elements of length `l` in `M`.

In the second form `elements` returns all elements of length `i` for `iâˆˆ v`.

```julia-repl
julia> M=BraidMonoid(coxgroup(:A,2))
BraidMonoid(Aâ‚‚)

julia> elements(M,4)
12-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 12.21
 21.12
 1.1.1.1
 2.2.2.2
 1.1.12
 1.12.2
 12.2.2
 2.2.21
 21.1.1
 2.21.1
 Î”.1
 Î”.2
```
"""
function PermGroups.elements(M::LocallyGarsideMonoid,l::Integer)
  d=get!(M.prop,:elements)do
    Dict(0=>[M()],1=>M.(eachindex(M.atoms)))
  end
  get!(d,l)do
    res=empty(d[1])
    for b in elements(M,l-1)
      lb=length(b.elm)
      if iszero(lb) r=Int[]
      else
        r=rightascents(M,b.elm[lb])
        if lb==1 rr=Int[] else rr=rightascents(M,b.elm[lb-1]) end
        for s in r
          w=*(M,b.elm[lb],M.atoms[s])
          if !any(i->isleftdescent(M,w,i),rr)
            elm=copy(b.elm)
            elm[end]=w
            push!(res,clone(b,elm))
          end
        end
      end
      for i in setdiff(eachindex(M.atoms),r)
        push!(res,clone(b,vcat(b.elm,[M.atoms[i]])))
      end
    end
    collect(Set(res))
  end
end

PermGroups.elements(M::LocallyGarsideMonoid,l::AbstractVector{<:Integer})=
  vcat(elements.(Ref(M),l)...)

#--------------------Interval: a trait-----------------------------------
abstract type IntervalStyle end
struct Interval<:IntervalStyle end
struct NoInterval<:IntervalStyle end
IntervalStyle(M::LocallyGarsideMonoid)=NoInterval()

Base.one(M::LocallyGarsideMonoid)=one(IntervalStyle(M),M)
Base.one(::Interval,M)=one(M.W)
Base.:*(M::LocallyGarsideMonoid,x,y)=*(IntervalStyle(M),M,x,y)
Base.:*(::Interval,M,x,y)=x*y
Base.:\(M::LocallyGarsideMonoid,x,y)=\(IntervalStyle(M),M,x,y)
Base.:\(::Interval,M,x,y)=x\y
Base.:/(M::LocallyGarsideMonoid,x,y)=/(IntervalStyle(M),M,x,y)
Base.:/(::Interval,M,x,y)=x/y
Base.inv(M::LocallyGarsideMonoid,x)=inv(IntervalStyle(M),M,x)
Base.inv(::Interval,M,x)=inv(x)
isrightdescent(M::LocallyGarsideMonoid,w,i::Integer)=isrightdescent(IntervalStyle(M),M,w,i)
isrightdescent(::Interval,M,w,i)=isleftdescent(M,inv(w),i)
mul!(M::LocallyGarsideMonoid,x,y)=*(M,x,y)
Base.reverse(M::LocallyGarsideMonoid,x)=reverse(IntervalStyle(M),M,x)
Base.reverse(::Interval,M,x)=inv(x)

#-----------------------BraidMonoid-----------------------------------
@GapObj struct BraidMonoid{T,TW}<:GarsideMonoid{T}
  Î´::T
  orderÎ´::Int
  stringÎ´::String
  atoms::Vector{T}
  W::TW
end

IntervalStyle(M::BraidMonoid)=Interval()
"""
`BraidMonoid(W::CoxeterGroup)`

The ordinary monoid of the Artin group associated to `W`
"""
BraidMonoid(W::FiniteCoxeterGroup)=BraidMonoid(longest(W),2,"\\Delta",
                                               gens(W),W,Dict{Symbol,Any}())

Base.show(io::IO, M::BraidMonoid)=print(io,"BraidMonoid(",M.W,")")

"""
`isleftdescent(M,w,i)`

returns `true` if and only if the `i`-th atom of the locally Garside monoid
`M` left-divides the simple `w`.
"""
CoxGroups.isleftdescent(M::BraidMonoid,w,i::Int)=isleftdescent(M.W,w,i)
CoxGroups.firstleftdescent(M::BraidMonoid,w)=firstleftdescent(M.W,w)

PermGroups.word(M::BraidMonoid,w)=word(M.W,w)

function rightgcdc(M::BraidMonoid{T},simp::Vararg{T,N})where{T,N}
  g,c=leftgcdc(M,inv.(simp)...)
  inv(g),inv.(c)
end

rightgcd(M::BraidMonoid{T},simp::Vararg{T,N}) where{T,N}=
  inv(leftgcd(M,inv.(simp)...))

mul!(M::BraidMonoid{<:Perm},x,y)=Perms.mul!(x,y)
#-----------------------GenArtinMonoid-----------------------------------
# braid monoid for e.g. infinite Coxeter groups
@GapObj struct GenArtinMonoid{T,TW}<:LocallyGarsideMonoid{T}
  atoms::Vector{T}
  W::TW
end

# The repetitions below reflect the poor type system of Julia
IntervalStyle(M::GenArtinMonoid)=Interval()
BraidMonoid(W::CoxeterGroup)=GenArtinMonoid(gens(W),W,Dict{Symbol,Any}())

Base.show(io::IO, M::GenArtinMonoid)=print(io,"BraidMonoid(",M.W,")")

CoxGroups.isleftdescent(M::GenArtinMonoid,w,i::Int)=isleftdescent(M.W,w,i)
CoxGroups.firstleftdescent(M::GenArtinMonoid,w)=firstleftdescent(M.W,w)

isrightdescent(M::GenArtinMonoid,w,i::Int)=isleftdescent(M.W,inv(w),i)
isrightascent(M::GenArtinMonoid,w,i::Int)=!isleftdescent(M.W,inv(w),i)

PermGroups.word(M::GenArtinMonoid,w)=word(M.W,w)

function rightgcdc(M::GenArtinMonoid{T},simp::Vararg{T,N})where {T,N}
  g,c=leftgcdc(M,inv.(simp)...)
  inv(g),inv.(c)
end

rightgcd(M::GenArtinMonoid{T},simp::Vararg{T,N}) where {T,N}=
  inv(leftgcd(M,inv.(simp)...))

#---------------------------------------------------------------------
abstract type LocallyGarsideElt{T,TM<:LocallyGarsideMonoid} end

struct GarsideElt{T,TM}<:LocallyGarsideElt{T,TM}
  M::TM
  elm::Vector{T}
  pd::Int
  # assume elm is a normal form perhaps not reduced if check=true
  function GarsideElt(M::TM,elm::AbstractVector{T},pd=0;check=true) where {T,TM<:GarsideMonoid}
    if !check return new{T,TM}(M,elm,pd) end
    i=1; while i<=length(elm) && elm[i]==M.Î´ i+=1;pd+=1 end
    j=length(elm); while j>0 && elm[j]==one(M) j-=1 end
    if i>1 || j<length(elm) new{T,TM}(M,view(elm,i:j),pd)
    else new{T,TM}(M,elm,pd)
    end
  end
end

struct GenGarsideElt{T,TM}<:LocallyGarsideElt{T,TM}
  M::TM
  elm::Vector{T}
end

function GarsideElt(M::LocallyGarsideMonoid,elm::AbstractVector;check=true)
  if check
    j=length(elm)
@inbounds while j>0 && elm[j]==one(M)
      j-=1
    end
    resize!(elm,j)
  end
  GenGarsideElt(M,elm)
end

clone(b::GenGarsideElt,elm;check=true)=GarsideElt(b.M,elm;check)
clone(b::GarsideElt{T,TM},elm::AbstractVector{T},pd=b.pd;check=true) where{T,TM}=
   GarsideElt(b.M,elm,pd;check)
Base.one(b::LocallyGarsideElt)=clone(b,empty(b.elm),0;check=false)
Base.isone(b::GarsideElt)=isempty(b.elm) && iszero(b.pd)
Base.copy(b::GarsideElt)=clone(b,copy(b.elm);check=false)

function Base.cmp(a::GarsideElt,b::GarsideElt)
  c=cmp(a.pd,b.pd)
  if c!=0 return c end
  cmp(a.elm,b.elm)
end

Base.isless(a::GarsideElt,b::GarsideElt)=cmp(a,b)==-1
Base.:(==)(a::GarsideElt,b::GarsideElt)=a.pd==b.pd && a.elm==b.elm

# hash is needed for using GarsideElt in Sets/Dicts
function Base.hash(a::GarsideElt, h::UInt)
  h=hash(a.pd, h)
  for e in a.elm
    h=hash(e, h)
  end
  h
end

"""
`leftdescents(b::LocallyGarsideElt)` the list of indices of the atoms
which left-divide `b`
"""
CoxGroups.leftdescents(b::LocallyGarsideElt)=filter(i->isleftdescent(b.M,b[1],
                                   i),eachindex(b.M.atoms))

# left divisors of b whose leftdescents don't intersect avoid
function left_divisors(b::LocallyGarsideElt,avoid)
  M=b.M
  if isone(b) return [b] end
  s=vcat(left_divisors(M,b[1])[2:end]...)
  if !isempty(avoid) 
    s=filter(x->isempty(intersect(leftdescents(M,x),avoid)),s)
  end
  res=[M()]
  for x in s
    append!(res,x.*left_divisors(\(M,x,b[1])*tail(b),rightascents(M,x)))
#   append!(res,Ref(M(x)).*left_divisors(M(x)^-1*b,rightascents(M,x)))
  end
  res
end

function left_divisors(b::LocallyGarsideElt,avoid,i)
  M=b.M
  if iszero(i) return [M()] end
  s=left_divisors(M,b[1])
  res=typeof(b)[]
  for j in 1:min(length(s)-1,i)
    sj=filter(x->isempty(intersect(leftdescents(M,x),avoid)),s[j+1])
    for x in sj
      append!(res,x.*left_divisors(\(M,x,b[1])*tail(b),rightascents(M,x),i-j))
    end
  end
  res
end

"""
`left_divisors(b::LocallyGarsideElt[, i])`

returns all left divisors of `b` (divisors of length `i` if specified)

```julia-repl
julia> B=DualBraidMonoid(CoxSym(4))
DualBraidMonoid(ð”– â‚„,c=[1, 3, 2])

julia> left_divisors(B(1,5,4,3))
10-element Vector{GarsideElt{Perm{Int16}, DualBraidMonoid{Perm{Int16}, CoxSym{Int16}}}}:
 .
 1
 1.4
 1.4.2
 1.4.3
 5
 6
 15
 15.4
 15.4.3

julia> left_divisors(B(1,5,4,3),1)
3-element Vector{GarsideElt{Perm{Int16}, DualBraidMonoid{Perm{Int16}, CoxSym{Int16}}}}:
 1
 5
 6
```
"""
left_divisors(b::LocallyGarsideElt)=left_divisors(b,Int[])
left_divisors(b::LocallyGarsideElt,i::Integer)=left_divisors(b,Int[],i)

#RightDivisors:=b->List(LeftDivisors(b.monoid.Reverse(b)),b.monoid.Reverse);

"""
`Brieskorn_normal_form(b::LocallyGarsideElt)`

Brieskorn  citeBri71 has noticed that if `L(b)`  is the left descent set of
`b`  (see [`leftdescents`](@ref)),  and if  `b_(L(b))` is  the right lcm of
`L(b)`,  then  `b_(L(b))`  left-divides  `b`.  We  can  now  divide  `b` by
`b_(L(b))`  and continue  this process  with the  quotient. In this way, we
obtain  an expression  `b=b_(Lâ‚)â‹¯ b_(Láµ£)`  where `Láµ¢=L(b_(Láµ¢)â‹¯ b_(Láµ£))` for
all  `i`, which we  call the *Brieskorn  normal form* of  `b`. The function
`Brieskorn_normal_form`  returns a  description of  this form, by returning
the   list  of  sets   `L(b)`  which  describe   the  above  decomposition.
```julia-repl
julia> W=coxgroup(:E,8);B=BraidMonoid(W)
BraidMonoid(Eâ‚ˆ)

julia> w=B(2,3,4,2,3,4,5,4,2,3,4,5,6,5,4,2,3,4,5,6,7,6,5,4,2,3,4,5,6,7,8)
2342345423456542345676542345678

julia> Brieskorn_normal_form(w)
2-element Vector{Vector{Int64}}:
 [2, 3, 4, 5, 6, 7]
 [8]

julia> Brieskorn_normal_form(w^2)
2-element Vector{Vector{Int64}}:
 [2, 3, 4, 5, 6, 7, 8]
 [2, 3, 4, 5, 6]
```
"""
function Brieskorn_normal_form(b::LocallyGarsideElt)
  res=Vector{Int}[]
  while !isone(b)
    I=leftdescents(b)
    push!(res,I)
    b=b.M(rightlcm(b.M,b.M.atoms[I]...))\b
  end
  res
end

function Base.inv(b::GarsideElt)
  k=length(b.elm)
  M=b.M
  GarsideElt(M,map(i->Î´ad(M,\(M,b.elm[i],M.Î´),-i-b.pd),k:-1:1),-b.pd-k;check=false)
end

Base.:/(a::GarsideElt,b::GarsideElt)=a*inv(b)
Base.:\(a::GarsideElt,b::GarsideElt)=inv(a)*b

function Base.denominator(b::GarsideElt)
  if b.pd>=0 return one(b) end
  ib=inv(b)
  if b.pd<-length(b.elm) ib
  else GarsideElt(b.M,@view ib.elm[end+b.pd+1:end];check=false)
  end
end

function Base.numerator(b::GarsideElt)
  if b.pd>=0 return b 
  elseif b.pd<-length(b.elm) return one(b)
  else GarsideElt(b.M,b.elm[1-b.pd:end];check=false)
  end
end

"""
  - `fraction(b::GarsideElt)`
  - `denominator(b::GarsideElt)`
  - `numerator(b::GarsideElt)`

`fraction(b)`  returns a  tuple `(x,y)`  of positive  Garside elements with
trivial  `leftgcd`  and  such  that  `b=x\\y`.  For  such  a decomposition,
`denominator(b)` returns `x` and `numerator(b)` returns `y`.
```julia-repl
julia> B=BraidMonoid(coxgroup(:A,3))
BraidMonoid(Aâ‚ƒ)

julia> b=B( 2, 1, -3, 1, 1)
(23)â»Â¹321.1.1

julia> fraction(b)
(23, 321.1.1)
```
"""
fraction(b::GarsideElt)=(denominator(b),numerator(b))

function Base.getindex(x::GarsideElt{T},i::Integer)::T where T
  if i<=x.pd return x.pd==0 ? one(x.M) : x.M.Î´
  elseif i>x.pd+length(x.elm) return one(x.M)
  else return x.elm[i-x.pd]
  end
end

Base.getindex(x::GarsideElt{T},i::AbstractVector{<:Integer}) where T=
  map(j->x[j]::T,i)

Base.lastindex(x::GarsideElt)=x.pd+length(x.elm)

function Base.getindex(x::LocallyGarsideElt,i::Integer)
  if i>length(x.elm) return one(x.M)
  else return x.elm[i]
  end
end

"""
`Î±(b::LocallyGarsideElt)`

returns as a Garside element  the first term in  the normal form of  `b`
(`b[1]` returns this term as a simple).

```julia-repl
julia> W=coxgroup(:A,3)
Aâ‚ƒ

julia> b=BraidMonoid(W)(2,1,2,1,1)
121.1.1

julia> Î±(b)
121
```
"""
Î±(b::LocallyGarsideElt)=GarsideElt(b.M,[b[1]])

"""
`Î±(b::LocallyGarsideElt,I)` 

returns the longest prefix of b using only `b.M.atoms[I]`
```julia-repl
julia> W=coxgroup(:A,4);B=BraidMonoid(W)
BraidMonoid(Aâ‚„)

julia> w0=B(longest(W))
Î”

julia> Î±(w0,[1,2,3])
121321
```
"""
function Î±(b::LocallyGarsideElt,I::AbstractVector)
  M=b.M
  res=M()
  i=1
  while i<=length(I)
    if isleftdescent(M,b[1],I[i])
      s=M(I[i])
      res*=s
      b=s\b
      i=1
    else i+=1
    end
  end
  res
end
  
function tail(b::GarsideElt)
  if isone(b) return b end
  if b.pd>0 return clone(b,b.elm,b.pd-1) end
  clone(b,b[2:end])
end

"""
`word(b::GarsideElt)`

returns  a description  of `b`  as a  list of  the atoms  of which  it is a
product.  If `b` is in the Garside group  but not the Garside monoid, it is
represented  in  fraction  normal  form  where  as a special convention the
inverses  of  the  atoms  are  represented  by  negating  the corresponding
integer.

```julia-repl
julia> B=BraidMonoid(coxgroup(:A,3))
BraidMonoid(Aâ‚ƒ)

julia> b=B(2,1,2,1,1)*inv(B(2,2))
(21)â»Â¹1.12.21

julia> word(b)
7-element Vector{Int64}:
 -1
 -2
  1
  1
  2
  2
  1
```
"""
function PermGroups.word(b::GarsideElt)
  M=b.M
  res=Int[]
  if b.pd<0 
    d,n=fraction(b)
    return vcat(-reverse(word(d)),word(n))
  end
  for i in 1:b.pd append!(res,word(M,M.Î´)) end
  for e in b.elm append!(res,word(M,e)) end
  res
end

PermGroups.word(b::LocallyGarsideElt)=vcat(word.(Ref(b.M),b.elm)...)

function Base.show(io::IO,b::GarsideElt)
  if !hasdecor(io)
    print(io,"B(",join(word(b),","),")")
    return
  end
  function p(b)
    l=map(e->word(io,b.M,e),b.elm)
    if b.pd!=0 pushfirst!(l,fromTeX(io,b.M.stringÎ´)*stringexp(io,b.pd)) end
    join(l,".")
  end
  if isone(b) print(io,".") 
  elseif get(io,:greedy,false) print(io,p(b))
  else den,num=fraction(b)
    if !isone(den) print(io,"(",p(den),")",stringexp(io,-1)) end
    print(io,p(num))
  end
end

function Base.show(io::IO,b::LocallyGarsideElt)
  if !hasdecor(io)
    print(io,"B(",join(word(b),","),")")
    return
  end
  printTeX(io,isempty(b.elm) ? "." : join(map(e->word(io,b.M,e),b.elm),"."))
end

# simple * braid
function Base.:*(x,b::LocallyGarsideElt)
  M=b.M
  v=b.elm
  res=empty(v)
  for i in 1:length(v)
    a,x=Î±2(M,x,v[i])
    push!(res,a)
    if x==v[i] return GarsideElt(M,append!(res,v[i:end]))
    elseif isone(x) return GarsideElt(M,append!(res,v[i+1:end]))
    end
  end
  GarsideElt(M,push!(res,x))
end

# multiply a simple x by a Garside element b; Gap3 PrefixToNormal
function Base.:*(x,b::GarsideElt)
  M=b.M
  v=b.elm
  res=empty(v)
  pd=0
  x=Î´ad(M,x,b.pd)
  for i in 1:length(v)
    a,x=Î±2(M,x,v[i])
    if a==M.Î´ pd+=1 else push!(res,a) end
    if x==v[i] return GarsideElt(M,append!(res,v[i:end]),pd+b.pd;check=false)
    elseif isone(x) return GarsideElt(M,append!(res,v[i+1:end]),pd+b.pd;check=false)
    end
  end
  GarsideElt(M,push!(res,x),pd+b.pd)
end

# multiply by simple; Gap3 AddToNormal
function Base.:*(a::LocallyGarsideElt,x)
  M=a.M
  if x==one(M) return a end # see if can suppress this special case
  v=copy(a.elm)
  push!(v,x)
  for i in length(v):-1:2
    x,y=Î±2(M,v[i-1],v[i])
    if y==one(M) # this implies i==length(v)
      resize!(v,i-1) 
      v[i-1]=x 
    elseif x==v[i-1] break
    else  v[i-1]=x;v[i]=y
    end
  end
  GarsideElt(M,v)
end

function Base.:*(a::GarsideElt,x)
  M=a.M
  if x==one(M) return a end # see if can suppress this special case
  v=copy(a.elm)
  push!(v,x)
  for i in length(v):-1:2
    x,y=Î±2(M,v[i-1],v[i])
    if y==one(M) # this implies i==length(v)
      if x==M.Î´
        return GarsideElt(M,Î´ad.(Ref(M),v[1:end-2],1),1+a.pd;check=false)
      end
      resize!(v,i-1) 
      v[i-1]=x 
    elseif x==v[i-1] break
    elseif x==M.Î´
      v[i]=y
      v[2:i-1]=Î´ad.(Ref(M),v[1:i-2],1)
      return GarsideElt(M,v[2:end],1+a.pd;check=false)
    else v[i-1]=x;v[i]=y
    end
  end
  clone(a,v;check=length(v)==1)
end

function Base.:*(a::LocallyGarsideElt,b::LocallyGarsideElt)
  res=a
  for x in b.elm 
    res*=x 
  end
  res
end

function Base.:*(a::GarsideElt,b::GarsideElt)
  res=GarsideElt(a.M,Î´ad.(Ref(a.M),a.elm,b.pd),a.pd+b.pd;check=false)
  for x in b.elm 
    res*=x 
  end
  res
end

# conjugation of b by simple r such that (b^r).pd>=b.pd
# About 2 times faster than (b,r)->b^b.M(r) for long words
#function Base.:^(b::GarsideElt{T},r::T) where T
#  M=b.M 
#  if r==one(M) return b end
#  l=*(M,b,r)
#  \(M,Î´ad(M,r,b.pd),l.elm[1])*clone(b,l.elm[2:end])
#end

#Base.:^(y::GarsideElt{T},r::T,F=x->x) where T<:Perm=y.M(r)\(y*F(r))
Base.:^(y::GarsideElt{T},r::T,F::Function) where T=y.M(r)\(y*F(r))

Base.:^(a::LocallyGarsideElt, n::Integer)=n>=0 ? Base.power_by_squaring(a,n) :
                                             Base.power_by_squaring(inv(a),-n)

Base.:^(a::GarsideElt,b::GarsideElt,F=x->x)=b\a*F(b)

function Base.reverse(b::GarsideElt)
  if haskey(b.M,:revMonoid)
    res=GarsideElt(b.M.revMonoid,empty(b.elm),b.pd;check=false)
    if isempty(b.elm) return res end
    for s in reverse(b.elm)
      res*=Î´ad(b.M.revMonoid,s^-1,b.pd)
    end
  else
    if isempty(b.elm) return b end
    res=GarsideElt(b.M,empty(b.elm),b.pd;check=false)
    for s in reverse(b.elm)
      res*=Î´ad(b.M,reverse(b.M,s),-b.pd)
    end
  end
  res
end

function Base.reverse(b::LocallyGarsideElt)
  if isempty(b.elm) return b end
  res=GarsideElt(b.M,empty(b.elm);check=false)
  for s in reverse(b.elm)
    res*=reverse(b.M,s)
  end
  res
end

function leftgcdc(elts::Vararg{LocallyGarsideElt,N})where {N}
  if isempty(elts) error("leftgcd needs an argument") end
  if length(elts)==1  
    elt=only(elts)
    return (elt,(one(elt),))
  end
  M=elts[1].M
  if hasfield(typeof(M),:Î´)
    m=minimum(map(x->x.pd,elts))
    gcd=clone(elts[1],empty(elts[1].elm),m;check=false)
    elts=map(x->clone(x,x.elm,x.pd-m;check=false),elts)
  else
    gcd=one(elts[1])
    elts=copy.(elts)
  end
  while true
    ff=map(x->x[1],elts)
    if any(isone,ff) g=one(M)
    else g,rest=leftgcdc(M,ff...)
    end
    if isone(g) return (gcd,elts)
    else gcd*=g
      elts=map((r,e)->r*GarsideElt(M,e.elm[2:end];check=false),rest,elts)
    end
  end
end

"""
`leftgcd(aâ‚,â€¦,aâ‚™)` 
`leftgcdc(aâ‚,â€¦,aâ‚™)` 

`aâ‚,â€¦,aâ‚™`  should be  elements of  the same  (locally) Garside  monoid. The
function returns the left gcd `d` of `aâ‚,â€¦,aâ‚™`. 

`leftgcdc` returns `(d,(dâ»Â¹aâ‚,â€¦,dâ»Â¹aâ‚™))`.

```julia-repl
julia> W=coxgroup(:A,3)
Aâ‚ƒ

julia> B=BraidMonoid(W)
BraidMonoid(Aâ‚ƒ)

julia> leftgcdc(B(2,1,2)^2,B(3,2)^2)
(2, (121.21, 32.2))
```
"""
leftgcd(elts::Vararg{LocallyGarsideElt,N}) where N=first(leftgcd(elts...))

function rightgcdc(elts::Vararg{LocallyGarsideElt,N})where N
  g,c=leftgcdc(map(reverse,elts)...)
  reverse(g),map(reverse,c)
end

"""
`rightgcd(aâ‚,â€¦,aâ‚™)` 
`rightgcdc(aâ‚,â€¦,aâ‚™)` 

`aâ‚,â€¦,aâ‚™`  should be  elements of  the same  (locally) Garside  monoid. The
function returns the right gcd `d` of `aâ‚,â€¦,aâ‚™`

`rightgcdc` returns `(d,(aâ‚/d,â€¦,aâ‚™/d))`.

```julia-repl
julia> W=coxgroup(:A,3)
Aâ‚ƒ

julia> B=BraidMonoid(W)
BraidMonoid(Aâ‚ƒ)

julia> rightgcdc(B(2,1,2)^2,B(3,2)^2)
(2.2, (12.21, 23))
```
"""
rightgcd(elts::Vararg{LocallyGarsideElt,N}) where N=
  reverse(leftgcd(map(reverse,elts)...))

function leftlcmc(elts::Vararg{GarsideElt,N})where N
  if isempty(elts) error("leftlcm needs an argument") end
  if length(elts)==1  
    elt=only(elts)
    return (elt,(one(elt),))
  end
  x,c=leftgcdc(inv.(elts)...)
  (inv(x),c)
end

"""
`leftlcm(aâ‚,â€¦,aâ‚™)`
`leftlcmc(aâ‚,â€¦,aâ‚™)`
    
`aâ‚,â€¦,aâ‚™`  should  be  elements  of  the  same Garside monoid. The function
returns  the least common left multiple  `m` of `aâ‚,â€¦,aâ‚™`.

`leftlcmc` returns '(m,(m/aâ‚,â€¦,m/aâ‚™))`.

```julia-repl
julia> B=BraidMonoid(coxgroup(:A,3))
BraidMonoid(Aâ‚ƒ)

julia> leftlcmc(B(2,1,2)^2,B(3,2)^2)
(Î”.121, (123, 23.321))
```
"""
leftlcm(elts::Vararg{GarsideElt,N}) where N=first(leftlcmc(elts...))

function rightlcmc(elts::Vararg{GarsideElt,N}) where N
  g,c=leftlcmc(map(reverse,elts)...)
  reverse(g),map(reverse,c)
end

"""
`rightlcm(aâ‚,â€¦,aâ‚™)`
`rightlcmc(aâ‚,â€¦,aâ‚™)`
    
`aâ‚,â€¦,aâ‚™`  should  be  elements  of  the  same Garside monoid. The function
returns  the least common right multiple  `m` of `aâ‚,â€¦,aâ‚™`.

`rightlcmc` returns '(m,(aâ‚â»Â¹*m,â€¦,aâ‚™â»Â¹*m))`.

```julia-repl
julia> B=BraidMonoid(coxgroup(:A,3))
BraidMonoid(Aâ‚ƒ)

julia> rightlcmc(B(2,1,2)^2,B(3,2)^2)
(Î”Â², (321.123, 12321.321))
```
"""
rightlcm(elts::Vararg{GarsideElt,N}) where N=reverse(leftlcm(map(reverse,elts)...))

function Cosets.Frobenius(x::GarsideElt,phi)
  y=deepcopy(x)
  y.elm.=Frobenius.(y.elm,phi)
  y
end

"""
`image(b::GarsideElt)`
    
This  function is defined only if `b`  is an element of an interval monoid,
for instance a braid. It returns the image of `b` in the group of which the
monoid  is an interval  monoid. For instance  it gives the  projection of a
braid in an Artin monoid back to the Coxeter group.

```julia-repl
julia> W=CoxSym(4)
ð”– â‚„

julia> b=BraidMonoid(W)(2,1,2,1,1)
121.1.1

julia> p=image(b)
(1,3)

julia> word(W,p)
3-element Vector{Int64}:
 1
 2
 1
```
"""
function image(a::GarsideElt)
  if IntervalStyle(a.M)==Interval() a.M.Î´^a.pd*prod(a.elm)
  else error(a," should be an element of an interval monoid")
  end
end
#-----------------------DualBraidMonoid-------------------------------
@GapObj struct DualBraidMonoid{T,TW}<:GarsideMonoid{T}
  Î´::T
  orderÎ´::Int
  stringÎ´::String
  Î´word::Vector{Int}
  atoms::Vector{T}
  W::TW
end

IntervalStyle(M::DualBraidMonoid)=Interval()

"""
`DualBraidMonoid(W;c=...)`

`W`  should be a well generated complex  reflection group and `c` a Coxeter
element of `W`, which should be a `Vector{Int}` specifying `W(c...)`. If no
`c`  is given a particular  one is chosen for  Coxeter groups by making the
product of elements in a partition of the Coxeter diagram in two sets where
in  each set elements commute pairwise;  for a complex reflection group the
representative stored in the Coxeter class is used.

The function returns the dual braid monoid determined by `W` and `c`

```julia-repl
julia> W=coxgroup(:A,3)
Aâ‚ƒ

julia> B=DualBraidMonoid(W)
DualBraidMonoid(Aâ‚ƒ,c=[1, 3, 2])

julia> B(2,1,2,1,1)
12.1.1.1

julia> B(-1,-2,-3,1,1)
(25.1)â»Â¹1.1
```
"""
function DualBraidMonoid(W::CoxeterGroup;
  c=reduce(vcat,bipartite_decomposition(W)),revMonoid=nothing)
  Î´=W(c...)
  M=DualBraidMonoid(Î´,order(Î´),"Î´",c,refls(W,1:nref(W)),W,Dict{Symbol,Any}())
  if revMonoid===nothing 
    M.revMonoid=DualBraidMonoid(W;c=reverse(c),revMonoid=M)
  else M.revMonoid=revMonoid
  end
  M
end

function DualBraidMonoid(W::PermRootGroup;
  c=word(conjugacy_classes(W)[position_regular_class(W,maximum(degrees(W)))]),
  revMonoid=nothing)
  if ngens(W)>semisimplerank(W) || length(refltype(W))>1
    error(W,"must me well-generated and irreducible")
  end
  Î´=W(c...)
  n=reflength(W,Î´)
  atoms=filter(r->reflength(W,Î´/r)<n,unique(refls(W)))
  M=DualBraidMonoid(Î´,order(Î´),"Î´",c,atoms,W,Dict{Symbol,Any}())
  if revMonoid===nothing
    if all(w->isone(w^2),gens(W))
       M.revMonoid=DualBraidMonoid(W;c=reverse(c),revMonoid=M)
    end
  else M.revMonoid=revMonoid
  end
  M
end

function CoxGroups.isleftdescent(M::DualBraidMonoid,w,i::Int)
  reflength(M.W,M.atoms[i]\w)<reflength(M.W,w)
end

Base.show(io::IO, M::DualBraidMonoid)=print(io,"DualBraidMonoid(",M.W,",c=",
                                            M.Î´word,")")

function atomsinbraidmonoid(M::DualBraidMonoid) # for coxeter groups
  get!(M,:atomsinbraidmonoid)do
    W=M.W
    h=order(M.Î´)
    Î´=word(W,M.Î´)
    w=repeat(Î´,outer=div(h,2))
    if isodd(h) append!(w,Î´[1:div(length(Î´),2)]) end
    if length(W,W(w...))!=length(w) w=repeat(Î´,outer=h) end
    w=map(i->vcat(w[1:i],-w[i-1:-1:1]),eachindex(w))
    B=BraidMonoid(W)
    w=unique!(map(x->B(x...),w))
    sort(w,by=x->findfirst(==(image(x)),refls(W,1:nref(W))))
  end
end

"""
`(B::BraidMonoid)(M::DualBraidMonoid,i::Integer)`

convert to an element of `B` the `i`-th atom of `M`.
"""
(B::BraidMonoid)(M::DualBraidMonoid,i::Integer)=atomsinbraidmonoid(M)[i]
"""
`(B::BraidMonoid)(M::DualBraidMonoid,s)`

convert to an element of `B` the simple `s` of `M`.
"""
(B::BraidMonoid)(M::DualBraidMonoid,s)=prod(B.(Ref(M),word(M,s)))
"""
`(B::BraidMonoid)(b::GarsideElt)`

`b` should be a dual braid. Convert `b` to an element of `B`.
"""
function (B::BraidMonoid)(b::GarsideElt{T,<:DualBraidMonoid})where T 
  B(b.M,b.M.Î´)^b.pd*prod(x->B(b.M,x),b.elm;init=B())
end

#----------------------------------------------------------------------------
struct Category{TO,TM} # TO type of objs TM type of maps
  obj::Vector{TO}
  atoms::Vector{Vector{Pair{TM,Int}}}
  # atoms[i] is a list of (m=>j): map m from obj[i] to obj[j]
end

function Base.show(io::IO,C::Category)
  print(io,"category with ",length(C.obj)," objects and ",
        sum(length,C.atoms)," generating maps")
  if get(io,:graph,false) println(io);showgraph(io,C) end
end

# constructs a category from an initial object o and a function
# atomsfrom which given object o returns atoms from o as "maps" m such
# that the target object is action(o,m)
function Category(atomsfrom::Function,o;action::Function=^)
  TM=eltype(atomsfrom(o))
  C=Category([o],[Pair{TM,Int}[]])
  i=1
  while i<=length(C.obj) 
    b=C.obj[i]
    for m in atomsfrom(b)
      target=action(b,m)
      p=findfirst(==(target),C.obj)
  #	Print(b,"^",m.map,"->",m.tgt,"\n");
      if p===nothing
         push!(C.obj,target)
         push!(C.atoms,empty(C.atoms[1]))
         p=length(C.obj)
      end
      push!(C.atoms[i],m=>p)
    end
    i+=1
    if iszero(i%100) print(".") end
  end
  C
end

function showgraph(io,C::Category)
  maps=vcat(map(i->map(((m,t),)->[i,m,t],sort(C.atoms[i],by=x->abs(x[2]-i))),
                 eachindex(C.obj))...)
  found=true
  while found
    found=false
    new=empty(maps)
    for m in maps
      p=findfirst(x->x[end]==m[1],new)
      if p===nothing
        p=findfirst(x->x[1]==m[end],new)
        if p===nothing
          push!(new,m)
        else 
          new[p]=vcat(m[1:end-1],new[p])
          found=true
        end
      else new[p]=vcat(new[p],m[2:end])
           found=true
      end
    end
    maps=new
  end
  showobj=get(io,:showobj,show)
  showmap=get(io,:showobj,show)
  for f in maps
    l1=l2=""
    for i in 1:2:length(f)-2
      a=sprint(showobj,C.obj[f[i]];context=io)
      ff=sprint(showmap,f[i+1];context=io)
      l=max(2,textwidth(ff))
      if textwidth(l1)+textwidth(a)+l+1>displaysize(io)[2]
        println(io,l1,"\n",l2)
        l1=l2=""
      end
      l2*=a*'\u2500'^(l-1)*"â†’ "
      l1*=' '^textwidth(a)*lpad(ff,l)*' '
    end
    println(io,l1,"\n",l2,C.obj[f[end]])
  end
end

"""
`endomorphisms(C::Category,o)`
returns generators of the endomorphisms of `C.obj[o]`
"""
function endomorphisms(C::Category{TO,TM},o)where {TO,TM}
  paths=[Tuple{Int,Int}[] for i in eachindex(C.obj)]
  paths[o]=Tuple{Int,Int}[]
  if isempty(C.atoms[o]) return TM[] end
  maps=[one(C.atoms[o][1][1]) for i in eachindex(C.obj)]
  function foo()
    reached=[o]
    for i in reached t=C.atoms[i]
      for (j,(m,o1)) in pairs(t)
        if !(o1 in reached)
          paths[o1]=vcat(paths[i],[(i,j)])
          if i!=o maps[o1]=maps[i]*m
          else maps[o1]=m
          end
          push!(reached,o1)
          if length(reached)==length(C.obj) return end
        end
      end
    end
  end
  foo()
  # here paths[p] describes a path to get from obj o to  obj p
  gens=Set(empty(maps))
  for i in eachindex(C.obj)
    t=C.atoms[i]
    for j in eachindex(t)
      if vcat(paths[i],[(i,j)])!=paths[t[j][2]]
        if i==o nmap=t[j][1]
        else nmap=maps[i]*t[j][1]
        end
        if t[j][2]==o push!(gens,nmap)
        elseif nmap!=maps[t[j][2]] push!(gens,nmap*inv(maps[t[j][2]]))
        end
      end
    end
  end
  gens
end

# return one map in C from o to o1 or nothing if none exists
function from(C::Category{TO,TM},o,o1)where {TO,TM}
  if isempty(C.atoms[o]) m=one(TM)
  else m=one(first(C.atoms[o][1]))
  end
  reached=[m=>o]
  if o==o1 return first(reached[1]) end
  j=1
  while true
    mi,i=reached[j]
    for (m,t) in C.atoms[i]
      if !any(x->t==last(x),reached)
        push!(reached,mi*m=>t)
        if t==o1 return first(reached[end]) end
      end
    end
    j+=1
    if j>length(reached) break end
  end
end

# returns atoms from a in F-twisted s-conjugacy category
function AtomicMaps(a,s::Symbol=:sc,F=(x,y=1)->x)
  M=a.M
  res=typeof(a)[]
  for i in eachindex(M.atoms)
    m=minc(a,M.atoms[i],Val(s),F)
    if m!==nothing && !any(k->isleftdescent(M,m,k),i+1:length(M.atoms))
      push!(res,M(m))
    end
  end
  filter(x->count(y->(y\x).pd>=0,res)==1,res)
end

# a braid x atom
function minc(a,x,::Val{:cyc},F=(x,y=1)->x)
  if a.pd>0 return x end
  if isempty(a.elm) return nothing end
  M=a.M
  if !isleftdescent(M,a.elm[1],findfirst(==(x),M.atoms)) return nothing end
  x
end

function preferred_prefix(b,F=(x,y=1)->x)
  M=b.M
  if isempty(b.elm) return one(M) end
  o=b.elm[end]
  F(\(M,o,Î±2(M,o,F(Î´ad(M,b.elm[1],-b.pd)))[1]),-1)
end

# Inf(a,x)  minimal m such that xâ‰¼ m and inf(a^m)>=inf(a). 
# m is simple; see algorithm 2 in Franco-Gonzales 1.
function minc(a,x,::Val{:inf},F=(x,y=1)->x)
  M=a.M
  m=x
  while true
    x=Î´ad(M,m,a.pd)
    for s in a.elm x=rightlcmc(M,x,s)[2][2] end
    m,c=rightlcmc(M,x,F(m))
    m=F(m,-1)
    if c[2]==one(M) break end
  end
  m
end

# SS(a,x)  Assumes a in SSS(a). Returns minimal m such that x<m and
# a^m is in SSS(a). m is simple. See algorithm 5 in Franco-Gonzales 1
function minc(a,x,::Val{:ss},F=(x,y=1)->x)
  ai=inv(a)
  while true
    m=x
    x=minc(a,x,Val(:inf),F)
    x=F(minc(ai,F(x),Val(:inf),(x,y=1)->F(x,-y)),-1)
    if x==m return m end
  end
end

# representativeSC(b) returns
# (conj=minimal r such that b^r in sliding circuit, 
#  circuit=sliding circuit)
function representativeSC(b,F=(x,y=1)->x)
  seen=typeof(b)[]
  l=[[b,b^0]]
  while !(b in seen)
    push!(seen,b)
    e=b.M(preferred_prefix(b,F))
    b=^(b,e,F)
    push!(l,[b,l[end][2]*e])
  end
  t=findfirst(x->x[1]==b,l)
  (conj=l[t][2],circuit=first.(l[t:end-1]))
end

# minc(a::GarsideElt,x::simple,:sc) 
# minimal simple m such that x<m and a^m is in SC(a).
function minc(a,x,::Val{:sc},F=(x,y=1)->x)
  M=a.M
# Gebhart-Gonzalez function F for a in SC such that a^x in SSS
  function ggF(a,x,F)
    f=empty([(a,x)])
    y=a
    while true # find the history under sliding of (a,x)
      push!(f,(y,x))
      r=preferred_prefix(y,F)
  #   x=\(M,r,*(M,x,preferred_prefix(^(y,x,F),F))) # why simples?
      x=(M(r)\M(x)*M(preferred_prefix(^(y,x,F),F)))[1]
      if x==one(M) return [one(M)] end
      y=^(y,r,F)
      p=findfirst(==((y,x)),f)
      if p!==nothing break end
    end
    map(last,filter(x->x[1]==a,f[p:end]))
  end
  x=minc(a,x,Val(:ss),F)
  f=ggF(a,x,F)
  if f!=[one(M)]
    p=findfirst(s->leftgcdc(M,x,s)[2][1]==one(M),f)
    p===nothing ? nothing : f[p]
  else p=preferred_prefix(a,F)
    if leftgcdc(M,x,p)[2][1]!=one(M) return nothing end
#   l:=filter(s->s!=x && M.LeftGcdSimples(x,s)[2]==M.identity,
#              vcat(LeftDivisorsSimple(M,p)...));
    l=left_divisors(M,\(M,x,p))
#   println("x=$x p=$p")
    l=.*(Ref(M),Ref(x),reduce(vcat,l[2:end];init=eltype(l)[]))
#   println("Warning: for b=",a," F=1 & x=",x," divides p=",p," ",length(l));
    l[findfirst(x->x==p || x in ggF(a,x,F),l)]
  end
end

minc(a,x,F=(x,y=1)->x)=minc(a,x,Val(:sc),F)

"""
`conjcat(b[,F];ss=:sc)`

returns  the conjugacy category  of the summit  set of `b`  of the required
type.
  - By default,  computes the  category of  sliding circuits  of `b`.
  - If `ss==:ss`,  computes  the  super  summit  set.  
  - If `ss==:cyc`, computes the cyclic  conjugacy category. 
  - If `ss==:inf` computes the category of all conjugate elements with 
    same `Inf` as `b`.

If  an argument  `F` is  given it  should be  the Frobenius of a Reflection
coset attached to `b.M.W`. Then the `F`-conjugacy category is returned.

```julia-repl
julia> W=coxgroup(:A,4)
Aâ‚„

julia> w=BraidMonoid(W)(4,3,3,2,1)
43.321

julia> C=conjcat(w)
category with 2 objects and 4 generating maps

julia> C.obj
2-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 32143
 21324
```

```julia-rep1
julia> xprint(C;graph=true)
category with 2 objects and 4 generating maps
     32143      21343      21324      13214 
32143â”€â”€â”€â”€â†’ 32143â”€â”€â”€â”€â†’ 21324â”€â”€â”€â”€â†’ 21324â”€â”€â”€â”€â†’ 32143
```

```julia-repl
julia> conjcat(w;ss=:ss).obj
4-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 32143
 13243
 21432
 21324
```
"""
function conjcat(b,F=(x,y=1)->x;ss::Symbol=:sc)
  if ss==:sc || ss==:ss b=representativeSC(b,F).circuit[1] end
  Category(x->AtomicMaps(x,ss,F),b;action=(b,m)->^(b,m,F))
end

"""
conjugating_elt(b,bâ‚[,F];ss=:sc)

`b`  and `bâ‚` should  be elements of  the same Garside  group. The function
returns  `a` such that `b^a=bâ‚` if such exists, and `nothing` otherwise. If
an  argument `ss`  is given,  the computation  is done in the corresponding
category  --- see [`conjcat`](@ref). If an  argument `F` is given it should
be  an automorphism of the braid monoid, like the Frobenius of a reflection
coset   attached  to  `b.M.W`;   the  computation  is   then  done  in  the
corresponding `F`-conjugacy category.

```julia-repl
julia> W=coxgroup(:D,4)
Dâ‚„

julia> B=BraidMonoid(W)
BraidMonoid(Dâ‚„)

julia> b=B(2,3,1,2,4,3)
231243

julia> b1=B(1,4,3,2,2,2)
1432.2.2

julia> conjugating_elt(b,b1)
(134312.23)â»Â¹

julia> c=conjugating_elt(b,b1;ss=:cyc)
232.2

julia> b^c
1432.2.2

julia> WF=spets(W,Perm(1,2,4))
Â³Dâ‚„

julia> F=Frobenius(WF);

julia> c=B(3,4,3,1,2,3)
343123

julia> conjugating_elt(b,c,F)
124312

julia> ^(b,B(1,2,4,3,1,2),F)
343123
```
"""
function conjugating_elt(b,c,F=(x,y=1)->x;ss::Symbol=:sc)
  if ss==:sc || ss==:ss
    bconj=representativeSC(b,F)
    cconj=representativeSC(c,F)
    b=bconj.circuit[1]
    bconj=bconj.conj
    c=cconj.circuit[1] 
    cconj=cconj.conj
    if b.pd!=c.pd || length(b.elm)!=length(c.elm) return nothing end
  else
    bconj=cconj=one(b)
  end
  if b==c return bconj*cconj^-1 end
  res=[bconj]
  class=[b]
  for (i,a) in enumerate(class)
    for m in AtomicMaps(a,ss,F)
      target=^(a,m,F)
      if !(target in class)
        e=res[i]*m
        if target==c 
          return e*cconj^-1 
        end
        push!(class,target)
        push!(res,e)
      end
    end 
  end
end

"""
`centralizer_gens(b[,F];ss=:sc)`

a  list of generators of the centralizer of `b`. The computation is done by
computing  the  endomorphisms  of  the  object  `b`  in the category of its
sliding  circuits. If an argument `ss` is given, the computation is done in
the corresponding category --- see `conjcat`.

If  an argument  `F` is  given it  should be  an automorphism  of the braid
monoid,  like the Frobenius of a reflection coset attached to `b.M.W`; then
the `F`-centralizer is computed.

```julia-repl
julia> W=coxgroup(:D,4)
Dâ‚„

julia> B=BraidMonoid(W)
BraidMonoid(Dâ‚„)

julia> w=B(4,4,4)
4.4.4

julia> cc=centralizer_gens(w)
8-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 1
 (31432)â»Â¹231432
 (1)â»Â¹34.431
 (2)â»Â¹34.432
 (32431)â»Â¹132431
 4
 34.43
 2

julia> shrink(cc)
5-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 4            
 2            
 1            
 34.43        
 (3243)â»Â¹13243

julia> centralizer_gens(w;ss=:cyc)
Set{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}} with 1 element:
  4

julia> F=Frobenius(spets(W,Perm(1,2,4)));

julia> centralizer_gens(w,F)
2-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 124      
 312343123
```
"""
function centralizer_gens(b,F=(x,y=1)->x;ss::Symbol=:sc)
  if ss==:ss || ss==:sc
    b=representativeSC(b,F)
    a=b.conj
    b=b.circuit[1]
    Ref(a).*endomorphisms(conjcat(b,F;ss=ss),1).*Ref(a^-1)
  else
    endomorphisms(conjcat(b,F;ss=ss),1)
  end
end

"""
`Presentation(M::GarsideMonoid)`

returns  a presentation of  the Garside group  defined by `M`  (as given in
theorem 4.1 of [Dehornoy-Paris 1999](biblio.htm#DePa99)).

```julia-repl
julia> M=DualBraidMonoid(coxgroup(:A,3))
DualBraidMonoid(Aâ‚ƒ,c=[1, 3, 2])

julia> p=Presentation(M)
Presentation: 6 generators, 15 relators, total length 62
```

```julia-rep1
julia> simplify(p)
<< presentation with 3 generators, 4 relators of total length 26>>
<< presentation with 3 generators, 3 relators of total length 16>>

julia> display_balanced(p)
1: ab=ba
2: cac=aca
3: cbc=bcb
```
"""
function Presentations.Presentation(M::GarsideMonoid)
  F=FpGroup(map(i->Symbol("x",i),eachindex(M.atoms))...)
  rels=AbsWord[]
  for i in eachindex(M.atoms)
    for j in 1:i-1
      v=leftlcmc(M,M.atoms[i],M.atoms[j])
      v=map(x->word(M,x),v[2]);
      push!(v[1],i);push!(v[2],j);
      push!(rels,F(vcat(v[1],-reverse(v[2]))...))
    end
  end
  Presentation(F/rels)
end

#----------------------------------------------------------------------------
@GapObj struct TwistedPowerMonoid{T,TM}<:GarsideMonoid{T}
  Î´::T
  orderÎ´::Int
  stringÎ´::String
  atoms::Vector{T}
  n::Int # twisting
  M::TM
end

struct TPMSimple{T,TM}
  v::Vector{T}
  t::Bool
  M::TM
end

Base.:(==)(a::TPMSimple,b::TPMSimple)=(a.v==b.v)&&(a.t==b.t)&&(a.M==b.M)

Base.hash(a::TPMSimple, h::UInt)=hash(a.v,hash(a.t,hash(a.M,h)))

Base.copy(a::TPMSimple)=TPMSimple(copy(a.v),a.t,a.M)

Base.:^(y::GarsideElt{T},r::T,F::Function) where T<:TPMSimple=y.M(r)\(y*F(r))

function Base.show(io::IO,r::TPMSimple)
  if r.t print(io,"t") end
  print(io,"(",join(map(a->word(io,r.M,a),r.v),","),")")
end

function TwistedPowerMonoid(M,n)
  Î´=TPMSimple([M.Î´ for i in 1:n],true,M)
  atoms=[TPMSimple([one(M) for i in 1:n],true,M)]
  for i in 1:n
    append!(atoms,map(a->
      TPMSimple([j==i ? a : one(M) for j in 1:n],false,M),
      M.atoms))
  end
  TwistedPowerMonoid(Î´,n*M.orderÎ´,M.stringÎ´*"_n",atoms,n,M,Dict{Symbol,Any}())
end

function isrightdescent(M::TwistedPowerMonoid,s,i::Integer)
  if i==1 return s.t end
  i1,i2=divrem(i-2,length(M.M.atoms)).+1
  isrightdescent(M.M,s.v[i1],i2)
end

#function isrightascent(M::TwistedPowerMonoid,s,i)
#  if i==1 return !s.t end
#  i1,i2=divrem(i-2,length(M.M.atoms)).+1
#  isrightascent(M.M,s.v[i1],i2)
#end

function CoxGroups.isleftdescent(M::TwistedPowerMonoid,s,i)
  if i==1 return s.t end
  i1,i2=divrem(i-2,length(M.M.atoms)).+1
  isleftdescent(M.M,s.v[s.t ? 1+mod(i1-2,M.n) : i1],i2)
end

Base.one(M::TwistedPowerMonoid)=TPMSimple(
           [one(M.M) for i in 1:M.n],false,M.M)

Base.:*(M::TwistedPowerMonoid,a::TPMSimple,b::TPMSimple)=TPMSimple(
     map(i->*(M.M,a.v[b.t ? 1+mod(i,M.n) : i],b.v[i]),1:M.n),a.t||b.t,M.M)

Base.:\(M::TwistedPowerMonoid,a::TPMSimple,b::TPMSimple)=TPMSimple(
     map(i->\(M.M,a.v[b.t!=a.t ? 1+mod(i,M.n) : i],b.v[i]),1:M.n),b.t!=a.t,M.M)

Base.:/(M::TwistedPowerMonoid,a::TPMSimple,b::TPMSimple)=TPMSimple(
     map(i->/(M.M,a.v[b.t ? 1+mod(i-2,M.n) : i],
                  b.v[b.t ? 1+mod(i-2,M.n) : i]),1:M.n),a.t!=b.t,M.M)

function Base.show(io::IO,M::TwistedPowerMonoid)
  print(io,"twisted $(ordinal(M.n)) power of $(M.M)");
end

# Algorithm following Hao Zheng "A new approach to extracting roots in Garside
# groups" Comm. Algebra 34 (2006) 1793--1802
function Gapjm.root(b0::GarsideElt,n=2)
  M=b0.M
  tM=TwistedPowerMonoid(M,n)
  l=vcat(fill(M.Î´,b0.pd),b0.elm)
  b=GarsideElt(tM,map(eachindex(l)) do j
          TPMSimple([i==1 ? l[j] : one(M) for i in 1:n],j==1,M)
          end)
  function inner(b)
    cst=b->all(x->allequal(x.v),b.elm)
    sc=representativeSC(b)
    conj=[sc.conj]
    class=[sc.circuit[1]]
    if cst(class[1]) return conj[1] end
    for a in class 
      for m in AtomicMaps(a)
        target=a^m
        if !(target in class)
          e=conj[findfirst(==(a),class)]*m
          if cst(target) return e end
          push!(class,target)
          push!(conj,e)
        end
      end
    end
  end
  conj=inner(b)
  if conj==nothing return nothing end
  a=b^conj
  a=GarsideElt(M,map(x->x.v[1],a.elm),a.pd)
  l=length(conj.elm)
  k=count(x->x.t,conj.elm)
  conj=GarsideElt(M,vcat(map(i->conj.elm[i].v[1+mod(i,n)],1:k),
                         map(i->conj.elm[i].v[1+mod(k,n)],k+1:l)),conj.pd)
  conj*a*conj^-1
end
#----------------------------------------------------------------------------
"""
shrink(l::Vector{<:GarsideElt})

The  list `l`  is a  list of  elements of  the same Garside group `G`. This
function  tries to find  another set of  generators of the  subgroup of `G`
generated by the elements of `l`, of smaller total length (the length being
counted  as returned by the  function `word`). This can  be use to simplify
the result of `centralizer_gens`, or other braid subgroups.

```julia-repl
julia> B=BraidMonoid(CoxSym(3))
BraidMonoid(ð”– â‚ƒ)

julia> b=[B(1)^3,B(2)^3,B(-2,-1,-1,2,2,2,2,1,1,2),B(1,1,1,2)]
4-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, CoxSym{Int16}}}}:
 1.1.1              
 2.2.2              
 (1.12)â»Â¹2.2.2.21.12
 1.1.12             

julia> shrink(b)
2-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, CoxSym{Int16}}}}:
 2  
 1  
```
"""
function shrink(b1::Vector{T})where T<:GarsideElt
  function f(b)
    ld,ln=length.(word.(fraction(b)))
    ld>ln ? (l=ld+ln,ld=ln,b=inv(b),s=true) : (l=ld+ln,ld=ld,b=b,s=true)
  end
  simplified=false
  function test(el,j)
    p=f(el)
    pos=findfirst(==(p),bs)
    if pos!==nothing && pos!=j
      print(" eliminated")
      simplified=true
      splice!(bs,max(pos,j))
      return true
    end
    if p>=bs[j] return false end
    print("<$(p.l)Ã·$(p.ld)>")
    bs[j]=p
    simplified=true
    return false
  end
  bs=sort!(f.(b1))
  while true
    globsimplified=false
    print("#I total length $(sum(x->x.l,bs)) maximal length $(bs[end].l)\n")
    for j in length(bs):-1:2
      simplified=false
      print("#I $j:<$(bs[j].l)Ã·$(bs[j].ld)>")
      for ab in bs
        if !bs[j].s && !ab.s continue end
        if ab>=bs[j] break end
        print(".")
        a=ab.b
        ai=inv(a)
        b=bs[j].b
        aib=ai*b
        bai=b*ai
#       print("i=",i,"bs[i]=",bs[i]," bs[j]=",bs[j],"\n")
        if test(aib,j) || test(bai,j) || test(aib*a,j) || 
           test(a*bai,j) || test(a*b,j) || test(b*a,j) 
         break end
      end
      if simplified globsimplified=true
      elseif j<=length(bs) bs[j]=(l=bs[j].l,ld=bs[j].ld,b=bs[j].b,s=false)
      else break
      end
      print("\n")
    end
    if !globsimplified 
      print("\n")
      break 
    end
    unique!(sort!(bs))
  end
  return map(x->x.b,bs)
end

"""
`hurwitz(l,i::Integer)`
the  Hurwitz action of the  generator Ïƒáµ¢ of the  braid group Bâ‚™ on the list
`l`   of  length  `n`  of  group  elements,  which  replaces  `láµ¢,láµ¢â‚Šâ‚`  by
`láµ¢â‚Šâ‚,láµ¢^láµ¢â‚Šâ‚`.  If `i<0`, does the action of `inv(Ïƒâ±¼)` where `j=-i`, which
replaces `lâ±¼,lâ±¼â‚Šâ‚` by `lâ±¼â‚Šâ‚^inv(lâ±¼),lâ±¼`.
"""
function hurwitz(l,i::Integer)
  l=copy(l)
  if i>0 l[i:i+1]=[l[i+1],l[i]^l[i+1]] 
  else l[-i:-i+1]=[l[-i]*l[-i+1]*inv(l[-i]),l[-i]]
  end
  l
end

"""
`hurwitz(l,v::AbstractVector{<:Integer})`

does successively `hurwitz(l,i)` for each `i` in `v`.
"""
function hurwitz(l,v::AbstractVector)
  for i in v l=hurwitz(l,i) end
  l
end

"""
`hurwitz(l,b)`
the  Hurwitz action of the braid  `bâˆˆ Bâ‚™` on the list  `l` of length `n` of
group elements.
"""
hurwitz(l,b::GarsideElt)=hurwitz(l,word(b))
  
# example
B=BraidMonoid(CoxSym(21))
b=[
B(19,19,19),B(11,11),B(10,10,10,10),B(8,8,8),B(3,3,3),B(-1,-1,2,2,1,1),B(2,2,
2,2),B(-3,-1,-2,-2,-1,-13,-14,-15,-16,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,
-13,-14,-15,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-1,-2,-3,-4,-5,-6,-7,
-8,-9,-10,-11,-12,-13,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-1,-2,-3,-4,-5,-6,
-7,-8,-9,-10,-11,-15,-11,-12,-13,-14,-12,-13,-11,-12,-14,-12,-13,-13,14,13,13,
12,14,12,11,13,12,14,13,12,11,15,11,10,9,8,7,6,5,4,3,2,1,12,11,10,9,8,7,6,5,4,
3,2,13,12,11,10,9,8,7,6,5,4,3,2,1,14,13,12,11,10,9,8,7,6,5,4,3,2,15,14,13,12,
11,10,9,8,7,6,5,4,3,2,1,16,15,14,13,1,2,2,1,3),B(-3,-1,-2,-2,-1,-1,-2,-3,-4,
-2,-3,-1,-2,-4,-2,-3,-1,2,2,2,1,3,2,4,2,1,3,2,4,3,2,1,1,2,2,1,3),B(-3,-1,-2,
-2,-3,-4,-1,-2,-3,-3,-2,-2,3,3,3,2,2,3,3,2,1,4,3,2,2,1,3),B(-3,-1,-2,-2,-3,-4,
-1,-2,-3,-3,-4,-2,-3,-3,4,4,3,3,2,4,3,3,2,1,4,3,2,2,1,3),B(-3,-1,-2,-2,-3,-4,
-5,-6,-7,-8,-9,-10,-11,-12,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-3,-4,-5,-6,-7,
-8,-9,-10,-2,-3,-4,-5,-6,-7,-8,-9,-9,-10,-11,-12,-10,-11,-9,-10,-12,-10,11,10,
12,10,9,11,10,12,11,10,9,9,8,7,6,5,4,3,2,10,9,8,7,6,5,4,3,11,10,9,8,7,6,5,4,3,
2,1,12,11,10,9,8,7,6,5,4,3,2,2,1,3),B(-5,-4,-3,-1,-2,-2,3,2,2,1,3,4,5),B(-19,
-18,-17,-16,-15,-14,-13,12,13,14,15,16,17,18,19),B(-5,-4,-3,-2,-1,-1,-2,-3,-4,
-5,-5,-3,-4,-4,5,4,4,3,5,5,4,3,2,1,1,2,3,4,5),B(-1,2,2,2,1),B(-3,4,4,4,
3),B(-3,2,2,2,3),B(-1,-2,-3,4,4,3,2,1),B(-3,-2,1,1,2,3),B(-3,-2,-10,-9,-8,-7,
-5,-6,-4,-5,-2,-3,-4,-4,-2,3,3,3,2,4,4,3,2,5,4,6,5,7,8,9,10,2,3),B(-3,-2,-10,
-9,-8,-7,-5,-6,-4,-5,-2,-3,-4,-4,-5,-2,-3,4,3,2,5,4,4,3,2,5,4,6,5,7,8,9,10,2,
3),B(-3,-1,-2,-10,-11,-5,-6,-7,-8,-9,-10,-4,-5,-6,-7,-8,-9,-2,-3,-4,-5,-6,-7,
-8,-1,-2,-3,-4,-5,-6,-7,-1,-2,-3,-4,-5,-6,-6,-7,-8,-9,-10,-6,-7,-8,-9,-7,-8,
-6,-7,-9,-10,-9,-7,-8,-6,-7,-10,-9,-7,8,7,9,10,7,6,8,7,9,10,9,7,6,8,7,9,8,7,6,
10,9,8,7,6,6,5,4,3,2,1,7,6,5,4,3,2,1,8,7,6,5,4,3,2,9,8,7,6,5,4,10,9,8,7,6,5,
11,10,2,1,3),B(-3,-1,-2,-2,-3,-4,-1,-2,-3,-3,-2,-2,-3,-3,2,3,3,2,2,3,3,2,1,4,
3,2,2,1,3),B(-3,-1,-2,-2,-3,-4,-1,-2,-3,-3,-4,-2,3,3,3,2,4,3,3,2,1,4,3,2,2,1,
3),B(-3,-1,-2,-2,-1,-1,-2,-2,-3,-4,-2,-3,-1,-2,-4,-2,-3,-1,2,2,2,1,3,2,4,2,1,
3,2,4,3,2,2,1,1,2,2,1,3),B(-3,-1,-2,-2,-1,-1,-2,-3,-4,-2,-3,-1,-2,-4,-2,-3,-1,
-2,-2,3,3,3,2,2,1,3,2,4,2,1,3,2,4,3,2,1,1,2,2,1,3),B(-5,6,6,6,5),B(-5,4,4,4,
5),B(-5,-3,-4,-2,3,3,3,2,4,3,5),B(-5,-4,-3,-2,-15,-13,-14,-12,-13,-11,-12,-10,
-11,-2,-11,-12,-13,-8,-9,-10,-11,-12,-7,-8,-9,-10,-11,-6,-7,-8,-9,-10,-2,-3,
-4,-5,-6,-7,-8,9,8,7,6,5,4,3,2,10,9,8,7,6,11,10,9,8,7,12,11,10,9,8,13,12,11,2,
11,10,12,11,13,12,14,13,15,2,3,4,5),B(-5,-4,-3,-2,-2,-3,-3,-2,-2,-2,3,3,2,2,2,
3,3,2,2,3,4,5),B(-5,-6,-1,-2,-3,-4,5,5,5,5,4,3,2,1,6,5),B(-5,-6,-4,-5,-3,4,3,
5,4,6,5),B(-7,8,8,7),B(-5,-6,-7,-4,-5,-6,-3,-4,-5,-2,-3,4,3,2,5,4,3,6,5,4,7,6,
5),B(-15,-13,-14,-12,-13,-13,12,12,12,13,13,12,14,13,15),B(-15,-13,-14,-12,
-13,-15,-13,14,14,14,13,15,13,12,14,13,15),B(-15,-13,-14,-12,-13,-17,-16,-15,
-13,-14,-12,13,13,13,12,14,13,15,16,17,13,12,14,13,15),B(-15,-13,-14,-12,-13,
-18,-17,-16,-15,-13,-14,-12,13,12,14,13,15,16,17,18,13,12,14,13,15),B(-15,-16,
-13,-14,-12,-13,-16,-15,-13,-14,-12,13,12,14,13,15,16,13,12,14,13,16,
15),B(-13,-14,-15,-16,-14,-12,-13,-16,-15,-13,14,13,15,16,13,12,14,16,15,14,
13),B(-13,-14,-15,-16,-17,-14,-12,-13,-17,-16,-15,-13,-14,-12,13,13,12,14,13,
15,16,17,13,12,14,17,16,15,14,13),B(-17,-15,-16,-13,-14,-15,-12,-13,-14,-17,
-16,-14,15,14,16,17,14,13,12,15,14,13,16,15,17),B(-10,11,11,11,10),B(-10,-10,
-9,-8,-7,6,6,7,8,9,10,10),B(-10,-7,-8,9,8,7,10),B(-8,-9,-10,11,10,9,8),B(-10,
-11,-13,-14,-15,-16,-11,-12,-13,-14,-15,-8,-9,-10,-11,-12,-13,14,13,12,11,10,
9,8,15,14,13,12,11,16,15,14,13,11,10),B(-13,-14,-15,-16,-10,-11,-16,-11,-12,
-13,-14,-15,-7,-8,-9,-10,-11,-12,-13,14,13,12,11,10,9,8,7,15,14,13,12,11,16,
11,10,16,15,14,13),B(-15,-13,-14,-12,-13,-11,-12,-10,-11,-11,-12,13,13,13,12,
11,11,10,12,11,13,12,14,13,15),B(-15,-13,-14,-12,-13,-11,-12,-10,-11,-11,-12,
-13,-13,-8,-9,-10,-11,-12,-7,-8,-9,-10,-11,-5,-6,-7,-8,-9,-10,-1,-2,-3,-4,-5,
-6,-7,-8,-9,-7,-9,-10,-7,-8,9,8,7,10,9,7,9,8,7,6,5,4,3,2,1,10,9,8,7,6,5,11,10,
9,8,7,12,11,10,9,8,13,13,12,11,11,10,12,11,13,12,14,13,15),B(-15,-13,-14,-12,
-13,-11,-12,-10,-11,-15,-11,-12,-13,14,13,12,11,15,11,10,12,11,13,12,14,13,
15),B(-10,-9,-8,-7,6,6,6,7,8,9,10),B(-13,-14,-10,-11,-12,-13,-13,-11,-12,-10,
11,11,10,12,11,13,13,12,11,10,14,13),B(-10,-9,-8,-7,-5,-6,-3,-4,-5,-2,-3,4,4,
4,3,2,5,4,3,6,5,7,8,9,10),B(-10,-9,-8,-7,-6,-5,-4,-3,-2,1,2,3,4,5,6,7,8,9,
10),B(-10,-11,-9,10,9,11,10),B(-12,11,12),B(-8,-8,9,8,8),B(-10,-8,-9,-9,-8,-7,
-6,-5,-3,-4,-2,3,2,4,3,5,6,7,8,9,9,8,10),B(-13,12,12,13),B(-13,-12,11,12,
13),B(-13,-14,-12,-13,-11,12,12,12,11,13,12,14,13),B(-13,-14,-8,-9,-10,-11,
-12,-13,-7,-8,-9,-10,-11,-12,-5,-6,-7,-8,-9,-10,-11,-4,-5,-6,-7,-8,-9,10,9,8,
7,6,5,4,11,10,9,8,7,6,5,12,11,10,9,8,7,13,12,11,10,9,8,14,13),B(-15,16,16,16,
16,15),B(-15,14,14,14,15),B(-13,-14,-15,16,16,16,16,15,14,13),B(-10,-9,-8,-7,
-5,-6,-6,-3,-4,-5,-2,-3,4,3,2,5,4,3,6,6,5,7,8,9,10),B(-15,-13,-14,-12,13,13,
13,12,14,13,15),B(-15,-13,-14,-12,-13,-16,-15,-13,-14,-16,-14,15,15,14,16,14,
13,15,16,13,12,14,13,15),B(-15,-13,-14,-12,-13,-11,-12,-10,-11,-11,-12,-13,
-13,-11,12,12,12,11,13,13,12,11,11,10,12,11,13,12,14,13,15),B(-15,-13,-14,-12,
-13,-11,-12,-10,-11,-11,-12,-13,-13,-11,-8,-9,-10,-11,-12,-13,-7,-8,-9,-10,
-11,-12,-5,-6,-7,-8,-9,-10,-11,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-9,-7,-8,-10,-8,
-9,-7,8,7,9,8,10,8,7,9,10,9,8,7,6,5,4,3,2,1,11,10,9,8,7,6,5,12,11,10,9,8,7,13,
12,11,10,9,8,11,13,13,12,11,11,10,12,11,13,12,14,13,15),B(-15,-13,-14,-12,-13,
-11,-12,-10,-11,-11,-12,-13,-13,-11,-8,-9,-10,-11,-12,-13,-7,-8,-9,-10,-11,
-12,-11,-9,-10,-12,-10,11,10,12,10,9,11,12,11,10,9,8,7,13,12,11,10,9,8,11,13,
13,12,11,11,10,12,11,13,12,14,13,15),B(-15,-13,-14,-12,-13,-11,-12,-10,-11,
-17,-18,-16,-17,-15,-16,-11,-12,-13,-14,-15,-13,-14,-11,-12,-13,-15,-13,14,13,
15,13,12,11,14,13,15,14,13,12,11,16,15,17,16,18,17,11,10,12,11,13,12,14,13,
15),B(-5,-4,-8,-7,-6,-4,5,4,6,7,8,4,5),B(-13,-14,-15,-16,17,17,17,16,15,14,
13),B(-13,-14,-15,-16,-10,-11,-12,-13,-14,15,14,13,12,11,10,16,15,14,13),B(-5,
-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,
-14,-15,-15,-16,-16,15,15,16,16,15,15,14,13,12,11,10,9,8,7,6,5,4,3,16,15,14,
13,12,11,10,9,8,7,6,5),B(-3,-3,-4,-2,3,2,4,3,3),B(-15,-13,-14,-12,-13,-11,-12,
-10,-11,-5,-4,-3,-11,-12,-13,-3,-2,-13,-8,-9,-10,-11,-12,-7,-8,-9,-10,-11,-6,
-7,-8,-9,-10,-2,-3,-4,-5,-6,-7,-8,-9,-9,-7,8,7,9,9,8,7,6,5,4,3,2,10,9,8,7,6,
11,10,9,8,7,12,11,10,9,8,13,2,3,13,12,11,3,4,5,11,10,12,11,13,12,14,13,
15),B(-17,-15,-16,-14,15,15,14,16,15,17),B(-17,-15,-16,-13,-14,-15,-12,-13,14,
14,14,13,12,15,14,13,16,15,17),B(-17,-16,-15,-14,-13,-12,-10,11,10,12,13,14,
15,16,17),B(-5,-6,-7,-8,-9,-10,-11,-12,-3,-4,-5,-6,-7,-8,-9,-10,-11,-11,-12,
-13,-14,-15,-16,-12,-13,-14,-15,-11,-12,-13,-14,-14,-15,-16,-15,-14,-16,-14,
15,15,15,15,14,16,14,15,16,15,14,14,13,12,11,15,14,13,12,16,15,14,13,12,11,11,
10,9,8,7,6,5,4,3,12,11,10,9,8,7,6,5),B(-17,-18,-19,-15,-16,-17,-18,-13,-14,
-15,-16,-17,-12,-13,-14,-15,-16,-11,-12,-13,-14,15,14,13,12,11,16,15,14,13,12,
17,16,15,14,13,18,17,16,15,19,18,17),B(-10,-3,-2,-10,-9,-8,-7,-6,-5,-4,-2,3,2,
4,5,6,7,8,9,10,2,3,10),B(-5,-4,-3,-2,-19,-17,-18,-15,-16,-17,-13,-14,-15,-16,
-8,-9,-10,-11,-12,-13,-14,-15,-7,-8,-9,-10,-11,-12,-13,-14,-6,-7,-8,-9,-10,
-11,-12,-13,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,12,11,10,9,8,7,6,5,4,3,2,13,12,11,
10,9,8,7,6,14,13,12,11,10,9,8,7,15,14,13,12,11,10,9,8,16,15,14,13,17,16,15,18,
17,19,2,3,4,5),B(-5,-4,-3,-2,-2,-3,-3,-2,-2,3,3,3,2,2,3,3,2,2,3,4,5)]
end
