"""
Garside  monoids are a general class  of monoids whose most famous examples
are  the braid and dual braid monoids. They have groups of fractions, which
in  both above examples is the braid  group. We implement braid groups as a
special case of a general implementation of Garside monoids and groups.

Let  us first  introduce some  vocabulary about  divisibility in monoids. A
*left-divisor*  of `x` is a `d` such that there exists `y` with `x=dy` (and
then  we say that `x` is  a *right multiple* of `d`,  and write `d‚âº x`). We
say  that a monoid `M`  is left cancellable if  an equality `dx=dy` implies
`x=y`.  We  define  symmetrically  right-divisors,  left  multiples,  right
cancellability  and the symbol `‚âΩ`. We say that `x` is an *atom* if `1` and
`x`  are its only left or right divisors. A  *left gcd* of `x` and `y` is a
common  left  divisor  `d`  of  `x`  and  `y`  such  that  any other common
left-divisor  is a left-divisor of `d`. Similarly  a *right lcm* of `x` and
`y`  is  a  common  multiple  which  is  a left-divisor of any other common
multiple.

We  call *Garside* a monoid `M` which:
  * is left and right cancellable.
  * is generated by its atoms.
  * admits left and  right  gcds  and  lcms.
  * is such that any element has only finitely many left (or right) divisors.
  * admits a *Garside element*, which is an element `Œî` whose set of left and right-divisors coincide and generate `M`.

Garside  elements are not  unique, but there  is a unique  minimal one (for
divisibility);  we assume that  a Garside element  `Œî` has been chosen. The
divisors  of `Œî` are called  the *simples* of `M`.  A Garside monoid embeds
into  its group of fractions, which is called a *Garside group*; the monoid
defines  a *Garside structure* for the group of fractions. A group may have
several  different Garside structures, for  instance braid groups of finite
Coxeter groups have an ordinary and a dual braid monoid.

We  implement more generally *locally* Garside monoids, which have the same
axioms,  excepted the  existence of  Garside elements  and that lcms do not
always  exist, but exist if any common  multiple exists. The set of simples
is not defined by a Garside element, but by the condition that they contain
the   atoms  and   are  closed   under  lcms   and  taking   divisors,  see
[bdm01](@cite);  each element is still  divisible by finitely many simples,
but  the set  of simples  may be  infinite. The  main example  is the Artin
monoid  of  an  infinite  Coxeter  group.  It  is not known whether locally
Garside  monoids embed in their group  of fractions, although this has been
proved  for Artin  monoids of  Coxeter groups  by [paris01](@cite). In this
case  computing in the monoid does not  help for computing in the group; we
implement for these cases only the monoid.

There  is another  generalization, *quasi-Garside  monoids*, where we relax
the  axiom  that  an  element  has  finititely  many divisors (there may me
infinitely atoms). We do not implement this in this module, but the package
`AffineA`  implements, following the work of Fran√ßois Digne, the dual braid
monoid of the affine Coxeter group `W(AÃÉ‚Çô)` which is quasi-Garside.

What allows computing with Garside and locally Garside monoids, and Garside
groups, is the fact that their elements admit normal forms --- these normal
forms were exhibited for braid monoids of Coxeter groups by [del72](@cite),
who extended earlier work of [bs72](@cite) and [gar69](@cite):

  1. Let `M` be a locally Garside monoid. Then for any `b‚àà M` there is a unique  maximal (for divisibility) simple left-divisor `Œ±(b)` of `b`. In a Garside monoid it is the [`leftgcd`](@ref)`(b,Œî)`.

  2. Let `M` be a Garside monoid with Garside element `Œî` and group of fractions `G`. Then for any `x‚àà  G`, for large enough `i` we have `Œî‚Å±x‚àà M`.

A  consequence  of  1.  is  that  every  element  of  `M`  has  a canonical
decomposition as a product of simples, its *left-greedy* normal form. If we
define   `œâ(x)`  by   `x=Œ±(x)œâ(x)`,  then   the  normal   form  of  `x`  is
`Œ±(x)Œ±(œâ(x))Œ±(œâ^2(x))‚Ä¶`.  For locally Garside monoids  we use this sequence
of  simples to represent elements of `M`. When  `M` is Garside we use 2. to
represent  any element of `G`:  given `x‚àà G` we  compute the smallest power
`i`  such that `Œî‚Å±x‚àà M`,  and we represent `x`  by the pair `(-i,Œî‚Å±x)`. The
second  term is an element of `M`,  not divisible by `Œî`, that we represent
by the sequence of simples that make up its normal form (this sequence thus
does not contain the identity or `Delta`).

In  our implementation a  Garside monoid is  a parametrized type whose most
general  instance is the abstract  type `LocallyGarsideMonoid{T}` where `T`
is the type of the simples.

We  now describe Artin-Tits braid monoids. Let `(W,S)` be a Coxeter system,
that is `W` has presentation

`‚ü®s‚àà S‚à£s¬≤=1, sts‚ãØ =tst‚ãØ   (m‚Çõ‚Çú factors on each side) for s,t‚àà S‚ü©`

for some Coxeter matrix `m‚Çõ‚Çú`. The braid group `B` associated to `(W,S)` is
the group defined by the presentation

`‚ü®ùê¨‚àà ùêí‚à£ ùê¨ùê≠ùê¨‚ãØ =ùê≠ùê¨ùê≠‚ãØ  (m‚Çõ‚Çú factors on each side) for ùê¨,ùê≠‚àà ùêí‚ü©`

The  associated *positive* braid  monoid `B‚Å∫` is  the monoid defined by the
presentation above --- it identifies with the submonoid of `B` generated by
`ùêí`  by [paris01](@cite). This  monoid is locally  Garside, with the set of
simples  in bijection with  the elements of  `W` and with  `ùêí` as atoms; we
will  denote by  `ùêñ `  the set  of simples,  and by  `ùê∞ ‚Üî  w` the bijection
between  simples and elements of `W`. The group `W` has a length defined in
terms of reduced expressions. Similarly, having only homogeneous relations,
`B‚Å∫`  has a natural length function. Then  `ùêñ ` can be characterised as the
subset of elements of `B‚Å∫` with the same length as their image in `W`.

If  `W` is finite, then `B‚Å∫` is Garside with Garside element the element of
`ùêñ  ` whose image is the longest element  of `W`. 

Given a Coxeter group `W`,
```julia-repl
julia> W=coxgroup(:A,4)
A‚ÇÑ

julia> B=BraidMonoid(W)
BraidMonoid(A‚ÇÑ)
```
constructs  the associated braid monoid, and  then, used as a function, `B`
constructs  elements of the braid monoid (or group when `W` is finite) from
a list of generators indices (or negative numbers representing inverses of
generators) given as arguments:

```julia-repl
julia> w=B(1,2,3,4) # represents ùê¨‚ÇÅùê¨‚ÇÇùê¨‚ÇÉùê¨‚ÇÑ
1234
```
The  operations `*`  and `^`  (exponentiation) are  implemented for locally
Garside  elements (and also multiplication of an element by a simple), and,
in the Garside case, `\\` and `/` (left and right division), `inv` and `^`,
and conjugation of an element by a simple.
```julia-repl
julia> w*w
1213243.4

julia> w*W(1) # multiplication by a simple
12134

julia> W(1)*w
1.1234

julia> w^3  # the terms of the normal form are printed separated by a .
121321432.343

julia> B(1,2)\\w
34

julia> w/B(3,4)
12

julia> w^B(1) # conjugation
2134

julia> w^W(1) # conjugation by a simple
2134

julia> word(Œ±(w^3))
9-element Vector{Int64}:
 1
 2
 1
 3
 2
 1
 4
 3
 2

julia> w^4
Œî.232432

julia> inv(w)
(1234)‚Åª¬π

julia> B(-4,-3,-2,-1) # another way of entering the same element
(1234)‚Åª¬π
```
How  an  element  of  a  Garside  group  is  printed  is  controlled by the
`IOcontext`  attribute  ':greedy'.  By  default,  elements  are  printed as
fractions `a‚Åª¬πb` where `a` and `b` have no left common divisor, and `a` and
`b`  are printed using the left-greedy normal form, that is a maximal power
of  the Garside element followed by the  rest. One can print the element in
the  left-greedy  normal  from  without  writing  it as a fraction first by
setting  the `IOContext`  `:greedy=>true`; with  the same  `w` as  above we
have:

```julia-repl
julia> xrepr(w^-1,greedy=true,limit=true)
"Œî‚Åª¬π.232432"
```
By default,  `repr` gives   `w`  back   in  a   form  which   after  assigning
`B=BraidMonoid(W)` can be input back into Julia:

```julia-repl
julia> repr(w)
"B(1,2,3,4)"

julia> repr(w^3)
"B(1,2,1,3,2,1,4,3,2,3,4,3)"

julia> repr(w^-1)
"B(-4,-3,-2,-1)"
```
In  general elements  of a  Garside monoid  are displayed  as a list of the
indices of their constituting atoms.

We  now describe the  dual braid monoid.  First we define interval monoids.
Given a group `W` and a set `S` of generators of `W` as a monoid, for `w‚ààW`
we  define the  length `l_S(w)`  as the  minimum number  of elements of `S`
needed  to write `w`.  We then define  left-divisors of `x`  as those `d‚ààW`
such  that there exists `y` with  `x=dy` and `l_S(d)+l_S(y)=l_S(x)`. We say
that  `w‚àà W` is balanced if its set of left and right divisors coincide; in
this  case we denote  this set by  `[1,w]`, an *interval*  for the poset of
`S`-divisibility.  We say that `w`  is Garside for `l_S`  if it is balanced
and  `[1,w]` is a lattice (where upper and lower bounds are lcms and gcds),
and generates `W`. Then we have the theorem:

If `w` is Garside for the `l_S`, the monoid `M` with generators `[1,w]` and
relations  `xy=z` whenever `xy=z` holds  in `W` and `l_S(x)+l_S(y)=l_S(z)`,
is  a Garside monoid, with simples `[1,w]`  and atoms `S`. It is called the
interval monoid defined by `l_S` and the interval `[1,w]`.

The  Artin-Tits braid monoid  is an interval  monoid by taking  for `S` the
Coxeter  generators, in which case `l_S`  is the Coxeter length, and taking
for `w` the longest element of `W`. The dual monoid, constructed by Birman,
Ko  and  Lee  for  type  `A`  and  by Bessis for all well-generated complex
reflection  groups, is obtained in  a similar way, by  taking this time for
`w` a Coxeter element, for `l_S` the reflection length (see
[`reflection_length`](@ref))  and for atoms  the reflections which  divide `w` for
the  reflection length (for Coxeter groups all reflections divide a Coxeter
element  but this  is not  the case  for well-generated  complex reflection
groups);  the simples of the dual monoid are of cardinality the generalized
Catalan numbers (see [`catalan`](@ref)). An interval monoid has naturally a
morphism  [`image`](@ref) `M‚ÜíW`, which is the quotient map which sends back
simple braids to `[1,w]`.

A last pertinent notion is *reversible* monoids. Since we store left normal
forms,  it is easy to compute left lcms and gcds, but hard to compute right
lcms  and gcds. But this becomes easy to  do if the monoid has an operation
'reverse',  which has the property that 'a' is a left-divisor of 'b' if and
only  if 'reverse(a)'  is a  right-divisor of  'reverse(b)'. This holds for
Artin-Tits  and dual braid monoids of groups generated by true reflections;
Artin-Tits monoids have a `reverse` operation which consists of reversing a
word,  written  as  a  list  of  atoms.  The above dual monoids also have a
`reverse`  operation defined  in the  same way,  but this operation changes
monoid:  it goes from  the dual monoid  for the Coxeter  element `w` to the
dual  monoid for the  Coxeter element `w‚Åª¬π`.  The operations 'rightlcm' and
'rightgcd' for non-simple elements are only implemented if the monoid has a
`reverse` operation.

A  finite Coxeter group is also a  reflection group in a real vector space,
thus  in its complexified `V`, and `B` also has a topological definition as
the  fundamental group of  the space `V ≥·µâ·µç/W`,  where `V ≥·µâ·µç` is  the set of
elements  of  `V`  which  are  not  fixed by any non-identity element. This
definition  of  a  braid  group  can  be  extended  to  any  finite complex
reflection  group, and following  the work of  Bessis we also implement the
dual braid monoid of well-generated complex reflection groups.

This  module implements also  functions to solve  the conjugacy problem and
compute   centralizers   in   Garside   groups,   following   the  work  of
[fg03](@cite) and [gg10](@cite).

Two  elements `w` and `w'` of a monoid  `M` are *conjugate* in `M` if there
exists  `x‚àà M` such that `wx=xw'`; if  `M` satisfies the √ñre conditions, it
has  a  group  of  fractions  where  this  becomes  `x‚Åª¬πwx=w'`,  the  usual
definition  of conjugacy. A special case  which is even closer to conjugacy
in  the group is if there exists `y‚àà  M` such that `w=xy` and `w'=yx`. This
relation  is not transitive in general,  but we call *cyclic conjugacy* the
transitive closure of this relation, a restricted form of conjugacy.

The next observation is that if `w,w'‚ààM` where `M` is Garside are conjugate
in  the group  of fractions  `G` then  they are  conjugate in `M`, since if
`wx=xw'`  then there is a  power `Œî‚Å±` which is  central and such that `xŒî‚Å±‚àà
M`. Then `wxŒî‚Å±=xŒî‚Å± w'` is a conjugation in `M`.

The crucial notions for solving the conjugacy problem in Garside groups are
`inf(w):=sup{i such that Œî‚Åª‚Å±w‚àà M}` and `sup(w):=inf{i such that w‚Åª¬πŒî‚Å±‚àà M}`:
the  number of conjugates of `w` with same `inf` and `sup` as `w` is finite
(since  our monoids have a finite number of simples). Further, a theorem of
Birman  shows that the maximum `inf` and minimum `sup` in a conjugacy class
can  be  achieved  simultaneously  (by  iterated cycling and decycling. See
[`Garside.cycle`](@ref)   and   [`Garside.decycle`](@ref));   the  elements
achieving  this are  called the  super summit  set of `w`, denoted `SS(w)`.
Thus  a  way  to  determine  if  `w`  and  `w'`  are  conjugate  is to find
representatives  `w‚ÇÅ‚ààSS(w)`, `w'‚ÇÅ‚ààSS(w')`,  and then  enumerate `SS(w)` and
see  if it contains `w'‚ÇÅ`. This can also be used to compute the centralizer
of  an element:  if we  consider the  super summit  set as a category whose
objects  are  its  elements  and  morphisms  are the conjugations by simple
elements,  the centralizer  of `w‚ÇÅ`  is given  by the endomorphisms of that
object.   For  the  implementation   of  finite  categories   we  use,  see
[`Category`](@ref) and [`endomorphisms`](@ref).

We illustrate this on an example:
```julia-repl
julia> b=B(2,1,4,1,4)
214.14

julia> c=B(1,4,1,4,3)
14.143

julia> d=conjugating_elt(b,c) # would return nothing if b, c are not conjugate
(1)‚Åª¬π21321432

julia> b^d
14.143

julia> centralizer_gens(b)
3-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 321432.213243
 21.1
 4

julia> C=conjcat(b;ss=Val(:ss)) # SS(b) as a category
category with 10 objects and 32 generating maps

julia> C.obj # the elements of SS(b). Notice it contains c
10-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 1214.4
 214.14
 124.24
 1343.1
 14.124
 143.13
 24.214
 134.14
 13.134
 14.143
```

There is a faster solution to the conjugacy problem given in [gg10](@cite):
for  each `b‚ààM`, they  define a particular  simple left-divisor of `b`, its
[`preferred_prefix`](@ref)  such that the  operation slide which cyclically
conjugates  `b` by  its preferred  prefix, is  eventually periodic, and the
period  is contained in the super summit set  of `x`. We say that `x` is in
its  sliding circuit if some iterated slide of `x` is equal to `x`. The set
of  sliding circuits in a  given conjugacy class is  smaller than the super
summit  set, thus allows to solve  the conjugacy problem faster. Continuing
from the above example,

```julia-repl
julia> word(W,preferred_prefix(b))
2-element Vector{Int64}:
 2
 1

julia> b^B(preferred_prefix(b))
1214.4

julia> C=conjcat(b) # with no Val argument computes the sliding circuits
category with 2 objects and 6 generating maps

julia> C.obj # the elements of the sliding circuits
2-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 1214.4
 1343.1
```

Finally, we have implemented the algorithm of [zheng2006](@cite) to extract
roots in a Garside monoid:

```julia-repl
julia> W=coxgroup(:A,3)
A‚ÇÉ

julia> B=BraidMonoid(W)
BraidMonoid(A‚ÇÉ)

julia> Pi=B(B.Œ¥)^2
Œî¬≤

julia> root(Pi,2)
Œî

julia> root(Pi,3)
1232

julia> root(Pi,4)
132
```
"""
module Garside
using ..Chevie
export BraidMonoid, shrink, Œ±, Œ¥ad, DualBraidMonoid, conjcat, fraction,
centralizer_gens, preferred_prefix, left_divisors, right_divisors, Category,
endomorphisms, image, leftgcd, leftgcdc, rightgcd, rightgcdc,
leftlcm, leftlcmc, rightlcm, rightlcmc, conjugating_elt, GarsideElt,
Brieskorn_normal_form, Monoid, MonoidElt, GarsideMonoid, LocallyGarsideMonoid,
hurwitz, rightascents

abstract type Monoid end

"""
`LocallyGarsideMonoid{T}`  is the abstract type of locally Garside monoids,
where  `T`  is  the  type  of  simples.  Such a monoid `M` needs, for `a,b`
simples, to implement the functions
  - `one(M)`
  - `isleftdescent(M,a::T,i::Integer)`  whether `M.atoms[i]‚âº a`
  - `isrightdescent(M,a::T,i::Integer)` whether `a‚âΩ M.atoms[i]`
  - `isrightascent(M,a::T,i::Integer)`  whether `a*M.atoms[i]` is simple
  - `*(M,a::T,b::T)`  when `a*b` is simple returns the simple `a*b`
  - `\\(M,a::T,b::T)` when `a‚âº b` returns the simple `a\b`
  - `/(M,a::T,b::T)`  when `a‚âΩ b` returns the simple `a/b`
"""
abstract type LocallyGarsideMonoid{T}<:Monoid end # T=type of simples
# Garside Monoids are scalars for broadcasting
Base.broadcastable(M::LocallyGarsideMonoid)=Ref(M)

"""
`GarsideMonoid{T}`  is the abstract  type of Garside  monoids, where `T` is
the type of simples. Such a monoid `M` should implement the same methods as
`LocallyGarsideMonoid`  except  that  `isrightascent(M,a)` is automatically
defined as `isleftdescent(M,\\(M,a,M.Œ¥),i)`.

An implementation should have fields `M.Œ¥`, `M.stringŒ¥`

An interval monoid should have a field `M.orderŒ¥`.
"""
abstract type GarsideMonoid{T}<:LocallyGarsideMonoid{T} end

CoxGroups.firstleftdescent(M::LocallyGarsideMonoid{T},elts::Vararg{T,N}) where {T,N}=
  findfirst(i->all(b->isleftdescent(M,b,i),elts),eachindex(M.atoms))

function leftgcdc(M::LocallyGarsideMonoid{T},simp::Vararg{T,N})where {T,N}
  if N==0 error("leftgcd needs at least one simple as argument") end
  x=copy(one(M)) # copy because of the mul! later
  while true
    i=firstleftdescent(M,simp...)
    if isnothing(i) return (x,simp) end
    a=atom(M,i)
    x=mul!(M,x,a)
    simp=map(y->\(M,a,y),simp)
  end
end

"""
`leftgcd(M::LocallyGarsideMonoid,s‚ÇÅ,‚Ä¶,s‚Çô)`
`leftgcdc(M::LocallyGarsideMonoid,s‚ÇÅ,‚Ä¶,s‚Çô)`

`s‚ÇÅ,‚Ä¶,s‚Çô` should be simples of `M`. The  function returns the left gcd `d` of
the `s·µ¢`.

`leftgcdc` returns `(d,(d‚Åª¬πs‚ÇÅ,‚Ä¶,d‚Åª¬πs‚Çô))`
"""
leftgcd(M::LocallyGarsideMonoid{T},simp::Vararg{T,N}) where {T,N}=first(leftgcdc(M,simp...))

function rightgcdc(M::LocallyGarsideMonoid{T},simp::Vararg{T,N})where {T,N}
  if N==0 error("rightgcd needs at least one simple as argument") end
  d=one(M)
  while true
    found=false
    for (i,a) in pairs(M.atoms)
      if all(b->isrightdescent(M,b,i),simp)
        found=true
        d=*(M,a,d)
        simp=map(x->/(M,x,a),simp)
      end
    end
    if !found return (d,simp) end
  end
end

"""
`rightgcd(M::LocallyGarsideMonoid,s‚ÇÅ,‚Ä¶,s‚Çô)`
`rightgcdc(M::LocallyGarsideMonoid,s‚ÇÅ,‚Ä¶,s‚Çô)`

`s‚ÇÅ,‚Ä¶,s‚Çô` should be simples of `M`. The  function returns the right gcd `d` of
the `s·µ¢`.

`rightgcdc` returns `(d,(s‚ÇÅd‚Åª¬π,‚Ä¶,s‚Çôd‚Åª¬π))`
"""
rightgcd(M::LocallyGarsideMonoid{T},simp::Vararg{T,N}) where{T,N}=
  first(rightgcdc(M,simp...))

"""
`Œ±2(M::LocallyGarsideMonoid,x,v)` returns M(x)*M(v)[1],M(x)*M(v)[2] 
for the simples x and v
"""
function Œ±2(M::LocallyGarsideMonoid,x,v)
  while true
    i=findfirst(i->isleftdescent(M,v,i) && isrightascent(M,x,i),
                eachindex(M.atoms))
    if isnothing(i) return (x,v) end
    a=atom(M,i)
    x=*(M,x,a) # could use mul! if make a copy of x first
    v=\(M,a,v)
  end
end

function Œ±2(M::GarsideMonoid,x,v)
  g,(_,cv)=leftgcdc(M,rightcomplŒ¥(M,x),v)
  (*(M,x,g),cv)
end

function rightlcmc(M::GarsideMonoid{T},simp::Vararg{T,N})where {T,N}
  _,c=rightgcdc(M,rightcomplŒ¥.(M,simp)...)
  *(M,simp[1],c[1]),c
end

"""
`rightlcm(M::GarsideMonoid,s‚ÇÅ,‚Ä¶,s‚Çô)`
`rightlcmc(M::GarsideMonoid,s‚ÇÅ,‚Ä¶,s‚Çô)`

`s‚ÇÅ,‚Ä¶,s‚Çô` should be simples of `M`. The  function returns the right lcm `m` of
the `s·µ¢`.

`rightlcmc` returns `(m,(s‚ÇÅ‚Åª¬πm,‚Ä¶,s‚Çô‚Åª¬πm))`
"""
rightlcm(M::GarsideMonoid{T},simp::Vararg{T,N}) where {T,N}=
  first(rightlcmc(M,simp...))

function leftlcmc(M::GarsideMonoid{T},simp::Vararg{T,N})where {T,N}
  _,c=leftgcdc(M,leftcomplŒ¥.(M,simp)...)
  *(M,c[1],simp[1]),c
end

"""
`leftlcm(M::GarsideMonoid,s‚ÇÅ,‚Ä¶,s‚Çô)`
`leftlcmc(M::GarsideMonoid,s‚ÇÅ,‚Ä¶,s‚Çô)`

`s‚ÇÅ,‚Ä¶,s‚Çô` should be simples of `M`. The  function returns the left lcm `m` of
the `s·µ¢`.

`leftlcmc` returns `(m,(ms‚ÇÅ‚Åª¬π,‚Ä¶,ms‚Çô‚Åª¬π))`
"""
leftlcm(M::GarsideMonoid{T},simp::Vararg{T,N}) where {T,N}=
   first(leftlcmc(M,simp...))

atom(M::LocallyGarsideMonoid,i)=M.atoms[i]

function (M::LocallyGarsideMonoid{T})(l::Vararg{<:Integer})where {T}
  if isempty(l) return GarsideElt(M,T[];check=false) end
  if l[1]>0 res=GarsideElt(M,[atom(M,l[1])];check=false)
  else res=inv(M(-l[1]))
  end
  for s in l[2:end]
    res*= s>0 ? atom(M,s) : M(s) # not very efficient when negative indices
  end
  res
end

# whether the simple x is one
Base.isone(M::LocallyGarsideMonoid,x)=x==one(M)

function (M::LocallyGarsideMonoid{T})(r::T)where T
  if hasfield(typeof(M),:Œ¥) && r==M.Œ¥ GarsideElt(M,T[],1;check=false)
  elseif isone(M,r) GarsideElt(M,T[];check=false)
  else GarsideElt(M,[r];check=false)
  end
end

"""
`word(M::GarsideMonoid,w)`

returns a word in the atoms of `M` representing the simple `w`

```julia-repl
julia> B=BraidMonoid(coxgroup(:A,3))
BraidMonoid(A‚ÇÉ)

julia> word(B,B.Œ¥)
6-element Vector{Int64}:
 1
 2
 1
 3
 2
 1
```
"""
function PermGroups.word(M::LocallyGarsideMonoid,w)
  res=Int[]
  while true
    i=firstleftdescent(M,w)
    if i===nothing return res end
    push!(res,i)
    w=\(M,atom(M,i),w)
  end
end

PermGroups.word(io::IO,M::LocallyGarsideMonoid,w)=joindigits(word(M,w);sep=" ")

"""
left_divisors(M::LocallyGarsideMonoid, s)

left_divisors(M::LocallyGarsideMonoid, s,i)

all  the left-divisors  of the  simple element  `s` of  `M`, as a vector of
vectors   of  simples,  where  the  i+1-th  vector  of  simples  holds  the
left-divisors  of length i in the atoms.  If a third argument `i` is given,
returns the list of divisors of length `i`.

```julia-repl
julia> W=coxgroup(:A,3)
A‚ÇÉ

julia> B=BraidMonoid(W)
BraidMonoid(A‚ÇÉ)

julia> map(x->B.(x),left_divisors(B,W(1,3,2)))
4-element Vector{Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}}:
 [.]
 [1, 3]
 [13]
 [132]

julia> B=DualBraidMonoid(W)
DualBraidMonoid(A‚ÇÉ,c=[1, 3, 2])

julia> map(x->B.(x),left_divisors(B,W(1,3,2)))
4-element Vector{Vector{GarsideElt{Perm{Int16}, DualBraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}}:
 [.]
 [1, 2, 3, 4, 5, 6]
 [12, 13, 15, 25, 34, 45]
 [Œ¥]
```
"""
function left_divisors(M::LocallyGarsideMonoid,s,i=-1)
  rest=[(left=one(M),right=s)]
  res=typeof(rest)[]
  while !isempty(rest)
    if length(res)==i return first.(rest) end
    push!(res,rest)
    new=empty(rest)
    for x in rest, i in leftdescents(M,x.right)
      push!(new,(left=*(M,x.left,M.atoms[i]),right=\(M,M.atoms[i],x.right)))
    end
    rest=unique(new)
  end
  map(x->first.(x),res)
end

CoxGroups.leftdescents(M::LocallyGarsideMonoid,s)=
     filter(i->isleftdescent(M,s,i),eachindex(M.atoms))

"""
`rightascents(M,s)` where `s` is a simple return the right ascents of `s`,
that is the list of `i` such that `s*M.atoms[i]` is still simple.
"""
rightascents(M::LocallyGarsideMonoid,s)=
     filter(i->isrightascent(M,s,i),eachindex(M.atoms))

rightcomplŒ¥(M::GarsideMonoid,x)=\(M,x,M.Œ¥)
leftcomplŒ¥(M::GarsideMonoid,x)=/(M,M.Œ¥,x)
isrightascent(M::GarsideMonoid,x,i)=isleftdescent(M,rightcomplŒ¥(M,x),i)

# w^(M.Œ¥^i)
"""
`Œ¥ad(M::GarsideMonoid,x,i=1)`

returns the image of the simple `x` by the `i`-th power of the automorphism
induced by conjugation by `M.Œ¥` (that is `x^(M.Œ¥^i)`).
"""
function Œ¥ad(M::GarsideMonoid,x,i::Integer=1)
  if IntervalStyle(M)==Interval() #horrible: has to know interval exists
    return iszero(i) ? x : x^(M.Œ¥^mod(i,M.orderŒ¥))
  end
  for j in i:-1:1 x=rightcomplŒ¥(M,rightcomplŒ¥(M,x)) end
  for j in i:-1   x=leftcomplŒ¥(M,leftcomplŒ¥(M,x)) end
  x
end

"""
`elements(M::LocallyGarsideMonoid,l::Integer)`
`elements(M::LocallyGarsideMonoid,v::AbstractVector{<:Integer})`

`M`  should have  an additive  length function  (that is,  a product of `l`
atoms  is not equal to any product of less than `l` atoms). `elements(M,l)`
returns the list of elements of length `l` in `M`.

In the second form `elements` returns all elements of length `i` for `i‚àà v`.

```julia-repl
julia> M=BraidMonoid(coxgroup(:A,2))
BraidMonoid(A‚ÇÇ)

julia> elements(M,4)
12-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 Œî.1
 Œî.2
 12.21
 12.2.2
 1.12.2
 1.1.12
 1.1.1.1
 21.12
 21.1.1
 2.21.1
 2.2.21
 2.2.2.2
```
"""
function PermGroups.elements(M::LocallyGarsideMonoid,l::Integer)
  d=get!(M.prop,:elements)do
    Dict(0=>[M()],1=>M.(eachindex(M.atoms)))
  end
  get!(d,l)do
    res=empty(d[1])
    for b in elements(M,l-1)
      lb=length(b.elm)
      if iszero(lb) r=Int[]
      else
        r=rightascents(M,b.elm[lb])
        if lb==1 rr=Int[] else rr=rightascents(M,b.elm[lb-1]) end
        for s in r
          w=*(M,b.elm[lb],M.atoms[s])
          if !any(i->isleftdescent(M,w,i),rr)
            elm=copy(b.elm)
            elm[end]=w
            push!(res,clone(b,elm))
          end
        end
      end
      for i in setdiff(eachindex(M.atoms),r)
        push!(res,clone(b,vcat(b.elm,[M.atoms[i]])))
      end
    end
    unique!(res)
  end
end

PermGroups.elements(M::LocallyGarsideMonoid,l::AbstractVector{<:Integer})=
  vcat(elements.(M,l)...)

#--------------------Interval: a trait-----------------------------------
abstract type IntervalStyle end
struct Interval<:IntervalStyle end
struct NoInterval<:IntervalStyle end
IntervalStyle(M::LocallyGarsideMonoid)=NoInterval()

Base.one(M::LocallyGarsideMonoid)=one(IntervalStyle(M),M)
Base.one(::Interval,M)=one(M.W)
Base.:*(M::LocallyGarsideMonoid,x,y)=*(IntervalStyle(M),M,x,y)
Base.:*(::Interval,M,x,y)=x*y
Base.:\(M::LocallyGarsideMonoid,x,y)=\(IntervalStyle(M),M,x,y)
Base.:\(::Interval,M,x,y)=x\y
Base.:/(M::LocallyGarsideMonoid,x,y)=/(IntervalStyle(M),M,x,y)
Base.:/(::Interval,M,x,y)=x/y
#Base.inv(M::LocallyGarsideMonoid,x)=inv(IntervalStyle(M),M,x)
#Base.inv(::Interval,M,x)=inv(x)
CoxGroups.isrightdescent(M::LocallyGarsideMonoid,w,i::Integer)=isrightdescent(IntervalStyle(M),M,w,i)
CoxGroups.isrightdescent(::Interval,M,w,i)=isleftdescent(M,inv(w),i)
mul!(M::LocallyGarsideMonoid,x,y)=mul!(IntervalStyle(M),M,x,y)
mul!(::Interval,M::LocallyGarsideMonoid{<:Perm},x,y)=Perms.mul!(x,y)
mul!(::Interval,M,x,y)=*(M,x,y)
mul!(::NoInterval,M,x,y)=*(M,x,y)
Base.reverse(M::LocallyGarsideMonoid,x)=reverse(IntervalStyle(M),M,x)
Base.reverse(::Interval,M,x)=inv(x)

#-----------------------BraidMonoid-----------------------------------
@GapObj struct BraidMonoid{T,TW}<:GarsideMonoid{T}
  Œ¥::T
  orderŒ¥::Int
  stringŒ¥::String
  one::T  # removing and using one(M.W) for one(M) gives more allocations
  atoms::Vector{T}
  W::TW
end

IntervalStyle(M::BraidMonoid)=Interval()
"""
`BraidMonoid(W::CoxeterGroup)`

The ordinary monoid of the Artin group associated to `W`
"""
BraidMonoid(W::FiniteCoxeterGroup)=BraidMonoid(longest(W),2,"\\Delta",one(W),
                                               gens(W),W,Dict{Symbol,Any}())

Base.show(io::IO, M::BraidMonoid)=print(io,"BraidMonoid(",M.W,")")
Base.one(M::BraidMonoid)=M.one

"""
`isleftdescent(M,w,i)`

returns `true` if and only if the `i`-th atom of the locally Garside monoid
`M` left-divides the simple `w`.
"""
CoxGroups.isleftdescent(M::BraidMonoid,w,i::Int)=isleftdescent(M.W,w,i)
CoxGroups.isrightdescent(M::BraidMonoid,w,i::Int)=isrightdescent(M.W,w,i)
isrightascent(M::BraidMonoid,w,i::Int)=!isrightdescent(M.W,w,i)

PermGroups.word(M::BraidMonoid,w)=word(M.W,w)

function rightgcdc(M::BraidMonoid{T},simp::Vararg{T,N})where{T,N}
  g,c=leftgcdc(M,inv.(simp)...)
  inv(g),inv.(c)
end

rightgcd(M::BraidMonoid{T},simp::Vararg{T,N}) where{T,N}=
  inv(leftgcd(M,inv.(simp)...))

BraidMonoid(W::Weyl.Affine)=BraidMonoid(W.G)

#-----------------------ArtinMonoid-----------------------------------
# Artin monoid for arbitrary (e.g. infinite) finitely generated Coxeter groups
@GapObj struct ArtinMonoid{T,TW}<:LocallyGarsideMonoid{T}
  one::T
  atoms::Vector{T}
  W::TW
end

# The repetitions below reflect the poor type system of Julia
IntervalStyle(M::ArtinMonoid)=Interval()
BraidMonoid(W::CoxeterGroup)=ArtinMonoid(one(W),gens(W),W,Dict{Symbol,Any}())

Base.show(io::IO, M::ArtinMonoid)=print(io,"BraidMonoid(",M.W,")")
Base.one(M::ArtinMonoid)=M.one

CoxGroups.isleftdescent(M::ArtinMonoid,w,i::Int)=isleftdescent(M.W,w,i)
CoxGroups.isrightdescent(M::ArtinMonoid,w,i::Int)=isrightdescent(M.W,w,i)
isrightascent(M::ArtinMonoid,w,i::Int)=!isrightdescent(M.W,w,i)

PermGroups.word(M::ArtinMonoid,w)=word(M.W,w)

function rightgcdc(M::ArtinMonoid{T},simp::Vararg{T,N})where {T,N}
  g,c=leftgcdc(M,inv.(simp)...)
  inv(g),inv.(c)
end

rightgcd(M::ArtinMonoid{T},simp::Vararg{T,N}) where {T,N}=
  inv(leftgcd(M,inv.(simp)...))

#---------------------------------------------------------------------
abstract type MonoidElt end
abstract type LocallyGarsideElt{T,TM<:LocallyGarsideMonoid}<:MonoidElt end

struct GarsideElt{T,TM}<:LocallyGarsideElt{T,TM}
  M::TM
  elm::Vector{T}
  pd::Int
  # assume elm is a normal form perhaps not reduced if check=true
  function GarsideElt(M::TM,elm::AbstractVector{T},pd=0;check=true) where {T,TM<:GarsideMonoid}
    if !check return new{T,TM}(M,elm,pd) end
    i=1; while i<=length(elm) && elm[i]==M.Œ¥ i+=1;pd+=1 end
    j=length(elm); while j>0 && isone(M,elm[j]) j-=1 end
    if i>1 || j<length(elm) new{T,TM}(M,view(elm,i:j),pd)
    else new{T,TM}(M,elm,pd)
    end
  end
end

struct GenGarsideElt{T,TM}<:LocallyGarsideElt{T,TM}
  M::TM
  elm::Vector{T}
end

function GarsideElt(M::LocallyGarsideMonoid,elm::AbstractVector;check=true)
  if check
    j=length(elm)
@inbounds while j>0 && isone(M,elm[j])
      j-=1
    end
    resize!(elm,j)
  end
  GenGarsideElt(M,elm)
end

clone(b::GenGarsideElt,elm;check=true)=GarsideElt(b.M,elm;check)
clone(b::GarsideElt{T,TM},elm::AbstractVector{T},pd=b.pd;check=true) where{T,TM}=
   GarsideElt(b.M,elm,pd;check)
Base.one(b::LocallyGarsideElt)=clone(b,empty(b.elm),0;check=false)
Base.isone(b::GarsideElt)=isempty(b.elm) && iszero(b.pd)
Base.copy(b::GarsideElt)=clone(b,copy(b.elm);check=false)

function Base.cmp(a::GarsideElt,b::GarsideElt)
  c=cmp(a.pd,b.pd)
  if c!=0 return c end
  cmp(a.elm,b.elm)
end

Base.isless(a::GarsideElt,b::GarsideElt)=cmp(a,b)==-1
Base.:(==)(a::GarsideElt,b::GarsideElt)=a.pd==b.pd && a.elm==b.elm

# hash is needed for using GarsideElt in Sets/Dicts
function Base.hash(a::GarsideElt, h::UInt)
  h=hash(a.pd, h)
  for e in a.elm
    h=hash(e, h)
  end
  h
end

"""
`Œ¥ad(b::GarsideElt,i=1)`

returns the image of `b` by the `i`-th power of the automorphism
induced by conjugation by `b.M.Œ¥`.
"""
Œ¥ad(b::GarsideElt,i::Integer=1)=clone(b,map(x->Œ¥ad(b.M,x,i),b.elm))

CoxGroups.isleftdescent(b::LocallyGarsideElt,i)=isleftdescent(b.M,head(b),i)
"""
`leftdescents(b::LocallyGarsideElt)` the list of indices of the atoms
which left-divide `b`
"""
CoxGroups.leftdescents(b::LocallyGarsideElt)=filter(i->isleftdescent(b,i),eachindex(b.M.atoms))

# left-divisors of b whose leftdescents don't intersect avoid
function left_divisors(b::LocallyGarsideElt,avoid)
  M=b.M
  if isone(b) return [b] end
  s=reduce(vcat,left_divisors(M,head(b))[2:end])
  if !isempty(avoid)
    s=filter(x->isempty(intersect(leftdescents(M,x),avoid)),s)
  end
  res=[M()]
  for x in s
    append!(res,x.*left_divisors(x\b,rightascents(M,x)))
  end
  res
end

function left_divisors(b::LocallyGarsideElt,avoid,i)
  M=b.M
  if iszero(i) return [M()] end
  s=left_divisors(M,head(b))
  res=typeof(b)[]
  for j in 1:min(length(s)-1,i)
    sj=filter(x->isempty(intersect(leftdescents(M,x),avoid)),s[j+1])
    for x in sj
      append!(res,x.*left_divisors(x\b,rightascents(M,x),i-j))
    end
  end
  res
end

"""
`left_divisors(b::LocallyGarsideElt[, i])`

returns all left-divisors of `b` (left-divisors of length `i` if specified)

```julia-repl
julia> B=DualBraidMonoid(coxsym(4))
DualBraidMonoid(ùîñ ‚ÇÑ,c=[1, 3, 2])

julia> left_divisors(B(1,5,4,3))
10-element Vector{GarsideElt{Perm{Int16}, DualBraidMonoid{Perm{Int16}, CoxSym{Int16}}}}:
 .
 1
 1.4
 1.4.2
 1.4.3
 5
 6
 15
 15.4
 15.4.3

julia> left_divisors(B(1,5,4,3),1)
3-element Vector{GarsideElt{Perm{Int16}, DualBraidMonoid{Perm{Int16}, CoxSym{Int16}}}}:
 1
 5
 6
```
"""
left_divisors(b::LocallyGarsideElt)=left_divisors(b,Int[])
left_divisors(b::LocallyGarsideElt,i::Integer)=left_divisors(b,Int[],i)
right_divisors(b::LocallyGarsideElt)=map(reverse,left_divisors(reverse(b)))

"""
`Brieskorn_normal_form(b::LocallyGarsideElt)`

Brieskorn  citeBri71 has noticed that if `L(b)`  is the left descent set of
`b`  (see [`leftdescents`](@ref)),  and if  `b_(L(b))` is  the right lcm of
`L(b)`,  then  `b_(L(b))`  left-divides  `b`.  We  can  now  divide  `b` by
`b_(L(b))`  and continue  this process  with the  quotient. In this way, we
obtain  an expression  `b=b_(L‚ÇÅ)‚ãØ b_(L·µ£)`  where `L·µ¢=L(b_(L·µ¢)‚ãØ b_(L·µ£))` for
all  `i`, which we  call the *Brieskorn  normal form* of  `b`. The function
`Brieskorn_normal_form`  returns a  description of  this form, by returning
the   list  of  sets   `L(b)`  which  describe   the  above  decomposition.
```julia-repl
julia> W=coxgroup(:E,8);B=BraidMonoid(W)
BraidMonoid(E‚Çà)

julia> w=B(2,3,4,2,3,4,5,4,2,3,4,5,6,5,4,2,3,4,5,6,7,6,5,4,2,3,4,5,6,7,8)
2342345423456542345676542345678

julia> Brieskorn_normal_form(w)
2-element Vector{Vector{Int64}}:
 [2, 3, 4, 5, 6, 7]
 [8]

julia> Brieskorn_normal_form(w^2)
2-element Vector{Vector{Int64}}:
 [2, 3, 4, 5, 6, 7, 8]
 [2, 3, 4, 5, 6]
```
"""
function Brieskorn_normal_form(b::LocallyGarsideElt)
  res=Vector{Int}[]
  while !isone(b)
    I=leftdescents(b)
    push!(res,I)
    b=b.M(rightlcm(b.M,b.M.atoms[I]...))\b
  end
  res
end

function Base.inv(b::GarsideElt)
  k=length(b.elm)
  M=b.M
  GarsideElt(M,map(i->Œ¥ad(M,\(M,b.elm[i],M.Œ¥),-i-b.pd),k:-1:1),-b.pd-k;check=false)
end

Base.:/(a::GarsideElt,b::GarsideElt)=a*inv(b)
Base.:\(a::GarsideElt,b::GarsideElt)=inv(a)*b
# a\b when b is positive and the result is positive
Base.:\(a::T,b::LocallyGarsideElt{T}) where T=\(b.M,a,head(b))*tail(b)

function Base.denominator(b::GarsideElt)
  if b.pd>=0 return one(b) end
  ib=inv(b)
  if b.pd<-length(b.elm) ib
  else GarsideElt(b.M,@view ib.elm[end+b.pd+1:end];check=false)
  end
end

function Base.numerator(b::GarsideElt)
  if b.pd>=0 return b
  elseif b.pd<-length(b.elm) return one(b)
  else GarsideElt(b.M,b.elm[1-b.pd:end];check=false)
  end
end

"""
  - `fraction(b::GarsideElt)`
  - `denominator(b::GarsideElt)`
  - `numerator(b::GarsideElt)`

`fraction(b)`  returns a  tuple `(x,y)`  of positive  Garside elements with
trivial  `leftgcd`  and  such  that  `b=x\\y`.  For  such  a decomposition,
`denominator(b)` returns `x` and `numerator(b)` returns `y`.
```julia-repl
julia> B=BraidMonoid(coxgroup(:A,3))
BraidMonoid(A‚ÇÉ)

julia> b=B( 2, 1, -3, 1, 1)
(23)‚Åª¬π321.1.1

julia> fraction(b)
(23, 321.1.1)
```
"""
fraction(b::GarsideElt)=(denominator(b),numerator(b))

Base.length(x::GarsideElt)=x.pd+length(x.elm) # Garside length
Base.length(x::LocallyGarsideElt)=length(x.elm)

function Base.getindex(x::LocallyGarsideElt,i::Integer)
  if i>length(x.elm) return one(x.M)
  else return x.elm[i]
  end
end

function Base.getindex(x::GarsideElt{T},i::Integer)::T where T
  if x.pd<0 error("getindex only defined for positive elements") end
  i<=x.pd ? x.M.Œ¥ : i<=length(x) ? x.elm[i-x.pd] : one(x.M)
end

Base.getindex(x::LocallyGarsideElt{T},i::AbstractVector{<:Integer}) where T=
  map(j->x[j]::T,i)

Base.lastindex(x::LocallyGarsideElt)=length(x)

head(x::LocallyGarsideElt)=x[1]

"""
`Œ±(b::LocallyGarsideElt)`

returns as a Garside element  the first term in  the normal form of  `b`
(the expression `b[1]` returns this term as a simple).

```julia-repl
julia> W=coxgroup(:A,3)
A‚ÇÉ

julia> b=BraidMonoid(W)(2,1,2,1,1)
121.1.1

julia> Œ±(b)
121
```
"""
Œ±(b::LocallyGarsideElt)=GarsideElt(b.M,[head(b)])

"""
`Œ±(b::LocallyGarsideElt,I)`

returns the longest prefix of b using only `b.M.atoms[I]`
```julia-repl
julia> W=coxgroup(:A,4);B=BraidMonoid(W)
BraidMonoid(A‚ÇÑ)

julia> w0=B(longest(W))
Œî

julia> Œ±(w0,[1,2,3])
121321
```
"""
function Œ±(b::LocallyGarsideElt,I::AbstractVector)
  M=b.M
  res=M()
  i=1
  while i<=length(I)
    if isleftdescent(b,I[i])
      s=M.atoms[I[i]]
      res*=s
      b=s\b
      i=1
    else i+=1
    end
  end
  res
end

function tail(b::GarsideElt)
  if isone(b) return b end
  if b.pd<0 error("tail is for positive elements")
  elseif b.pd>0 clone(b,b.elm,b.pd-1;check=false)
  else clone(b,b[2:end];check=false)
  end
end

function tail(b::LocallyGarsideElt)
  if isone(b) return b end
  clone(b,b[2:end];check=false)
end

"""
`word(b::GarsideElt)`

returns  a description  of `b`  as a  list of  the atoms  of which  it is a
product.  If `b` is in the Garside group  but not the Garside monoid, it is
represented  in  fraction  normal  form  where  as a special convention the
inverses  of  the  atoms  are  represented  by  negating  the corresponding
integer.

```julia-repl
julia> B=BraidMonoid(coxgroup(:A,3))
BraidMonoid(A‚ÇÉ)

julia> b=B(2,1,2,1,1)*inv(B(2,2))
(21)‚Åª¬π1.12.21

julia> word(b)
7-element Vector{Int64}:
 -1
 -2
  1
  1
  2
  2
  1
```
"""
function PermGroups.word(b::GarsideElt)
  M=b.M
  res=Int[]
  if b.pd<0
    d,n=fraction(b)
    return vcat(-reverse(word(d)),word(n))
  end
  for i in 1:b.pd append!(res,word(M,M.Œ¥)) end
  for e in b.elm append!(res,word(M,e)) end
  res
end

PermGroups.word(b::LocallyGarsideElt)=vcat(word.(b.M,b.elm)...)

function Base.show(io::IO,b::GarsideElt)
  if !hasdecor(io)
    print(io,"B(",join(word(b),","),")")
    return
  end
  function p(b)
    l=map(e->word(io,b.M,e),b.elm)
    if b.pd!=0 pushfirst!(l,fromTeX(io,b.M.stringŒ¥)*stringexp(io,b.pd)) end
    join(l,".")
  end
  if isone(b) print(io,".")
  elseif get(io,:greedy,false) print(io,p(b))
  else den,num=fraction(b)
    if !isone(den) print(io,"(",p(den),")",stringexp(io,-1)) end
    print(io,p(num))
  end
end

function Base.show(io::IO,b::LocallyGarsideElt)
  if !hasdecor(io)
    print(io,"B(",join(word(b),","),")")
    return
  end
  printTeX(io,isempty(b.elm) ? "." : join(map(e->word(io,b.M,e),b.elm),"."))
end

# simple * braid
function Base.:*(x::T,b::LocallyGarsideElt{T})where T
  M=b.M
  v=b.elm
  res=empty(v)
  for i in 1:length(v)
    a,x=Œ±2(M,x,v[i])
    push!(res,a)
    if x==v[i] return GarsideElt(M,append!(res,v[i:end]))
    elseif isone(M,x) return GarsideElt(M,append!(res,v[i+1:end]))
    end
  end
  GarsideElt(M,push!(res,x))
end

# multiply a simple x by a Garside element b (Gap3 PrefixToNormal)
function Base.:*(x::T,b::GarsideElt{T})where T
  M=b.M
  v=b.elm
  res=empty(v)
  pd=0
  x=Œ¥ad(M,x,b.pd)
  for i in 1:length(v)
    a,x=Œ±2(M,x,v[i])
    if a==M.Œ¥ pd+=1 else push!(res,a) end
    if x==v[i] return GarsideElt(M,append!(res,v[i:end]),pd+b.pd;check=false)
    elseif isone(M,x) return GarsideElt(M,append!(res,v[i+1:end]),pd+b.pd;check=false)
    end
  end
  GarsideElt(M,push!(res,x),pd+b.pd)
end

# multiply by simple; Gap3 AddToNormal
function Base.:*(a::LocallyGarsideElt{T},x::T)where T
  M=a.M
  if isone(M,x) return a end # see if can suppress this special case
  v=copy(a.elm)
  push!(v,x)
  for i in length(v):-1:2
    x,y=Œ±2(M,v[i-1],v[i])
    if isone(M,y) # this implies i==length(v)
      resize!(v,i-1)
      v[i-1]=x
    elseif x==v[i-1] break
    else  v[i-1]=x;v[i]=y
    end
  end
  GarsideElt(M,v)
end

function Base.:*(a::GarsideElt{T},x::T)where T
  M=a.M
  if isone(M,x) return a end # see if can suppress this special case
  v=copy(a.elm)
  push!(v,x)
  for i in length(v):-1:2
    x,y=Œ±2(M,v[i-1],v[i])
    if isone(M,y) # this implies i==length(v)
      if x==M.Œ¥
        return GarsideElt(M,Œ¥ad.(M,v[1:end-2],1),1+a.pd;check=false)
      end
      resize!(v,i-1)
      v[i-1]=x
    elseif x==v[i-1] break
    elseif x==M.Œ¥
      v[i]=y
      v[2:i-1]=Œ¥ad.(M,v[1:i-2],1)
      return GarsideElt(M,v[2:end],1+a.pd;check=false)
    else v[i-1]=x;v[i]=y
    end
  end
  clone(a,v;check=length(v)==1)
end

function Base.:*(a::LocallyGarsideElt{T},b::LocallyGarsideElt{T})where T
  res=a
  for x in b.elm
    res*=x
  end
  res
end

function Base.:*(a::GarsideElt{T},b::GarsideElt{T})where T
  res=GarsideElt(a.M,Œ¥ad.(a.M,a.elm,b.pd),a.pd+b.pd;check=false)
  for x in b.elm
    res*=x
  end
  res
end

# conjugation of positive b by simple r assuming that r divides b*r
# About 30% faster than b^b.M(r) for long words
function Base.:^(b::GarsideElt{T},r::T,F::Function=x->x) where T
  if isone(b.M,r) return b end
  r\(b*F(r))
end

Base.:^(a::LocallyGarsideElt, n::Integer)=n>=0 ? Base.power_by_squaring(a,n) :
                                             Base.power_by_squaring(inv(a),-n)

Base.:^(a::GarsideElt,b::GarsideElt,F::Function=x->x)=b\a*F(b)

function Base.reverse(b::GarsideElt)
  if haskey(b.M,:revMonoid)
    res=GarsideElt(b.M.revMonoid,empty(b.elm),b.pd;check=false)
    if isempty(b.elm) return res end
    for s in reverse(b.elm)
      res*=Œ¥ad(b.M.revMonoid,reverse(b.M,s),b.pd)
    end
  else
    if b.M isa DualBraidMonoid && !all(w->isone(w^2),gens(b.M.W))
      error("no reversing theory for ",b.M)
    end
    if isempty(b.elm) return b end
    res=GarsideElt(b.M,empty(b.elm),b.pd;check=false)
    for s in reverse(b.elm)
      res*=Œ¥ad(b.M,reverse(b.M,s),-b.pd)
    end
  end
  res
end

function Base.reverse(b::LocallyGarsideElt)
  if isempty(b.elm) return b end
  res=GarsideElt(b.M,empty(b.elm);check=false)
  for s in reverse(b.elm)
    res*=reverse(b.M,s)
  end
  res
end

function leftgcdc(elts::Vararg{LocallyGarsideElt,N})where {N}
  if isempty(elts) error("leftgcd needs an argument") end
  if length(elts)==1
    elt=only(elts)
    return (elt,(one(elt),))
  end
  M=elts[1].M
  if hasfield(typeof(M),:Œ¥)
    m=minimum(map(x->x.pd,elts))
    gcd=clone(elts[1],empty(elts[1].elm),m;check=false)
    elts=map(x->clone(x,x.elm,x.pd-m;check=false),elts)
  else
    gcd=one(elts[1])
    elts=copy.(elts)
  end
  while true
    ff=head.(elts)
    if any(isone,ff) g=one(M)
    else g,rest=leftgcdc(M,ff...)
    end
    if isone(g) return (gcd,elts)
    else gcd*=g
      elts=rest.*tail.(elts)
    end
  end
end

"""
`leftgcd(a‚ÇÅ,‚Ä¶,a‚Çô)`
`leftgcdc(a‚ÇÅ,‚Ä¶,a‚Çô)`

`a‚ÇÅ,‚Ä¶,a‚Çô`  should be  elements of  the same  (locally) Garside  monoid. The
function returns the left gcd `d` of `a‚ÇÅ,‚Ä¶,a‚Çô`.

`leftgcdc` returns `(d,(d‚Åª¬πa‚ÇÅ,‚Ä¶,d‚Åª¬πa‚Çô))`.

```julia-repl
julia> W=coxgroup(:A,3)
A‚ÇÉ

julia> B=BraidMonoid(W)
BraidMonoid(A‚ÇÉ)

julia> leftgcdc(B(2,1,2)^2,B(3,2)^2)
(2, (121.21, 32.2))
```
"""
leftgcd(elts::Vararg{LocallyGarsideElt,N}) where N=first(leftgcdc(elts...))

function rightgcdc(elts::Vararg{LocallyGarsideElt,N})where N
  g,c=leftgcdc(map(reverse,elts)...)
  reverse(g),map(reverse,c)
end

"""
`rightgcd(a‚ÇÅ,‚Ä¶,a‚Çô)`
`rightgcdc(a‚ÇÅ,‚Ä¶,a‚Çô)`

`a‚ÇÅ,‚Ä¶,a‚Çô`  should be  elements of  the same  (locally) Garside  monoid. The
function returns the right gcd `d` of `a‚ÇÅ,‚Ä¶,a‚Çô`

`rightgcdc` returns `(d,(a‚ÇÅ/d,‚Ä¶,a‚Çô/d))`.

```julia-repl
julia> W=coxgroup(:A,3)
A‚ÇÉ

julia> B=BraidMonoid(W)
BraidMonoid(A‚ÇÉ)

julia> rightgcdc(B(2,1,2)^2,B(3,2)^2)
(2.2, (12.21, 23))
```
"""
rightgcd(elts::Vararg{LocallyGarsideElt,N}) where N=
  reverse(leftgcd(map(reverse,elts)...))

function leftlcmc(elts::Vararg{GarsideElt,N})where N
  if isempty(elts) error("leftlcm needs an argument") end
  if length(elts)==1
    elt=only(elts)
    return (elt,(one(elt),))
  end
  x,c=leftgcdc(inv.(elts)...)
  (inv(x),c)
end

"""
`leftlcm(a‚ÇÅ,‚Ä¶,a‚Çô)`
`leftlcmc(a‚ÇÅ,‚Ä¶,a‚Çô)`

`a‚ÇÅ,‚Ä¶,a‚Çô`  should  be  elements  of  the  same Garside monoid. The function
returns  the least common left multiple  `m` of `a‚ÇÅ,‚Ä¶,a‚Çô`.

`leftlcmc` returns '(m,(m/a‚ÇÅ,‚Ä¶,m/a‚Çô))`.

```julia-repl
julia> B=BraidMonoid(coxgroup(:A,3))
BraidMonoid(A‚ÇÉ)

julia> leftlcmc(B(2,1,2)^2,B(3,2)^2)
(Œî.121, (123, 23.321))
```
"""
leftlcm(elts::Vararg{GarsideElt,N}) where N=first(leftlcmc(elts...))

function rightlcmc(elts::Vararg{GarsideElt,N}) where N
  g,c=leftlcmc(map(reverse,elts)...)
  reverse(g),map(reverse,c)
end

"""
`rightlcm(a‚ÇÅ,‚Ä¶,a‚Çô)`
`rightlcmc(a‚ÇÅ,‚Ä¶,a‚Çô)`

`a‚ÇÅ,‚Ä¶,a‚Çô`  should  be  elements  of  the  same Garside monoid. The function
returns  the least common right multiple  `m` of `a‚ÇÅ,‚Ä¶,a‚Çô`.

`rightlcmc` returns '(m,(a‚ÇÅ‚Åª¬π*m,‚Ä¶,a‚Çô‚Åª¬π*m))`.

```julia-repl
julia> B=BraidMonoid(coxgroup(:A,3))
BraidMonoid(A‚ÇÉ)

julia> rightlcmc(B(2,1,2)^2,B(3,2)^2)
(Œî¬≤, (321.123, 12321.321))
```
"""
rightlcm(elts::Vararg{GarsideElt,N}) where N=reverse(leftlcm(map(reverse,elts)...))

Cosets.Frobenius(x::GarsideElt,phi)=clone(x,Frobenius.(x.elm,phi))

"""
`image(b::GarsideElt)`

This  function is defined only if `b`  is an element of an interval monoid,
for instance a braid. It returns the image of `b` in the group of which the
monoid  is an interval  monoid. For instance  it gives the  projection of a
braid in an Artin monoid back to the Coxeter group.

```julia-repl
julia> W=coxsym(4)
ùîñ ‚ÇÑ

julia> b=BraidMonoid(W)(2,1,2,1,1)
121.1.1

julia> p=image(b)
(1,3)

julia> word(W,p)
3-element Vector{Int64}:
 1
 2
 1
```
"""
function image(a::GarsideElt)
  if IntervalStyle(a.M)==Interval() a.M.Œ¥^a.pd*prod(a.elm)
  else error(a," should be an element of an interval monoid")
  end
end

"""
`words(b::LocallyGarsideElt)`

returns all the decompositions in atoms of `b`

```julia-repl
julia> W=coxgroup(:A,2)
A‚ÇÇ

julia> pi=BraidMonoid(W)(longest(W))^2
Œî¬≤

julia> words(pi)
8-element Vector{Vector{Int64}}:
 [1, 1, 2, 1, 1, 2]
 [1, 2, 1, 1, 2, 1]
 [1, 2, 1, 2, 1, 2]
 [1, 2, 2, 1, 2, 2]
 [2, 1, 1, 2, 1, 1]
 [2, 1, 2, 1, 2, 1]
 [2, 1, 2, 2, 1, 2]
 [2, 2, 1, 2, 2, 1]
```
"""
function Groups.words(b::LocallyGarsideElt)
  M=b.M
  if isone(b) return [Int[]] end
  s=head(b);œâ=tail(b)
  reduce(vcat,map(leftdescents(M,s))do i
    pushfirst!.(words(M(\(M,atom(M,i),s))*œâ),i)
  end)
end

function Groups.words(M::LocallyGarsideMonoid,w)
  if isone(M,w) return [Int[]] end
  reduce(vcat,map(leftdescents(M,w))do i
    pushfirst!.(words(M,\(M,atom(M,i),w)),i)
  end)
end

Base.rand(M::LocallyGarsideMonoid,i::Integer)=M(rand(1:length(M.atoms),i)...)

#-----------------------DualBraidMonoid-------------------------------
@GapObj struct DualBraidMonoid{T,TW}<:GarsideMonoid{T}
  Œ¥::T
  orderŒ¥::Int
  stringŒ¥::String
  Œ¥word::Vector{Int}
  atoms::Vector{T}
  one::T
  W::TW
end

IntervalStyle(M::DualBraidMonoid)=Interval()

"""
`DualBraidMonoid(W;c=xxx)`

`W`  should be a well generated complex  reflection group and `c` a Coxeter
element  of `W`, given as a  word (a `Vector{Int}`) specifiying the element
`W(c...)`. 

If  no `c`  is given  a particular  one is  chosen (what the notation `xxx`
above tries to convey). The choice is as follows:

For  `W` a Coxeter  group the Coxeter  diagram is partitioned  in two sets
where  in each set reflections commute pairwise;  `c` is the product of the
product of the reflections in each set (see `bipartite_decomposition`).

For  a complex  reflection group  the representative  stored in the Coxeter
class is used for `c`.

The  function returns the dual braid monoid  determined by `W` and `c`, the
interval  monoid  for  `W`  generated  by  its reflections and the interval
`[1,c]`.

```julia-repl
julia> W=coxgroup(:A,3)
A‚ÇÉ

julia> D=DualBraidMonoid(W)
DualBraidMonoid(A‚ÇÉ,c=[1, 3, 2])

julia> D(2,1,2,1,1)
12.1.1.1

julia> D(-1,-2,-3,1,1)
(25.1)‚Åª¬π1.1

julia> W=crg(4)
G‚ÇÑ

julia> D=DualBraidMonoid(W)
DualBraidMonoid(G‚ÇÑ,c=[1, 2])

julia> left_divisors(D(D.Œ¥))
5-element Vector{GarsideElt{Perm{Int16}, DualBraidMonoid{Perm{Int16}, PRG{Cyc{Rational{Int64}}, Int16}}}}:
 .
 1
 2
 3
 Œ¥
```
"""
function DualBraidMonoid(W::CoxeterGroup;
  c=reduce(vcat,bipartite_decomposition(W)),revMonoid=nothing)
  Œ¥=W(c...)
  M=DualBraidMonoid(Œ¥,order(Œ¥),"Œ¥",c,refls(W,1:nref(W)),one(W),W,Dict{Symbol,Any}())
  if revMonoid===nothing
    M.revMonoid=DualBraidMonoid(W;c=reverse(c),revMonoid=M)
  else M.revMonoid=revMonoid
  end
  M
end

function DualBraidMonoid(W::PermRootGroup;
  c=word(conjugacy_classes(W)[position_regular_class(W,maximum(degrees(W)))]),
  revMonoid=nothing)
  if ngens(W)>semisimplerank(W) || length(refltype(W))>1
    error(W,"must me well-generated and irreducible")
  end
  Œ¥=W(c...)
  n=reflength(W,Œ¥)
  atoms=filter(r->reflength(W,Œ¥/r)<n,unique(refls(W)))
  M=DualBraidMonoid(Œ¥,order(Œ¥),"Œ¥",c,atoms,one(W),W,Dict{Symbol,Any}())
  if revMonoid===nothing
    if all(w->isone(w^2),gens(W))
       M.revMonoid=DualBraidMonoid(W;c=reverse(c),revMonoid=M)
    end
  else M.revMonoid=revMonoid
  end
  M
end

function CoxGroups.isleftdescent(M::DualBraidMonoid,w,i::Int)
  reflength(M.W,atom(M,i)\w)<reflength(M.W,w)
end

# next is characteristic of dual monoids
CoxGroups.isrightdescent(M::DualBraidMonoid,w,i::Int)=isleftdescent(M,w,i)

Base.one(M::DualBraidMonoid)=M.one

Base.show(io::IO, M::DualBraidMonoid)=print(io,"DualBraidMonoid(",M.W,",c=",
                                            M.Œ¥word,")")

function atomsinbraidmonoid(M::DualBraidMonoid) # for coxeter groups
  get!(M,:atomsinbraidmonoid)do
    W=M.W
    h=order(M.Œ¥)
    Œ¥=word(W,M.Œ¥)
    w=repeat(Œ¥,outer=div(h,2))
    if isodd(h) append!(w,Œ¥[1:div(length(Œ¥),2)]) end
    if length(W,W(w...))!=length(w) w=repeat(Œ¥,outer=h) end
    w=map(i->vcat(w[1:i],-w[i-1:-1:1]),eachindex(w))
    B=BraidMonoid(W)
    w=unique!(map(x->B(x...),w))
    sort(w,by=x->findfirst(==(image(x)),refls(W,1:nref(W))))
  end
end

"""
`(B::BraidMonoid)(D::DualBraidMonoid,i::Integer)`

For  monoids of the  same Coxeter group,  convert to an  element of `B` the
`i`-th atom of `D`.
"""
(B::BraidMonoid)(M::DualBraidMonoid,i::Integer)=atomsinbraidmonoid(M)[i]
"""
`(B::BraidMonoid)(D::DualBraidMonoid,s)`

For  monoids of the  same Coxeter group,  convert to an  element of `B` the
simple `s` of `D`.
"""
(B::BraidMonoid)(M::DualBraidMonoid,s)=prod(B.(M,word(M,s)))
"""
`(B::BraidMonoid)(b::GarsideElt)`

`b` should be a dual braid. Convert `b` to an element of `B`.
"""
function (B::BraidMonoid)(b::GarsideElt{T,<:DualBraidMonoid})where T
  B(b.M,b.M.Œ¥)^b.pd*prod(x->B(b.M,x),b.elm;init=B())
end

#----------------------------------------------------------------------------
"""
The `struct Category{TO,TM}` represents a finite category whose objects are
of type `TO` and maps of type `TM`. It has two fields:

  - `.obj::Vector{TO}` the objects
  - `.atoms::Vector{Vector{Pair{TM,Int}}}` a vector of same length as `.obj` representing  the atoms (generators)  of the category;  `atoms[i]` is a `Vector` of pairs `m=>j` holding a map `m` from `obj[i]` to `obj[j]`.

```julia-rep1
julia> W=coxsym(4);B=BraidMonoid(W);b=B(1,1,2,2,3)
1.12.23

julia> print(conjcat(b))
Category([B(1,2,2,1,3),B(2,1,3,1,2),B(2,1,3,3,2),B(3,2,2,1,3)],[
[B(1,2)=>2, B(2,1,3)=>3],
[B(2,1,3)=>1, B(1,3,2,1)=>4],
[B(2,1,3)=>4, B(1,2,3,2)=>1],
[B(2,1,3)=>2, B(3,2)=>3]])

julia> xprint(conjcat(b);graph=true) # show graphically the category
category with 4 objects and 8 generating maps
      1232       12       213       213       213       32 
213.32‚Äï‚Äï‚Äï‚ûî 12.213‚Äï‚ûî 213.12‚Äï‚Äï‚ûî 12.213‚Äï‚Äï‚ûî 213.32‚Äï‚Äï‚ûî 32.213‚Äï‚ûî 213.32
      1321       213 
213.12‚Äï‚Äï‚Äï‚ûî 32.213‚Äï‚Äï‚ûî 213.12
```
"""
struct Category{TO,TM}
  obj::Vector{TO}
  atoms::Vector{Vector{Pair{TM,Int}}}
end

function Base.show(io::IO,::MIME"text/plain",C::Category)
  print(io,"category with ",length(C.obj)," objects and ",
        sum(length,C.atoms)," generating maps")
  if get(io,:graph,false) println(io);showgraph(io,C) end
end

function Base.show(io::IO,C::Category)
  if get(io,:limit,false) show(io,MIME("text/plain"),C)
  else
    print(io,"Category([")
    join(io,C.obj,",")
    print(io,"],[\n")
    join(io,map(x->"["*join(map(((m,o),)->repr(m)*"=>"*repr(o),x),", "),C.atoms),"],\n")
    print(io,"]])")
  end
end

"""
`Category(atomsfrom::Function,o;action::Function=^)`

constructs a category from an initial object `o` and two functions:
  - `atomsfrom(o)` given an object `o` returns  the list of atoms from `o`. 
  - `action(o,m)` returns the target object of the map `m` starting from `o`. 

If  `action` is  not given,  it is  assumed that  `o^m` does the job. While
constructing  the category, `action` is only applied for atoms `m`.

The  result is  a `Category{TO,TM}`  where `TO=typeof(o)`  and `TM`  is the
`eltype`  of the result of  `atomsfrom`. 

As an example we construct a Garside category associated to the braid group
of  `G‚ÇÉ‚ÇÅ`, realized as the  centralizer of a 4th  root of `Œ¥¬≥‚Å∞` in the dual
braid  monoid of `E‚Çà`; that is the fixed points of `Œ¥ad¬π‚Åµ` in the 2-divided
category.

```julia-repl
julia> W=coxgroup(:E,8);M=DualBraidMonoid(W)
DualBraidMonoid(E‚Çà,c=[1, 4, 6, 8, 3, 2, 5, 7])

julia> s4=left_divisors(M,M.Œ¥,4); # simples of length 4

julia> s=M(s4[findfirst(x->x*Œ¥ad(M,x,8)==M.Œ¥,s4)])#an object of 2-divided cat
(1 8 17 35)

julia> "the right-lcms of the `Œ¥‚Å±`-orbits on `leftdescents(b)`"
       function satoms(b,i)
         M=b.M
         ld=M.atoms[leftdescents(b)]
         di=Perm(ld,Œ¥ad.(Ref(M),ld,i))
         if isnothing(di) error(b," is not Œ¥^\$i-stable") end
         map(o->M(rightlcm(M,ld[o]...)),orbits(di,eachindex(ld)))
       end
satoms

julia> Category(x->satoms(x,15),s;action=(o,m)->inv(m)*o*Œ¥ad(m,8))
category with 88 objects and 660 generating maps
```
"""
function Category(atomsfrom::Function,o;action::Function=^)
  TM=eltype(atomsfrom(o))
  C=Category([o],[Pair{TM,Int}[]])
  i=1
  while i<=length(C.obj)
    b=C.obj[i]
    for m in atomsfrom(b)
      target=action(b,m)
      p=findfirst(==(target),C.obj)
  #	Print(b,"^",m.map,"->",m.tgt,"\n");
      if p===nothing
         push!(C.obj,target)
         push!(C.atoms,empty(C.atoms[1]))
         p=length(C.obj)
      end
      push!(C.atoms[i],m=>p)
    end
    i+=1
    if iszero(i%100) print(".") end
  end
  C
end

# io properties :showobj and :showmap can vary the output
function showgraph(io,C::Category)
#   If the  julia objects  of type  `TM` belong  to a  monoid, a
#   general  map can be represented  as a triple `(i,m,j)`  where `m` is of
#   type `TM` representing a map from `obj[i]` to `obj[j]`.
  maps=vcat(map(i->map(((m,t),)->[i,m,t],sort(C.atoms[i],by=x->abs(x[2]-i))),
                 eachindex(C.obj))...)
  found=true
  while found
    found=false
    new=empty(maps)
    for m in maps
      p=findfirst(x->x[end]==m[1],new)
      if p===nothing
        p=findfirst(x->x[1]==m[end],new)
        if p===nothing
          push!(new,m)
        else
          new[p]=vcat(m[1:end-1],new[p])
          found=true
        end
      else new[p]=vcat(new[p],m[2:end])
           found=true
      end
    end
    maps=new
  end
  showobj=get(io,:showobj,show)
  showmap=get(io,:showmap,show)
  for f in maps
    l1=l2=""
    for i in 1:2:length(f)-2
      a=sprint(showobj,C.obj[f[i]];context=io)
      ff=sprint(showmap,f[i+1];context=io)
      l=max(2,textwidth(ff))
      if textwidth(l1)+textwidth(a)+l+1>displaysize(io)[2]
        println(io,l1,"\n",l2)
        l1=l2=""
      end
      aa=Char[0x2192,0x2794,0x1F816,0x27F6]
      bb=Char[0x2500,0x23AF,0x2015,0x23BA,0x23BB,0x23BC,0x23BD]
      l2*=a*bb[3]^(l-1)*aa[2]*" "
      l1*=' '^textwidth(a)*lpad(ff,l)*' '
    end
    println(io,l1,"\n",l2,C.obj[f[end]])
  end
end

"""
`endomorphisms(C::Category,o::Integer)`
Assuming  the atoms of `C`  are invertible by `inv`  and maps multiply with
`*`, returns generators of the endomorphisms of `C.obj[o]`
```julia-repl
julia> W=coxsym(4);M=BraidMonoid(W)
BraidMonoid(ùîñ ‚ÇÑ)

julia> endomorphisms(conjcat(M(1,1,2,2,3)),1) # generators of centralizer
2-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, CoxSym{Int16}}}}:
 213.1232
 12.213
```
"""
function endomorphisms(C::Category{TO,TM},o::Integer)where {TO,TM}
  paths=[Tuple{Int,Int}[] for i in eachindex(C.obj)]
  paths[o]=Tuple{Int,Int}[]
  if isempty(C.atoms[o]) return TM[] end
  maps=[one(C.atoms[o][1][1]) for i in eachindex(C.obj)]
  function foo()
    reached=[o]
    for i in reached t=C.atoms[i]
      for (j,(m,o1)) in pairs(t)
        if !(o1 in reached)
          paths[o1]=vcat(paths[i],[(i,j)])
          if i!=o maps[o1]=maps[i]*m
          else maps[o1]=m
          end
          push!(reached,o1)
          if length(reached)==length(C.obj) return end
        end
      end
    end
  end
  foo()
  # here paths[p] describes a path to get from obj o to  obj p
  gens=Set(empty(maps))
  for i in eachindex(C.obj)
    t=C.atoms[i]
    for j in eachindex(t)
      if vcat(paths[i],[(i,j)])!=paths[t[j][2]]
        if i==o nmap=t[j][1]
        else nmap=maps[i]*t[j][1]
        end
        if t[j][2]==o push!(gens,nmap)
        elseif nmap!=maps[t[j][2]] push!(gens,nmap*inv(maps[t[j][2]]))
        end
      end
    end
  end
  collect(gens)
end

# return one map in C from o to o1 or nothing if none exists
function mapbetween(C::Category{TO,TM},o,o1)where {TO,TM}
  if isempty(C.atoms[o]) m=one(TM)
  else m=one(first(C.atoms[o][1]))
  end
  reached=[m=>o]
  if o==o1 return first(reached[1]) end
  j=1
  while true
    mi,i=reached[j]
    for (m,t) in C.atoms[i]
      if !any(x->t==last(x),reached)
        push!(reached,mi*m=>t)
        if t==o1 return first(reached[end]) end
      end
    end
    j+=1
    if j>length(reached) break end
  end
end

# returns atoms from a in F-twisted s-conjugacy category
function conjatoms(a,::Val{s}=Val(:sc),F::Function=(x,y=1)->x)where s
  M=a.M
  res=typeof(a)[]
  for i in eachindex(M.atoms)
    m=minc(a,M.atoms[i],Val(s),F)
    if m!==nothing && !any(k->isleftdescent(M,m,k),i+1:length(M.atoms))
      push!(res,M(m))
    end
  end
  filter(x->count(y->(y\x).pd>=0,res)==1,res)
end

# a braid x atom; return x if x‚âºa, nothing else
function minc(a,x,::Val{:cyc},F::Function=(x,y=1)->x)
  if a.pd>0 return x end
  if isone(a) return nothing end
  if isleftdescent(a,findfirst(==(x),a.M.atoms)) return x end
end

# given a Garside element a and a simple x, returns the
# minimal m such that x‚âº m and inf(inv(m)*a*F(m))>=inf(a).
# Since m=Œî works, m exists and is simple; see algorithm 2 in Franco-Gonzales 1.
function minc(a,x,::Val{:inf},F::Function=(x,y=1)->x)
  M=a.M
  m=x
  while true
    x=Œ¥ad(M,m,a.pd)
    for s in a.elm x=rightlcmc(M,x,s)[2][2] end
    m,c=rightlcmc(M,x,F(m))
    m=F(m,-1)
    if isone(M,c[2]) break end
  end
  m
end

"""
`cycle(b)`

if the normal form of `b` is `Œî‚Å±b‚ÇÅ‚Ä¶b‚Çô` then `cycle(b)=b^Œ¥ad(b‚ÇÅ,-i)`.
returns `(cycle(b),Œ¥ad(b‚ÇÅ,-i))`.
"""
function cycle(b)
  M=b.M
  l=length(b.elm)
  if l==0 return b,one(M) end
  w=Œ¥ad(M,b.elm[1],-b.pd)
  if length(b.elm)==1 return (GarsideElt(M,[w],b.pd),w) end
  clone(b,b.elm[2:end])*w,w
end

"""
`decycle(b)`

if the normal form of `b` is `Œî‚Å±b‚ÇÅ‚Ä¶b‚Çô` then `decycle(b)=b^inv(b‚Çô)`.
returns `(decycle(b),inv(b‚Çô))`.
"""
function decycle(b)
  M=b.M
  if length(b.elm)==0 return b,M() end
  w=M(b.elm[end])^-1
  b^w,w
end

# given a Garside element a assumed to be in SSS(a) and a simple x, 
# returns the minimal m such that x<m and a^m is in SSS(a). 
# m is simple. See algorithm 5 in Franco-Gonzales 1
function minc(a,x,::Val{:ss},F::Function=(x,y=1)->x)
  ai=inv(a)
  while true
    m=x
    x=minc(a,x,Val(:inf),F)
    x=F(minc(ai,F(x),Val(:inf),(x,y=1)->F(x,-y)),-1)
    if x==m return m end
  end
end

"""
`preferred_prefix(b)`

if the normal form of `b` is `Œî‚Å±b‚ÇÅ‚Ä¶b‚Çô` then 
`preferred_prefix(b)=inv(b‚Çô)*Œ±(b‚ÇôŒî‚Åª‚Å±(b‚ÇÅ))`.
"""
function preferred_prefix(b,F::Function=(x,y=1)->x)
  M=b.M
  if isempty(b.elm) return one(M) end
  o=b.elm[end]
  F(\(M,o,Œ±2(M,o,F(Œ¥ad(M,b.elm[1],-b.pd)))[1]),-1)
end

# representativeSC(b) returns
# (conj=minimal r such that b^r is in a sliding circuit,
#  circuit=sliding circuit of b^r)
function representativeSC(b,F::Function=(x,y=1)->x)
  seen=Set{typeof(b)}()
  l=[(b,b^0)]
  while !(b in seen)
    push!(seen,b)
    r=preferred_prefix(b,F)
    b=^(b,r,F) # slide b
    push!(l,(b,l[end][2]*b.M(r)))
  end
  t=findfirst(x->x[1]==b,l)
  (conj=l[t][2],circuit=first.(l[t:end-1]))
end

# given a Garside element a assumed to be in SC(a) and a simple x, 
# minimal m such that x<m and inv(m)*a*F(m) is in SC(a). m is simple
function minc(a,x,::Val{:sc},F::Function=(x,y=1)->x)
  M=a.M
# Gebhart-Gonzalez function F for a in SC such that a^x in SSS
  function ggF(a,x,F)
    f=empty([(a,x)])
    y=a
    while true # find the history under sliding of (a,x)
      push!(f,(y,x))
      r=preferred_prefix(y,F)
  #   x=\(M,r,*(M,x,preferred_prefix(^(y,x,F),F))) # why simples?
      x=head(M(r)\M(x)*M(preferred_prefix(^(y,x,F),F)))
      if isone(M,x) return [x] end
      y=^(y,r,F)
      p=findfirst(==((y,x)),f)
      if p!==nothing break end
    end
    map(last,filter(x->x[1]==a,f[p:end]))
  end
  x=minc(a,x,Val(:ss),F)
  f=ggF(a,x,F)
  if f!=[one(M)]
    p=findfirst(s->isone(M,leftgcdc(M,x,s)[2][1]),f)
    p===nothing ? nothing : f[p]
  else p=preferred_prefix(a,F)
    if !isone(M,leftgcdc(M,x,p)[2][1]) return nothing end
#   l:=filter(s->s!=x && M.LeftGcdSimples(x,s)[2]==M.identity,
#              vcat(LeftDivisorsSimple(M,p)...));
    l=left_divisors(M,\(M,x,p))
#   println("x=$x p=$p")
    l=.*(M,Ref(x),reduce(vcat,l[2:end];init=eltype(l)[]))
#   println("Warning: for b=",a," F=1 & x=",x," divides p=",p," ",length(l));
    l[findfirst(x->x==p || x in ggF(a,x,F),l)]
  end
end

minc(a,x,F::Function=(x,y=1)->x)=minc(a,x,Val(:sc),F)

"""
`conjcat(b[,F];ss=Val(:sc))`

returns  the conjugacy category  of the summit  set of `b`  of the required
type.
  - By default,  computes the  category of  sliding circuits  of `b`.
  - If `ss==Val(:ss)`,  computes  the  super  summit  set of `b`..
  - If `ss==Val(:cyc)`, computes the cyclic  conjugacy category of `b`.
  - If `ss==Val(:inf)` computes the category of all elements conjugate to `b` and with at least same `Inf`.

If  an argument  `F` is  given it  should be  the Frobenius of a Reflection
coset attached to `b.M.W`. Then the `F`-conjugacy category is returned.

```julia-repl
julia> W=coxgroup(:A,4)
A‚ÇÑ

julia> w=BraidMonoid(W)(4,3,3,2,1)
43.321

julia> C=conjcat(w)
category with 2 objects and 4 generating maps

julia> C.obj # the (sliding circuits) summit set
2-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 32143
 21324
```

```julia-rep1
julia> xprint(C;graph=true)   # show the conjugations among the summit set
category with 2 objects and 4 generating maps
     32143      21343      21324      13214
32143‚îÄ‚îÄ‚îÄ‚îÄ‚Üí 32143‚îÄ‚îÄ‚îÄ‚îÄ‚Üí 21324‚îÄ‚îÄ‚îÄ‚îÄ‚Üí 21324‚îÄ‚îÄ‚îÄ‚îÄ‚Üí 32143
```

```julia-repl
julia> conjcat(w;ss=Val(:ss)).obj # the super summit set
4-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 32143
 13243
 21432
 21324
```
"""
function conjcat(b,F::Function=(x,y=1)->x;ss=Val(:sc))
  if ss==Val(:sc) || ss==Val(:ss) b=representativeSC(b,F).circuit[1] end
  Category(x->conjatoms(x,ss,F),b;action=(b,m)->^(b,m,F))
end

"""
conjugating_elt(b,b‚ÇÅ[,F];ss=Val(:sc))

`b`  and `b‚ÇÅ` should  be elements of  the same Garside  group. The function
returns  `a` such that `b^a=b‚ÇÅ` if such exists, and `nothing` otherwise. If
an  argument `ss`  is given,  the computation  is done in the corresponding
category  --- see [`conjcat`](@ref). If an  argument `F` is given it should
be  an automorphism of the braid monoid, like the Frobenius of a reflection
coset   attached  to  `b.M.W`;   the  computation  is   then  done  in  the
corresponding `F`-conjugacy category.

```julia-repl
julia> W=coxgroup(:D,4)
D‚ÇÑ

julia> B=BraidMonoid(W)
BraidMonoid(D‚ÇÑ)

julia> b=B(2,3,1,2,4,3)
231243

julia> b1=B(1,4,3,2,2,2)
1432.2.2

julia> conjugating_elt(b,b1)
(134312.23)‚Åª¬π

julia> c=conjugating_elt(b,b1;ss=Val(:cyc))
232.2

julia> b^c
1432.2.2

julia> WF=spets(W,Perm(1,2,4))
¬≥D‚ÇÑ

julia> F=Frobenius(WF);

julia> c=B(3,4,3,1,2,3)
343123

julia> conjugating_elt(b,c,F)
124312

julia> ^(b,B(1,2,4,3,1,2),F)
343123
```
"""
function conjugating_elt(b,c,F::Function=(x,y=1)->x;ss=Val(:sc))
  if ss==Val(:sc) || ss==Val(:ss)
    bconj=representativeSC(b,F)
    cconj=representativeSC(c,F)
    b=bconj.circuit[1]
    bconj=bconj.conj
    c=cconj.circuit[1]
    cconj=cconj.conj
    if b.pd!=c.pd || length(b.elm)!=length(c.elm) return nothing end
  else
    bconj=cconj=one(b)
  end
  if b==c return bconj*cconj^-1 end
  res=[bconj]
  class=[b]
  for (i,a) in enumerate(class)
    for m in conjatoms(a,ss,F)
      target=^(a,m,F)
      if !(target in class)
        e=res[i]*m
        if target==c
          return e*cconj^-1
        end
        push!(class,target)
        push!(res,e)
      end
    end
  end
end

"""
`centralizer_gens(b[,F];ss=Val(:sc))`

a  list of generators of the centralizer of `b`. The computation is done by
computing  the  endomorphisms  of  the  object  `b`  in the category of its
sliding  circuits. If an argument `ss` is given, the computation is done in
the corresponding category --- see [`conjcat`](@ref).

If  an argument  `F` is  given it  should be  an automorphism  of the braid
monoid,  like the Frobenius of a reflection coset attached to `b.M.W`; then
the `F`-centralizer is computed.

```julia-repl
julia> W=coxgroup(:D,4)
D‚ÇÑ

julia> B=BraidMonoid(W)
BraidMonoid(D‚ÇÑ)

julia> w=B(4,4,4)
4.4.4

julia> cc=centralizer_gens(w)
8-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 1
 (31432)‚Åª¬π231432
 (1)‚Åª¬π34.431
 (2)‚Åª¬π34.432
 (32431)‚Åª¬π132431
 4
 34.43
 2

julia> shrink(cc)
5-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 4
 2
 1
 34.43
 (3243)‚Åª¬π13243

julia> centralizer_gens(w;ss=Val(:cyc))
1-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 4

julia> F=Frobenius(spets(W,Perm(1,2,4)));

julia> centralizer_gens(w,F)
2-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}}}:
 124
 312343123
```
"""
function centralizer_gens(b,F::Function=(x,y=1)->x;ss=Val(:sc))
 if ss==Val(:ss) || ss==Val(:sc)
    b=representativeSC(b,F)
    a=b.conj
    b=b.circuit[1]
    Ref(a).*endomorphisms(conjcat(b,F;ss),1).*Ref(a^-1)
  else
    endomorphisms(conjcat(b,F;ss),1)
  end
end

"""
`Presentation(M::GarsideMonoid;vars=Symbol.("x",eachindex(M.atoms)))`

returns  a presentation of  the Garside group  defined by `M`  (as given in
[depa99; theorem 4.1](@cite), using `vars` as names for the generators.

```julia-repl
julia> M=DualBraidMonoid(coxgroup(:A,3))
DualBraidMonoid(A‚ÇÉ,c=[1, 3, 2])

julia> p=Presentation(M,vars=Symbol.(collect("abcdef")))
Presentation: 6 generators, 15 relators, total length 62
```

```julia-rep1
julia> simplify(p)
<< presentation with 3 generators, 4 relators of total length 26>>
<< presentation with 3 generators, 3 relators of total length 16>>

julia> display_balanced(p)
1: ab=ba
2: cac=aca
3: cbc=bcb
```
"""
function GroupPresentations.Presentation(M::GarsideMonoid;vars=Symbol.("x",eachindex(M.atoms)))
  F=FpGroup(vars...)
  rels=AbsWord[]
  for i in eachindex(M.atoms)
    for j in 1:i-1
      v=word.(M,leftlcmc(M,M.atoms[i],M.atoms[j])[2])
      push!(v[1],i);push!(v[2],j)
      push!(rels,F(vcat(v[1],-reverse(v[2]))...))
    end
  end
  Presentation(F/rels)
end

#----------------------------------------------------------------------------
@GapObj struct TwistedPowerMonoid{T,TM}<:GarsideMonoid{T}
  Œ¥::T
  orderŒ¥::Int
  stringŒ¥::String
  atoms::Vector{T}
  n::Int # twisting
  M::TM
end

struct TPMSimple{T,TM}
  v::Vector{T}
  t::Bool
  M::TM
end

Base.:(==)(a::TPMSimple,b::TPMSimple)=(a.v==b.v)&&(a.t==b.t)&&(a.M==b.M)

Base.hash(a::TPMSimple, h::UInt)=hash(a.v,hash(a.t,hash(a.M,h)))

Base.copy(a::TPMSimple)=TPMSimple(copy(a.v),a.t,a.M)

function Base.show(io::IO,r::TPMSimple)
  if r.t print(io,"t") end
  print(io,"(",join(map(a->word(io,r.M,a),r.v),","),")")
end

function TwistedPowerMonoid(M,n)
  Œ¥=TPMSimple([M.Œ¥ for i in 1:n],true,M)
  atoms=[TPMSimple([one(M) for i in 1:n],true,M)]
  for i in 1:n
    append!(atoms,map(a->
      TPMSimple([j==i ? a : one(M) for j in 1:n],false,M),
      M.atoms))
  end
  TwistedPowerMonoid(Œ¥,n*M.orderŒ¥,M.stringŒ¥*"_n",atoms,n,M,Dict{Symbol,Any}())
end

function CoxGroups.isrightdescent(M::TwistedPowerMonoid,s,i::Integer)
  if i==1 return s.t end
  i1,i2=divrem(i-2,length(M.M.atoms)).+1
  isrightdescent(M.M,s.v[i1],i2)
end

#function isrightascent(M::TwistedPowerMonoid,s,i)
#  if i==1 return !s.t end
#  i1,i2=divrem(i-2,length(M.M.atoms)).+1
#  isrightascent(M.M,s.v[i1],i2)
#end

function CoxGroups.isleftdescent(M::TwistedPowerMonoid,s,i)
  if i==1 return s.t end
  i1,i2=divrem(i-2,length(M.M.atoms)).+1
  isleftdescent(M.M,s.v[s.t ? 1+mod(i1-2,M.n) : i1],i2)
end

Base.one(M::TwistedPowerMonoid)=TPMSimple(
           [one(M.M) for i in 1:M.n],false,M.M)

Base.:*(M::TwistedPowerMonoid,a::TPMSimple,b::TPMSimple)=TPMSimple(
     map(i->*(M.M,a.v[b.t ? 1+mod(i,M.n) : i],b.v[i]),1:M.n),a.t||b.t,M.M)

Base.:\(M::TwistedPowerMonoid,a::TPMSimple,b::TPMSimple)=TPMSimple(
     map(i->\(M.M,a.v[b.t!=a.t ? 1+mod(i,M.n) : i],b.v[i]),1:M.n),b.t!=a.t,M.M)

Base.:/(M::TwistedPowerMonoid,a::TPMSimple,b::TPMSimple)=TPMSimple(
     map(i->/(M.M,a.v[b.t ? 1+mod(i-2,M.n) : i],
                  b.v[b.t ? 1+mod(i-2,M.n) : i]),1:M.n),a.t!=b.t,M.M)

function Base.show(io::IO,M::TwistedPowerMonoid)
  print(io,"twisted $(ordinal(M.n)) power of $(M.M)");
end

# Algorithm following Hao Zheng "A new approach to extracting roots in Garside
# groups" Comm. Algebra 34 (2006) 1793--1802
function LaurentPolynomials.root(b0::GarsideElt,n=2)
  M=b0.M
  tM=TwistedPowerMonoid(M,n)
  l=vcat(fill(M.Œ¥,b0.pd),b0.elm)
  b=GarsideElt(tM,map(eachindex(l)) do j
          TPMSimple([i==1 ? l[j] : one(M) for i in 1:n],j==1,M)
          end)
  function inner(b)
    cst=b->all(x->allequal(x.v),b.elm)
    sc=representativeSC(b)
    conj=[sc.conj]
    class=[sc.circuit[1]]
    if cst(class[1]) return conj[1] end
    for a in class
      for m in conjatoms(a)
        target=a^m
        if !(target in class)
          e=conj[findfirst(==(a),class)]*m
          if cst(target) return e end
          push!(class,target)
          push!(conj,e)
        end
      end
    end
  end
  conj=inner(b)
  if conj==nothing return nothing end
  a=b^conj
  a=GarsideElt(M,map(x->x.v[1],a.elm),a.pd)
  l=length(conj.elm)
  k=count(x->x.t,conj.elm)
  conj=GarsideElt(M,
  Vector{typeof(one(M))}(vcat(map(i->conj.elm[i].v[1+mod(i,n)],1:k),
                              map(i->conj.elm[i].v[1+mod(k,n)],k+1:l))),conj.pd)
  conj*a*conj^-1
end
#----------------------------------------------------------------------------
"""
shrink(l::Vector{<:GarsideElt})

The  list `l`  is a  list of  elements of  the same Garside group `G`. This
function  tries to find  another set of  generators of the  subgroup of `G`
generated by the elements of `l`, of smaller total length (the length being
counted  as returned by the  function `word`). This can  be use to simplify
the result of `centralizer_gens`, or other braid subgroups.

```julia-repl
julia> B=BraidMonoid(coxsym(3))
BraidMonoid(ùîñ ‚ÇÉ)

julia> b=[B(1)^3,B(2)^3,B(-2,-1,-1,2,2,2,2,1,1,2),B(1,1,1,2)]
4-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, CoxSym{Int16}}}}:
 1.1.1
 2.2.2
 (1.12)‚Åª¬π2.2.2.21.12
 1.1.12

julia> shrink(b)
2-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, CoxSym{Int16}}}}:
 2
 1
```
"""
function shrink(b1::Vector{T})where T<:GarsideElt
  function f(b)
    ld,ln=length.(word.(fraction(b)))
    ld>ln ? (l=ld+ln,ld=ln,b=inv(b),s=true) : (l=ld+ln,ld=ld,b=b,s=true)
  end
  simplified=false
  function test(el,j)
    p=f(el)
    pos=findfirst(==(p),bs)
    if pos!==nothing && pos!=j
      print(" eliminated")
      simplified=true
      splice!(bs,max(pos,j))
      return true
    end
    if p>=bs[j] return false end
    print("<$(p.l)√∑$(p.ld)>")
    bs[j]=p
    simplified=true
    return false
  end
  bs=sort!(f.(b1))
  while true
    globsimplified=false
    print("#I total length $(sum(x->x.l,bs)) maximal length $(bs[end].l)\n")
    for j in length(bs):-1:2
      simplified=false
      print("#I $j:<$(bs[j].l)√∑$(bs[j].ld)>")
      for ab in bs
        if !bs[j].s && !ab.s continue end
        if ab>=bs[j] break end
        print(".")
        a=ab.b
        ai=inv(a)
        b=bs[j].b
        aib=ai*b
        bai=b*ai
#       print("i=",i,"bs[i]=",bs[i]," bs[j]=",bs[j],"\n")
        if test(aib,j) || test(bai,j) || test(aib*a,j) ||
           test(a*bai,j) || test(a*b,j) || test(b*a,j)
         break end
      end
      if simplified globsimplified=true
      elseif j<=length(bs) bs[j]=(l=bs[j].l,ld=bs[j].ld,b=bs[j].b,s=false)
      else break
      end
      print("\n")
    end
    if !globsimplified
      print("\n")
      break
    end
    unique!(sort!(bs))
  end
  return map(x->x.b,bs)
end

"""
`hurwitz(l,i::Integer)`
the  Hurwitz action of  the generator `œÉ·µ¢`  of the braid  group `B‚Çô` on the
list  `l`  of  length  `n`  of  group elements, which replaces `l·µ¢,l·µ¢‚Çä‚ÇÅ` by
`l·µ¢‚Çä‚ÇÅ,l·µ¢^l·µ¢‚Çä‚ÇÅ`.  If `i<0`, does the action of `inv(œÉ‚±º)` where `j=-i`, which
replaces `l‚±º,l‚±º‚Çä‚ÇÅ` by `l‚±º‚Çä‚ÇÅ^inv(l‚±º),l‚±º`.

The  following  expression  computes  the  orbit  of the list `l` under the
various Huwitz actions: `orbit(1:length(l)-1,l,hurwitz)`.
"""
function hurwitz(l,i::Integer)
  l=copy(l)
  if i>0 l[i:i+1]=[l[i+1],l[i]^l[i+1]]
  else l[-i:-i+1]=[l[-i]*l[-i+1]*inv(l[-i]),l[-i]]
  end
  l
end

"""
`hurwitz(l,v::AbstractVector{<:Integer})`

does successively `hurwitz(l,i)` for each `i` in `v`.
"""
function hurwitz(l,v::AbstractVector)
  for i in v l=hurwitz(l,i) end
  l
end

"""
`hurwitz(l,b)`
the  Hurwitz action of the braid  `b‚àà B‚Çô` on the list  `l` of length `n` of
group elements.
"""
hurwitz(l,b::GarsideElt)=hurwitz(l,word(b))

# For a list l of group elements, returns the Hurwitz orbit of l.
# To find the dual atoms apply it to an expression for a Coxeter element
# like l=B.(1:ngens(W)) and take union(hurwitzorbit(l)...)
hurwitzorbit(l::AbstractVector)=orbit(1:length(l)-1,l,hurwitz)

include("cp.jl") # Corran-Picantin monoid

# example for shrink
B=BraidMonoid(coxsym(21))
b=[
B(19,19,19),B(11,11),B(10,10,10,10),B(8,8,8),B(3,3,3),B(-1,-1,2,2,1,1),B(2,2,
2,2),B(-3,-1,-2,-2,-1,-13,-14,-15,-16,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,
-13,-14,-15,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-1,-2,-3,-4,-5,-6,-7,
-8,-9,-10,-11,-12,-13,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-1,-2,-3,-4,-5,-6,
-7,-8,-9,-10,-11,-15,-11,-12,-13,-14,-12,-13,-11,-12,-14,-12,-13,-13,14,13,13,
12,14,12,11,13,12,14,13,12,11,15,11,10,9,8,7,6,5,4,3,2,1,12,11,10,9,8,7,6,5,4,
3,2,13,12,11,10,9,8,7,6,5,4,3,2,1,14,13,12,11,10,9,8,7,6,5,4,3,2,15,14,13,12,
11,10,9,8,7,6,5,4,3,2,1,16,15,14,13,1,2,2,1,3),B(-3,-1,-2,-2,-1,-1,-2,-3,-4,
-2,-3,-1,-2,-4,-2,-3,-1,2,2,2,1,3,2,4,2,1,3,2,4,3,2,1,1,2,2,1,3),B(-3,-1,-2,
-2,-3,-4,-1,-2,-3,-3,-2,-2,3,3,3,2,2,3,3,2,1,4,3,2,2,1,3),B(-3,-1,-2,-2,-3,-4,
-1,-2,-3,-3,-4,-2,-3,-3,4,4,3,3,2,4,3,3,2,1,4,3,2,2,1,3),B(-3,-1,-2,-2,-3,-4,
-5,-6,-7,-8,-9,-10,-11,-12,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-3,-4,-5,-6,-7,
-8,-9,-10,-2,-3,-4,-5,-6,-7,-8,-9,-9,-10,-11,-12,-10,-11,-9,-10,-12,-10,11,10,
12,10,9,11,10,12,11,10,9,9,8,7,6,5,4,3,2,10,9,8,7,6,5,4,3,11,10,9,8,7,6,5,4,3,
2,1,12,11,10,9,8,7,6,5,4,3,2,2,1,3),B(-5,-4,-3,-1,-2,-2,3,2,2,1,3,4,5),B(-19,
-18,-17,-16,-15,-14,-13,12,13,14,15,16,17,18,19),B(-5,-4,-3,-2,-1,-1,-2,-3,-4,
-5,-5,-3,-4,-4,5,4,4,3,5,5,4,3,2,1,1,2,3,4,5),B(-1,2,2,2,1),B(-3,4,4,4,
3),B(-3,2,2,2,3),B(-1,-2,-3,4,4,3,2,1),B(-3,-2,1,1,2,3),B(-3,-2,-10,-9,-8,-7,
-5,-6,-4,-5,-2,-3,-4,-4,-2,3,3,3,2,4,4,3,2,5,4,6,5,7,8,9,10,2,3),B(-3,-2,-10,
-9,-8,-7,-5,-6,-4,-5,-2,-3,-4,-4,-5,-2,-3,4,3,2,5,4,4,3,2,5,4,6,5,7,8,9,10,2,
3),B(-3,-1,-2,-10,-11,-5,-6,-7,-8,-9,-10,-4,-5,-6,-7,-8,-9,-2,-3,-4,-5,-6,-7,
-8,-1,-2,-3,-4,-5,-6,-7,-1,-2,-3,-4,-5,-6,-6,-7,-8,-9,-10,-6,-7,-8,-9,-7,-8,
-6,-7,-9,-10,-9,-7,-8,-6,-7,-10,-9,-7,8,7,9,10,7,6,8,7,9,10,9,7,6,8,7,9,8,7,6,
10,9,8,7,6,6,5,4,3,2,1,7,6,5,4,3,2,1,8,7,6,5,4,3,2,9,8,7,6,5,4,10,9,8,7,6,5,
11,10,2,1,3),B(-3,-1,-2,-2,-3,-4,-1,-2,-3,-3,-2,-2,-3,-3,2,3,3,2,2,3,3,2,1,4,
3,2,2,1,3),B(-3,-1,-2,-2,-3,-4,-1,-2,-3,-3,-4,-2,3,3,3,2,4,3,3,2,1,4,3,2,2,1,
3),B(-3,-1,-2,-2,-1,-1,-2,-2,-3,-4,-2,-3,-1,-2,-4,-2,-3,-1,2,2,2,1,3,2,4,2,1,
3,2,4,3,2,2,1,1,2,2,1,3),B(-3,-1,-2,-2,-1,-1,-2,-3,-4,-2,-3,-1,-2,-4,-2,-3,-1,
-2,-2,3,3,3,2,2,1,3,2,4,2,1,3,2,4,3,2,1,1,2,2,1,3),B(-5,6,6,6,5),B(-5,4,4,4,
5),B(-5,-3,-4,-2,3,3,3,2,4,3,5),B(-5,-4,-3,-2,-15,-13,-14,-12,-13,-11,-12,-10,
-11,-2,-11,-12,-13,-8,-9,-10,-11,-12,-7,-8,-9,-10,-11,-6,-7,-8,-9,-10,-2,-3,
-4,-5,-6,-7,-8,9,8,7,6,5,4,3,2,10,9,8,7,6,11,10,9,8,7,12,11,10,9,8,13,12,11,2,
11,10,12,11,13,12,14,13,15,2,3,4,5),B(-5,-4,-3,-2,-2,-3,-3,-2,-2,-2,3,3,2,2,2,
3,3,2,2,3,4,5),B(-5,-6,-1,-2,-3,-4,5,5,5,5,4,3,2,1,6,5),B(-5,-6,-4,-5,-3,4,3,
5,4,6,5),B(-7,8,8,7),B(-5,-6,-7,-4,-5,-6,-3,-4,-5,-2,-3,4,3,2,5,4,3,6,5,4,7,6,
5),B(-15,-13,-14,-12,-13,-13,12,12,12,13,13,12,14,13,15),B(-15,-13,-14,-12,
-13,-15,-13,14,14,14,13,15,13,12,14,13,15),B(-15,-13,-14,-12,-13,-17,-16,-15,
-13,-14,-12,13,13,13,12,14,13,15,16,17,13,12,14,13,15),B(-15,-13,-14,-12,-13,
-18,-17,-16,-15,-13,-14,-12,13,12,14,13,15,16,17,18,13,12,14,13,15),B(-15,-16,
-13,-14,-12,-13,-16,-15,-13,-14,-12,13,12,14,13,15,16,13,12,14,13,16,
15),B(-13,-14,-15,-16,-14,-12,-13,-16,-15,-13,14,13,15,16,13,12,14,16,15,14,
13),B(-13,-14,-15,-16,-17,-14,-12,-13,-17,-16,-15,-13,-14,-12,13,13,12,14,13,
15,16,17,13,12,14,17,16,15,14,13),B(-17,-15,-16,-13,-14,-15,-12,-13,-14,-17,
-16,-14,15,14,16,17,14,13,12,15,14,13,16,15,17),B(-10,11,11,11,10),B(-10,-10,
-9,-8,-7,6,6,7,8,9,10,10),B(-10,-7,-8,9,8,7,10),B(-8,-9,-10,11,10,9,8),B(-10,
-11,-13,-14,-15,-16,-11,-12,-13,-14,-15,-8,-9,-10,-11,-12,-13,14,13,12,11,10,
9,8,15,14,13,12,11,16,15,14,13,11,10),B(-13,-14,-15,-16,-10,-11,-16,-11,-12,
-13,-14,-15,-7,-8,-9,-10,-11,-12,-13,14,13,12,11,10,9,8,7,15,14,13,12,11,16,
11,10,16,15,14,13),B(-15,-13,-14,-12,-13,-11,-12,-10,-11,-11,-12,13,13,13,12,
11,11,10,12,11,13,12,14,13,15),B(-15,-13,-14,-12,-13,-11,-12,-10,-11,-11,-12,
-13,-13,-8,-9,-10,-11,-12,-7,-8,-9,-10,-11,-5,-6,-7,-8,-9,-10,-1,-2,-3,-4,-5,
-6,-7,-8,-9,-7,-9,-10,-7,-8,9,8,7,10,9,7,9,8,7,6,5,4,3,2,1,10,9,8,7,6,5,11,10,
9,8,7,12,11,10,9,8,13,13,12,11,11,10,12,11,13,12,14,13,15),B(-15,-13,-14,-12,
-13,-11,-12,-10,-11,-15,-11,-12,-13,14,13,12,11,15,11,10,12,11,13,12,14,13,
15),B(-10,-9,-8,-7,6,6,6,7,8,9,10),B(-13,-14,-10,-11,-12,-13,-13,-11,-12,-10,
11,11,10,12,11,13,13,12,11,10,14,13),B(-10,-9,-8,-7,-5,-6,-3,-4,-5,-2,-3,4,4,
4,3,2,5,4,3,6,5,7,8,9,10),B(-10,-9,-8,-7,-6,-5,-4,-3,-2,1,2,3,4,5,6,7,8,9,
10),B(-10,-11,-9,10,9,11,10),B(-12,11,12),B(-8,-8,9,8,8),B(-10,-8,-9,-9,-8,-7,
-6,-5,-3,-4,-2,3,2,4,3,5,6,7,8,9,9,8,10),B(-13,12,12,13),B(-13,-12,11,12,
13),B(-13,-14,-12,-13,-11,12,12,12,11,13,12,14,13),B(-13,-14,-8,-9,-10,-11,
-12,-13,-7,-8,-9,-10,-11,-12,-5,-6,-7,-8,-9,-10,-11,-4,-5,-6,-7,-8,-9,10,9,8,
7,6,5,4,11,10,9,8,7,6,5,12,11,10,9,8,7,13,12,11,10,9,8,14,13),B(-15,16,16,16,
16,15),B(-15,14,14,14,15),B(-13,-14,-15,16,16,16,16,15,14,13),B(-10,-9,-8,-7,
-5,-6,-6,-3,-4,-5,-2,-3,4,3,2,5,4,3,6,6,5,7,8,9,10),B(-15,-13,-14,-12,13,13,
13,12,14,13,15),B(-15,-13,-14,-12,-13,-16,-15,-13,-14,-16,-14,15,15,14,16,14,
13,15,16,13,12,14,13,15),B(-15,-13,-14,-12,-13,-11,-12,-10,-11,-11,-12,-13,
-13,-11,12,12,12,11,13,13,12,11,11,10,12,11,13,12,14,13,15),B(-15,-13,-14,-12,
-13,-11,-12,-10,-11,-11,-12,-13,-13,-11,-8,-9,-10,-11,-12,-13,-7,-8,-9,-10,
-11,-12,-5,-6,-7,-8,-9,-10,-11,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-9,-7,-8,-10,-8,
-9,-7,8,7,9,8,10,8,7,9,10,9,8,7,6,5,4,3,2,1,11,10,9,8,7,6,5,12,11,10,9,8,7,13,
12,11,10,9,8,11,13,13,12,11,11,10,12,11,13,12,14,13,15),B(-15,-13,-14,-12,-13,
-11,-12,-10,-11,-11,-12,-13,-13,-11,-8,-9,-10,-11,-12,-13,-7,-8,-9,-10,-11,
-12,-11,-9,-10,-12,-10,11,10,12,10,9,11,12,11,10,9,8,7,13,12,11,10,9,8,11,13,
13,12,11,11,10,12,11,13,12,14,13,15),B(-15,-13,-14,-12,-13,-11,-12,-10,-11,
-17,-18,-16,-17,-15,-16,-11,-12,-13,-14,-15,-13,-14,-11,-12,-13,-15,-13,14,13,
15,13,12,11,14,13,15,14,13,12,11,16,15,17,16,18,17,11,10,12,11,13,12,14,13,
15),B(-5,-4,-8,-7,-6,-4,5,4,6,7,8,4,5),B(-13,-14,-15,-16,17,17,17,16,15,14,
13),B(-13,-14,-15,-16,-10,-11,-12,-13,-14,15,14,13,12,11,10,16,15,14,13),B(-5,
-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,
-14,-15,-15,-16,-16,15,15,16,16,15,15,14,13,12,11,10,9,8,7,6,5,4,3,16,15,14,
13,12,11,10,9,8,7,6,5),B(-3,-3,-4,-2,3,2,4,3,3),B(-15,-13,-14,-12,-13,-11,-12,
-10,-11,-5,-4,-3,-11,-12,-13,-3,-2,-13,-8,-9,-10,-11,-12,-7,-8,-9,-10,-11,-6,
-7,-8,-9,-10,-2,-3,-4,-5,-6,-7,-8,-9,-9,-7,8,7,9,9,8,7,6,5,4,3,2,10,9,8,7,6,
11,10,9,8,7,12,11,10,9,8,13,2,3,13,12,11,3,4,5,11,10,12,11,13,12,14,13,
15),B(-17,-15,-16,-14,15,15,14,16,15,17),B(-17,-15,-16,-13,-14,-15,-12,-13,14,
14,14,13,12,15,14,13,16,15,17),B(-17,-16,-15,-14,-13,-12,-10,11,10,12,13,14,
15,16,17),B(-5,-6,-7,-8,-9,-10,-11,-12,-3,-4,-5,-6,-7,-8,-9,-10,-11,-11,-12,
-13,-14,-15,-16,-12,-13,-14,-15,-11,-12,-13,-14,-14,-15,-16,-15,-14,-16,-14,
15,15,15,15,14,16,14,15,16,15,14,14,13,12,11,15,14,13,12,16,15,14,13,12,11,11,
10,9,8,7,6,5,4,3,12,11,10,9,8,7,6,5),B(-17,-18,-19,-15,-16,-17,-18,-13,-14,
-15,-16,-17,-12,-13,-14,-15,-16,-11,-12,-13,-14,15,14,13,12,11,16,15,14,13,12,
17,16,15,14,13,18,17,16,15,19,18,17),B(-10,-3,-2,-10,-9,-8,-7,-6,-5,-4,-2,3,2,
4,5,6,7,8,9,10,2,3,10),B(-5,-4,-3,-2,-19,-17,-18,-15,-16,-17,-13,-14,-15,-16,
-8,-9,-10,-11,-12,-13,-14,-15,-7,-8,-9,-10,-11,-12,-13,-14,-6,-7,-8,-9,-10,
-11,-12,-13,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,12,11,10,9,8,7,6,5,4,3,2,13,12,11,
10,9,8,7,6,14,13,12,11,10,9,8,7,15,14,13,12,11,10,9,8,16,15,14,13,17,16,15,18,
17,19,2,3,4,5),B(-5,-4,-3,-2,-2,-3,-3,-2,-2,3,3,3,2,2,3,3,2,2,3,4,5)]
end
